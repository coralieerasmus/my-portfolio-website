"use strict"; (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[31], { 63185: function (t, e, n) { n.d(e, { Z: function () { return differenceInDays } }); var r = n(56907), u = n(58357), o = n(41784), a = n(42472); function compareLocalAsc(t, e) { var n = t.getFullYear() - e.getFullYear() || t.getMonth() - e.getMonth() || t.getDate() - e.getDate() || t.getHours() - e.getHours() || t.getMinutes() - e.getMinutes() || t.getSeconds() - e.getSeconds() || t.getMilliseconds() - e.getMilliseconds(); return n < 0 ? -1 : n > 0 ? 1 : n } function differenceInDays(t, e) { (0, a.Z)(2, arguments); var n = (0, r.Z)(t), i = (0, r.Z)(e), s = compareLocalAsc(n, i), c = Math.abs(function (t, e) { (0, a.Z)(2, arguments); var n = (0, o.Z)(t), r = (0, o.Z)(e); return Math.round((n.getTime() - (0, u.Z)(n) - (r.getTime() - (0, u.Z)(r))) / 864e5) }(n, i)); n.setDate(n.getDate() - s * c); var f = Number(compareLocalAsc(n, i) === -s), d = s * (c - f); return 0 === d ? 0 : d } }, 4783: function (t, e, n) { n.d(e, { Z: function () { return endOfDay } }); var r = n(56907), u = n(42472); function endOfDay(t) { (0, u.Z)(1, arguments); var e = (0, r.Z)(t); return e.setHours(23, 59, 59, 999), e } }, 77794: function (t, e, n) { n.d(e, { Z: function () { return endOfToday } }); var r = n(4783); function endOfToday() { return (0, r.Z)(Date.now()) } }, 40681: function (t, e, n) { n.d(e, { Z: function () { return endOfTomorrow } }); function endOfTomorrow() { var t = new Date, e = t.getFullYear(), n = t.getMonth(), r = t.getDate(), u = new Date(0); return u.setFullYear(e, n, r + 1), u.setHours(23, 59, 59, 999), u } }, 72576: function (t, e, n) { n.d(e, { Z: function () { return endOfWeek } }); var r = n(67329), u = n(56907), o = n(36770), a = n(42472); function endOfWeek(t, e) { (0, a.Z)(1, arguments); var n, i, s, c, f, d, l, Z, v = (0, r.j)(), g = (0, o.Z)(null !== (n = null !== (i = null !== (s = null !== (c = null == e ? void 0 : e.weekStartsOn) && void 0 !== c ? c : null == e ? void 0 : null === (f = e.locale) || void 0 === f ? void 0 : null === (d = f.options) || void 0 === d ? void 0 : d.weekStartsOn) && void 0 !== s ? s : v.weekStartsOn) && void 0 !== i ? i : null === (l = v.locale) || void 0 === l ? void 0 : null === (Z = l.options) || void 0 === Z ? void 0 : Z.weekStartsOn) && void 0 !== n ? n : 0); if (!(g >= 0 && g <= 6)) throw RangeError("weekStartsOn must be between 0 and 6 inclusively"); var D = (0, u.Z)(t), w = D.getDay(); return D.setDate(D.getDate() + ((w < g ? -7 : 0) + 6 - (w - g))), D.setHours(23, 59, 59, 999), D } }, 28191: function (t, e, n) { n.d(e, { Z: function () { return isSaturday } }); var r = n(56907), u = n(42472); function isSaturday(t) { return (0, u.Z)(1, arguments), 6 === (0, r.Z)(t).getDay() } }, 12488: function (t, e, n) { n.d(e, { Z: function () { return isSunday } }); var r = n(56907), u = n(42472); function isSunday(t) { return (0, u.Z)(1, arguments), 0 === (0, r.Z)(t).getDay() } }, 41784: function (t, e, n) { n.d(e, { Z: function () { return startOfDay } }); var r = n(56907), u = n(42472); function startOfDay(t) { (0, u.Z)(1, arguments); var e = (0, r.Z)(t); return e.setHours(0, 0, 0, 0), e } }, 27690: function (t, e, n) { n.d(e, { Z: function () { return startOfToday } }); var r = n(41784); function startOfToday() { return (0, r.Z)(Date.now()) } }, 3594: function (t, e, n) { n.d(e, { Z: function () { return startOfTomorrow } }); function startOfTomorrow() { var t = new Date, e = t.getFullYear(), n = t.getMonth(), r = t.getDate(), u = new Date(0); return u.setFullYear(e, n, r + 1), u.setHours(0, 0, 0, 0), u } }, 85812: function (t, e, n) { n.d(e, { Z: function () { return sub } }); var r = n(69223), u = n(36770), o = n(56907), a = n(42472); function sub(t, e) { if ((0, a.Z)(2, arguments), !e || "object" !== (0, r.Z)(e)) return new Date(NaN); var n = e.years ? (0, u.Z)(e.years) : 0, i = e.months ? (0, u.Z)(e.months) : 0, s = e.weeks ? (0, u.Z)(e.weeks) : 0, c = e.days ? (0, u.Z)(e.days) : 0, f = e.hours ? (0, u.Z)(e.hours) : 0, d = e.minutes ? (0, u.Z)(e.minutes) : 0, l = e.seconds ? (0, u.Z)(e.seconds) : 0, Z = function (t, e) { return (0, a.Z)(2, arguments), function (t, e) { (0, a.Z)(2, arguments); var n = (0, o.Z)(t), r = (0, u.Z)(e); return isNaN(r) ? new Date(NaN) : (r && n.setDate(n.getDate() + r), n) }(t, -(0, u.Z)(e)) }(function (t, e) { return (0, a.Z)(2, arguments), function (t, e) { (0, a.Z)(2, arguments); var n = (0, o.Z)(t), r = (0, u.Z)(e); if (isNaN(r)) return new Date(NaN); if (!r) return n; var i = n.getDate(), s = new Date(n.getTime()); return (s.setMonth(n.getMonth() + r + 1, 0), i >= s.getDate()) ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), i), n) }(t, -(0, u.Z)(e)) }(t, i + 12 * n), c + 7 * s); return new Date(Z.getTime() - 1e3 * (l + 60 * (d + 60 * f))) } } }]);

(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[152], { 14068: function () { }, 67907: function (e, t, i) { "use strict"; i.d(t, { W_: function () { return Navigation } }), i(62020); var s = i(65388); function Navigation(e) { let { swiper: t, extendParams: i, on: r, emit: l } = e; function getEl(e) { let i; return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e)) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])), e && !i) ? e : i } function toggleEl(e, i) { let r = t.params.navigation; (e = (0, s.m)(e)).forEach(e => { e && (e.classList[i ? "add" : "remove"](...r.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = i), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](r.lockClass)) }) } function update() { let { nextEl: e, prevEl: i } = t.navigation; if (t.params.loop) { toggleEl(i, !1), toggleEl(e, !1); return } toggleEl(i, t.isBeginning && !t.params.rewind), toggleEl(e, t.isEnd && !t.params.rewind) } function onPrevClick(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), l("navigationPrev")) } function onNextClick(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), l("navigationNext")) } function init() { var e, i, r; let l = t.params.navigation; if (t.params.navigation = (e = t.originalParams.navigation, i = t.params.navigation, r = { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }, t.params.createElements && Object.keys(r).forEach(l => { if (!i[l] && !0 === i.auto) { let n = (0, s.e)(t.el, `.${r[l]}`)[0]; n || ((n = (0, s.c)("div", r[l])).className = r[l], t.el.append(n)), i[l] = n, e[l] = n } }), i), !(l.nextEl || l.prevEl)) return; let n = getEl(l.nextEl), a = getEl(l.prevEl); Object.assign(t.navigation, { nextEl: n, prevEl: a }), n = (0, s.m)(n), a = (0, s.m)(a); let initButton = (e, i) => { e && e.addEventListener("click", "next" === i ? onNextClick : onPrevClick), !t.enabled && e && e.classList.add(...l.lockClass.split(" ")) }; n.forEach(e => initButton(e, "next")), a.forEach(e => initButton(e, "prev")) } function destroy() { let { nextEl: e, prevEl: i } = t.navigation; e = (0, s.m)(e), i = (0, s.m)(i); let destroyButton = (e, i) => { e.removeEventListener("click", "next" === i ? onNextClick : onPrevClick), e.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; e.forEach(e => destroyButton(e, "next")), i.forEach(e => destroyButton(e, "prev")) } i({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }, r("init", () => { !1 === t.params.navigation.enabled ? disable() : (init(), update()) }), r("toEdge fromEdge lock unlock", () => { update() }), r("destroy", () => { destroy() }), r("enable disable", () => { let { nextEl: e, prevEl: i } = t.navigation; if (e = (0, s.m)(e), i = (0, s.m)(i), t.enabled) { update(); return } [...e, ...i].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass)) }), r("click", (e, i) => { let { nextEl: r, prevEl: n } = t.navigation; r = (0, s.m)(r), n = (0, s.m)(n); let a = i.target; if (t.params.navigation.hideOnClick && !n.includes(a) && !r.includes(a)) { let e; if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === a || t.pagination.el.contains(a))) return; r.length ? e = r[0].classList.contains(t.params.navigation.hiddenClass) : n.length && (e = n[0].classList.contains(t.params.navigation.hiddenClass)), !0 === e ? l("navigationShow") : l("navigationHide"), [...r, ...n].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass)) } }); let disable = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), destroy() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), init(), update() }, disable, update, init, destroy }) } }, 62020: function (e, t, i) { "use strict"; function isObject(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function extend(e, t) { void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach(i => { void 0 === e[i] ? e[i] = t[i] : isObject(t[i]) && isObject(e[i]) && Object.keys(t[i]).length > 0 && extend(e[i], t[i]) }) } i.d(t, { a: function () { return getWindow }, g: function () { return getDocument } }); let s = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function getDocument() { let e = "undefined" != typeof document ? document : {}; return extend(e, s), e } let r = { document: s, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function getWindow() { let e = "undefined" != typeof window ? window : {}; return extend(e, r), e } }, 65388: function (e, t, i) { "use strict"; i.d(t, { a: function () { return elementParents }, c: function () { return createElement }, d: function () { return now }, e: function () { return elementChildren }, f: function () { return elementOuterSize }, h: function () { return elementIndex }, j: function () { return getTranslate }, m: function () { return makeElementsArray }, n: function () { return nextTick }, o: function () { return elementStyle }, p: function () { return elementNextAll }, q: function () { return elementPrevAll }, r: function () { return animateCSSModeScroll }, s: function () { return setCSSProperty }, t: function () { return showWarning }, u: function () { return function extend() { let e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < arguments.length; i += 1) { let s = i < 0 || arguments.length <= i ? void 0 : arguments[i]; if (null != s && ("undefined" != typeof window && void 0 !== window.HTMLElement ? !(s instanceof HTMLElement) : !s || 1 !== s.nodeType && 11 !== s.nodeType)) { let i = Object.keys(Object(s)).filter(e => 0 > t.indexOf(e)); for (let t = 0, r = i.length; t < r; t += 1) { let r = i[t], l = Object.getOwnPropertyDescriptor(s, r); void 0 !== l && l.enumerable && (isObject(e[r]) && isObject(s[r]) ? s[r].__swiper__ ? e[r] = s[r] : extend(e[r], s[r]) : !isObject(e[r]) && isObject(s[r]) ? (e[r] = {}, s[r].__swiper__ ? e[r] = s[r] : extend(e[r], s[r])) : e[r] = s[r]) } } } return e } }, v: function () { return deleteProps } }); var s = i(62020); function deleteProps(e) { Object.keys(e).forEach(t => { try { e[t] = null } catch (e) { } try { delete e[t] } catch (e) { } }) } function nextTick(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function now() { return Date.now() } function getTranslate(e, t) { let i, r, l; void 0 === t && (t = "x"); let n = (0, s.a)(), a = function (e) { let t; let i = (0, s.a)(); return i.getComputedStyle && (t = i.getComputedStyle(e, null)), !t && e.currentStyle && (t = e.currentStyle), t || (t = e.style), t }(e); return n.WebKitCSSMatrix ? ((r = a.transform || a.webkitTransform).split(",").length > 6 && (r = r.split(", ").map(e => e.replace(",", ".")).join(", ")), l = new n.WebKitCSSMatrix("none" === r ? "" : r)) : i = (l = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === t && (r = n.WebKitCSSMatrix ? l.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (r = n.WebKitCSSMatrix ? l.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), r || 0 } function isObject(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function setCSSProperty(e, t, i) { e.style.setProperty(t, i) } function animateCSSModeScroll(e) { let t, { swiper: i, targetPosition: r, side: l } = e, n = (0, s.a)(), a = -i.translate, o = null, d = i.params.speed; i.wrapperEl.style.scrollSnapType = "none", n.cancelAnimationFrame(i.cssModeFrameID); let c = r > a ? "next" : "prev", isOutOfBound = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, animate = () => { t = new Date().getTime(), null === o && (o = t); let e = Math.max(Math.min((t - o) / d, 1), 0), s = a + (.5 - Math.cos(e * Math.PI) / 2) * (r - a); if (isOutOfBound(s, r) && (s = r), i.wrapperEl.scrollTo({ [l]: s }), isOutOfBound(s, r)) { i.wrapperEl.style.overflow = "hidden", i.wrapperEl.style.scrollSnapType = "", setTimeout(() => { i.wrapperEl.style.overflow = "", i.wrapperEl.scrollTo({ [l]: s }) }), n.cancelAnimationFrame(i.cssModeFrameID); return } i.cssModeFrameID = n.requestAnimationFrame(animate) }; animate() } function elementChildren(e, t) { return void 0 === t && (t = ""), [...e.children].filter(e => e.matches(t)) } function showWarning(e) { try { console.warn(e); return } catch (e) { } } function createElement(e, t) { var i; void 0 === t && (t = []); let s = document.createElement(e); return s.classList.add(...Array.isArray(t) ? t : (void 0 === (i = t) && (i = ""), i.trim().split(" ").filter(e => !!e.trim()))), s } function elementPrevAll(e, t) { let i = []; for (; e.previousElementSibling;) { let s = e.previousElementSibling; t ? s.matches(t) && i.push(s) : i.push(s), e = s } return i } function elementNextAll(e, t) { let i = []; for (; e.nextElementSibling;) { let s = e.nextElementSibling; t ? s.matches(t) && i.push(s) : i.push(s), e = s } return i } function elementStyle(e, t) { let i = (0, s.a)(); return i.getComputedStyle(e, null).getPropertyValue(t) } function elementIndex(e) { let t, i = e; if (i) { for (t = 0; null !== (i = i.previousSibling);)1 === i.nodeType && (t += 1); return t } } function elementParents(e, t) { let i = [], s = e.parentElement; for (; s;)t ? s.matches(t) && i.push(s) : i.push(s), s = s.parentElement; return i } function elementOuterSize(e, t, i) { let r = (0, s.a)(); return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } function makeElementsArray(e) { return (Array.isArray(e) ? e : [e]).filter(e => !!e) } }, 4370: function (e, t, i) { "use strict"; let s, r, l; i.d(t, { tq: function () { return m }, o5: function () { return v } }); var n = i(50959), a = i(62020), o = i(65388); function getSupport() { return s || (s = function () { let e = (0, a.a)(), t = (0, a.g)(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), s } function getDevice(e) { return void 0 === e && (e = {}), r || (r = function (e) { let { userAgent: t } = void 0 === e ? {} : e, i = getSupport(), s = (0, a.a)(), r = s.navigator.platform, l = t || s.navigator.userAgent, n = { ios: !1, android: !1 }, o = s.screen.width, d = s.screen.height, c = l.match(/(Android);?[\s\/]+([\d.]+)?/), u = l.match(/(iPad).*OS\s([\d_]+)/), p = l.match(/(iPod)(.*OS\s([\d_]+))?/), h = !u && l.match(/(iPhone\sOS|iOS)\s([\d_]+)/), f = "MacIntel" === r; return !u && f && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && ((u = l.match(/(Version)\/([\d.]+)/)) || (u = [0, 1, "13_0_0"]), f = !1), c && "Win32" !== r && (n.os = "android", n.android = !0), (u || h || p) && (n.os = "ios", n.ios = !0), n }(e)), r } let toggleSlideClasses = (e, t, i) => { t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i) }, processLazyPreloader = (e, t) => { if (!e || e.destroyed || !e.params) return; let i = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`); if (i) { let t = i.querySelector(`.${e.params.lazyPreloaderClass}`); !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { i.shadowRoot && (t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`)) && t.remove() })), t && t.remove() } }, unlazy = (e, t) => { if (!e.slides[t]) return; let i = e.slides[t].querySelector('[loading="lazy"]'); i && i.removeAttribute("loading") }, preload = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext, i = e.slides.length; if (!i || !t || t < 0) return; t = Math.min(t, i); let s = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), r = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { let i = [r - t]; i.push(...Array.from({ length: t }).map((e, t) => r + s + t)), e.slides.forEach((t, s) => { i.includes(t.column) && unlazy(e, s) }); return } let l = r + s - 1; if (e.params.rewind || e.params.loop) for (let s = r - t; s <= l + t; s += 1) { let t = (s % i + i) % i; (t < r || t > l) && unlazy(e, t) } else for (let s = Math.max(r - t, 0); s <= Math.min(l + t, i - 1); s += 1)s !== r && (s > l || s < r) && unlazy(e, s) }; function transitionEmit(e) { let { swiper: t, runCallbacks: i, direction: s, step: r } = e, { activeIndex: l, previousIndex: n } = t, a = s; if (a || (a = l > n ? "next" : l < n ? "prev" : "reset"), t.emit(`transition${r}`), i && l !== n) { if ("reset" === a) { t.emit(`slideResetTransition${r}`); return } t.emit(`slideChangeTransition${r}`), "next" === a ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`) } } function preventEdgeSwipe(e, t, i) { let s = (0, a.a)(), { params: r } = e, l = r.edgeSwipeDetection, n = r.edgeSwipeThreshold; return !l || !(i <= n) && !(i >= s.innerWidth - n) || "prevent" === l && (t.preventDefault(), !0) } function onTouchStart(e) { let t = (0, a.g)(), i = e; i.originalEvent && (i = i.originalEvent); let s = this.touchEventsData; if ("pointerdown" === i.type) { if (null !== s.pointerId && s.pointerId !== i.pointerId) return; s.pointerId = i.pointerId } else "touchstart" === i.type && 1 === i.targetTouches.length && (s.touchId = i.targetTouches[0].identifier); if ("touchstart" === i.type) { preventEdgeSwipe(this, i, i.targetTouches[0].pageX); return } let { params: r, touches: l, enabled: n } = this; if (!n || !r.simulateTouch && "mouse" === i.pointerType || this.animating && r.preventInteractionOnTransition) return; !this.animating && r.cssMode && r.loop && this.loopFix(); let d = i.target; if ("wrapper" === r.touchEventsTarget && !this.wrapperEl.contains(d) || "which" in i && 3 === i.which || "button" in i && i.button > 0 || s.isTouched && s.isMoved) return; let c = !!r.noSwipingClass && "" !== r.noSwipingClass, u = i.composedPath ? i.composedPath() : i.path; c && i.target && i.target.shadowRoot && u && (d = u[0]); let p = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, h = !!(i.target && i.target.shadowRoot); if (r.noSwiping && (h ? function (e, t) { return void 0 === t && (t = this), function __closestFrom(t) { if (!t || t === (0, a.g)() || t === (0, a.a)()) return null; t.assignedSlot && (t = t.assignedSlot); let i = t.closest(e); return i || t.getRootNode ? i || __closestFrom(t.getRootNode().host) : null }(t) }(p, d) : d.closest(p))) { this.allowClick = !0; return } if (r.swipeHandler && !d.closest(r.swipeHandler)) return; l.currentX = i.pageX, l.currentY = i.pageY; let f = l.currentX, m = l.currentY; if (!preventEdgeSwipe(this, i, f)) return; Object.assign(s, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = f, l.startY = m, s.touchStartTime = (0, o.d)(), this.allowClick = !0, this.updateSize(), this.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1); let v = !0; d.matches(s.focusableElements) && (v = !1, "SELECT" === d.nodeName && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== d && t.activeElement.blur(); let g = v && this.allowTouchMove && r.touchStartPreventDefault; (r.touchStartForcePreventDefault || g) && !d.isContentEditable && i.preventDefault(), r.freeMode && r.freeMode.enabled && this.freeMode && this.animating && !r.cssMode && this.freeMode.onTouchStart(), this.emit("touchStart", i) } function onTouchMove(e) { let t, i; let s = (0, a.g)(), r = this.touchEventsData, { params: l, touches: n, rtlTranslate: d, enabled: c } = this; if (!c || !l.simulateTouch && "mouse" === e.pointerType) return; let u = e; if (u.originalEvent && (u = u.originalEvent), "pointermove" === u.type) { if (null !== r.touchId) return; let e = u.pointerId; if (e !== r.pointerId) return } if ("touchmove" === u.type) { if (!(t = [...u.changedTouches].filter(e => e.identifier === r.touchId)[0]) || t.identifier !== r.touchId) return } else t = u; if (!r.isTouched) { r.startMoving && r.isScrolling && this.emit("touchMoveOpposite", u); return } let p = t.pageX, h = t.pageY; if (u.preventedByNestedSwiper) { n.startX = p, n.startY = h; return } if (!this.allowTouchMove) { u.target.matches(r.focusableElements) || (this.allowClick = !1), r.isTouched && (Object.assign(n, { startX: p, startY: h, currentX: p, currentY: h }), r.touchStartTime = (0, o.d)()); return } if (l.touchReleaseOnEdges && !l.loop) { if (this.isVertical()) { if (h < n.startY && this.translate <= this.maxTranslate() || h > n.startY && this.translate >= this.minTranslate()) { r.isTouched = !1, r.isMoved = !1; return } } else if (p < n.startX && this.translate <= this.maxTranslate() || p > n.startX && this.translate >= this.minTranslate()) return } if (s.activeElement && u.target === s.activeElement && u.target.matches(r.focusableElements)) { r.isMoved = !0, this.allowClick = !1; return } r.allowTouchCallbacks && this.emit("touchMove", u), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = p, n.currentY = h; let f = n.currentX - n.startX, m = n.currentY - n.startY; if (this.params.threshold && Math.sqrt(f ** 2 + m ** 2) < this.params.threshold) return; if (void 0 === r.isScrolling) { let e; this.isHorizontal() && n.currentY === n.startY || this.isVertical() && n.currentX === n.startX ? r.isScrolling = !1 : f * f + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(f)) / Math.PI, r.isScrolling = this.isHorizontal() ? e > l.touchAngle : 90 - e > l.touchAngle) } if (r.isScrolling && this.emit("touchMoveOpposite", u), void 0 === r.startMoving && (n.currentX !== n.startX || n.currentY !== n.startY) && (r.startMoving = !0), r.isScrolling) { r.isTouched = !1; return } if (!r.startMoving) return; this.allowClick = !1, !l.cssMode && u.cancelable && u.preventDefault(), l.touchMoveStopPropagation && !l.nested && u.stopPropagation(); let v = this.isHorizontal() ? f : m, g = this.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY; l.oneWayMovement && (v = Math.abs(v) * (d ? 1 : -1), g = Math.abs(g) * (d ? 1 : -1)), n.diff = v, v *= l.touchRatio, d && (v = -v, g = -g); let w = this.touchesDirection; this.swipeDirection = v > 0 ? "prev" : "next", this.touchesDirection = g > 0 ? "prev" : "next"; let S = this.params.loop && !l.cssMode, b = "next" === this.touchesDirection && this.allowSlideNext || "prev" === this.touchesDirection && this.allowSlidePrev; if (!r.isMoved) { if (S && b && this.loopFix({ direction: this.swipeDirection }), r.startTranslate = this.getTranslate(), this.setTransition(0), this.animating) { let e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); this.wrapperEl.dispatchEvent(e) } r.allowMomentumBounce = !1, l.grabCursor && (!0 === this.allowSlideNext || !0 === this.allowSlidePrev) && this.setGrabCursor(!0), this.emit("sliderFirstMove", u) } if (new Date().getTime(), r.isMoved && r.allowThresholdMove && w !== this.touchesDirection && S && b && Math.abs(v) >= 1) { Object.assign(n, { startX: p, startY: h, currentX: p, currentY: h, startTranslate: r.currentTranslate }), r.loopSwapReset = !0, r.startTranslate = r.currentTranslate; return } this.emit("sliderMove", u), r.isMoved = !0, r.currentTranslate = v + r.startTranslate; let y = !0, T = l.resistanceRatio; if (l.touchReleaseOnEdges && (T = 0), v > 0 ? (S && b && !i && r.allowThresholdMove && r.currentTranslate > (l.centeredSlides ? this.minTranslate() - this.slidesSizesGrid[this.activeIndex + 1] : this.minTranslate()) && this.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > this.minTranslate() && (y = !1, l.resistance && (r.currentTranslate = this.minTranslate() - 1 + (-this.minTranslate() + r.startTranslate + v) ** T))) : v < 0 && (S && b && !i && r.allowThresholdMove && r.currentTranslate < (l.centeredSlides ? this.maxTranslate() + this.slidesSizesGrid[this.slidesSizesGrid.length - 1] : this.maxTranslate()) && this.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: this.slides.length - ("auto" === l.slidesPerView ? this.slidesPerViewDynamic() : Math.ceil(parseFloat(l.slidesPerView, 10))) }), r.currentTranslate < this.maxTranslate() && (y = !1, l.resistance && (r.currentTranslate = this.maxTranslate() + 1 - (this.maxTranslate() - r.startTranslate - v) ** T))), y && (u.preventedByNestedSwiper = !0), !this.allowSlideNext && "next" === this.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !this.allowSlidePrev && "prev" === this.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), this.allowSlidePrev || this.allowSlideNext || (r.currentTranslate = r.startTranslate), l.threshold > 0) { if (Math.abs(v) > l.threshold || r.allowThresholdMove) { if (!r.allowThresholdMove) { r.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, r.currentTranslate = r.startTranslate, n.diff = this.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY; return } } else { r.currentTranslate = r.startTranslate; return } } l.followFinger && !l.cssMode && ((l.freeMode && l.freeMode.enabled && this.freeMode || l.watchSlidesProgress) && (this.updateActiveIndex(), this.updateSlidesClasses()), l.freeMode && l.freeMode.enabled && this.freeMode && this.freeMode.onTouchMove(), this.updateProgress(r.currentTranslate), this.setTranslate(r.currentTranslate)) } function onTouchEnd(e) { let t, i; let s = this, r = s.touchEventsData, l = e; l.originalEvent && (l = l.originalEvent); let n = "touchend" === l.type || "touchcancel" === l.type; if (n) { if (!(t = [...l.changedTouches].filter(e => e.identifier === r.touchId)[0]) || t.identifier !== r.touchId) return } else { if (null !== r.touchId || l.pointerId !== r.pointerId) return; t = l } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(l.type)) { let e = ["pointercancel", "contextmenu"].includes(l.type) && (s.browser.isSafari || s.browser.isWebView); if (!e) return } r.pointerId = null, r.touchId = null; let { params: a, touches: d, rtlTranslate: c, slidesGrid: u, enabled: p } = s; if (!p || !a.simulateTouch && "mouse" === l.pointerType) return; if (r.allowTouchCallbacks && s.emit("touchEnd", l), r.allowTouchCallbacks = !1, !r.isTouched) { r.isMoved && a.grabCursor && s.setGrabCursor(!1), r.isMoved = !1, r.startMoving = !1; return } a.grabCursor && r.isMoved && r.isTouched && (!0 === s.allowSlideNext || !0 === s.allowSlidePrev) && s.setGrabCursor(!1); let h = (0, o.d)(), f = h - r.touchStartTime; if (s.allowClick) { let e = l.path || l.composedPath && l.composedPath(); s.updateClickedSlide(e && e[0] || l.target, e), s.emit("tap click", l), f < 300 && h - r.lastClickTime < 300 && s.emit("doubleTap doubleClick", l) } if (r.lastClickTime = (0, o.d)(), (0, o.n)(() => { s.destroyed || (s.allowClick = !0) }), !r.isTouched || !r.isMoved || !s.swipeDirection || 0 === d.diff && !r.loopSwapReset || r.currentTranslate === r.startTranslate && !r.loopSwapReset) { r.isTouched = !1, r.isMoved = !1, r.startMoving = !1; return } if (r.isTouched = !1, r.isMoved = !1, r.startMoving = !1, i = a.followFinger ? c ? s.translate : -s.translate : -r.currentTranslate, a.cssMode) return; if (a.freeMode && a.freeMode.enabled) { s.freeMode.onTouchEnd({ currentPos: i }); return } let m = i >= -s.maxTranslate() && !s.params.loop, v = 0, g = s.slidesSizesGrid[0]; for (let e = 0; e < u.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { let t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; void 0 !== u[e + t] ? (m || i >= u[e] && i < u[e + t]) && (v = e, g = u[e + t] - u[e]) : (m || i >= u[e]) && (v = e, g = u[u.length - 1] - u[u.length - 2]) } let w = null, S = null; a.rewind && (s.isBeginning ? S = a.virtual && a.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1 : s.isEnd && (w = 0)); let b = (i - u[v]) / g, y = v < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (f > a.longSwipesMs) { if (!a.longSwipes) { s.slideTo(s.activeIndex); return } "next" === s.swipeDirection && (b >= a.longSwipesRatio ? s.slideTo(a.rewind && s.isEnd ? w : v + y) : s.slideTo(v)), "prev" === s.swipeDirection && (b > 1 - a.longSwipesRatio ? s.slideTo(v + y) : null !== S && b < 0 && Math.abs(b) > a.longSwipesRatio ? s.slideTo(S) : s.slideTo(v)) } else { if (!a.shortSwipes) { s.slideTo(s.activeIndex); return } let e = s.navigation && (l.target === s.navigation.nextEl || l.target === s.navigation.prevEl); e ? l.target === s.navigation.nextEl ? s.slideTo(v + y) : s.slideTo(v) : ("next" === s.swipeDirection && s.slideTo(null !== w ? w : v + y), "prev" === s.swipeDirection && s.slideTo(null !== S ? S : v)) } } function onResize() { let e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); let { allowSlideNext: s, allowSlidePrev: r, snapGrid: l } = e, n = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); let a = n && t.loop; "auto" !== t.slidesPerView && !(t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }, 500)), e.allowSlidePrev = r, e.allowSlideNext = s, e.params.watchOverflow && l !== e.snapGrid && e.checkOverflow() } function onClick(e) { this.enabled && !this.allowClick && (this.params.preventClicks && e.preventDefault(), this.params.preventClicksPropagation && this.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function onScroll() { let { wrapperEl: e, rtlTranslate: t, enabled: i } = this; if (!i) return; this.previousTranslate = this.translate, this.isHorizontal() ? this.translate = -e.scrollLeft : this.translate = -e.scrollTop, 0 === this.translate && (this.translate = 0), this.updateActiveIndex(), this.updateSlidesClasses(); let s = this.maxTranslate() - this.minTranslate(); (0 === s ? 0 : (this.translate - this.minTranslate()) / s) !== this.progress && this.updateProgress(t ? -this.translate : this.translate), this.emit("setTranslate", this.translate, !1) } function onLoad(e) { processLazyPreloader(this, e.target), !this.params.cssMode && ("auto" === this.params.slidesPerView || this.params.autoHeight) && this.update() } function onDocumentTouchStart() { !this.documentTouchHandlerProceeded && (this.documentTouchHandlerProceeded = !0, this.params.touchReleaseOnEdges && (this.el.style.touchAction = "auto")) } let events = (e, t) => { let i = (0, a.g)(), { params: s, el: r, wrapperEl: l, device: n } = e, o = !!s.nested, d = "on" === t ? "addEventListener" : "removeEventListener"; i[d]("touchstart", e.onDocumentTouchStart, { passive: !1, capture: o }), r[d]("touchstart", e.onTouchStart, { passive: !1 }), r[d]("pointerdown", e.onTouchStart, { passive: !1 }), i[d]("touchmove", e.onTouchMove, { passive: !1, capture: o }), i[d]("pointermove", e.onTouchMove, { passive: !1, capture: o }), i[d]("touchend", e.onTouchEnd, { passive: !0 }), i[d]("pointerup", e.onTouchEnd, { passive: !0 }), i[d]("pointercancel", e.onTouchEnd, { passive: !0 }), i[d]("touchcancel", e.onTouchEnd, { passive: !0 }), i[d]("pointerout", e.onTouchEnd, { passive: !0 }), i[d]("pointerleave", e.onTouchEnd, { passive: !0 }), i[d]("contextmenu", e.onTouchEnd, { passive: !0 }), (s.preventClicks || s.preventClicksPropagation) && r[d]("click", e.onClick, !0), s.cssMode && l[d]("scroll", e.onScroll), s.updateOnWindowResize ? e[t](n.ios || n.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : e[t]("observerUpdate", onResize, !0), r[d]("load", e.onLoad, { capture: !0 }) }, isGridEnabled = (e, t) => e.grid && t.grid && t.grid.rows > 1; var d = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; let c = { eventsEmitter: { on(e, t, i) { let s = this; if (!s.eventsListeners || s.destroyed || "function" != typeof t) return s; let r = i ? "unshift" : "push"; return e.split(" ").forEach(e => { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][r](t) }), s }, once(e, t, i) { let s = this; if (!s.eventsListeners || s.destroyed || "function" != typeof t) return s; function onceHandler() { s.off(e, onceHandler), onceHandler.__emitterProxy && delete onceHandler.__emitterProxy; for (var i = arguments.length, r = Array(i), l = 0; l < i; l++)r[l] = arguments[l]; t.apply(s, r) } return onceHandler.__emitterProxy = t, s.on(e, onceHandler, i) }, onAny(e, t) { return !this.eventsListeners || this.destroyed || "function" != typeof e || 0 > this.eventsAnyListeners.indexOf(e) && this.eventsAnyListeners[t ? "unshift" : "push"](e), this }, offAny(e) { if (!this.eventsListeners || this.destroyed || !this.eventsAnyListeners) return this; let t = this.eventsAnyListeners.indexOf(e); return t >= 0 && this.eventsAnyListeners.splice(t, 1), this }, off(e, t) { let i = this; return i.eventsListeners && !i.destroyed && i.eventsListeners && e.split(" ").forEach(e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach((s, r) => { (s === t || s.__emitterProxy && s.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1) }) }), i }, emit() { let e, t, i; let s = this; if (!s.eventsListeners || s.destroyed || !s.eventsListeners) return s; for (var r = arguments.length, l = Array(r), n = 0; n < r; n++)l[n] = arguments[n]; "string" == typeof l[0] || Array.isArray(l[0]) ? (e = l[0], t = l.slice(1, l.length), i = s) : (e = l[0].events, t = l[0].data, i = l[0].context || s), t.unshift(i); let a = Array.isArray(e) ? e : e.split(" "); return a.forEach(e => { s.eventsAnyListeners && s.eventsAnyListeners.length && s.eventsAnyListeners.forEach(s => { s.apply(i, [e, ...t]) }), s.eventsListeners && s.eventsListeners[e] && s.eventsListeners[e].forEach(e => { e.apply(i, t) }) }), s } }, update: { updateSize: function () { let e, t; let i = this.el; e = void 0 !== this.params.width && null !== this.params.width ? this.params.width : i.clientWidth, t = void 0 !== this.params.height && null !== this.params.height ? this.params.height : i.clientHeight, 0 === e && this.isHorizontal() || 0 === t && this.isVertical() || (e = e - parseInt((0, o.o)(i, "padding-left") || 0, 10) - parseInt((0, o.o)(i, "padding-right") || 0, 10), t = t - parseInt((0, o.o)(i, "padding-top") || 0, 10) - parseInt((0, o.o)(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(this, { width: e, height: t, size: this.isHorizontal() ? e : t })) }, updateSlides: function () { let e; let t = this; function getDirectionPropertyValue(e, i) { return parseFloat(e.getPropertyValue(t.getDirectionLabel(i)) || 0) } let i = t.params, { wrapperEl: s, slidesEl: r, size: l, rtlTranslate: n, wrongRTL: a } = t, d = t.virtual && i.virtual.enabled, c = d ? t.virtual.slides.length : t.slides.length, u = (0, o.e)(r, `.${t.params.slideClass}, swiper-slide`), p = d ? t.virtual.slides.length : u.length, h = [], f = [], m = [], v = i.slidesOffsetBefore; "function" == typeof v && (v = i.slidesOffsetBefore.call(t)); let g = i.slidesOffsetAfter; "function" == typeof g && (g = i.slidesOffsetAfter.call(t)); let w = t.snapGrid.length, S = t.slidesGrid.length, b = i.spaceBetween, y = -v, T = 0, E = 0; if (void 0 === l) return; "string" == typeof b && b.indexOf("%") >= 0 ? b = parseFloat(b.replace("%", "")) / 100 * l : "string" == typeof b && (b = parseFloat(b)), t.virtualSize = -b, u.forEach(e => { n ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" }), i.centeredSlides && i.cssMode && ((0, o.s)(s, "--swiper-centered-offset-before", ""), (0, o.s)(s, "--swiper-centered-offset-after", "")); let x = i.grid && i.grid.rows > 1 && t.grid; x ? t.grid.initSlides(u) : t.grid && t.grid.unsetSlides(); let C = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter(e => void 0 !== i.breakpoints[e].slidesPerView).length > 0; for (let s = 0; s < p; s += 1) { let r; if (e = 0, u[s] && (r = u[s]), x && t.grid.updateSlide(s, r, u), !u[s] || "none" !== (0, o.o)(r, "display")) { if ("auto" === i.slidesPerView) { C && (u[s].style[t.getDirectionLabel("width")] = ""); let l = getComputedStyle(r), n = r.style.transform, a = r.style.webkitTransform; if (n && (r.style.transform = "none"), a && (r.style.webkitTransform = "none"), i.roundLengths) e = t.isHorizontal() ? (0, o.f)(r, "width", !0) : (0, o.f)(r, "height", !0); else { let t = getDirectionPropertyValue(l, "width"), i = getDirectionPropertyValue(l, "padding-left"), s = getDirectionPropertyValue(l, "padding-right"), n = getDirectionPropertyValue(l, "margin-left"), a = getDirectionPropertyValue(l, "margin-right"), o = l.getPropertyValue("box-sizing"); if (o && "border-box" === o) e = t + n + a; else { let { clientWidth: l, offsetWidth: o } = r; e = t + i + s + n + a + (o - l) } } n && (r.style.transform = n), a && (r.style.webkitTransform = a), i.roundLengths && (e = Math.floor(e)) } else e = (l - (i.slidesPerView - 1) * b) / i.slidesPerView, i.roundLengths && (e = Math.floor(e)), u[s] && (u[s].style[t.getDirectionLabel("width")] = `${e}px`); u[s] && (u[s].swiperSlideSize = e), m.push(e), i.centeredSlides ? (y = y + e / 2 + T / 2 + b, 0 === T && 0 !== s && (y = y - l / 2 - b), 0 === s && (y = y - l / 2 - b), .001 > Math.abs(y) && (y = 0), i.roundLengths && (y = Math.floor(y)), E % i.slidesPerGroup == 0 && h.push(y), f.push(y)) : (i.roundLengths && (y = Math.floor(y)), (E - Math.min(t.params.slidesPerGroupSkip, E)) % t.params.slidesPerGroup == 0 && h.push(y), f.push(y), y = y + e + b), t.virtualSize += e + b, T = e, E += 1 } } if (t.virtualSize = Math.max(t.virtualSize, l) + g, n && a && ("slide" === i.effect || "coverflow" === i.effect) && (s.style.width = `${t.virtualSize + b}px`), i.setWrapperSize && (s.style[t.getDirectionLabel("width")] = `${t.virtualSize + b}px`), x && t.grid.updateWrapperSize(e, h), !i.centeredSlides) { let e = []; for (let s = 0; s < h.length; s += 1) { let r = h[s]; i.roundLengths && (r = Math.floor(r)), h[s] <= t.virtualSize - l && e.push(r) } h = e, Math.floor(t.virtualSize - l) - Math.floor(h[h.length - 1]) > 1 && h.push(t.virtualSize - l) } if (d && i.loop) { let e = m[0] + b; if (i.slidesPerGroup > 1) { let s = Math.ceil((t.virtual.slidesBefore + t.virtual.slidesAfter) / i.slidesPerGroup), r = e * i.slidesPerGroup; for (let e = 0; e < s; e += 1)h.push(h[h.length - 1] + r) } for (let s = 0; s < t.virtual.slidesBefore + t.virtual.slidesAfter; s += 1)1 === i.slidesPerGroup && h.push(h[h.length - 1] + e), f.push(f[f.length - 1] + e), t.virtualSize += e } if (0 === h.length && (h = [0]), 0 !== b) { let e = t.isHorizontal() && n ? "marginLeft" : t.getDirectionLabel("marginRight"); u.filter((e, t) => !i.cssMode || !!i.loop || t !== u.length - 1).forEach(t => { t.style[e] = `${b}px` }) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; m.forEach(t => { e += t + (b || 0) }), e -= b; let t = e - l; h = h.map(e => e <= 0 ? -v : e > t ? t + g : e) } if (i.centerInsufficientSlides) { let e = 0; if (m.forEach(t => { e += t + (b || 0) }), (e -= b) < l) { let t = (l - e) / 2; h.forEach((e, i) => { h[i] = e - t }), f.forEach((e, i) => { f[i] = e + t }) } } if (Object.assign(t, { slides: u, snapGrid: h, slidesGrid: f, slidesSizesGrid: m }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { (0, o.s)(s, "--swiper-centered-offset-before", `${-h[0]}px`), (0, o.s)(s, "--swiper-centered-offset-after", `${t.size / 2 - m[m.length - 1] / 2}px`); let e = -t.snapGrid[0], i = -t.slidesGrid[0]; t.snapGrid = t.snapGrid.map(t => t + e), t.slidesGrid = t.slidesGrid.map(e => e + i) } if (p !== c && t.emit("slidesLengthChange"), h.length !== w && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), f.length !== S && t.emit("slidesGridLengthChange"), i.watchSlidesProgress && t.updateSlidesOffset(), t.emit("slidesUpdated"), !d && !i.cssMode && ("slide" === i.effect || "fade" === i.effect)) { let e = `${i.containerModifierClass}backface-hidden`, s = t.el.classList.contains(e); p <= i.maxBackfaceHiddenSlides ? s || t.el.classList.add(e) : s && t.el.classList.remove(e) } }, updateAutoHeight: function (e) { let t; let i = this, s = [], r = i.virtual && i.params.virtual.enabled, l = 0; "number" == typeof e ? i.setTransition(e) : !0 === e && i.setTransition(i.params.speed); let getSlideByIndex = e => r ? i.slides[i.getSlideIndexByData(e)] : i.slides[e]; if ("auto" !== i.params.slidesPerView && i.params.slidesPerView > 1) { if (i.params.centeredSlides) (i.visibleSlides || []).forEach(e => { s.push(e) }); else for (t = 0; t < Math.ceil(i.params.slidesPerView); t += 1) { let e = i.activeIndex + t; if (e > i.slides.length && !r) break; s.push(getSlideByIndex(e)) } } else s.push(getSlideByIndex(i.activeIndex)); for (t = 0; t < s.length; t += 1)if (void 0 !== s[t]) { let e = s[t].offsetHeight; l = e > l ? e : l } (l || 0 === l) && (i.wrapperEl.style.height = `${l}px`) }, updateSlidesOffset: function () { let e = this.slides, t = this.isElement ? this.isHorizontal() ? this.wrapperEl.offsetLeft : this.wrapperEl.offsetTop : 0; for (let i = 0; i < e.length; i += 1)e[i].swiperSlideOffset = (this.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - this.cssOverflowAdjustment() }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); let t = this.params, { slides: i, rtlTranslate: s, snapGrid: r } = this; if (0 === i.length) return; void 0 === i[0].swiperSlideOffset && this.updateSlidesOffset(); let l = -e; s && (l = e), i.forEach(e => { e.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass) }), this.visibleSlidesIndexes = [], this.visibleSlides = []; let n = t.spaceBetween; "string" == typeof n && n.indexOf("%") >= 0 ? n = parseFloat(n.replace("%", "")) / 100 * this.size : "string" == typeof n && (n = parseFloat(n)); for (let e = 0; e < i.length; e += 1) { let a = i[e], o = a.swiperSlideOffset; t.cssMode && t.centeredSlides && (o -= i[0].swiperSlideOffset); let d = (l + (t.centeredSlides ? this.minTranslate() : 0) - o) / (a.swiperSlideSize + n), c = (l - r[0] + (t.centeredSlides ? this.minTranslate() : 0) - o) / (a.swiperSlideSize + n), u = -(l - o), p = u + this.slidesSizesGrid[e], h = u >= 0 && u <= this.size - this.slidesSizesGrid[e], f = u >= 0 && u < this.size - 1 || p > 1 && p <= this.size || u <= 0 && p >= this.size; f && (this.visibleSlides.push(a), this.visibleSlidesIndexes.push(e), i[e].classList.add(t.slideVisibleClass)), h && i[e].classList.add(t.slideFullyVisibleClass), a.progress = s ? -d : d, a.originalProgress = s ? -c : c } }, updateProgress: function (e) { if (void 0 === e) { let t = this.rtlTranslate ? -1 : 1; e = this && this.translate && this.translate * t || 0 } let t = this.params, i = this.maxTranslate() - this.minTranslate(), { progress: s, isBeginning: r, isEnd: l, progressLoop: n } = this, a = r, o = l; if (0 === i) s = 0, r = !0, l = !0; else { s = (e - this.minTranslate()) / i; let t = 1 > Math.abs(e - this.minTranslate()), n = 1 > Math.abs(e - this.maxTranslate()); r = t || s <= 0, l = n || s >= 1, t && (s = 0), n && (s = 1) } if (t.loop) { let t = this.getSlideIndexByData(0), i = this.getSlideIndexByData(this.slides.length - 1), s = this.slidesGrid[t], r = this.slidesGrid[i], l = this.slidesGrid[this.slidesGrid.length - 1], a = Math.abs(e); (n = a >= s ? (a - s) / l : (a + l - r) / l) > 1 && (n -= 1) } Object.assign(this, { progress: s, progressLoop: n, isBeginning: r, isEnd: l }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && this.updateSlidesProgress(e), r && !a && this.emit("reachBeginning toEdge"), l && !o && this.emit("reachEnd toEdge"), (a && !r || o && !l) && this.emit("fromEdge"), this.emit("progress", s) }, updateSlidesClasses: function () { let e, t, i; let { slides: s, params: r, slidesEl: l, activeIndex: n } = this, a = this.virtual && r.virtual.enabled, d = this.grid && r.grid && r.grid.rows > 1, getFilteredSlide = e => (0, o.e)(l, `.${r.slideClass}${e}, swiper-slide${e}`)[0]; if (a) { if (r.loop) { let t = n - this.virtual.slidesBefore; t < 0 && (t = this.virtual.slides.length + t), t >= this.virtual.slides.length && (t -= this.virtual.slides.length), e = getFilteredSlide(`[data-swiper-slide-index="${t}"]`) } else e = getFilteredSlide(`[data-swiper-slide-index="${n}"]`) } else d ? (e = s.filter(e => e.column === n)[0], i = s.filter(e => e.column === n + 1)[0], t = s.filter(e => e.column === n - 1)[0]) : e = s[n]; e && !d && (i = (0, o.p)(e, `.${r.slideClass}, swiper-slide`)[0], r.loop && !i && (i = s[0]), t = (0, o.q)(e, `.${r.slideClass}, swiper-slide`)[0], r.loop), s.forEach(s => { toggleSlideClasses(s, s === e, r.slideActiveClass), toggleSlideClasses(s, s === i, r.slideNextClass), toggleSlideClasses(s, s === t, r.slidePrevClass) }), this.emitSlidesClasses() }, updateActiveIndex: function (e) { let t, i; let s = this, r = s.rtlTranslate ? s.translate : -s.translate, { snapGrid: l, params: n, activeIndex: a, realIndex: o, snapIndex: d } = s, c = e, getVirtualRealIndex = e => { let t = e - s.virtual.slidesBefore; return t < 0 && (t = s.virtual.slides.length + t), t >= s.virtual.slides.length && (t -= s.virtual.slides.length), t }; if (void 0 === c && (c = function (e) { let t; let { slidesGrid: i, params: s } = e, r = e.rtlTranslate ? e.translate : -e.translate; for (let e = 0; e < i.length; e += 1)void 0 !== i[e + 1] ? r >= i[e] && r < i[e + 1] - (i[e + 1] - i[e]) / 2 ? t = e : r >= i[e] && r < i[e + 1] && (t = e + 1) : r >= i[e] && (t = e); return s.normalizeSlideIndex && (t < 0 || void 0 === t) && (t = 0), t }(s)), l.indexOf(r) >= 0) t = l.indexOf(r); else { let e = Math.min(n.slidesPerGroupSkip, c); t = e + Math.floor((c - e) / n.slidesPerGroup) } if (t >= l.length && (t = l.length - 1), c === a && !s.params.loop) { t !== d && (s.snapIndex = t, s.emit("snapIndexChange")); return } if (c === a && s.params.loop && s.virtual && s.params.virtual.enabled) { s.realIndex = getVirtualRealIndex(c); return } let u = s.grid && n.grid && n.grid.rows > 1; if (s.virtual && n.virtual.enabled && n.loop) i = getVirtualRealIndex(c); else if (u) { let e = s.slides.filter(e => e.column === c)[0], t = parseInt(e.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(t) && (t = Math.max(s.slides.indexOf(e), 0)), i = Math.floor(t / n.grid.rows) } else if (s.slides[c]) { let e = s.slides[c].getAttribute("data-swiper-slide-index"); i = e ? parseInt(e, 10) : c } else i = c; Object.assign(s, { previousSnapIndex: d, snapIndex: t, previousRealIndex: o, realIndex: i, previousIndex: a, activeIndex: c }), s.initialized && preload(s), s.emit("activeIndexChange"), s.emit("snapIndexChange"), (s.initialized || s.params.runCallbacksOnInit) && (o !== i && s.emit("realIndexChange"), s.emit("slideChange")) }, updateClickedSlide: function (e, t) { let i; let s = this.params, r = e.closest(`.${s.slideClass}, swiper-slide`); !r && this.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => { !r && e.matches && e.matches(`.${s.slideClass}, swiper-slide`) && (r = e) }); let l = !1; if (r) { for (let e = 0; e < this.slides.length; e += 1)if (this.slides[e] === r) { l = !0, i = e; break } } if (r && l) this.clickedSlide = r, this.virtual && this.params.virtual.enabled ? this.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : this.clickedIndex = i; else { this.clickedSlide = void 0, this.clickedIndex = void 0; return } s.slideToClickedSlide && void 0 !== this.clickedIndex && this.clickedIndex !== this.activeIndex && this.slideToClickedSlide() } }, translate: { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); let { params: t, rtlTranslate: i, translate: s, wrapperEl: r } = this; if (t.virtualTranslate) return i ? -s : s; if (t.cssMode) return s; let l = (0, o.j)(r, e); return l += this.cssOverflowAdjustment(), i && (l = -l), l || 0 }, setTranslate: function (e, t) { let { rtlTranslate: i, params: s, wrapperEl: r, progress: l } = this, n = 0, a = 0; this.isHorizontal() ? n = i ? -e : e : a = e, s.roundLengths && (n = Math.floor(n), a = Math.floor(a)), this.previousTranslate = this.translate, this.translate = this.isHorizontal() ? n : a, s.cssMode ? r[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = this.isHorizontal() ? -n : -a : s.virtualTranslate || (this.isHorizontal() ? n -= this.cssOverflowAdjustment() : a -= this.cssOverflowAdjustment(), r.style.transform = `translate3d(${n}px, ${a}px, 0px)`); let o = this.maxTranslate() - this.minTranslate(); (0 === o ? 0 : (e - this.minTranslate()) / o) !== l && this.updateProgress(e), this.emit("setTranslate", this.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, i, s, r) { let l; void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === s && (s = !0); let n = this, { params: a, wrapperEl: d } = n; if (n.animating && a.preventInteractionOnTransition) return !1; let c = n.minTranslate(), u = n.maxTranslate(); if (l = s && e > c ? c : s && e < u ? u : e, n.updateProgress(l), a.cssMode) { let e = n.isHorizontal(); if (0 === t) d[e ? "scrollLeft" : "scrollTop"] = -l; else { if (!n.support.smoothScroll) return (0, o.r)({ swiper: n, targetPosition: -l, side: e ? "left" : "top" }), !0; d.scrollTo({ [e ? "left" : "top"]: -l, behavior: "smooth" }) } return !0 } return 0 === t ? (n.setTransition(0), n.setTranslate(l), i && (n.emit("beforeTransitionStart", t, r), n.emit("transitionEnd"))) : (n.setTransition(t), n.setTranslate(l), i && (n.emit("beforeTransitionStart", t, r), n.emit("transitionStart")), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, n.animating = !1, i && n.emit("transitionEnd")) }), n.wrapperEl.addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd))), !0 } }, transition: { setTransition: function (e, t) { this.params.cssMode || (this.wrapperEl.style.transitionDuration = `${e}ms`, this.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), this.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); let { params: i } = this; i.cssMode || (i.autoHeight && this.updateAutoHeight(), transitionEmit({ swiper: this, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); let { params: i } = this; this.animating = !1, i.cssMode || (this.setTransition(0), transitionEmit({ swiper: this, runCallbacks: e, direction: t, step: "End" })) } }, slide: { slideTo: function (e, t, i, s, r) { let l; void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10)); let n = this, a = e; a < 0 && (a = 0); let { params: d, snapGrid: c, slidesGrid: u, previousIndex: p, activeIndex: h, rtlTranslate: f, wrapperEl: m, enabled: v } = n; if (!v && !s && !r || n.destroyed || n.animating && d.preventInteractionOnTransition) return !1; void 0 === t && (t = n.params.speed); let g = Math.min(n.params.slidesPerGroupSkip, a), w = g + Math.floor((a - g) / n.params.slidesPerGroup); w >= c.length && (w = c.length - 1); let S = -c[w]; if (d.normalizeSlideIndex) for (let e = 0; e < u.length; e += 1) { let t = -Math.floor(100 * S), i = Math.floor(100 * u[e]), s = Math.floor(100 * u[e + 1]); void 0 !== u[e + 1] ? t >= i && t < s - (s - i) / 2 ? a = e : t >= i && t < s && (a = e + 1) : t >= i && (a = e) } if (n.initialized && a !== h && (!n.allowSlideNext && (f ? S > n.translate && S > n.minTranslate() : S < n.translate && S < n.minTranslate()) || !n.allowSlidePrev && S > n.translate && S > n.maxTranslate() && (h || 0) !== a)) return !1; if (a !== (p || 0) && i && n.emit("beforeSlideChangeStart"), n.updateProgress(S), l = a > h ? "next" : a < h ? "prev" : "reset", f && -S === n.translate || !f && S === n.translate) return n.updateActiveIndex(a), d.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), "slide" !== d.effect && n.setTranslate(S), "reset" !== l && (n.transitionStart(i, l), n.transitionEnd(i, l)), !1; if (d.cssMode) { let e = n.isHorizontal(), i = f ? S : -S; if (0 === t) { let t = n.virtual && n.params.virtual.enabled; t && (n.wrapperEl.style.scrollSnapType = "none", n._immediateVirtual = !0), t && !n._cssModeVirtualInitialSet && n.params.initialSlide > 0 ? (n._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { m[e ? "scrollLeft" : "scrollTop"] = i })) : m[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame(() => { n.wrapperEl.style.scrollSnapType = "", n._immediateVirtual = !1 }) } else { if (!n.support.smoothScroll) return (0, o.r)({ swiper: n, targetPosition: i, side: e ? "left" : "top" }), !0; m.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } return n.setTransition(t), n.setTranslate(S), n.updateActiveIndex(a), n.updateSlidesClasses(), n.emit("beforeTransitionStart", t, s), n.transitionStart(i, l), 0 === t ? n.transitionEnd(i, l) : n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.wrapperEl.removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(i, l)) }), n.wrapperEl.addEventListener("transitionend", n.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, i, s) { if (void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e) { let t = parseInt(e, 10); e = t } let r = this; if (r.destroyed) return; void 0 === t && (t = r.params.speed); let l = r.grid && r.params.grid && r.params.grid.rows > 1, n = e; if (r.params.loop) { if (r.virtual && r.params.virtual.enabled) n += r.virtual.slidesBefore; else { let e; if (l) { let t = n * r.params.grid.rows; e = r.slides.filter(e => 1 * e.getAttribute("data-swiper-slide-index") === t)[0].column } else e = r.getSlideIndexByData(n); let t = l ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length, { centeredSlides: i } = r.params, a = r.params.slidesPerView; "auto" === a ? a = r.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(r.params.slidesPerView, 10)), i && a % 2 == 0 && (a += 1)); let o = t - e < a; if (i && (o = o || e < Math.ceil(a / 2)), s && i && "auto" !== r.params.slidesPerView && !l && (o = !1), o) { let s = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev"; r.loopFix({ direction: s, slideTo: !0, activeSlideIndex: "next" === s ? e + 1 : e - t + 1, slideRealIndex: "next" === s ? r.realIndex : void 0 }) } if (l) { let e = n * r.params.grid.rows; n = r.slides.filter(t => 1 * t.getAttribute("data-swiper-slide-index") === e)[0].column } else n = r.getSlideIndexByData(n) } } return requestAnimationFrame(() => { r.slideTo(n, t, i, s) }), r }, slideNext: function (e, t, i) { void 0 === t && (t = !0); let s = this, { enabled: r, params: l, animating: n } = s; if (!r || s.destroyed) return s; void 0 === e && (e = s.params.speed); let a = l.slidesPerGroup; "auto" === l.slidesPerView && 1 === l.slidesPerGroup && l.slidesPerGroupAuto && (a = Math.max(s.slidesPerViewDynamic("current", !0), 1)); let o = s.activeIndex < l.slidesPerGroupSkip ? 1 : a, d = s.virtual && l.virtual.enabled; if (l.loop) { if (n && !d && l.loopPreventsSliding) return !1; if (s.loopFix({ direction: "next" }), s._clientLeft = s.wrapperEl.clientLeft, s.activeIndex === s.slides.length - 1 && l.cssMode) return requestAnimationFrame(() => { s.slideTo(s.activeIndex + o, e, t, i) }), !0 } return l.rewind && s.isEnd ? s.slideTo(0, e, t, i) : s.slideTo(s.activeIndex + o, e, t, i) }, slidePrev: function (e, t, i) { void 0 === t && (t = !0); let s = this, { params: r, snapGrid: l, slidesGrid: n, rtlTranslate: a, enabled: o, animating: d } = s; if (!o || s.destroyed) return s; void 0 === e && (e = s.params.speed); let c = s.virtual && r.virtual.enabled; if (r.loop) { if (d && !c && r.loopPreventsSliding) return !1; s.loopFix({ direction: "prev" }), s._clientLeft = s.wrapperEl.clientLeft } let u = a ? s.translate : -s.translate; function normalize(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } let p = normalize(u), h = l.map(e => normalize(e)), f = l[h.indexOf(p) - 1]; if (void 0 === f && r.cssMode) { let e; l.forEach((t, i) => { p >= t && (e = i) }), void 0 !== e && (f = l[e > 0 ? e - 1 : e]) } let m = 0; if (void 0 !== f && ((m = n.indexOf(f)) < 0 && (m = s.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = Math.max(m = m - s.slidesPerViewDynamic("previous", !0) + 1, 0))), r.rewind && s.isBeginning) { let r = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1; return s.slideTo(r, e, t, i) } return r.loop && 0 === s.activeIndex && r.cssMode ? (requestAnimationFrame(() => { s.slideTo(m, e, t, i) }), !0) : s.slideTo(m, e, t, i) }, slideReset: function (e, t, i) { if (void 0 === t && (t = !0), !this.destroyed) return void 0 === e && (e = this.params.speed), this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e, t, i, s) { if (void 0 === t && (t = !0), void 0 === s && (s = .5), this.destroyed) return; void 0 === e && (e = this.params.speed); let r = this.activeIndex, l = Math.min(this.params.slidesPerGroupSkip, r), n = l + Math.floor((r - l) / this.params.slidesPerGroup), a = this.rtlTranslate ? this.translate : -this.translate; if (a >= this.snapGrid[n]) { let e = this.snapGrid[n], t = this.snapGrid[n + 1]; a - e > (t - e) * s && (r += this.params.slidesPerGroup) } else { let e = this.snapGrid[n - 1], t = this.snapGrid[n]; a - e <= (t - e) * s && (r -= this.params.slidesPerGroup) } return r = Math.min(r = Math.max(r, 0), this.slidesGrid.length - 1), this.slideTo(r, e, t, i) }, slideToClickedSlide: function () { let e; let t = this; if (t.destroyed) return; let { params: i, slidesEl: s } = t, r = "auto" === i.slidesPerView ? t.slidesPerViewDynamic() : i.slidesPerView, l = t.clickedIndex, n = t.isElement ? "swiper-slide" : `.${i.slideClass}`; if (i.loop) { if (t.animating) return; e = parseInt(t.clickedSlide.getAttribute("data-swiper-slide-index"), 10), i.centeredSlides ? l < t.loopedSlides - r / 2 || l > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), l = t.getSlideIndex((0, o.e)(s, `${n}[data-swiper-slide-index="${e}"]`)[0]), (0, o.n)(() => { t.slideTo(l) })) : t.slideTo(l) : l > t.slides.length - r ? (t.loopFix(), l = t.getSlideIndex((0, o.e)(s, `${n}[data-swiper-slide-index="${e}"]`)[0]), (0, o.n)(() => { t.slideTo(l) })) : t.slideTo(l) } else t.slideTo(l) } }, loop: { loopCreate: function (e) { let t = this, { params: i, slidesEl: s } = t; if (!i.loop || t.virtual && t.params.virtual.enabled) return; let initSlides = () => { let e = (0, o.e)(s, `.${i.slideClass}, swiper-slide`); e.forEach((e, t) => { e.setAttribute("data-swiper-slide-index", t) }) }, r = t.grid && i.grid && i.grid.rows > 1, l = i.slidesPerGroup * (r ? i.grid.rows : 1), n = t.slides.length % l != 0, a = r && t.slides.length % i.grid.rows != 0, addBlankSlides = e => { for (let s = 0; s < e; s += 1) { let e = t.isElement ? (0, o.c)("swiper-slide", [i.slideBlankClass]) : (0, o.c)("div", [i.slideClass, i.slideBlankClass]); t.slidesEl.append(e) } }; if (n) { if (i.loopAddBlankSlides) { let e = l - t.slides.length % l; addBlankSlides(e), t.recalcSlides(), t.updateSlides() } else (0, o.t)("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); initSlides() } else if (a) { if (i.loopAddBlankSlides) { let e = i.grid.rows - t.slides.length % i.grid.rows; addBlankSlides(e), t.recalcSlides(), t.updateSlides() } else (0, o.t)("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); initSlides() } else initSlides(); t.loopFix({ slideRealIndex: e, direction: i.centeredSlides ? void 0 : "next" }) }, loopFix: function (e) { let { slideRealIndex: t, slideTo: i = !0, direction: s, setTranslate: r, activeSlideIndex: l, byController: n, byMousewheel: a } = void 0 === e ? {} : e, d = this; if (!d.params.loop) return; d.emit("beforeLoopFix"); let { slides: c, allowSlidePrev: u, allowSlideNext: p, slidesEl: h, params: f } = d, { centeredSlides: m } = f; if (d.allowSlidePrev = !0, d.allowSlideNext = !0, d.virtual && f.virtual.enabled) { i && (f.centeredSlides || 0 !== d.snapIndex ? f.centeredSlides && d.snapIndex < f.slidesPerView ? d.slideTo(d.virtual.slides.length + d.snapIndex, 0, !1, !0) : d.snapIndex === d.snapGrid.length - 1 && d.slideTo(d.virtual.slidesBefore, 0, !1, !0) : d.slideTo(d.virtual.slides.length, 0, !1, !0)), d.allowSlidePrev = u, d.allowSlideNext = p, d.emit("loopFix"); return } let v = f.slidesPerView; "auto" === v ? v = d.slidesPerViewDynamic() : (v = Math.ceil(parseFloat(f.slidesPerView, 10)), m && v % 2 == 0 && (v += 1)); let g = f.slidesPerGroupAuto ? v : f.slidesPerGroup, w = g; w % g != 0 && (w += g - w % g), w += f.loopAdditionalSlides, d.loopedSlides = w; let S = d.grid && f.grid && f.grid.rows > 1; c.length < v + w ? (0, o.t)("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : S && "row" === f.grid.fill && (0, o.t)("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); let b = [], y = [], T = d.activeIndex; void 0 === l ? l = d.getSlideIndex(c.filter(e => e.classList.contains(f.slideActiveClass))[0]) : T = l; let E = "next" === s || !s, x = "prev" === s || !s, C = 0, P = 0, M = S ? Math.ceil(c.length / f.grid.rows) : c.length, O = S ? c[l].column : l, k = O + (m && void 0 === r ? -v / 2 + .5 : 0); if (k < w) { C = Math.max(w - k, g); for (let e = 0; e < w - k; e += 1) { let t = e - Math.floor(e / M) * M; if (S) { let e = M - t - 1; for (let t = c.length - 1; t >= 0; t -= 1)c[t].column === e && b.push(t) } else b.push(M - t - 1) } } else if (k + v > M - w) { P = Math.max(k - (M - 2 * w), g); for (let e = 0; e < P; e += 1) { let t = e - Math.floor(e / M) * M; S ? c.forEach((e, i) => { e.column === t && y.push(i) }) : y.push(t) } } if (d.__preventObserver__ = !0, requestAnimationFrame(() => { d.__preventObserver__ = !1 }), x && b.forEach(e => { c[e].swiperLoopMoveDOM = !0, h.prepend(c[e]), c[e].swiperLoopMoveDOM = !1 }), E && y.forEach(e => { c[e].swiperLoopMoveDOM = !0, h.append(c[e]), c[e].swiperLoopMoveDOM = !1 }), d.recalcSlides(), "auto" === f.slidesPerView ? d.updateSlides() : S && (b.length > 0 && x || y.length > 0 && E) && d.slides.forEach((e, t) => { d.grid.updateSlide(t, e, d.slides) }), f.watchSlidesProgress && d.updateSlidesOffset(), i) { if (b.length > 0 && x) { if (void 0 === t) { let e = d.slidesGrid[T], t = d.slidesGrid[T + C], i = t - e; a ? d.setTranslate(d.translate - i) : (d.slideTo(T + Math.ceil(C), 0, !1, !0), r && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - i, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - i)) } else if (r) { let e = S ? b.length / f.grid.rows : b.length; d.slideTo(d.activeIndex + e, 0, !1, !0), d.touchEventsData.currentTranslate = d.translate } } else if (y.length > 0 && E) { if (void 0 === t) { let e = d.slidesGrid[T], t = d.slidesGrid[T - P], i = t - e; a ? d.setTranslate(d.translate - i) : (d.slideTo(T - P, 0, !1, !0), r && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - i, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - i)) } else { let e = S ? y.length / f.grid.rows : y.length; d.slideTo(d.activeIndex - e, 0, !1, !0) } } } if (d.allowSlidePrev = u, d.allowSlideNext = p, d.controller && d.controller.control && !n) { let e = { slideRealIndex: t, direction: s, setTranslate: r, activeSlideIndex: l, byController: !0 }; Array.isArray(d.controller.control) ? d.controller.control.forEach(t => { !t.destroyed && t.params.loop && t.loopFix({ ...e, slideTo: t.params.slidesPerView === f.slidesPerView && i }) }) : d.controller.control instanceof d.constructor && d.controller.control.params.loop && d.controller.control.loopFix({ ...e, slideTo: d.controller.control.params.slidesPerView === f.slidesPerView && i }) } d.emit("loopFix") }, loopDestroy: function () { let { params: e, slidesEl: t } = this; if (!e.loop || this.virtual && this.params.virtual.enabled) return; this.recalcSlides(); let i = []; this.slides.forEach(e => { let t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; i[t] = e }), this.slides.forEach(e => { e.removeAttribute("data-swiper-slide-index") }), i.forEach(e => { t.append(e) }), this.recalcSlides(), this.slideTo(this.realIndex, 0) } }, grabCursor: { setGrabCursor: function (e) { let t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; let i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => { t.__preventObserver__ = !1 }) }, unsetGrabCursor: function () { let e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 })) } }, events: { attachEvents: function () { let { params: e } = this; this.onTouchStart = onTouchStart.bind(this), this.onTouchMove = onTouchMove.bind(this), this.onTouchEnd = onTouchEnd.bind(this), this.onDocumentTouchStart = onDocumentTouchStart.bind(this), e.cssMode && (this.onScroll = onScroll.bind(this)), this.onClick = onClick.bind(this), this.onLoad = onLoad.bind(this), events(this, "on") }, detachEvents: function () { events(this, "off") } }, breakpoints: { setBreakpoint: function () { let e = this, { realIndex: t, initialized: i, params: s, el: r } = e, l = s.breakpoints; if (!l || l && 0 === Object.keys(l).length) return; let n = e.getBreakpoint(l, e.params.breakpointsBase, e.el); if (!n || e.currentBreakpoint === n) return; let a = n in l ? l[n] : void 0, d = a || e.originalParams, c = isGridEnabled(e, s), u = isGridEnabled(e, d), p = e.params.grabCursor, h = d.grabCursor, f = s.enabled; c && !u ? (r.classList.remove(`${s.containerModifierClass}grid`, `${s.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && u && (r.classList.add(`${s.containerModifierClass}grid`), (d.grid.fill && "column" === d.grid.fill || !d.grid.fill && "column" === s.grid.fill) && r.classList.add(`${s.containerModifierClass}grid-column`), e.emitContainerClasses()), p && !h ? e.unsetGrabCursor() : !p && h && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(t => { if (void 0 === d[t]) return; let i = s[t] && s[t].enabled, r = d[t] && d[t].enabled; i && !r && e[t].disable(), !i && r && e[t].enable() }); let m = d.direction && d.direction !== s.direction, v = s.loop && (d.slidesPerView !== s.slidesPerView || m), g = s.loop; m && i && e.changeDirection(), (0, o.u)(e.params, d); let w = e.params.enabled, S = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), f && !w ? e.disable() : !f && w && e.enable(), e.currentBreakpoint = n, e.emit("_beforeBreakpoint", d), i && (v ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !g && S ? (e.loopCreate(t), e.updateSlides()) : g && !S && e.loopDestroy()), e.emit("breakpoint", d) }, getBreakpoint: function (e, t, i) { if (void 0 === t && (t = "window"), !e || "container" === t && !i) return; let s = !1, r = (0, a.a)(), l = "window" === t ? r.innerHeight : i.clientHeight, n = Object.keys(e).map(e => { if ("string" == typeof e && 0 === e.indexOf("@")) { let t = parseFloat(e.substr(1)); return { value: l * t, point: e } } return { value: e, point: e } }); n.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)); for (let e = 0; e < n.length; e += 1) { let { point: l, value: a } = n[e]; "window" === t ? r.matchMedia(`(min-width: ${a}px)`).matches && (s = l) : a <= i.clientWidth && (s = l) } return s || "max" } }, checkOverflow: { checkOverflow: function () { let { isLocked: e, params: t } = this, { slidesOffsetBefore: i } = t; if (i) { let e = this.slides.length - 1, t = this.slidesGrid[e] + this.slidesSizesGrid[e] + 2 * i; this.isLocked = this.size > t } else this.isLocked = 1 === this.snapGrid.length; !0 === t.allowSlideNext && (this.allowSlideNext = !this.isLocked), !0 === t.allowSlidePrev && (this.allowSlidePrev = !this.isLocked), e && e !== this.isLocked && (this.isEnd = !1), e !== this.isLocked && this.emit(this.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { let { classNames: e, params: t, rtl: i, el: s, device: r } = this, l = function (e, t) { let i = []; return e.forEach(e => { "object" == typeof e ? Object.keys(e).forEach(s => { e[s] && i.push(t + s) }) : "string" == typeof e && i.push(t + e) }), i }(["initialized", t.direction, { "free-mode": this.params.freeMode && t.freeMode.enabled }, { autoheight: t.autoHeight }, { rtl: i }, { grid: t.grid && t.grid.rows > 1 }, { "grid-column": t.grid && t.grid.rows > 1 && "column" === t.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": t.cssMode }, { centered: t.cssMode && t.centeredSlides }, { "watch-progress": t.watchSlidesProgress }], t.containerModifierClass); e.push(...l), s.classList.add(...e), this.emitContainerClasses() }, removeClasses: function () { let { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, u = {}; let Swiper = class Swiper { constructor() { let e, t; for (var i = arguments.length, s = Array(i), r = 0; r < i; r++)s[r] = arguments[r]; 1 === s.length && s[0].constructor && "Object" === Object.prototype.toString.call(s[0]).slice(8, -1) ? t = s[0] : [e, t] = s, t || (t = {}), t = (0, o.u)({}, t), e && !t.el && (t.el = e); let n = (0, a.g)(); if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) { let e = []; return n.querySelectorAll(t.el).forEach(i => { let s = (0, o.u)({}, t, { el: i }); e.push(new Swiper(s)) }), e } let c = this; c.__swiper__ = !0, c.support = getSupport(), c.device = getDevice({ userAgent: t.userAgent }), c.browser = (l || (l = function () { let e = (0, a.a)(), t = getDevice(), i = !1; function isSafari() { let t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && 0 > t.indexOf("chrome") && 0 > t.indexOf("android") } if (isSafari()) { let t = String(e.navigator.userAgent); if (t.includes("Version/")) { let [e, s] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e)); i = e < 16 || 16 === e && s < 2 } } let s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent), r = isSafari(), l = r || s && t.ios; return { isSafari: i || r, needPerspectiveFix: i, need3dFix: l, isWebView: s } }()), l), c.eventsListeners = {}, c.eventsAnyListeners = [], c.modules = [...c.__modules__], t.modules && Array.isArray(t.modules) && c.modules.push(...t.modules); let p = {}; c.modules.forEach(e => { var i; e({ params: t, swiper: c, extendParams: (i = t, function (e) { void 0 === e && (e = {}); let t = Object.keys(e)[0], s = e[t]; if ("object" != typeof s || null === s || (!0 === i[t] && (i[t] = { enabled: !0 }), "navigation" === t && i[t] && i[t].enabled && !i[t].prevEl && !i[t].nextEl && (i[t].auto = !0), ["pagination", "scrollbar"].indexOf(t) >= 0 && i[t] && i[t].enabled && !i[t].el && (i[t].auto = !0), !(t in i && "enabled" in s))) { (0, o.u)(p, e); return } "object" != typeof i[t] || "enabled" in i[t] || (i[t].enabled = !0), i[t] || (i[t] = { enabled: !1 }), (0, o.u)(p, e) }), on: c.on.bind(c), once: c.once.bind(c), off: c.off.bind(c), emit: c.emit.bind(c) }) }); let h = (0, o.u)({}, d, p); return c.params = (0, o.u)({}, h, u, t), c.originalParams = (0, o.u)({}, c.params), c.passedParams = (0, o.u)({}, t), c.params && c.params.on && Object.keys(c.params.on).forEach(e => { c.on(e, c.params.on[e]) }), c.params && c.params.onAny && c.onAny(c.params.onAny), Object.assign(c, { enabled: c.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === c.params.direction, isVertical: () => "vertical" === c.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return 8388608 * Math.trunc(this.translate / 8388608) }, allowSlideNext: c.params.allowSlideNext, allowSlidePrev: c.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: c.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: c.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), c.emit("_swiper"), c.params.init && c.init(), c } getDirectionLabel(e) { return this.isHorizontal() ? e : ({ width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" })[e] } getSlideIndex(e) { let { slidesEl: t, params: i } = this, s = (0, o.e)(t, `.${i.slideClass}, swiper-slide`), r = (0, o.h)(s[0]); return (0, o.h)(e) - r } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(t => 1 * t.getAttribute("data-swiper-slide-index") === e)[0]) } recalcSlides() { let { slidesEl: e, params: t } = this; this.slides = (0, o.e)(e, `.${t.slideClass}, swiper-slide`) } enable() { this.enabled || (this.enabled = !0, this.params.grabCursor && this.setGrabCursor(), this.emit("enable")) } disable() { this.enabled && (this.enabled = !1, this.params.grabCursor && this.unsetGrabCursor(), this.emit("disable")) } setProgress(e, t) { e = Math.min(Math.max(e, 0), 1); let i = this.minTranslate(), s = this.maxTranslate(), r = (s - i) * e + i; this.translateTo(r, void 0 === t ? 0 : t), this.updateActiveIndex(), this.updateSlidesClasses() } emitContainerClasses() { let e = this; if (!e.params._emitClasses || !e.el) return; let t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { let t = this; return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ") } emitSlidesClasses() { let e = this; if (!e.params._emitClasses || !e.el) return; let t = []; e.slides.forEach(i => { let s = e.getSlideClasses(i); t.push({ slideEl: i, classNames: s }), e.emit("_slideClass", i, s) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); let { params: i, slides: s, slidesGrid: r, slidesSizesGrid: l, size: n, activeIndex: a } = this, o = 1; if ("number" == typeof i.slidesPerView) return i.slidesPerView; if (i.centeredSlides) { let e, t = s[a] ? Math.ceil(s[a].swiperSlideSize) : 0; for (let i = a + 1; i < s.length; i += 1)s[i] && !e && (t += Math.ceil(s[i].swiperSlideSize), o += 1, t > n && (e = !0)); for (let i = a - 1; i >= 0; i -= 1)s[i] && !e && (t += s[i].swiperSlideSize, o += 1, t > n && (e = !0)) } else if ("current" === e) for (let e = a + 1; e < s.length; e += 1) { let i = t ? r[e] + l[e] - r[a] < n : r[e] - r[a] < n; i && (o += 1) } else for (let e = a - 1; e >= 0; e -= 1) { let t = r[a] - r[e] < n; t && (o += 1) } return o } update() { let e; let t = this; if (!t || t.destroyed) return; let { snapGrid: i, params: s } = t; function setTranslate() { let e = t.rtlTranslate ? -1 * t.translate : t.translate, i = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate()); t.setTranslate(i), t.updateActiveIndex(), t.updateSlidesClasses() } if (s.breakpoints && t.setBreakpoint(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach(e => { e.complete && processLazyPreloader(t, e) }), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) setTranslate(), s.autoHeight && t.updateAutoHeight(); else { if (("auto" === s.slidesPerView || s.slidesPerView > 1) && t.isEnd && !s.centeredSlides) { let i = t.virtual && s.virtual.enabled ? t.virtual.slides : t.slides; e = t.slideTo(i.length - 1, 0, !1, !0) } else e = t.slideTo(t.activeIndex, 0, !1, !0); e || setTranslate() } s.watchOverflow && i !== t.snapGrid && t.checkOverflow(), t.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); let i = this.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (this.el.classList.remove(`${this.params.containerModifierClass}${i}`), this.el.classList.add(`${this.params.containerModifierClass}${e}`), this.emitContainerClasses(), this.params.direction = e, this.slides.forEach(t => { "vertical" === e ? t.style.width = "" : t.style.height = "" }), this.emit("changeDirection"), t && this.update()), this } changeLanguageDirection(e) { (!this.rtl || "rtl" !== e) && (this.rtl || "ltr" !== e) && (this.rtl = "rtl" === e, this.rtlTranslate = "horizontal" === this.params.direction && this.rtl, this.rtl ? (this.el.classList.add(`${this.params.containerModifierClass}rtl`), this.el.dir = "rtl") : (this.el.classList.remove(`${this.params.containerModifierClass}rtl`), this.el.dir = "ltr"), this.update()) } mount(e) { let t = this; if (t.mounted) return !0; let i = e || t.params.el; if ("string" == typeof i && (i = document.querySelector(i)), !i) return !1; i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); let getWrapperSelector = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`, s = (() => { if (i && i.shadowRoot && i.shadowRoot.querySelector) { let e = i.shadowRoot.querySelector(getWrapperSelector()); return e } return (0, o.e)(i, getWrapperSelector())[0] })(); return !s && t.params.createElements && (s = (0, o.c)("div", t.params.wrapperClass), i.append(s), (0, o.e)(i, `.${t.params.slideClass}`).forEach(e => { s.append(e) })), Object.assign(t, { el: i, wrapperEl: s, slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : s, hostEl: t.isElement ? i.parentNode.host : i, mounted: !0, rtl: "rtl" === i.dir.toLowerCase() || "rtl" === (0, o.o)(i, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === (0, o.o)(i, "direction")), wrongRTL: "-webkit-box" === (0, o.o)(s, "display") }), !0 } init(e) { let t = this; if (t.initialized) return t; let i = t.mount(e); if (!1 === i) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); let s = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach(e => { e.complete ? processLazyPreloader(t, e) : e.addEventListener("load", e => { processLazyPreloader(t, e.target) }) }), preload(t), t.initialized = !0, preload(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); let i = this, { params: s, el: r, wrapperEl: l, slides: n } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), r.removeAttribute("style"), l.removeAttribute("style"), n && n.length && n.forEach(e => { e.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => { i.off(e) }), !1 !== e && (i.el.swiper = null, (0, o.v)(i)), i.destroyed = !0), null } static extendDefaults(e) { (0, o.u)(u, e) } static get extendedDefaults() { return u } static get defaults() { return d } static installModule(e) { Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []); let t = Swiper.prototype.__modules__; "function" == typeof e && 0 > t.indexOf(e) && t.push(e) } static use(e) { return Array.isArray(e) ? e.forEach(e => Swiper.installModule(e)) : Swiper.installModule(e), Swiper } }; Object.keys(c).forEach(e => { Object.keys(c[e]).forEach(t => { Swiper.prototype[t] = c[e][t] }) }), Swiper.use([function (e) { let { swiper: t, on: i, emit: s } = e, r = (0, a.a)(), l = null, n = null, resizeHandler = () => { t && !t.destroyed && t.initialized && (s("beforeResize"), s("resize")) }, createObserver = () => { t && !t.destroyed && t.initialized && (l = new ResizeObserver(e => { n = r.requestAnimationFrame(() => { let { width: i, height: s } = t, r = i, l = s; e.forEach(e => { let { contentBoxSize: i, contentRect: s, target: n } = e; n && n !== t.el || (r = s ? s.width : (i[0] || i).inlineSize, l = s ? s.height : (i[0] || i).blockSize) }), (r !== i || l !== s) && resizeHandler() }) })).observe(t.el) }, removeObserver = () => { n && r.cancelAnimationFrame(n), l && l.unobserve && t.el && (l.unobserve(t.el), l = null) }, orientationChangeHandler = () => { t && !t.destroyed && t.initialized && s("orientationchange") }; i("init", () => { if (t.params.resizeObserver && void 0 !== r.ResizeObserver) { createObserver(); return } r.addEventListener("resize", resizeHandler), r.addEventListener("orientationchange", orientationChangeHandler) }), i("destroy", () => { removeObserver(), r.removeEventListener("resize", resizeHandler), r.removeEventListener("orientationchange", orientationChangeHandler) }) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: r } = e, l = [], n = (0, a.a)(), attach = function (e, i) { void 0 === i && (i = {}); let s = n.MutationObserver || n.WebkitMutationObserver, a = new s(e => { if (t.__preventObserver__) return; if (1 === e.length) { r("observerUpdate", e[0]); return } let observerUpdate = function () { r("observerUpdate", e[0]) }; n.requestAnimationFrame ? n.requestAnimationFrame(observerUpdate) : n.setTimeout(observerUpdate, 0) }); a.observe(e, { attributes: void 0 === i.attributes || i.attributes, childList: void 0 === i.childList || i.childList, characterData: void 0 === i.characterData || i.characterData }), l.push(a) }; i({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), s("init", () => { if (t.params.observer) { if (t.params.observeParents) { let e = (0, o.a)(t.hostEl); for (let t = 0; t < e.length; t += 1)attach(e[t]) } attach(t.hostEl, { childList: t.params.observeSlideChildren }), attach(t.wrapperEl, { attributes: !1 }) } }), s("destroy", () => { l.forEach(e => { e.disconnect() }), l.splice(0, l.length) }) }]); let p = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function isObject(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) && !e.__swiper__ } function extend(e, t) { let i = ["__proto__", "constructor", "prototype"]; Object.keys(t).filter(e => 0 > i.indexOf(e)).forEach(i => { void 0 === e[i] ? e[i] = t[i] : isObject(t[i]) && isObject(e[i]) && Object.keys(t[i]).length > 0 ? t[i].__swiper__ ? e[i] = t[i] : extend(e[i], t[i]) : e[i] = t[i] }) } function needsNavigation(e) { return void 0 === e && (e = {}), e.navigation && void 0 === e.navigation.nextEl && void 0 === e.navigation.prevEl } function needsPagination(e) { return void 0 === e && (e = {}), e.pagination && void 0 === e.pagination.el } function needsScrollbar(e) { return void 0 === e && (e = {}), e.scrollbar && void 0 === e.scrollbar.el } function uniqueClasses(e) { void 0 === e && (e = ""); let t = e.split(" ").map(e => e.trim()).filter(e => !!e), i = []; return t.forEach(e => { 0 > i.indexOf(e) && i.push(e) }), i.join(" ") } let updateOnVirtualData = e => { e && !e.destroyed && e.params.virtual && (!e.params.virtual || e.params.virtual.enabled) && (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate()) }; function _extends() { return (_extends = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s]) } return e }).apply(this, arguments) } function isChildSwiperSlide(e) { return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide") } function useIsomorphicLayoutEffect(e, t) { return "undefined" == typeof window ? (0, n.useEffect)(e, t) : (0, n.useLayoutEffect)(e, t) } let h = (0, n.createContext)(null), f = (0, n.createContext)(null), m = (0, n.forwardRef)(function (e, t) { var i; let { className: s, tag: r = "div", wrapperTag: l = "div", children: a, onSwiper: o, ...c } = void 0 === e ? {} : e, u = !1, [h, m] = (0, n.useState)("swiper"), [v, g] = (0, n.useState)(null), [w, S] = (0, n.useState)(!1), b = (0, n.useRef)(!1), y = (0, n.useRef)(null), T = (0, n.useRef)(null), E = (0, n.useRef)(null), x = (0, n.useRef)(null), C = (0, n.useRef)(null), P = (0, n.useRef)(null), M = (0, n.useRef)(null), O = (0, n.useRef)(null), { params: k, passedParams: L, rest: _, events: I } = function (e, t) { void 0 === e && (e = {}), void 0 === t && (t = !0); let i = { on: {} }, s = {}, r = {}; extend(i, d), i._emitClasses = !0, i.init = !1; let l = {}, n = p.map(e => e.replace(/_/, "")), a = Object.assign({}, e); return Object.keys(a).forEach(a => { void 0 !== e[a] && (n.indexOf(a) >= 0 ? isObject(e[a]) ? (i[a] = {}, r[a] = {}, extend(i[a], e[a]), extend(r[a], e[a])) : (i[a] = e[a], r[a] = e[a]) : 0 === a.search(/on[A-Z]/) && "function" == typeof e[a] ? t ? s[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : i.on[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : l[a] = e[a]) }), ["navigation", "pagination", "scrollbar"].forEach(e => { !0 === i[e] && (i[e] = {}), !1 === i[e] && delete i[e] }), { params: i, passedParams: r, rest: l, events: s } }(c), { slides: z, slots: A } = function (e) { let t = [], i = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return n.Children.toArray(e).forEach(e => { if (isChildSwiperSlide(e)) t.push(e); else if (e.props && e.props.slot && i[e.props.slot]) i[e.props.slot].push(e); else if (e.props && e.props.children) { let s = function processChildren(e) { let t = []; return n.Children.toArray(e).forEach(e => { isChildSwiperSlide(e) ? t.push(e) : e.props && e.props.children && processChildren(e.props.children).forEach(e => t.push(e)) }), t }(e.props.children); s.length > 0 ? s.forEach(e => t.push(e)) : i["container-end"].push(e) } else i["container-end"].push(e) }), { slides: t, slots: i } }(a), onBeforeBreakpoint = () => { S(!w) }; Object.assign(k.on, { _containerClasses(e, t) { m(t) } }); let initSwiper = () => { Object.assign(k.on, I), u = !0; let e = { ...k }; if (delete e.wrapperClass, T.current = new Swiper(e), T.current.virtual && T.current.params.virtual.enabled) { T.current.virtual.slides = z; let e = { cache: !1, slides: z, renderExternal: g, renderExternalUpdate: !1 }; extend(T.current.params.virtual, e), extend(T.current.originalParams.virtual, e) } }; y.current || initSwiper(), T.current && T.current.on("_beforeBreakpoint", onBeforeBreakpoint); let attachEvents = () => { !u && I && T.current && Object.keys(I).forEach(e => { T.current.on(e, I[e]) }) }, detachEvents = () => { I && T.current && Object.keys(I).forEach(e => { T.current.off(e, I[e]) }) }; return (0, n.useEffect)(() => () => { T.current && T.current.off("_beforeBreakpoint", onBeforeBreakpoint) }), (0, n.useEffect)(() => { !b.current && T.current && (T.current.emitSlidesClasses(), b.current = !0) }), useIsomorphicLayoutEffect(() => { if (t && (t.current = y.current), y.current) return T.current.destroyed && initSwiper(), function (e, t) { let { el: i, nextEl: s, prevEl: r, paginationEl: l, scrollbarEl: n, swiper: a } = e; needsNavigation(t) && s && r && (a.params.navigation.nextEl = s, a.originalParams.navigation.nextEl = s, a.params.navigation.prevEl = r, a.originalParams.navigation.prevEl = r), needsPagination(t) && l && (a.params.pagination.el = l, a.originalParams.pagination.el = l), needsScrollbar(t) && n && (a.params.scrollbar.el = n, a.originalParams.scrollbar.el = n), a.init(i) }({ el: y.current, nextEl: C.current, prevEl: P.current, paginationEl: M.current, scrollbarEl: O.current, swiper: T.current }, k), o && !T.current.destroyed && o(T.current), () => { T.current && !T.current.destroyed && T.current.destroy(!0, !1) } }, []), useIsomorphicLayoutEffect(() => { attachEvents(); let e = function (e, t, i, s, r) { let l = []; if (!t) return l; let addKey = e => { 0 > l.indexOf(e) && l.push(e) }; if (i && s) { let e = s.map(r), t = i.map(r); e.join("") !== t.join("") && addKey("children"), s.length !== i.length && addKey("children") } let n = p.filter(e => "_" === e[0]).map(e => e.replace(/_/, "")); return n.forEach(i => { if (i in e && i in t) { if (isObject(e[i]) && isObject(t[i])) { let s = Object.keys(e[i]), r = Object.keys(t[i]); s.length !== r.length ? addKey(i) : (s.forEach(s => { e[i][s] !== t[i][s] && addKey(i) }), r.forEach(s => { e[i][s] !== t[i][s] && addKey(i) })) } else e[i] !== t[i] && addKey(i) } }), l }(L, E.current, z, x.current, e => e.key); return E.current = L, x.current = z, e.length && T.current && !T.current.destroyed && function (e) { let t, i, s, r, l, n, a, o, { swiper: d, slides: c, passedParams: u, changedParams: p, nextEl: h, prevEl: f, scrollbarEl: m, paginationEl: v } = e, g = p.filter(e => "children" !== e && "direction" !== e && "wrapperClass" !== e), { params: w, pagination: S, navigation: b, scrollbar: y, virtual: T, thumbs: E } = d; p.includes("thumbs") && u.thumbs && u.thumbs.swiper && w.thumbs && !w.thumbs.swiper && (t = !0), p.includes("controller") && u.controller && u.controller.control && w.controller && !w.controller.control && (i = !0), p.includes("pagination") && u.pagination && (u.pagination.el || v) && (w.pagination || !1 === w.pagination) && S && !S.el && (s = !0), p.includes("scrollbar") && u.scrollbar && (u.scrollbar.el || m) && (w.scrollbar || !1 === w.scrollbar) && y && !y.el && (r = !0), p.includes("navigation") && u.navigation && (u.navigation.prevEl || f) && (u.navigation.nextEl || h) && (w.navigation || !1 === w.navigation) && b && !b.prevEl && !b.nextEl && (l = !0); let destroyModule = e => { d[e] && (d[e].destroy(), "navigation" === e ? (d.isElement && (d[e].prevEl.remove(), d[e].nextEl.remove()), w[e].prevEl = void 0, w[e].nextEl = void 0, d[e].prevEl = void 0, d[e].nextEl = void 0) : (d.isElement && d[e].el.remove(), w[e].el = void 0, d[e].el = void 0)) }; if (p.includes("loop") && d.isElement && (w.loop && !u.loop ? n = !0 : !w.loop && u.loop ? a = !0 : o = !0), g.forEach(e => { if (isObject(w[e]) && isObject(u[e])) Object.assign(w[e], u[e]), ("navigation" === e || "pagination" === e || "scrollbar" === e) && "enabled" in u[e] && !u[e].enabled && destroyModule(e); else { let t = u[e]; (!0 === t || !1 === t) && ("navigation" === e || "pagination" === e || "scrollbar" === e) ? !1 === t && destroyModule(e) : w[e] = u[e] } }), g.includes("controller") && !i && d.controller && d.controller.control && w.controller && w.controller.control && (d.controller.control = w.controller.control), p.includes("children") && c && T && w.virtual.enabled ? (T.slides = c, T.update(!0)) : p.includes("virtual") && T && w.virtual.enabled && (c && (T.slides = c), T.update(!0)), p.includes("children") && c && w.loop && (o = !0), t) { let e = E.init(); e && E.update(!0) } i && (d.controller.control = w.controller.control), s && (d.isElement && (!v || "string" == typeof v) && ((v = document.createElement("div")).classList.add("swiper-pagination"), v.part.add("pagination"), d.el.appendChild(v)), v && (w.pagination.el = v), S.init(), S.render(), S.update()), r && (d.isElement && (!m || "string" == typeof m) && ((m = document.createElement("div")).classList.add("swiper-scrollbar"), m.part.add("scrollbar"), d.el.appendChild(m)), m && (w.scrollbar.el = m), y.init(), y.updateSize(), y.setTranslate()), l && (d.isElement && (h && "string" != typeof h || ((h = document.createElement("div")).classList.add("swiper-button-next"), h.innerHTML = d.hostEl.constructor.nextButtonSvg, h.part.add("button-next"), d.el.appendChild(h)), f && "string" != typeof f || ((f = document.createElement("div")).classList.add("swiper-button-prev"), f.innerHTML = d.hostEl.constructor.prevButtonSvg, f.part.add("button-prev"), d.el.appendChild(f))), h && (w.navigation.nextEl = h), f && (w.navigation.prevEl = f), b.init(), b.update()), p.includes("allowSlideNext") && (d.allowSlideNext = u.allowSlideNext), p.includes("allowSlidePrev") && (d.allowSlidePrev = u.allowSlidePrev), p.includes("direction") && d.changeDirection(u.direction, !1), (n || o) && d.loopDestroy(), (a || o) && d.loopCreate(), d.update() }({ swiper: T.current, slides: z, passedParams: L, changedParams: e, nextEl: C.current, prevEl: P.current, scrollbarEl: O.current, paginationEl: M.current }), () => { detachEvents() } }), useIsomorphicLayoutEffect(() => { updateOnVirtualData(T.current) }, [v]), n.createElement(r, _extends({ ref: y, className: uniqueClasses(`${h}${s ? ` ${s}` : ""}`) }, _), n.createElement(f.Provider, { value: T.current }, A["container-start"], n.createElement(l, { className: (void 0 === (i = k.wrapperClass) && (i = ""), i) ? i.includes("swiper-wrapper") ? i : `swiper-wrapper ${i}` : "swiper-wrapper" }, A["wrapper-start"], k.virtual ? function (e, t, i) { if (!i) return null; let getSlideIndex = e => { let i = e; return e < 0 ? i = t.length + e : i >= t.length && (i -= t.length), i }, s = e.isHorizontal() ? { [e.rtlTranslate ? "right" : "left"]: `${i.offset}px` } : { top: `${i.offset}px` }, { from: r, to: l } = i, a = e.params.loop ? -t.length : 0, o = e.params.loop ? 2 * t.length : t.length, d = []; for (let e = a; e < o; e += 1)e >= r && e <= l && d.push(t[getSlideIndex(e)]); return d.map((t, i) => n.cloneElement(t, { swiper: e, style: s, key: t.props.virtualIndex || t.key || `slide-${i}` })) }(T.current, z, v) : z.map((e, t) => n.cloneElement(e, { swiper: T.current, swiperSlideIndex: t })), A["wrapper-end"]), needsNavigation(k) && n.createElement(n.Fragment, null, n.createElement("div", { ref: P, className: "swiper-button-prev" }), n.createElement("div", { ref: C, className: "swiper-button-next" })), needsScrollbar(k) && n.createElement("div", { ref: O, className: "swiper-scrollbar" }), needsPagination(k) && n.createElement("div", { ref: M, className: "swiper-pagination" }), A["container-end"])) }); m.displayName = "Swiper"; let v = (0, n.forwardRef)(function (e, t) { let { tag: i = "div", children: s, className: r = "", swiper: l, zoom: a, lazy: o, virtualIndex: d, swiperSlideIndex: c, ...u } = void 0 === e ? {} : e, p = (0, n.useRef)(null), [f, m] = (0, n.useState)("swiper-slide"), [v, g] = (0, n.useState)(!1); function updateClasses(e, t, i) { t === p.current && m(i) } useIsomorphicLayoutEffect(() => { if (void 0 !== c && (p.current.swiperSlideIndex = c), t && (t.current = p.current), p.current && l) { if (l.destroyed) { "swiper-slide" !== f && m("swiper-slide"); return } return l.on("_slideClass", updateClasses), () => { l && l.off("_slideClass", updateClasses) } } }), useIsomorphicLayoutEffect(() => { l && p.current && !l.destroyed && m(l.getSlideClasses(p.current)) }, [l]); let w = { isActive: f.indexOf("swiper-slide-active") >= 0, isVisible: f.indexOf("swiper-slide-visible") >= 0, isPrev: f.indexOf("swiper-slide-prev") >= 0, isNext: f.indexOf("swiper-slide-next") >= 0 }, renderChildren = () => "function" == typeof s ? s(w) : s; return n.createElement(i, _extends({ ref: p, className: uniqueClasses(`${f}${r ? ` ${r}` : ""}`), "data-swiper-slide-index": d, onLoad: () => { g(!0) } }, u), a && n.createElement(h.Provider, { value: w }, n.createElement("div", { className: "swiper-zoom-container", "data-swiper-zoom": "number" == typeof a ? a : void 0 }, renderChildren(), o && !v && n.createElement("div", { className: "swiper-lazy-preloader" }))), !a && n.createElement(h.Provider, { value: w }, renderChildren(), o && !v && n.createElement("div", { className: "swiper-lazy-preloader" }))) }); v.displayName = "SwiperSlide" } }]);

(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[303], {
  26591: function (b, A, D) { "use strict"; D.r(A), D.d(A, { default: function () { return er } }); var N = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"], V = { _disable: [], allowInput: !1, allowInvalidPreload: !1, altFormat: "F j, Y", altInput: !1, altInputClass: "form-control input", animate: "object" == typeof window && -1 === window.navigator.userAgent.indexOf("MSIE"), ariaDateFormat: "F j, Y", autoFillDefaultTime: !0, clickOpens: !0, closeOnSelect: !0, conjunction: ", ", dateFormat: "Y-m-d", defaultHour: 12, defaultMinute: 0, defaultSeconds: 0, disable: [], disableMobile: !1, enableSeconds: !1, enableTime: !1, errorHandler: function (b) { return "undefined" != typeof console && console.warn(b) }, getWeek: function (b) { var A = new Date(b.getTime()); A.setHours(0, 0, 0, 0), A.setDate(A.getDate() + 3 - (A.getDay() + 6) % 7); var D = new Date(A.getFullYear(), 0, 4); return 1 + Math.round(((A.getTime() - D.getTime()) / 864e5 - 3 + (D.getDay() + 6) % 7) / 7) }, hourIncrement: 1, ignoredFocusElements: [], inline: !1, locale: "default", minuteIncrement: 5, mode: "single", monthSelectorType: "dropdown", nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>", noCalendar: !1, now: new Date, onChange: [], onClose: [], onDayCreate: [], onDestroy: [], onKeyDown: [], onMonthChange: [], onOpen: [], onParseConfig: [], onReady: [], onValueUpdate: [], onYearChange: [], onPreCalendarPosition: [], plugins: [], position: "auto", positionElement: void 0, prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>", shorthandCurrentMonth: !1, showMonths: 1, static: !1, time_24hr: !1, weekNumbers: !1, wrap: !1 }, Y = { weekdays: { shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, months: { shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], firstDayOfWeek: 0, ordinal: function (b) { var A = b % 100; if (A > 3 && A < 21) return "th"; switch (A % 10) { case 1: return "st"; case 2: return "nd"; case 3: return "rd"; default: return "th" } }, rangeSeparator: " to ", weekAbbreviation: "Wk", scrollTitle: "Scroll to increment", toggleTitle: "Click to toggle", amPM: ["AM", "PM"], yearAriaLabel: "Year", monthAriaLabel: "Month", hourAriaLabel: "Hour", minuteAriaLabel: "Minute", time_24hr: !1 }, pad = function (b, A) { return void 0 === A && (A = 2), ("000" + b).slice(-1 * A) }, utils_int = function (b) { return !0 === b ? 1 : 0 }; function debounce(b, A) { var D; return function () { var N = this, V = arguments; clearTimeout(D), D = setTimeout(function () { return b.apply(N, V) }, A) } } var arrayify = function (b) { return b instanceof Array ? b : [b] }; function toggleClass(b, A, D) { if (!0 === D) return b.classList.add(A); b.classList.remove(A) } function createElement(b, A, D) { var N = window.document.createElement(b); return A = A || "", D = D || "", N.className = A, void 0 !== D && (N.textContent = D), N } function clearNode(b) { for (; b.firstChild;)b.removeChild(b.firstChild) } function createNumberInput(b, A) { var D = createElement("div", "numInputWrapper"), N = createElement("input", "numInput " + b), V = createElement("span", "arrowUp"), Y = createElement("span", "arrowDown"); if (-1 === navigator.userAgent.indexOf("MSIE 9.0") ? N.type = "number" : (N.type = "text", N.pattern = "\\d*"), void 0 !== A) for (var Z in A) N.setAttribute(Z, A[Z]); return D.appendChild(N), D.appendChild(V), D.appendChild(Y), D } function getEventTarget(b) { try { if ("function" == typeof b.composedPath) return b.composedPath()[0]; return b.target } catch (A) { return b.target } } var doNothing = function () { }, monthToStr = function (b, A, D) { return D.months[A ? "shorthand" : "longhand"][b] }, Z = { D: doNothing, F: function (b, A, D) { b.setMonth(D.months.longhand.indexOf(A)) }, G: function (b, A) { b.setHours((b.getHours() >= 12 ? 12 : 0) + parseFloat(A)) }, H: function (b, A) { b.setHours(parseFloat(A)) }, J: function (b, A) { b.setDate(parseFloat(A)) }, K: function (b, A, D) { b.setHours(b.getHours() % 12 + 12 * utils_int(RegExp(D.amPM[1], "i").test(A))) }, M: function (b, A, D) { b.setMonth(D.months.shorthand.indexOf(A)) }, S: function (b, A) { b.setSeconds(parseFloat(A)) }, U: function (b, A) { return new Date(1e3 * parseFloat(A)) }, W: function (b, A, D) { var N = parseInt(A), V = new Date(b.getFullYear(), 0, 2 + (N - 1) * 7, 0, 0, 0, 0); return V.setDate(V.getDate() - V.getDay() + D.firstDayOfWeek), V }, Y: function (b, A) { b.setFullYear(parseFloat(A)) }, Z: function (b, A) { return new Date(A) }, d: function (b, A) { b.setDate(parseFloat(A)) }, h: function (b, A) { b.setHours((b.getHours() >= 12 ? 12 : 0) + parseFloat(A)) }, i: function (b, A) { b.setMinutes(parseFloat(A)) }, j: function (b, A) { b.setDate(parseFloat(A)) }, l: doNothing, m: function (b, A) { b.setMonth(parseFloat(A) - 1) }, n: function (b, A) { b.setMonth(parseFloat(A) - 1) }, s: function (b, A) { b.setSeconds(parseFloat(A)) }, u: function (b, A) { return new Date(parseFloat(A)) }, w: doNothing, y: function (b, A) { b.setFullYear(2e3 + parseFloat(A)) } }, ee = { D: "", F: "", G: "(\\d\\d|\\d)", H: "(\\d\\d|\\d)", J: "(\\d\\d|\\d)\\w+", K: "", M: "", S: "(\\d\\d|\\d)", U: "(.+)", W: "(\\d\\d|\\d)", Y: "(\\d{4})", Z: "(.+)", d: "(\\d\\d|\\d)", h: "(\\d\\d|\\d)", i: "(\\d\\d|\\d)", j: "(\\d\\d|\\d)", l: "", m: "(\\d\\d|\\d)", n: "(\\d\\d|\\d)", s: "(\\d\\d|\\d)", u: "(.+)", w: "(\\d\\d|\\d)", y: "(\\d{2})" }, et = { Z: function (b) { return b.toISOString() }, D: function (b, A, D) { return A.weekdays.shorthand[et.w(b, A, D)] }, F: function (b, A, D) { return monthToStr(et.n(b, A, D) - 1, !1, A) }, G: function (b, A, D) { return pad(et.h(b, A, D)) }, H: function (b) { return pad(b.getHours()) }, J: function (b, A) { return void 0 !== A.ordinal ? b.getDate() + A.ordinal(b.getDate()) : b.getDate() }, K: function (b, A) { return A.amPM[utils_int(b.getHours() > 11)] }, M: function (b, A) { return monthToStr(b.getMonth(), !0, A) }, S: function (b) { return pad(b.getSeconds()) }, U: function (b) { return b.getTime() / 1e3 }, W: function (b, A, D) { return D.getWeek(b) }, Y: function (b) { return pad(b.getFullYear(), 4) }, d: function (b) { return pad(b.getDate()) }, h: function (b) { return b.getHours() % 12 ? b.getHours() % 12 : 12 }, i: function (b) { return pad(b.getMinutes()) }, j: function (b) { return b.getDate() }, l: function (b, A) { return A.weekdays.longhand[b.getDay()] }, m: function (b) { return pad(b.getMonth() + 1) }, n: function (b) { return b.getMonth() + 1 }, s: function (b) { return b.getSeconds() }, u: function (b) { return b.getTime() }, w: function (b) { return b.getDay() }, y: function (b) { return String(b.getFullYear()).substring(2) } }, createDateFormatter = function (b) { var A = b.config, D = void 0 === A ? V : A, N = b.l10n, Z = void 0 === N ? Y : N, ee = b.isMobile, ea = void 0 !== ee && ee; return function (b, A, N) { var V = N || Z; return void 0 === D.formatDate || ea ? A.split("").map(function (A, N, Y) { return et[A] && "\\" !== Y[N - 1] ? et[A](b, V, D) : "\\" !== A ? A : "" }).join("") : D.formatDate(b, A, V) } }, createDateParser = function (b) { var A = b.config, D = void 0 === A ? V : A, N = b.l10n, et = void 0 === N ? Y : N; return function (b, A, N, Y) { if (0 === b || b) { var ea, er = Y || et; if (b instanceof Date) ea = new Date(b.getTime()); else if ("string" != typeof b && void 0 !== b.toFixed) ea = new Date(b); else if ("string" == typeof b) { var en = A || (D || V).dateFormat, eo = String(b).trim(); if ("today" === eo) ea = new Date, N = !0; else if (D && D.parseDate) ea = D.parseDate(b, en); else if (/Z$/.test(eo) || /GMT$/.test(eo)) ea = new Date(b); else { for (var es = void 0, el = [], ed = 0, eu = 0, ec = ""; ed < en.length; ed++) { var em = en[ed], eh = "\\" === em, ep = "\\" === en[ed - 1] || eh; if (ee[em] && !ep) { ec += ee[em]; var ev = new RegExp(ec).exec(b); ev && (es = !0) && el["Y" !== em ? "push" : "unshift"]({ fn: Z[em], val: ev[++eu] }) } else eh || (ec += ".") } ea = D && D.noCalendar ? new Date(new Date().setHours(0, 0, 0, 0)) : new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0), el.forEach(function (b) { var A = b.fn, D = b.val; return ea = A(ea, D, er) || ea }), ea = es ? ea : void 0 } } if (!(ea instanceof Date && !isNaN(ea.getTime()))) { D.errorHandler(Error("Invalid date provided: " + b)); return } return !0 === N && ea.setHours(0, 0, 0, 0), ea } } }; function compareDates(b, A, D) { return (void 0 === D && (D = !0), !1 !== D) ? new Date(b.getTime()).setHours(0, 0, 0, 0) - new Date(A.getTime()).setHours(0, 0, 0, 0) : b.getTime() - A.getTime() } var calculateSecondsSinceMidnight = function (b, A, D) { return 3600 * b + 60 * A + D }, parseSeconds = function (b) { var A = Math.floor(b / 3600), D = (b - 3600 * A) / 60; return [A, D, b - 3600 * A - 60 * D] }, ea = { DAY: 864e5 }; function getDefaultHours(b) { var A = b.defaultHour, D = b.defaultMinute, N = b.defaultSeconds; if (void 0 !== b.minDate) { var V = b.minDate.getHours(), Y = b.minDate.getMinutes(), Z = b.minDate.getSeconds(); A < V && (A = V), A === V && D < Y && (D = Y), A === V && D === Y && N < Z && (N = b.minDate.getSeconds()) } if (void 0 !== b.maxDate) { var ee = b.maxDate.getHours(), et = b.maxDate.getMinutes(); (A = Math.min(A, ee)) === ee && (D = Math.min(et, D)), A === ee && D === et && (N = b.maxDate.getSeconds()) } return { hours: A, minutes: D, seconds: N } } D(29911); var __assign = function () { return (__assign = Object.assign || function (b) { for (var A, D = 1, N = arguments.length; D < N; D++)for (var V in A = arguments[D]) Object.prototype.hasOwnProperty.call(A, V) && (b[V] = A[V]); return b }).apply(this, arguments) }, __spreadArrays = function () { for (var b = 0, A = 0, D = arguments.length; A < D; A++)b += arguments[A].length; for (var N = Array(b), V = 0, A = 0; A < D; A++)for (var Y = arguments[A], Z = 0, ee = Y.length; Z < ee; Z++, V++)N[V] = Y[Z]; return N }; function _flatpickr(b, A) { for (var D = Array.prototype.slice.call(b).filter(function (b) { return b instanceof HTMLElement }), Z = [], et = 0; et < D.length; et++) { var er = D[et]; try { if (null !== er.getAttribute("data-fp-omit")) continue; void 0 !== er._flatpickr && (er._flatpickr.destroy(), er._flatpickr = void 0), er._flatpickr = function (b, A) { var D, Z = { config: __assign(__assign({}, V), flatpickr.defaultConfig), l10n: Y }; function getClosestActiveElement() { var b; return (null === (b = Z.calendarContainer) || void 0 === b ? void 0 : b.getRootNode()).activeElement || document.activeElement } function bindToInstance(b) { return b.bind(Z) } function setCalendarWidth() { var b = Z.config; (!1 !== b.weekNumbers || 1 !== b.showMonths) && !0 !== b.noCalendar && window.requestAnimationFrame(function () { if (void 0 !== Z.calendarContainer && (Z.calendarContainer.style.visibility = "hidden", Z.calendarContainer.style.display = "block"), void 0 !== Z.daysContainer) { var A = (Z.days.offsetWidth + 1) * b.showMonths; Z.daysContainer.style.width = A + "px", Z.calendarContainer.style.width = A + (void 0 !== Z.weekWrapper ? Z.weekWrapper.offsetWidth : 0) + "px", Z.calendarContainer.style.removeProperty("visibility"), Z.calendarContainer.style.removeProperty("display") } }) } function updateTime(b) { if (0 === Z.selectedDates.length) { var A = void 0 === Z.config.minDate || compareDates(new Date, Z.config.minDate) >= 0 ? new Date : new Date(Z.config.minDate.getTime()), D = getDefaultHours(Z.config); A.setHours(D.hours, D.minutes, D.seconds, A.getMilliseconds()), Z.selectedDates = [A], Z.latestSelectedDateObj = A } void 0 !== b && "blur" !== b.type && function (b) { b.preventDefault(); var A = "keydown" === b.type, D = getEventTarget(b); void 0 !== Z.amPM && D === Z.amPM && (Z.amPM.textContent = Z.l10n.amPM[utils_int(Z.amPM.textContent === Z.l10n.amPM[0])]); var N = parseFloat(D.getAttribute("min")), V = parseFloat(D.getAttribute("max")), Y = parseFloat(D.getAttribute("step")), ee = parseInt(D.value, 10), et = ee + Y * (b.delta || (A ? 38 === b.which ? 1 : -1 : 0)); if (void 0 !== D.value && 2 === D.value.length) { var ea = D === Z.hourElement, er = D === Z.minuteElement; et < N ? (et = V + et + utils_int(!ea) + (utils_int(ea) && utils_int(!Z.amPM)), er && incrementNumInput(void 0, -1, Z.hourElement)) : et > V && (et = D === Z.hourElement ? et - V - utils_int(!Z.amPM) : N, er && incrementNumInput(void 0, 1, Z.hourElement)), Z.amPM && ea && (1 === Y ? et + ee === 23 : Math.abs(et - ee) > Y) && (Z.amPM.textContent = Z.l10n.amPM[utils_int(Z.amPM.textContent === Z.l10n.amPM[0])]), D.value = pad(et) } }(b); var N = Z._input.value; setHoursFromInputs(), updateValue(), Z._input.value !== N && Z._debouncedChange() } function setHoursFromInputs() { if (void 0 !== Z.hourElement && void 0 !== Z.minuteElement) { var b = (parseInt(Z.hourElement.value.slice(-2), 10) || 0) % 24, A = (parseInt(Z.minuteElement.value, 10) || 0) % 60, D = void 0 !== Z.secondElement ? (parseInt(Z.secondElement.value, 10) || 0) % 60 : 0; void 0 !== Z.amPM && (b = b % 12 + 12 * utils_int(Z.amPM.textContent === Z.l10n.amPM[1])); var N = void 0 !== Z.config.minTime || Z.config.minDate && Z.minDateHasTime && Z.latestSelectedDateObj && 0 === compareDates(Z.latestSelectedDateObj, Z.config.minDate, !0), V = void 0 !== Z.config.maxTime || Z.config.maxDate && Z.maxDateHasTime && Z.latestSelectedDateObj && 0 === compareDates(Z.latestSelectedDateObj, Z.config.maxDate, !0); if (void 0 !== Z.config.maxTime && void 0 !== Z.config.minTime && Z.config.minTime > Z.config.maxTime) { var Y = calculateSecondsSinceMidnight(Z.config.minTime.getHours(), Z.config.minTime.getMinutes(), Z.config.minTime.getSeconds()), ee = calculateSecondsSinceMidnight(Z.config.maxTime.getHours(), Z.config.maxTime.getMinutes(), Z.config.maxTime.getSeconds()), et = calculateSecondsSinceMidnight(b, A, D); if (et > ee && et < Y) { var ea = parseSeconds(Y); b = ea[0], A = ea[1], D = ea[2] } } else { if (V) { var er = void 0 !== Z.config.maxTime ? Z.config.maxTime : Z.config.maxDate; (b = Math.min(b, er.getHours())) === er.getHours() && (A = Math.min(A, er.getMinutes())), A === er.getMinutes() && (D = Math.min(D, er.getSeconds())) } if (N) { var en = void 0 !== Z.config.minTime ? Z.config.minTime : Z.config.minDate; (b = Math.max(b, en.getHours())) === en.getHours() && A < en.getMinutes() && (A = en.getMinutes()), A === en.getMinutes() && (D = Math.max(D, en.getSeconds())) } } setHours(b, A, D) } } function setHoursFromDate(b) { var A = b || Z.latestSelectedDateObj; A && A instanceof Date && setHours(A.getHours(), A.getMinutes(), A.getSeconds()) } function setHours(b, A, D) { void 0 !== Z.latestSelectedDateObj && Z.latestSelectedDateObj.setHours(b % 24, A, D || 0, 0), Z.hourElement && Z.minuteElement && !Z.isMobile && (Z.hourElement.value = pad(Z.config.time_24hr ? b : (12 + b) % 12 + 12 * utils_int(b % 12 == 0)), Z.minuteElement.value = pad(A), void 0 !== Z.amPM && (Z.amPM.textContent = Z.l10n.amPM[utils_int(b >= 12)]), void 0 !== Z.secondElement && (Z.secondElement.value = pad(D))) } function onYearInput(b) { var A = parseInt(getEventTarget(b).value) + (b.delta || 0); (A / 1e3 > 1 || "Enter" === b.key && !/[^\d]/.test(A.toString())) && changeYear(A) } function bind(b, A, D, N) { return A instanceof Array ? A.forEach(function (A) { return bind(b, A, D, N) }) : b instanceof Array ? b.forEach(function (b) { return bind(b, A, D, N) }) : void (b.addEventListener(A, D, N), Z._handlers.push({ remove: function () { return b.removeEventListener(A, D, N) } })) } function triggerChange() { triggerEvent("onChange") } function jumpToDate(b, A) { var D = void 0 !== b ? Z.parseDate(b) : Z.latestSelectedDateObj || (Z.config.minDate && Z.config.minDate > Z.now ? Z.config.minDate : Z.config.maxDate && Z.config.maxDate < Z.now ? Z.config.maxDate : Z.now), N = Z.currentYear, V = Z.currentMonth; try { void 0 !== D && (Z.currentYear = D.getFullYear(), Z.currentMonth = D.getMonth()) } catch (b) { b.message = "Invalid date supplied: " + D, Z.config.errorHandler(b) } A && Z.currentYear !== N && (triggerEvent("onYearChange"), buildMonthSwitch()), A && (Z.currentYear !== N || Z.currentMonth !== V) && triggerEvent("onMonthChange"), Z.redraw() } function timeIncrement(b) { var A = getEventTarget(b); ~A.className.indexOf("arrow") && incrementNumInput(b, A.classList.contains("arrowUp") ? 1 : -1) } function incrementNumInput(b, A, D) { var N = b && getEventTarget(b), V = D || N && N.parentNode && N.parentNode.firstChild, Y = createEvent("increment"); Y.delta = A, V && V.dispatchEvent(Y) } function createDay(b, A, D, N) { var V = isEnabled(A, !0), Y = createElement("span", b, A.getDate().toString()); return Y.dateObj = A, Y.$i = N, Y.setAttribute("aria-label", Z.formatDate(A, Z.config.ariaDateFormat)), -1 === b.indexOf("hidden") && 0 === compareDates(A, Z.now) && (Z.todayDateElem = Y, Y.classList.add("today"), Y.setAttribute("aria-current", "date")), V ? (Y.tabIndex = -1, isDateSelected(A) && (Y.classList.add("selected"), Z.selectedDateElem = Y, "range" === Z.config.mode && (toggleClass(Y, "startRange", Z.selectedDates[0] && 0 === compareDates(A, Z.selectedDates[0], !0)), toggleClass(Y, "endRange", Z.selectedDates[1] && 0 === compareDates(A, Z.selectedDates[1], !0)), "nextMonthDay" === b && Y.classList.add("inRange")))) : Y.classList.add("flatpickr-disabled"), "range" === Z.config.mode && "range" === Z.config.mode && !(Z.selectedDates.length < 2) && compareDates(A, Z.selectedDates[0]) >= 0 && 0 >= compareDates(A, Z.selectedDates[1]) && !isDateSelected(A) && Y.classList.add("inRange"), Z.weekNumbers && 1 === Z.config.showMonths && "prevMonthDay" !== b && N % 7 == 6 && Z.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + Z.config.getWeek(A) + "</span>"), triggerEvent("onDayCreate", Y), Y } function focusOnDayElem(b) { b.focus(), "range" === Z.config.mode && onMouseOver(b) } function getFirstAvailableDay(b) { for (var A = b > 0 ? 0 : Z.config.showMonths - 1, D = b > 0 ? Z.config.showMonths : -1, N = A; N != D; N += b)for (var V = Z.daysContainer.children[N], Y = b > 0 ? 0 : V.children.length - 1, ee = b > 0 ? V.children.length : -1, et = Y; et != ee; et += b) { var ea = V.children[et]; if (-1 === ea.className.indexOf("hidden") && isEnabled(ea.dateObj)) return ea } } function focusOnDay(b, A) { var D = getClosestActiveElement(), N = isInView(D || document.body), V = void 0 !== b ? b : N ? D : void 0 !== Z.selectedDateElem && isInView(Z.selectedDateElem) ? Z.selectedDateElem : void 0 !== Z.todayDateElem && isInView(Z.todayDateElem) ? Z.todayDateElem : getFirstAvailableDay(A > 0 ? 1 : -1); void 0 === V ? Z._input.focus() : N ? function (b, A) { for (var D = -1 === b.className.indexOf("Month") ? b.dateObj.getMonth() : Z.currentMonth, N = A > 0 ? Z.config.showMonths : -1, V = A > 0 ? 1 : -1, Y = D - Z.currentMonth; Y != N; Y += V)for (var ee = Z.daysContainer.children[Y], et = D - Z.currentMonth === Y ? b.$i + A : A < 0 ? ee.children.length - 1 : 0, ea = ee.children.length, er = et; er >= 0 && er < ea && er != (A > 0 ? ea : -1); er += V) { var en = ee.children[er]; if (-1 === en.className.indexOf("hidden") && isEnabled(en.dateObj) && Math.abs(b.$i - er) >= Math.abs(A)) return focusOnDayElem(en) } Z.changeMonth(V), focusOnDay(getFirstAvailableDay(V), 0) }(V, A) : focusOnDayElem(V) } function buildDays() { if (void 0 !== Z.daysContainer) { clearNode(Z.daysContainer), Z.weekNumbers && clearNode(Z.weekNumbers); for (var b = document.createDocumentFragment(), A = 0; A < Z.config.showMonths; A++) { var D = new Date(Z.currentYear, Z.currentMonth, 1); D.setMonth(Z.currentMonth + A), b.appendChild(function (b, A) { for (var D = (new Date(b, A, 1).getDay() - Z.l10n.firstDayOfWeek + 7) % 7, N = Z.utils.getDaysInMonth((A - 1 + 12) % 12, b), V = Z.utils.getDaysInMonth(A, b), Y = window.document.createDocumentFragment(), ee = Z.config.showMonths > 1, et = ee ? "prevMonthDay hidden" : "prevMonthDay", ea = ee ? "nextMonthDay hidden" : "nextMonthDay", er = N + 1 - D, en = 0; er <= N; er++, en++)Y.appendChild(createDay("flatpickr-day " + et, new Date(b, A - 1, er), er, en)); for (er = 1; er <= V; er++, en++)Y.appendChild(createDay("flatpickr-day", new Date(b, A, er), er, en)); for (var eo = V + 1; eo <= 42 - D && (1 === Z.config.showMonths || en % 7 != 0); eo++, en++)Y.appendChild(createDay("flatpickr-day " + ea, new Date(b, A + 1, eo % V), eo, en)); var es = createElement("div", "dayContainer"); return es.appendChild(Y), es }(D.getFullYear(), D.getMonth())) } Z.daysContainer.appendChild(b), Z.days = Z.daysContainer.firstChild, "range" === Z.config.mode && 1 === Z.selectedDates.length && onMouseOver() } } function buildMonthSwitch() { if (!(Z.config.showMonths > 1) && "dropdown" === Z.config.monthSelectorType) { Z.monthsDropdownContainer.tabIndex = -1, Z.monthsDropdownContainer.innerHTML = ""; for (var b, A = 0; A < 12; A++)if (b = A, !(void 0 !== Z.config.minDate && Z.currentYear === Z.config.minDate.getFullYear() && b < Z.config.minDate.getMonth() || void 0 !== Z.config.maxDate && Z.currentYear === Z.config.maxDate.getFullYear() && b > Z.config.maxDate.getMonth())) { var D = createElement("option", "flatpickr-monthDropdown-month"); D.value = new Date(Z.currentYear, A).getMonth().toString(), D.textContent = monthToStr(A, Z.config.shorthandCurrentMonth, Z.l10n), D.tabIndex = -1, Z.currentMonth === A && (D.selected = !0), Z.monthsDropdownContainer.appendChild(D) } } } function buildMonths() { clearNode(Z.monthNav), Z.monthNav.appendChild(Z.prevMonthNav), Z.config.showMonths && (Z.yearElements = [], Z.monthElements = []); for (var b = Z.config.showMonths; b--;) { var A = function () { var b, A = createElement("div", "flatpickr-month"), D = window.document.createDocumentFragment(); Z.config.showMonths > 1 || "static" === Z.config.monthSelectorType ? b = createElement("span", "cur-month") : (Z.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months"), Z.monthsDropdownContainer.setAttribute("aria-label", Z.l10n.monthAriaLabel), bind(Z.monthsDropdownContainer, "change", function (b) { var A = parseInt(getEventTarget(b).value, 10); Z.changeMonth(A - Z.currentMonth), triggerEvent("onMonthChange") }), buildMonthSwitch(), b = Z.monthsDropdownContainer); var N = createNumberInput("cur-year", { tabindex: "-1" }), V = N.getElementsByTagName("input")[0]; V.setAttribute("aria-label", Z.l10n.yearAriaLabel), Z.config.minDate && V.setAttribute("min", Z.config.minDate.getFullYear().toString()), Z.config.maxDate && (V.setAttribute("max", Z.config.maxDate.getFullYear().toString()), V.disabled = !!Z.config.minDate && Z.config.minDate.getFullYear() === Z.config.maxDate.getFullYear()); var Y = createElement("div", "flatpickr-current-month"); return Y.appendChild(b), Y.appendChild(N), D.appendChild(Y), A.appendChild(D), { container: A, yearElement: V, monthElement: b } }(); Z.yearElements.push(A.yearElement), Z.monthElements.push(A.monthElement), Z.monthNav.appendChild(A.container) } Z.monthNav.appendChild(Z.nextMonthNav) } function buildWeekdays() { Z.weekdayContainer ? clearNode(Z.weekdayContainer) : Z.weekdayContainer = createElement("div", "flatpickr-weekdays"); for (var b = Z.config.showMonths; b--;) { var A = createElement("div", "flatpickr-weekdaycontainer"); Z.weekdayContainer.appendChild(A) } return updateWeekdays(), Z.weekdayContainer } function updateWeekdays() { if (Z.weekdayContainer) { var b = Z.l10n.firstDayOfWeek, A = __spreadArrays(Z.l10n.weekdays.shorthand); b > 0 && b < A.length && (A = __spreadArrays(A.splice(b, A.length), A.splice(0, b))); for (var D = Z.config.showMonths; D--;)Z.weekdayContainer.children[D].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + A.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      " } } function changeMonth(b, A) { void 0 === A && (A = !0); var D = A ? b : b - Z.currentMonth; D < 0 && !0 === Z._hidePrevMonthArrow || D > 0 && !0 === Z._hideNextMonthArrow || (Z.currentMonth += D, (Z.currentMonth < 0 || Z.currentMonth > 11) && (Z.currentYear += Z.currentMonth > 11 ? 1 : -1, Z.currentMonth = (Z.currentMonth + 12) % 12, triggerEvent("onYearChange"), buildMonthSwitch()), buildDays(), triggerEvent("onMonthChange"), updateNavigationCurrentMonth()) } function isCalendarElem(b) { return Z.calendarContainer.contains(b) } function documentClick(b) { if (Z.isOpen && !Z.config.inline) { var A = getEventTarget(b), D = isCalendarElem(A), N = !(A === Z.input || A === Z.altInput || Z.element.contains(A) || b.path && b.path.indexOf && (~b.path.indexOf(Z.input) || ~b.path.indexOf(Z.altInput))) && !D && !isCalendarElem(b.relatedTarget), V = !Z.config.ignoredFocusElements.some(function (b) { return b.contains(A) }); N && V && (Z.config.allowInput && Z.setDate(Z._input.value, !1, Z.config.altInput ? Z.config.altFormat : Z.config.dateFormat), void 0 !== Z.timeContainer && void 0 !== Z.minuteElement && void 0 !== Z.hourElement && "" !== Z.input.value && void 0 !== Z.input.value && updateTime(), Z.close(), Z.config && "range" === Z.config.mode && 1 === Z.selectedDates.length && Z.clear(!1)) } } function changeYear(b) { if (!(!b || Z.config.minDate && b < Z.config.minDate.getFullYear() || Z.config.maxDate && b > Z.config.maxDate.getFullYear())) { var A = Z.currentYear !== b; Z.currentYear = b || Z.currentYear, Z.config.maxDate && Z.currentYear === Z.config.maxDate.getFullYear() ? Z.currentMonth = Math.min(Z.config.maxDate.getMonth(), Z.currentMonth) : Z.config.minDate && Z.currentYear === Z.config.minDate.getFullYear() && (Z.currentMonth = Math.max(Z.config.minDate.getMonth(), Z.currentMonth)), A && (Z.redraw(), triggerEvent("onYearChange"), buildMonthSwitch()) } } function isEnabled(b, A) { void 0 === A && (A = !0); var D, N = Z.parseDate(b, void 0, A); if (Z.config.minDate && N && 0 > compareDates(N, Z.config.minDate, void 0 !== A ? A : !Z.minDateHasTime) || Z.config.maxDate && N && compareDates(N, Z.config.maxDate, void 0 !== A ? A : !Z.maxDateHasTime) > 0) return !1; if (!Z.config.enable && 0 === Z.config.disable.length) return !0; if (void 0 === N) return !1; for (var V = !!Z.config.enable, Y = null !== (D = Z.config.enable) && void 0 !== D ? D : Z.config.disable, ee = 0, et = void 0; ee < Y.length; ee++) { if ("function" == typeof (et = Y[ee]) && et(N) || et instanceof Date && void 0 !== N && et.getTime() === N.getTime()) return V; if ("string" == typeof et) { var ea = Z.parseDate(et, void 0, !0); return ea && ea.getTime() === N.getTime() ? V : !V } if ("object" == typeof et && void 0 !== N && et.from && et.to && N.getTime() >= et.from.getTime() && N.getTime() <= et.to.getTime()) return V } return !V } function isInView(b) { return void 0 !== Z.daysContainer && -1 === b.className.indexOf("hidden") && -1 === b.className.indexOf("flatpickr-disabled") && Z.daysContainer.contains(b) } function onBlur(b) { var A = b.target === Z._input, D = Z._input.value.trimEnd() !== getDateStr(); A && D && !(b.relatedTarget && isCalendarElem(b.relatedTarget)) && Z.setDate(Z._input.value, !0, b.target === Z.altInput ? Z.config.altFormat : Z.config.dateFormat) } function onKeyDown(A) { var D = getEventTarget(A), N = Z.config.wrap ? b.contains(D) : D === Z._input, V = Z.config.allowInput, Y = Z.isOpen && (!V || !N), ee = Z.config.inline && N && !V; if (13 === A.keyCode && N) { if (V) return Z.setDate(Z._input.value, !0, D === Z.altInput ? Z.config.altFormat : Z.config.dateFormat), Z.close(), D.blur(); Z.open() } else if (isCalendarElem(D) || Y || ee) { var et = !!Z.timeContainer && Z.timeContainer.contains(D); switch (A.keyCode) { case 13: et ? (A.preventDefault(), updateTime(), focusAndClose()) : selectDate(A); break; case 27: A.preventDefault(), focusAndClose(); break; case 8: case 46: N && !Z.config.allowInput && (A.preventDefault(), Z.clear()); break; case 37: case 39: if (et || N) Z.hourElement && Z.hourElement.focus(); else { A.preventDefault(); var ea = getClosestActiveElement(); if (void 0 !== Z.daysContainer && (!1 === V || ea && isInView(ea))) { var er = 39 === A.keyCode ? 1 : -1; A.ctrlKey ? (A.stopPropagation(), changeMonth(er), focusOnDay(getFirstAvailableDay(1), 0)) : focusOnDay(void 0, er) } } break; case 38: case 40: A.preventDefault(); var en = 40 === A.keyCode ? 1 : -1; Z.daysContainer && void 0 !== D.$i || D === Z.input || D === Z.altInput ? A.ctrlKey ? (A.stopPropagation(), changeYear(Z.currentYear - en), focusOnDay(getFirstAvailableDay(1), 0)) : et || focusOnDay(void 0, 7 * en) : D === Z.currentYearElement ? changeYear(Z.currentYear - en) : Z.config.enableTime && (!et && Z.hourElement && Z.hourElement.focus(), updateTime(A), Z._debouncedChange()); break; case 9: if (et) { var eo = [Z.hourElement, Z.minuteElement, Z.secondElement, Z.amPM].concat(Z.pluginElements).filter(function (b) { return b }), es = eo.indexOf(D); if (-1 !== es) { var el = eo[es + (A.shiftKey ? -1 : 1)]; A.preventDefault(), (el || Z._input).focus() } } else !Z.config.noCalendar && Z.daysContainer && Z.daysContainer.contains(D) && A.shiftKey && (A.preventDefault(), Z._input.focus()) } } if (void 0 !== Z.amPM && D === Z.amPM) switch (A.key) { case Z.l10n.amPM[0].charAt(0): case Z.l10n.amPM[0].charAt(0).toLowerCase(): Z.amPM.textContent = Z.l10n.amPM[0], setHoursFromInputs(), updateValue(); break; case Z.l10n.amPM[1].charAt(0): case Z.l10n.amPM[1].charAt(0).toLowerCase(): Z.amPM.textContent = Z.l10n.amPM[1], setHoursFromInputs(), updateValue() }(N || isCalendarElem(D)) && triggerEvent("onKeyDown", A) } function onMouseOver(b, A) { if (void 0 === A && (A = "flatpickr-day"), !(1 !== Z.selectedDates.length || b && (!b.classList.contains(A) || b.classList.contains("flatpickr-disabled")))) { for (var D = b ? b.dateObj.getTime() : Z.days.firstElementChild.dateObj.getTime(), N = Z.parseDate(Z.selectedDates[0], void 0, !0).getTime(), V = Math.min(D, Z.selectedDates[0].getTime()), Y = Math.max(D, Z.selectedDates[0].getTime()), ee = !1, et = 0, er = 0, en = V; en < Y; en += ea.DAY)!isEnabled(new Date(en), !0) && (ee = ee || en > V && en < Y, en < N && (!et || en > et) ? et = en : en > N && (!er || en < er) && (er = en)); Array.from(Z.rContainer.querySelectorAll("*:nth-child(-n+" + Z.config.showMonths + ") > ." + A)).forEach(function (A) { var V, Y, ea, en = A.dateObj.getTime(), eo = et > 0 && en < et || er > 0 && en > er; if (eo) { A.classList.add("notAllowed"), ["inRange", "startRange", "endRange"].forEach(function (b) { A.classList.remove(b) }); return } (!ee || eo) && (["startRange", "inRange", "endRange", "notAllowed"].forEach(function (b) { A.classList.remove(b) }), void 0 !== b && (b.classList.add(D <= Z.selectedDates[0].getTime() ? "startRange" : "endRange"), N < D && en === N ? A.classList.add("startRange") : N > D && en === N && A.classList.add("endRange"), en >= et && (0 === er || en <= er) && (V = en) > Math.min(Y = N, ea = D) && V < Math.max(Y, ea) && A.classList.add("inRange"))) }) } } function onResize() { !Z.isOpen || Z.config.static || Z.config.inline || positionCalendar() } function minMaxDateSetter(b) { return function (A) { var D = Z.config["_" + b + "Date"] = Z.parseDate(A, Z.config.dateFormat), N = Z.config["_" + ("min" === b ? "max" : "min") + "Date"]; void 0 !== D && (Z["min" === b ? "minDateHasTime" : "maxDateHasTime"] = D.getHours() > 0 || D.getMinutes() > 0 || D.getSeconds() > 0), Z.selectedDates && (Z.selectedDates = Z.selectedDates.filter(function (b) { return isEnabled(b) }), Z.selectedDates.length || "min" !== b || setHoursFromDate(D), updateValue()), Z.daysContainer && (redraw(), void 0 !== D ? Z.currentYearElement[b] = D.getFullYear().toString() : Z.currentYearElement.removeAttribute(b), Z.currentYearElement.disabled = !!N && void 0 !== D && N.getFullYear() === D.getFullYear()) } } function getInputElem() { return Z.config.wrap ? b.querySelector("[data-input]") : b } function setupLocale() { "object" != typeof Z.config.locale && void 0 === flatpickr.l10ns[Z.config.locale] && Z.config.errorHandler(Error("flatpickr: invalid locale " + Z.config.locale)), Z.l10n = __assign(__assign({}, flatpickr.l10ns.default), "object" == typeof Z.config.locale ? Z.config.locale : "default" !== Z.config.locale ? flatpickr.l10ns[Z.config.locale] : void 0), ee.D = "(" + Z.l10n.weekdays.shorthand.join("|") + ")", ee.l = "(" + Z.l10n.weekdays.longhand.join("|") + ")", ee.M = "(" + Z.l10n.months.shorthand.join("|") + ")", ee.F = "(" + Z.l10n.months.longhand.join("|") + ")", ee.K = "(" + Z.l10n.amPM[0] + "|" + Z.l10n.amPM[1] + "|" + Z.l10n.amPM[0].toLowerCase() + "|" + Z.l10n.amPM[1].toLowerCase() + ")", void 0 === __assign(__assign({}, A), JSON.parse(JSON.stringify(b.dataset || {}))).time_24hr && void 0 === flatpickr.defaultConfig.time_24hr && (Z.config.time_24hr = Z.l10n.time_24hr), Z.formatDate = createDateFormatter(Z), Z.parseDate = createDateParser({ config: Z.config, l10n: Z.l10n }) } function positionCalendar(b) { if ("function" == typeof Z.config.position) return void Z.config.position(Z, b); if (void 0 !== Z.calendarContainer) { triggerEvent("onPreCalendarPosition"); var A = b || Z._positionElement, D = Array.prototype.reduce.call(Z.calendarContainer.children, function (b, A) { return b + A.offsetHeight }, 0), N = Z.calendarContainer.offsetWidth, V = Z.config.position.split(" "), Y = V[0], ee = V.length > 1 ? V[1] : null, et = A.getBoundingClientRect(), ea = window.innerHeight - et.bottom, er = "above" === Y || "below" !== Y && ea < D && et.top > D, en = window.pageYOffset + et.top + (er ? -D - 2 : A.offsetHeight + 2); if (toggleClass(Z.calendarContainer, "arrowTop", !er), toggleClass(Z.calendarContainer, "arrowBottom", er), !Z.config.inline) { var eo = window.pageXOffset + et.left, es = !1, el = !1; "center" === ee ? (eo -= (N - et.width) / 2, es = !0) : "right" === ee && (eo -= N - et.width, el = !0), toggleClass(Z.calendarContainer, "arrowLeft", !es && !el), toggleClass(Z.calendarContainer, "arrowCenter", es), toggleClass(Z.calendarContainer, "arrowRight", el); var ed = window.document.body.offsetWidth - (window.pageXOffset + et.right), eu = eo + N > window.document.body.offsetWidth, ec = ed + N > window.document.body.offsetWidth; if (toggleClass(Z.calendarContainer, "rightMost", eu), !Z.config.static) { if (Z.calendarContainer.style.top = en + "px", eu) { if (ec) { var em = function () { for (var b = null, A = 0; A < document.styleSheets.length; A++) { var D = document.styleSheets[A]; if (D.cssRules) { try { D.cssRules } catch (b) { continue } b = D; break } } return null != b ? b : function () { var b = document.createElement("style"); return document.head.appendChild(b), b.sheet }() }(); if (void 0 === em) return; var eh = window.document.body.offsetWidth, ep = em.cssRules.length, ev = "{left:" + et.left + "px;right:auto;}"; toggleClass(Z.calendarContainer, "rightMost", !1), toggleClass(Z.calendarContainer, "centerMost", !0), em.insertRule(".flatpickr-calendar.centerMost:before,.flatpickr-calendar.centerMost:after" + ev, ep), Z.calendarContainer.style.left = Math.max(0, eh / 2 - N / 2) + "px", Z.calendarContainer.style.right = "auto" } else Z.calendarContainer.style.left = "auto", Z.calendarContainer.style.right = ed + "px" } else Z.calendarContainer.style.left = eo + "px", Z.calendarContainer.style.right = "auto" } } } } function redraw() { Z.config.noCalendar || Z.isMobile || (buildMonthSwitch(), updateNavigationCurrentMonth(), buildDays()) } function focusAndClose() { Z._input.focus(), -1 !== window.navigator.userAgent.indexOf("MSIE") || void 0 !== navigator.msMaxTouchPoints ? setTimeout(Z.close, 0) : Z.close() } function selectDate(b) { b.preventDefault(), b.stopPropagation(); var A = function findParent(b, A) { return A(b) ? b : b.parentNode ? findParent(b.parentNode, A) : void 0 }(getEventTarget(b), function (b) { return b.classList && b.classList.contains("flatpickr-day") && !b.classList.contains("flatpickr-disabled") && !b.classList.contains("notAllowed") }); if (void 0 !== A) { var D = Z.latestSelectedDateObj = new Date(A.dateObj.getTime()), N = (D.getMonth() < Z.currentMonth || D.getMonth() > Z.currentMonth + Z.config.showMonths - 1) && "range" !== Z.config.mode; if (Z.selectedDateElem = A, "single" === Z.config.mode) Z.selectedDates = [D]; else if ("multiple" === Z.config.mode) { var V = isDateSelected(D); V ? Z.selectedDates.splice(parseInt(V), 1) : Z.selectedDates.push(D) } else "range" === Z.config.mode && (2 === Z.selectedDates.length && Z.clear(!1, !1), Z.latestSelectedDateObj = D, Z.selectedDates.push(D), 0 !== compareDates(D, Z.selectedDates[0], !0) && Z.selectedDates.sort(function (b, A) { return b.getTime() - A.getTime() })); if (setHoursFromInputs(), N) { var Y = Z.currentYear !== D.getFullYear(); Z.currentYear = D.getFullYear(), Z.currentMonth = D.getMonth(), Y && (triggerEvent("onYearChange"), buildMonthSwitch()), triggerEvent("onMonthChange") } if (updateNavigationCurrentMonth(), buildDays(), updateValue(), N || "range" === Z.config.mode || 1 !== Z.config.showMonths ? void 0 !== Z.selectedDateElem && void 0 === Z.hourElement && Z.selectedDateElem && Z.selectedDateElem.focus() : focusOnDayElem(A), void 0 !== Z.hourElement && void 0 !== Z.hourElement && Z.hourElement.focus(), Z.config.closeOnSelect) { var ee = "single" === Z.config.mode && !Z.config.enableTime, et = "range" === Z.config.mode && 2 === Z.selectedDates.length && !Z.config.enableTime; (ee || et) && focusAndClose() } triggerChange() } } Z.parseDate = createDateParser({ config: Z.config, l10n: Z.l10n }), Z._handlers = [], Z.pluginElements = [], Z.loadedPlugins = [], Z._bind = bind, Z._setHoursFromDate = setHoursFromDate, Z._positionCalendar = positionCalendar, Z.changeMonth = changeMonth, Z.changeYear = changeYear, Z.clear = function (b, A) { if (void 0 === b && (b = !0), void 0 === A && (A = !0), Z.input.value = "", void 0 !== Z.altInput && (Z.altInput.value = ""), void 0 !== Z.mobileInput && (Z.mobileInput.value = ""), Z.selectedDates = [], Z.latestSelectedDateObj = void 0, !0 === A && (Z.currentYear = Z._initialDate.getFullYear(), Z.currentMonth = Z._initialDate.getMonth()), !0 === Z.config.enableTime) { var D = getDefaultHours(Z.config); setHours(D.hours, D.minutes, D.seconds) } Z.redraw(), b && triggerEvent("onChange") }, Z.close = function () { Z.isOpen = !1, Z.isMobile || (void 0 !== Z.calendarContainer && Z.calendarContainer.classList.remove("open"), void 0 !== Z._input && Z._input.classList.remove("active")), triggerEvent("onClose") }, Z.onMouseOver = onMouseOver, Z._createElement = createElement, Z.createDay = createDay, Z.destroy = function () { void 0 !== Z.config && triggerEvent("onDestroy"); for (var b = Z._handlers.length; b--;)Z._handlers[b].remove(); if (Z._handlers = [], Z.mobileInput) Z.mobileInput.parentNode && Z.mobileInput.parentNode.removeChild(Z.mobileInput), Z.mobileInput = void 0; else if (Z.calendarContainer && Z.calendarContainer.parentNode) { if (Z.config.static && Z.calendarContainer.parentNode) { var A = Z.calendarContainer.parentNode; if (A.lastChild && A.removeChild(A.lastChild), A.parentNode) { for (; A.firstChild;)A.parentNode.insertBefore(A.firstChild, A); A.parentNode.removeChild(A) } } else Z.calendarContainer.parentNode.removeChild(Z.calendarContainer) } Z.altInput && (Z.input.type = "text", Z.altInput.parentNode && Z.altInput.parentNode.removeChild(Z.altInput), delete Z.altInput), Z.input && (Z.input.type = Z.input._type, Z.input.classList.remove("flatpickr-input"), Z.input.removeAttribute("readonly")), ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (b) { try { delete Z[b] } catch (b) { } }) }, Z.isEnabled = isEnabled, Z.jumpToDate = jumpToDate, Z.updateValue = updateValue, Z.open = function (b, A) { if (void 0 === A && (A = Z._positionElement), !0 === Z.isMobile) { if (b) { b.preventDefault(); var D = getEventTarget(b); D && D.blur() } void 0 !== Z.mobileInput && (Z.mobileInput.focus(), Z.mobileInput.click()), triggerEvent("onOpen"); return } if (!Z._input.disabled && !Z.config.inline) { var N = Z.isOpen; Z.isOpen = !0, N || (Z.calendarContainer.classList.add("open"), Z._input.classList.add("active"), triggerEvent("onOpen"), positionCalendar(A)), !0 !== Z.config.enableTime || !0 !== Z.config.noCalendar || !1 !== Z.config.allowInput || void 0 !== b && Z.timeContainer.contains(b.relatedTarget) || setTimeout(function () { return Z.hourElement.select() }, 50) } }, Z.redraw = redraw, Z.set = function (b, A) { if (null !== b && "object" == typeof b) for (var D in Object.assign(Z.config, b), b) void 0 !== et[D] && et[D].forEach(function (b) { return b() }); else Z.config[b] = A, void 0 !== et[b] ? et[b].forEach(function (b) { return b() }) : N.indexOf(b) > -1 && (Z.config[b] = arrayify(A)); Z.redraw(), updateValue(!0) }, Z.setDate = function (b, A, D) { if (void 0 === A && (A = !1), void 0 === D && (D = Z.config.dateFormat), 0 !== b && !b || b instanceof Array && 0 === b.length) return Z.clear(A); setSelectedDate(b, D), Z.latestSelectedDateObj = Z.selectedDates[Z.selectedDates.length - 1], Z.redraw(), jumpToDate(void 0, A), setHoursFromDate(), 0 === Z.selectedDates.length && Z.clear(!1), updateValue(A), A && triggerEvent("onChange") }, Z.toggle = function (b) { if (!0 === Z.isOpen) return Z.close(); Z.open(b) }; var et = { locale: [setupLocale, updateWeekdays], showMonths: [buildMonths, setCalendarWidth, buildWeekdays], minDate: [jumpToDate], maxDate: [jumpToDate], positionElement: [updatePositionElement], clickOpens: [function () { !0 === Z.config.clickOpens ? (bind(Z._input, "focus", Z.open), bind(Z._input, "click", Z.open)) : (Z._input.removeEventListener("focus", Z.open), Z._input.removeEventListener("click", Z.open)) }] }; function setSelectedDate(b, A) { var D = []; if (b instanceof Array) D = b.map(function (b) { return Z.parseDate(b, A) }); else if (b instanceof Date || "number" == typeof b) D = [Z.parseDate(b, A)]; else if ("string" == typeof b) switch (Z.config.mode) { case "single": case "time": D = [Z.parseDate(b, A)]; break; case "multiple": D = b.split(Z.config.conjunction).map(function (b) { return Z.parseDate(b, A) }); break; case "range": D = b.split(Z.l10n.rangeSeparator).map(function (b) { return Z.parseDate(b, A) }) } else Z.config.errorHandler(Error("Invalid date supplied: " + JSON.stringify(b))); Z.selectedDates = Z.config.allowInvalidPreload ? D : D.filter(function (b) { return b instanceof Date && isEnabled(b, !1) }), "range" === Z.config.mode && Z.selectedDates.sort(function (b, A) { return b.getTime() - A.getTime() }) } function parseDateRules(b) { return b.slice().map(function (b) { return "string" == typeof b || "number" == typeof b || b instanceof Date ? Z.parseDate(b, void 0, !0) : b && "object" == typeof b && b.from && b.to ? { from: Z.parseDate(b.from, void 0), to: Z.parseDate(b.to, void 0) } : b }).filter(function (b) { return b }) } function updatePositionElement() { Z._positionElement = Z.config.positionElement || Z._input } function triggerEvent(b, A) { if (void 0 !== Z.config) { var D = Z.config[b]; if (void 0 !== D && D.length > 0) for (var N = 0; D[N] && N < D.length; N++)D[N](Z.selectedDates, Z.input.value, Z, A); "onChange" === b && (Z.input.dispatchEvent(createEvent("change")), Z.input.dispatchEvent(createEvent("input"))) } } function createEvent(b) { var A = document.createEvent("Event"); return A.initEvent(b, !0, !0), A } function isDateSelected(b) { for (var A = 0; A < Z.selectedDates.length; A++) { var D = Z.selectedDates[A]; if (D instanceof Date && 0 === compareDates(D, b)) return "" + A } return !1 } function updateNavigationCurrentMonth() { Z.config.noCalendar || Z.isMobile || !Z.monthNav || (Z.yearElements.forEach(function (b, A) { var D = new Date(Z.currentYear, Z.currentMonth, 1); D.setMonth(Z.currentMonth + A), Z.config.showMonths > 1 || "static" === Z.config.monthSelectorType ? Z.monthElements[A].textContent = monthToStr(D.getMonth(), Z.config.shorthandCurrentMonth, Z.l10n) + " " : Z.monthsDropdownContainer.value = D.getMonth().toString(), b.value = D.getFullYear().toString() }), Z._hidePrevMonthArrow = void 0 !== Z.config.minDate && (Z.currentYear === Z.config.minDate.getFullYear() ? Z.currentMonth <= Z.config.minDate.getMonth() : Z.currentYear < Z.config.minDate.getFullYear()), Z._hideNextMonthArrow = void 0 !== Z.config.maxDate && (Z.currentYear === Z.config.maxDate.getFullYear() ? Z.currentMonth + 1 > Z.config.maxDate.getMonth() : Z.currentYear > Z.config.maxDate.getFullYear())) } function getDateStr(b) { var A = b || (Z.config.altInput ? Z.config.altFormat : Z.config.dateFormat); return Z.selectedDates.map(function (b) { return Z.formatDate(b, A) }).filter(function (b, A, D) { return "range" !== Z.config.mode || Z.config.enableTime || D.indexOf(b) === A }).join("range" !== Z.config.mode ? Z.config.conjunction : Z.l10n.rangeSeparator) } function updateValue(b) { void 0 === b && (b = !0), void 0 !== Z.mobileInput && Z.mobileFormatStr && (Z.mobileInput.value = void 0 !== Z.latestSelectedDateObj ? Z.formatDate(Z.latestSelectedDateObj, Z.mobileFormatStr) : ""), Z.input.value = getDateStr(Z.config.dateFormat), void 0 !== Z.altInput && (Z.altInput.value = getDateStr(Z.config.altFormat)), !1 !== b && triggerEvent("onValueUpdate") } function onMonthNavClick(b) { var A = getEventTarget(b), D = Z.prevMonthNav.contains(A), N = Z.nextMonthNav.contains(A); D || N ? changeMonth(D ? -1 : 1) : Z.yearElements.indexOf(A) >= 0 ? A.select() : A.classList.contains("arrowUp") ? Z.changeYear(Z.currentYear + 1) : A.classList.contains("arrowDown") && Z.changeYear(Z.currentYear - 1) } return Z.element = Z.input = b, Z.isOpen = !1, function () { var D = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"], Y = __assign(__assign({}, JSON.parse(JSON.stringify(b.dataset || {}))), A), ee = {}; Z.config.parseDate = Y.parseDate, Z.config.formatDate = Y.formatDate, Object.defineProperty(Z.config, "enable", { get: function () { return Z.config._enable }, set: function (b) { Z.config._enable = parseDateRules(b) } }), Object.defineProperty(Z.config, "disable", { get: function () { return Z.config._disable }, set: function (b) { Z.config._disable = parseDateRules(b) } }); var et = "time" === Y.mode; if (!Y.dateFormat && (Y.enableTime || et)) { var ea = flatpickr.defaultConfig.dateFormat || V.dateFormat; ee.dateFormat = Y.noCalendar || et ? "H:i" + (Y.enableSeconds ? ":S" : "") : ea + " H:i" + (Y.enableSeconds ? ":S" : "") } if (Y.altInput && (Y.enableTime || et) && !Y.altFormat) { var er = flatpickr.defaultConfig.altFormat || V.altFormat; ee.altFormat = Y.noCalendar || et ? "h:i" + (Y.enableSeconds ? ":S K" : " K") : er + " h:i" + (Y.enableSeconds ? ":S" : "") + " K" } Object.defineProperty(Z.config, "minDate", { get: function () { return Z.config._minDate }, set: minMaxDateSetter("min") }), Object.defineProperty(Z.config, "maxDate", { get: function () { return Z.config._maxDate }, set: minMaxDateSetter("max") }); var minMaxTimeSetter = function (b) { return function (A) { Z.config["min" === b ? "_minTime" : "_maxTime"] = Z.parseDate(A, "H:i:S") } }; Object.defineProperty(Z.config, "minTime", { get: function () { return Z.config._minTime }, set: minMaxTimeSetter("min") }), Object.defineProperty(Z.config, "maxTime", { get: function () { return Z.config._maxTime }, set: minMaxTimeSetter("max") }), "time" === Y.mode && (Z.config.noCalendar = !0, Z.config.enableTime = !0), Object.assign(Z.config, ee, Y); for (var en = 0; en < D.length; en++)Z.config[D[en]] = !0 === Z.config[D[en]] || "true" === Z.config[D[en]]; N.filter(function (b) { return void 0 !== Z.config[b] }).forEach(function (b) { Z.config[b] = arrayify(Z.config[b] || []).map(bindToInstance) }), Z.isMobile = !Z.config.disableMobile && !Z.config.inline && "single" === Z.config.mode && !Z.config.disable.length && !Z.config.enable && !Z.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); for (var en = 0; en < Z.config.plugins.length; en++) { var eo = Z.config.plugins[en](Z) || {}; for (var es in eo) N.indexOf(es) > -1 ? Z.config[es] = arrayify(eo[es]).map(bindToInstance).concat(Z.config[es]) : void 0 === Y[es] && (Z.config[es] = eo[es]) } Y.altInputClass || (Z.config.altInputClass = getInputElem().className + " " + Z.config.altInputClass), triggerEvent("onParseConfig") }(), setupLocale(), function () { if (Z.input = getInputElem(), !Z.input) { Z.config.errorHandler(Error("Invalid input element specified")); return } Z.input._type = Z.input.type, Z.input.type = "text", Z.input.classList.add("flatpickr-input"), Z._input = Z.input, Z.config.altInput && (Z.altInput = createElement(Z.input.nodeName, Z.config.altInputClass), Z._input = Z.altInput, Z.altInput.placeholder = Z.input.placeholder, Z.altInput.disabled = Z.input.disabled, Z.altInput.required = Z.input.required, Z.altInput.tabIndex = Z.input.tabIndex, Z.altInput.type = "text", Z.input.setAttribute("type", "hidden"), !Z.config.static && Z.input.parentNode && Z.input.parentNode.insertBefore(Z.altInput, Z.input.nextSibling)), Z.config.allowInput || Z._input.setAttribute("readonly", "readonly"), updatePositionElement() }(), function () { Z.selectedDates = [], Z.now = Z.parseDate(Z.config.now) || new Date; var b = Z.config.defaultDate || (("INPUT" === Z.input.nodeName || "TEXTAREA" === Z.input.nodeName) && Z.input.placeholder && Z.input.value === Z.input.placeholder ? null : Z.input.value); b && setSelectedDate(b, Z.config.dateFormat), Z._initialDate = Z.selectedDates.length > 0 ? Z.selectedDates[0] : Z.config.minDate && Z.config.minDate.getTime() > Z.now.getTime() ? Z.config.minDate : Z.config.maxDate && Z.config.maxDate.getTime() < Z.now.getTime() ? Z.config.maxDate : Z.now, Z.currentYear = Z._initialDate.getFullYear(), Z.currentMonth = Z._initialDate.getMonth(), Z.selectedDates.length > 0 && (Z.latestSelectedDateObj = Z.selectedDates[0]), void 0 !== Z.config.minTime && (Z.config.minTime = Z.parseDate(Z.config.minTime, "H:i")), void 0 !== Z.config.maxTime && (Z.config.maxTime = Z.parseDate(Z.config.maxTime, "H:i")), Z.minDateHasTime = !!Z.config.minDate && (Z.config.minDate.getHours() > 0 || Z.config.minDate.getMinutes() > 0 || Z.config.minDate.getSeconds() > 0), Z.maxDateHasTime = !!Z.config.maxDate && (Z.config.maxDate.getHours() > 0 || Z.config.maxDate.getMinutes() > 0 || Z.config.maxDate.getSeconds() > 0) }(), Z.utils = { getDaysInMonth: function (b, A) { return (void 0 === b && (b = Z.currentMonth), void 0 === A && (A = Z.currentYear), 1 === b && (A % 4 == 0 && A % 100 != 0 || A % 400 == 0)) ? 29 : Z.l10n.daysInMonth[b] } }, Z.isMobile || function () { var b = window.document.createDocumentFragment(); if (Z.calendarContainer = createElement("div", "flatpickr-calendar"), Z.calendarContainer.tabIndex = -1, !Z.config.noCalendar) { if (b.appendChild((Z.monthNav = createElement("div", "flatpickr-months"), Z.yearElements = [], Z.monthElements = [], Z.prevMonthNav = createElement("span", "flatpickr-prev-month"), Z.prevMonthNav.innerHTML = Z.config.prevArrow, Z.nextMonthNav = createElement("span", "flatpickr-next-month"), Z.nextMonthNav.innerHTML = Z.config.nextArrow, buildMonths(), Object.defineProperty(Z, "_hidePrevMonthArrow", { get: function () { return Z.__hidePrevMonthArrow }, set: function (b) { Z.__hidePrevMonthArrow !== b && (toggleClass(Z.prevMonthNav, "flatpickr-disabled", b), Z.__hidePrevMonthArrow = b) } }), Object.defineProperty(Z, "_hideNextMonthArrow", { get: function () { return Z.__hideNextMonthArrow }, set: function (b) { Z.__hideNextMonthArrow !== b && (toggleClass(Z.nextMonthNav, "flatpickr-disabled", b), Z.__hideNextMonthArrow = b) } }), Z.currentYearElement = Z.yearElements[0], updateNavigationCurrentMonth(), Z.monthNav)), Z.innerContainer = createElement("div", "flatpickr-innerContainer"), Z.config.weekNumbers) { var A = function () { Z.calendarContainer.classList.add("hasWeeks"); var b = createElement("div", "flatpickr-weekwrapper"); b.appendChild(createElement("span", "flatpickr-weekday", Z.l10n.weekAbbreviation)); var A = createElement("div", "flatpickr-weeks"); return b.appendChild(A), { weekWrapper: b, weekNumbers: A } }(), D = A.weekWrapper, N = A.weekNumbers; Z.innerContainer.appendChild(D), Z.weekNumbers = N, Z.weekWrapper = D } Z.rContainer = createElement("div", "flatpickr-rContainer"), Z.rContainer.appendChild(buildWeekdays()), Z.daysContainer || (Z.daysContainer = createElement("div", "flatpickr-days"), Z.daysContainer.tabIndex = -1), buildDays(), Z.rContainer.appendChild(Z.daysContainer), Z.innerContainer.appendChild(Z.rContainer), b.appendChild(Z.innerContainer) } Z.config.enableTime && b.appendChild(function () { Z.calendarContainer.classList.add("hasTime"), Z.config.noCalendar && Z.calendarContainer.classList.add("noCalendar"); var b = getDefaultHours(Z.config); Z.timeContainer = createElement("div", "flatpickr-time"), Z.timeContainer.tabIndex = -1; var A = createElement("span", "flatpickr-time-separator", ":"), D = createNumberInput("flatpickr-hour", { "aria-label": Z.l10n.hourAriaLabel }); Z.hourElement = D.getElementsByTagName("input")[0]; var N = createNumberInput("flatpickr-minute", { "aria-label": Z.l10n.minuteAriaLabel }); if (Z.minuteElement = N.getElementsByTagName("input")[0], Z.hourElement.tabIndex = Z.minuteElement.tabIndex = -1, Z.hourElement.value = pad(Z.latestSelectedDateObj ? Z.latestSelectedDateObj.getHours() : Z.config.time_24hr ? b.hours : function (b) { switch (b % 24) { case 0: case 12: return 12; default: return b % 12 } }(b.hours)), Z.minuteElement.value = pad(Z.latestSelectedDateObj ? Z.latestSelectedDateObj.getMinutes() : b.minutes), Z.hourElement.setAttribute("step", Z.config.hourIncrement.toString()), Z.minuteElement.setAttribute("step", Z.config.minuteIncrement.toString()), Z.hourElement.setAttribute("min", Z.config.time_24hr ? "0" : "1"), Z.hourElement.setAttribute("max", Z.config.time_24hr ? "23" : "12"), Z.hourElement.setAttribute("maxlength", "2"), Z.minuteElement.setAttribute("min", "0"), Z.minuteElement.setAttribute("max", "59"), Z.minuteElement.setAttribute("maxlength", "2"), Z.timeContainer.appendChild(D), Z.timeContainer.appendChild(A), Z.timeContainer.appendChild(N), Z.config.time_24hr && Z.timeContainer.classList.add("time24hr"), Z.config.enableSeconds) { Z.timeContainer.classList.add("hasSeconds"); var V = createNumberInput("flatpickr-second"); Z.secondElement = V.getElementsByTagName("input")[0], Z.secondElement.value = pad(Z.latestSelectedDateObj ? Z.latestSelectedDateObj.getSeconds() : b.seconds), Z.secondElement.setAttribute("step", Z.minuteElement.getAttribute("step")), Z.secondElement.setAttribute("min", "0"), Z.secondElement.setAttribute("max", "59"), Z.secondElement.setAttribute("maxlength", "2"), Z.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":")), Z.timeContainer.appendChild(V) } return Z.config.time_24hr || (Z.amPM = createElement("span", "flatpickr-am-pm", Z.l10n.amPM[utils_int((Z.latestSelectedDateObj ? Z.hourElement.value : Z.config.defaultHour) > 11)]), Z.amPM.title = Z.l10n.toggleTitle, Z.amPM.tabIndex = -1, Z.timeContainer.appendChild(Z.amPM)), Z.timeContainer }()), toggleClass(Z.calendarContainer, "rangeMode", "range" === Z.config.mode), toggleClass(Z.calendarContainer, "animate", !0 === Z.config.animate), toggleClass(Z.calendarContainer, "multiMonth", Z.config.showMonths > 1), Z.calendarContainer.appendChild(b); var V = void 0 !== Z.config.appendTo && void 0 !== Z.config.appendTo.nodeType; if ((Z.config.inline || Z.config.static) && (Z.calendarContainer.classList.add(Z.config.inline ? "inline" : "static"), Z.config.inline && (!V && Z.element.parentNode ? Z.element.parentNode.insertBefore(Z.calendarContainer, Z._input.nextSibling) : void 0 !== Z.config.appendTo && Z.config.appendTo.appendChild(Z.calendarContainer)), Z.config.static)) { var Y = createElement("div", "flatpickr-wrapper"); Z.element.parentNode && Z.element.parentNode.insertBefore(Y, Z.element), Y.appendChild(Z.element), Z.altInput && Y.appendChild(Z.altInput), Y.appendChild(Z.calendarContainer) } Z.config.static || Z.config.inline || (void 0 !== Z.config.appendTo ? Z.config.appendTo : window.document.body).appendChild(Z.calendarContainer) }(), function () { if (Z.config.wrap && ["open", "close", "toggle", "clear"].forEach(function (b) { Array.prototype.forEach.call(Z.element.querySelectorAll("[data-" + b + "]"), function (A) { return bind(A, "click", Z[b]) }) }), Z.isMobile) { (function () { var b = Z.config.enableTime ? Z.config.noCalendar ? "time" : "datetime-local" : "date"; Z.mobileInput = createElement("input", Z.input.className + " flatpickr-mobile"), Z.mobileInput.tabIndex = 1, Z.mobileInput.type = b, Z.mobileInput.disabled = Z.input.disabled, Z.mobileInput.required = Z.input.required, Z.mobileInput.placeholder = Z.input.placeholder, Z.mobileFormatStr = "datetime-local" === b ? "Y-m-d\\TH:i:S" : "date" === b ? "Y-m-d" : "H:i:S", Z.selectedDates.length > 0 && (Z.mobileInput.defaultValue = Z.mobileInput.value = Z.formatDate(Z.selectedDates[0], Z.mobileFormatStr)), Z.config.minDate && (Z.mobileInput.min = Z.formatDate(Z.config.minDate, "Y-m-d")), Z.config.maxDate && (Z.mobileInput.max = Z.formatDate(Z.config.maxDate, "Y-m-d")), Z.input.getAttribute("step") && (Z.mobileInput.step = String(Z.input.getAttribute("step"))), Z.input.type = "hidden", void 0 !== Z.altInput && (Z.altInput.type = "hidden"); try { Z.input.parentNode && Z.input.parentNode.insertBefore(Z.mobileInput, Z.input.nextSibling) } catch (b) { } bind(Z.mobileInput, "change", function (b) { Z.setDate(getEventTarget(b).value, !1, Z.mobileFormatStr), triggerEvent("onChange"), triggerEvent("onClose") }) })(); return } var b = debounce(onResize, 50); Z._debouncedChange = debounce(triggerChange, 300), Z.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent) && bind(Z.daysContainer, "mouseover", function (b) { "range" === Z.config.mode && onMouseOver(getEventTarget(b)) }), bind(Z._input, "keydown", onKeyDown), void 0 !== Z.calendarContainer && bind(Z.calendarContainer, "keydown", onKeyDown), Z.config.inline || Z.config.static || bind(window, "resize", b), void 0 !== window.ontouchstart ? bind(window.document, "touchstart", documentClick) : bind(window.document, "mousedown", documentClick), bind(window.document, "focus", documentClick, { capture: !0 }), !0 === Z.config.clickOpens && (bind(Z._input, "focus", Z.open), bind(Z._input, "click", Z.open)), void 0 !== Z.daysContainer && (bind(Z.monthNav, "click", onMonthNavClick), bind(Z.monthNav, ["keyup", "increment"], onYearInput), bind(Z.daysContainer, "click", selectDate)), void 0 !== Z.timeContainer && void 0 !== Z.minuteElement && void 0 !== Z.hourElement && (bind(Z.timeContainer, ["increment"], updateTime), bind(Z.timeContainer, "blur", updateTime, { capture: !0 }), bind(Z.timeContainer, "click", timeIncrement), bind([Z.hourElement, Z.minuteElement], ["focus", "click"], function (b) { return getEventTarget(b).select() }), void 0 !== Z.secondElement && bind(Z.secondElement, "focus", function () { return Z.secondElement && Z.secondElement.select() }), void 0 !== Z.amPM && bind(Z.amPM, "click", function (b) { updateTime(b) })), Z.config.allowInput && bind(Z._input, "blur", onBlur) }(), (Z.selectedDates.length || Z.config.noCalendar) && (Z.config.enableTime && setHoursFromDate(Z.config.noCalendar ? Z.latestSelectedDateObj : void 0), updateValue(!1)), setCalendarWidth(), D = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), !Z.isMobile && D && positionCalendar(), triggerEvent("onReady"), Z }(er, A || {}), Z.push(er._flatpickr) } catch (b) { console.error(b) } } return 1 === Z.length ? Z[0] : Z } "undefined" != typeof HTMLElement && "undefined" != typeof HTMLCollection && "undefined" != typeof NodeList && (HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (b) { return _flatpickr(this, b) }, HTMLElement.prototype.flatpickr = function (b) { return _flatpickr([this], b) }); var flatpickr = function (b, A) { return "string" == typeof b ? _flatpickr(window.document.querySelectorAll(b), A) : b instanceof Node ? _flatpickr([b], A) : _flatpickr(b, A) }; flatpickr.defaultConfig = {}, flatpickr.l10ns = { en: __assign({}, Y), default: __assign({}, Y) }, flatpickr.localize = function (b) { flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), b) }, flatpickr.setDefaults = function (b) { flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), b) }, flatpickr.parseDate = createDateParser({}), flatpickr.formatDate = createDateFormatter({}), flatpickr.compareDates = compareDates, "undefined" != typeof jQuery && void 0 !== jQuery.fn && (jQuery.fn.flatpickr = function (b) { return _flatpickr(this, b) }), Date.prototype.fp_incr = function (b) { return new Date(this.getFullYear(), this.getMonth(), this.getDate() + ("string" == typeof b ? parseInt(b, 10) : b)) }, "undefined" != typeof window && (window.flatpickr = flatpickr); var er = flatpickr }, 29911: function () { "use strict"; "function" != typeof Object.assign && (Object.assign = function (b) { for (var A = [], D = 1; D < arguments.length; D++)A[D - 1] = arguments[D]; if (!b) throw TypeError("Cannot convert undefined or null to object"); for (var _loop_1 = function (A) { A && Object.keys(A).forEach(function (D) { return b[D] = A[D] }) }, N = 0; N < A.length; N++)_loop_1(A[N]); return b }) }, 27365: function (b, A) { var D, N, V; D = "undefined" != typeof window && void 0 !== window.flatpickr ? window.flatpickr : { l10ns: {} }, N = { weekdays: { shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"], longhand: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"] }, months: { shorthand: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sept", "okt", "nov", "dec"], longhand: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"] }, firstDayOfWeek: 1, weekAbbreviation: "wk", rangeSeparator: " t/m ", scrollTitle: "Scroll voor volgende / vorige", toggleTitle: "Klik om te wisselen", time_24hr: !0, ordinal: function (b) { return 1 === b || 8 === b || b >= 20 ? "ste" : "de" } }, D.l10ns.nl = N, V = D.l10ns, A.Dutch = N, A.default = V, Object.defineProperty(A, "__esModule", { value: !0 }) }, 5943: function (b) {/*!
   * mux-embed
   * @version 4.30.0
   * @copyright 2023 Mux, Inc
   */b.exports = function () {
      var b = {
        80: function (b, A, D) { b.exports = D(728).default }, 728: function (b, A, D) { "use strict"; D.d(A, { default: function () { return td } }); var N = D(48), V = D.n(N), i = function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (b) { var A = 16 * Math.random() | 0; return ("x" === b ? A : 3 & A | 8).toString(16) }) }, o = function () { return ("000000" + (2176782336 * Math.random() << 0).toString(36)).slice(-6) }, s = function (b) { var A, D; if (b && void 0 !== b.nodeName) return b.muxId || (b.muxId = o()), b.muxId; try { D = document.querySelector(b) } catch (b) { } return D && !D.muxId && (D.muxId = b), (null === (A = D) || void 0 === A ? void 0 : A.muxId) || b }, u = function (b) { b && void 0 !== b.nodeName ? b = s(A = b) : A = document.querySelector(b); var A, D = A && A.nodeName ? A.nodeName.toLowerCase() : ""; return [A, b, D] }, Y = D(640), Z = D.n(Y), ee = Z().methodFactory; Z().methodFactory = function (b, A, D) { var N = ee(b, A, D); return function () { for (var b = ["[mux]"], A = 0; A < arguments.length; A++)b.push(arguments[A]); N.apply(void 0, b) } }, Z().setLevel(Z().getLevel()); var et = Z(); function p() { return "1" === (V().doNotTrack || V().navigator && V().navigator.doNotTrack) } var ea = { now: function () { var b = V().performance, A = b && b.timing, D = A && A.navigationStart; return Math.round("number" == typeof D && "function" == typeof b.now ? D + b.now() : Date.now()) } }, h = function (b) { return v(b)[0] }, v = function (b) { if ("string" != typeof b || "" === b) return ["localhost"]; var A, D = (b.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/) || [])[4]; return D && (A = (D.match(/[^\.]+\.[^\.]+$/) || [])[0]), [D, A] }, er = { exists: function () { var b = V().performance; return void 0 !== (b && b.timing) }, domContentLoadedEventEnd: function () { var b = V().performance, A = b && b.timing; return A && A.domContentLoadedEventEnd }, navigationStart: function () { var b = V().performance, A = b && b.timing; return A && A.navigationStart } }; function y(b, A, D) { D = void 0 === D ? 1 : D, b[A] = b[A] || 0, b[A] += D } var en = ["x-request-id", "cf-ray", "x-amz-cf-id", "x-akamai-request-id"], eo = ["x-cdn", "content-type"].concat(en); function w(b) { var A = {}; return (b = b || "").trim().split(/[\r\n]+/).forEach(function (b) { if (b) { var D = b.split(": "), N = D.shift(); N && (eo.indexOf(N.toLowerCase()) >= 0 || 0 === N.toLowerCase().indexOf("x-litix-")) && (A[N] = D.join(": ")) } }), A } function T(b) { if (b) { var A = en.find(function (A) { return void 0 !== b[A] }); return A ? b[A] : void 0 } } var k = function (b) { var A = {}; for (var D in b) { var N = b[D]; -1 !== N["DATA-ID"].search("io.litix.data.") && (A[N["DATA-ID"].replace("io.litix.data.", "")] = N.VALUE) } return A }; function E(b, A) { var D = Object.keys(b); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(b); A && (N = N.filter(function (A) { return Object.getOwnPropertyDescriptor(b, A).enumerable })), D.push.apply(D, N) } return D } function O(b) { for (var A = 1; A < arguments.length; A++) { var D = null != arguments[A] ? arguments[A] : {}; A % 2 ? E(Object(D), !0).forEach(function (A) { var N; N = D[A], A in b ? Object.defineProperty(b, A, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : b[A] = N }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(D)) : E(Object(D)).forEach(function (A) { Object.defineProperty(b, A, Object.getOwnPropertyDescriptor(D, A)) }) } return b } var x = function (b) { if (!b) return {}; var A = er.navigationStart(), D = b.loading, N = D ? D.start : b.trequest, V = D ? D.first : b.tfirst, Y = D ? D.end : b.tload; return { bytesLoaded: b.total, requestStart: Math.round(A + N), responseStart: Math.round(A + V), responseEnd: Math.round(A + Y) } }, P = function (b) { if (b && "function" == typeof b.getAllResponseHeaders) return w(b.getAllResponseHeaders()) }; function q(b, A) { var D = Object.keys(b); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(b); A && (N = N.filter(function (A) { return Object.getOwnPropertyDescriptor(b, A).enumerable })), D.push.apply(D, N) } return D } function S(b) { for (var A = 1; A < arguments.length; A++) { var D = null != arguments[A] ? arguments[A] : {}; A % 2 ? q(Object(D), !0).forEach(function (A) { var N; N = D[A], A in b ? Object.defineProperty(b, A, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : b[A] = N }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(D)) : q(Object(D)).forEach(function (A) { Object.defineProperty(b, A, Object.getOwnPropertyDescriptor(D, A)) }) } return b } var R = function (b, A) { if (!b || !b.requestEndDate) return {}; var D, N = h(b.url), V = b.url, Y = b.bytesLoaded, Z = new Date(b.requestStartDate).getTime(), ee = new Date(b.firstByteDate).getTime(), et = new Date(b.requestEndDate).getTime(), ea = isNaN(b.duration) ? 0 : b.duration, er = "function" == typeof A.getMetricsFor ? A.getMetricsFor(b.mediaType).HttpList : A.getDashMetrics().getHttpRequests(b.mediaType); return er.length > 0 && (D = w(er[er.length - 1]._responseHeaders || "")), { requestStart: Z, requestResponseStart: ee, requestResponseEnd: et, requestBytesLoaded: Y, requestResponseHeaders: D, requestMediaDuration: ea, requestHostname: N, requestUrl: V, requestId: D ? T(D) : void 0 } }, I = function (b, A) { var D = A.getQualityFor(b), N = A.getCurrentTrackFor(b).bitrateList; return N ? { currentLevel: D, renditionWidth: N[D].width || null, renditionHeight: N[D].height || null, renditionBitrate: N[D].bandwidth } : {} }, L = function (b) { var A; return null === (A = b.match(/.*codecs\*?="(.*)"/)) || void 0 === A ? void 0 : A[1] }, j = function (b) { try { var A, D; return null === (A = b.getVersion) || void 0 === A || null === (D = A.call(b)) || void 0 === D ? void 0 : D.split(".").map(function (b) { return parseInt(b) })[0] } catch (b) { return !1 } }; function C(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var es = 0, el = function () { var b, A; function e() { !function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, e) } return b = [{ key: "on", value: function (b, A, D) { return A._eventEmitterGuid = A._eventEmitterGuid || ++es, this._listeners = this._listeners || {}, this._listeners[b] = this._listeners[b] || [], D && (A = A.bind(D)), this._listeners[b].push(A), A } }, { key: "off", value: function (b, A) { var D = this._listeners && this._listeners[b]; D && D.forEach(function (b, N) { b._eventEmitterGuid === A._eventEmitterGuid && D.splice(N, 1) }) } }, { key: "one", value: function (b, A, D) { var N = this; A._eventEmitterGuid = A._eventEmitterGuid || ++es; var n = function n() { N.off(b, n), A.apply(D || this, arguments) }; n._eventEmitterGuid = A._eventEmitterGuid, this.on(b, n) } }, { key: "emit", value: function (b, A) { var D = this; if (this._listeners) { A = A || {}; var N = this._listeners["before*"] || [], V = this._listeners[b] || [], Y = this._listeners["after" + b] || [], o = function (A, N) { (A = A.slice()).forEach(function (A) { A.call(D, { type: b }, N) }) }; o(N, A), o(V, A), o(Y, A) } } }], C(e.prototype, b), A && C(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function U(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ed = function () { var b; function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, this._playbackHeartbeatInterval = null, this._playheadShouldBeProgressing = !1, b.on("playing", function () { A._playheadShouldBeProgressing = !0 }), b.on("play", this._startPlaybackHeartbeatInterval.bind(this)), b.on("playing", this._startPlaybackHeartbeatInterval.bind(this)), b.on("adbreakstart", this._startPlaybackHeartbeatInterval.bind(this)), b.on("adplay", this._startPlaybackHeartbeatInterval.bind(this)), b.on("adplaying", this._startPlaybackHeartbeatInterval.bind(this)), b.on("seeking", this._startPlaybackHeartbeatInterval.bind(this)), b.on("devicewake", this._startPlaybackHeartbeatInterval.bind(this)), b.on("viewstart", this._startPlaybackHeartbeatInterval.bind(this)), b.on("rebufferstart", this._startPlaybackHeartbeatInterval.bind(this)), b.on("pause", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("ended", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("viewend", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("error", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("aderror", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("adpause", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("adended", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("adbreakend", this._stopPlaybackHeartbeatInterval.bind(this)), b.on("seeked", function () { b.data.player_is_paused ? A._stopPlaybackHeartbeatInterval() : A._startPlaybackHeartbeatInterval() }), b.on("timeupdate", function () { null !== A._playbackHeartbeatInterval && b.emit("playbackheartbeat") }), b.on("devicesleep", function (D, N) { null !== A._playbackHeartbeatInterval && (V().clearInterval(A._playbackHeartbeatInterval), b.emit("playbackheartbeatend", { viewer_time: N.viewer_time }), A._playbackHeartbeatInterval = null) }) } return U(e.prototype, [{ key: "_startPlaybackHeartbeatInterval", value: function () { var b = this; null === this._playbackHeartbeatInterval && (this.pm.emit("playbackheartbeat"), this._playbackHeartbeatInterval = V().setInterval(function () { b.pm.emit("playbackheartbeat") }, this.pm.playbackHeartbeatTime)) } }, { key: "_stopPlaybackHeartbeatInterval", value: function () { this._playheadShouldBeProgressing = !1, null !== this._playbackHeartbeatInterval && (V().clearInterval(this._playbackHeartbeatInterval), this.pm.emit("playbackheartbeatend"), this._playbackHeartbeatInterval = null) } }]), b && U(e, b), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function F(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eu = (eG = function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), b.on("viewinit", function () { A.viewErrored = !1 }), b.on("error", function (D, N) { try { var V = b.errorTranslator({ player_error_code: N.player_error_code, player_error_message: N.player_error_message, player_error_context: N.player_error_context }); V ? (b.data.player_error_code = V.player_error_code || N.player_error_code, b.data.player_error_message = V.player_error_message || N.player_error_message, b.data.player_error_context = V.player_error_context || N.player_error_context, A.viewErrored = !0) : (delete b.data.player_error_code, delete b.data.player_error_message, delete b.data.player_error_context) } catch (D) { b.mux.log.warn("Exception in error translator callback.", D), A.viewErrored = !0 } }) }, eV && F(eG.prototype, eV), ej && F(eG, ej), Object.defineProperty(eG, "prototype", { writable: !1 }), eG); function Q(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ec = function () { var b, A; function e(b) { (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, this._watchTimeTrackerLastCheckedTime = null, b.on("playbackheartbeat", this._updateWatchTime.bind(this)), b.on("playbackheartbeatend", this._clearWatchTimeState.bind(this)) } return b = [{ key: "_updateWatchTime", value: function (b, A) { var D = A.viewer_time; null === this._watchTimeTrackerLastCheckedTime && (this._watchTimeTrackerLastCheckedTime = D), y(this.pm.data, "view_watch_time", D - this._watchTimeTrackerLastCheckedTime), this._watchTimeTrackerLastCheckedTime = D } }, { key: "_clearWatchTimeState", value: function (b, A) { this._updateWatchTime(b, A), this._watchTimeTrackerLastCheckedTime = null } }], Q(e.prototype, b), A && Q(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function J(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var em = function () { var b, A; function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, this._playbackTimeTrackerLastPlayheadPosition = -1, this._lastTime = ea.now(), this._isAdPlaying = !1, this._callbackUpdatePlaybackTime = null; var D = this._startPlaybackTimeTracking.bind(this); b.on("playing", D), b.on("adplaying", D), b.on("seeked", D); var N = this._stopPlaybackTimeTracking.bind(this); b.on("playbackheartbeatend", N), b.on("seeking", N), b.on("adplaying", function () { A._isAdPlaying = !0 }), b.on("adended", function () { A._isAdPlaying = !1 }), b.on("adpause", function () { A._isAdPlaying = !1 }), b.on("adbreakstart", function () { A._isAdPlaying = !1 }), b.on("adbreakend", function () { A._isAdPlaying = !1 }), b.on("adplay", function () { A._isAdPlaying = !1 }), b.on("viewinit", function () { A._playbackTimeTrackerLastPlayheadPosition = -1, A._lastTime = ea.now(), A._isAdPlaying = !1, A._callbackUpdatePlaybackTime = null }) } return b = [{ key: "_startPlaybackTimeTracking", value: function () { null === this._callbackUpdatePlaybackTime && (this._callbackUpdatePlaybackTime = this._updatePlaybackTime.bind(this), this._playbackTimeTrackerLastPlayheadPosition = this.pm.data.player_playhead_time, this.pm.on("playbackheartbeat", this._callbackUpdatePlaybackTime)) } }, { key: "_stopPlaybackTimeTracking", value: function () { this._callbackUpdatePlaybackTime && (this._updatePlaybackTime(), this.pm.off("playbackheartbeat", this._callbackUpdatePlaybackTime), this._callbackUpdatePlaybackTime = null, this._playbackTimeTrackerLastPlayheadPosition = -1) } }, { key: "_updatePlaybackTime", value: function () { var b = this.pm.data.player_playhead_time, A = ea.now(), D = -1; this._playbackTimeTrackerLastPlayheadPosition >= 0 && b > this._playbackTimeTrackerLastPlayheadPosition ? D = b - this._playbackTimeTrackerLastPlayheadPosition : this._isAdPlaying && (D = A - this._lastTime), D > 0 && D <= 1e3 && y(this.pm.data, "view_content_playback_time", D), this._playbackTimeTrackerLastPlayheadPosition = b, this._lastTime = A } }], J(e.prototype, b), A && J(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function z(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eh = function () { var b, A; function e(b) { (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b; var A = this._updatePlayheadTime.bind(this); b.on("playbackheartbeat", A), b.on("playbackheartbeatend", A), b.on("timeupdate", A), b.on("destroy", function () { b.off("timeupdate", A) }) } return b = [{ key: "_updateMaxPlayheadPosition", value: function () { this.pm.data.view_max_playhead_position = void 0 === this.pm.data.view_max_playhead_position ? this.pm.data.player_playhead_time : Math.max(this.pm.data.view_max_playhead_position, this.pm.data.player_playhead_time) } }, { key: "_updatePlayheadTime", value: function (b, A) { var D = this, a = function () { D.pm.currentFragmentPDT && D.pm.currentFragmentStart && (D.pm.data.player_program_time = D.pm.currentFragmentPDT + D.pm.data.player_playhead_time - D.pm.currentFragmentStart) }; if (A && A.player_playhead_time) this.pm.data.player_playhead_time = A.player_playhead_time, a(), this._updateMaxPlayheadPosition(); else if (this.pm.getPlayheadTime) { var N = this.pm.getPlayheadTime(); void 0 !== N && (this.pm.data.player_playhead_time = N, a(), this._updateMaxPlayheadPosition()) } } }], z(e.prototype, b), A && z(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function X(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ep = (eq = function e(b) { if (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, e), !b.disableRebufferTracking) { var A, a = function (b, D) { n(D), A = void 0 }, n = function (D) { if (A) { var N = D.viewer_time - A; y(b.data, "view_rebuffer_duration", N), A = D.viewer_time, b.data.view_rebuffer_duration > 3e5 && (b.emit("viewend"), b.send("viewend"), b.mux.log.warn("Ending view after rebuffering for longer than ".concat(3e5, "ms, future events will be ignored unless a programchange or videochange occurs."))) } b.data.view_watch_time >= 0 && b.data.view_rebuffer_count > 0 && (b.data.view_rebuffer_frequency = b.data.view_rebuffer_count / b.data.view_watch_time, b.data.view_rebuffer_percentage = b.data.view_rebuffer_duration / b.data.view_watch_time) }; b.on("playbackheartbeat", function (b, A) { return n(A) }), b.on("rebufferstart", function (D, N) { A || (y(b.data, "view_rebuffer_count", 1), A = N.viewer_time, b.one("rebufferend", a)) }), b.on("viewinit", function () { A = void 0, b.off("rebufferend", a) }) } }, e$ && X(eq.prototype, e$), eY && X(eq, eY), Object.defineProperty(eq, "prototype", { writable: !1 }), eq); function te(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ev = function () { var b, A; function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, b.disableRebufferTracking || b.disablePlayheadRebufferTracking || (this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null, b.on("playbackheartbeat", this._checkIfRebuffering.bind(this)), b.on("playbackheartbeatend", this._cleanupRebufferTracker.bind(this)), b.on("seeking", function () { A._cleanupRebufferTracker(null, { viewer_time: ea.now() }) })) } return b = [{ key: "_checkIfRebuffering", value: function (b, A) { if (this.pm.seekingTracker.isSeeking || this.pm.adTracker.isAdBreak || !this.pm.playbackHeartbeat._playheadShouldBeProgressing) this._cleanupRebufferTracker(b, A); else if (null !== this._lastCheckedTime) { if (this._lastPlayheadTime === this.pm.data.player_playhead_time) { var D = A.viewer_time - this._lastPlayheadTimeUpdatedTime; "number" == typeof this.pm.sustainedRebufferThreshold && D >= this.pm.sustainedRebufferThreshold && (this._rebuffering || (this._rebuffering = !0, this.pm.emit("rebufferstart", { viewer_time: this._lastPlayheadTimeUpdatedTime }))), this._lastCheckedTime = A.viewer_time } else this._cleanupRebufferTracker(b, A, !0) } else this._prepareRebufferTrackerState(A.viewer_time) } }, { key: "_clearRebufferTrackerState", value: function () { this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null } }, { key: "_prepareRebufferTrackerState", value: function (b) { this._lastCheckedTime = b, this._lastPlayheadTime = this.pm.data.player_playhead_time, this._lastPlayheadTimeUpdatedTime = b } }, { key: "_cleanupRebufferTracker", value: function (b, A) { var D = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (this._rebuffering) this._rebuffering = !1, this.pm.emit("rebufferend", { viewer_time: A.viewer_time }); else { if (null === this._lastCheckedTime) return; var N = this.pm.data.player_playhead_time - this._lastPlayheadTime, V = A.viewer_time - this._lastPlayheadTimeUpdatedTime; "number" == typeof this.pm.minimumRebufferDuration && N > 0 && V - N > this.pm.minimumRebufferDuration && (this._lastCheckedTime = null, this.pm.emit("rebufferstart", { viewer_time: this._lastPlayheadTimeUpdatedTime }), this.pm.emit("rebufferend", { viewer_time: this._lastPlayheadTimeUpdatedTime + V - N })) } D ? this._prepareRebufferTrackerState(A.viewer_time) : this._clearRebufferTrackerState() } }], te(e.prototype, b), A && te(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function ne(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var e_ = function () { var b; function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, b.on("viewinit", function () { var D = b.data, N = D.view_id; if (!D.view_program_changed) { var n = function (D, V) { var Y = V.viewer_time; "playing" === D.type && void 0 === b.data.view_time_to_first_frame ? A.calculateTimeToFirstFrame(Y || ea.now(), N) : "adplaying" === D.type && (void 0 === b.data.view_time_to_first_frame || A._inPrerollPosition()) && A.calculateTimeToFirstFrame(Y || ea.now(), N) }; b.one("playing", n), b.one("adplaying", n), b.one("viewend", function () { b.off("playing", n), b.off("adplaying", n) }) } }) } return ne(e.prototype, [{ key: "_inPrerollPosition", value: function () { return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3 } }, { key: "calculateTimeToFirstFrame", value: function (b, A) { A === this.pm.data.view_id && (this.pm.watchTimeTracker._updateWatchTime(null, { viewer_time: b }), this.pm.data.view_time_to_first_frame = this.pm.data.view_watch_time, (this.pm.data.player_autoplay_on || this.pm.data.video_is_autoplay) && this.NAVIGATION_START && (this.pm.data.view_aggregate_startup_time = this.pm.data.view_start + this.pm.data.view_watch_time - this.NAVIGATION_START)) } }]), b && ne(e, b), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function oe(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ef = (eK = function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), b.on("viewinit", function () { A._lastPlayheadPosition = -1 }), ["pause", "rebufferstart", "seeking", "error", "adbreakstart", "hb"].forEach(function (D) { b.on(D, function () { if (A._lastPlayheadPosition >= 0 && b.data.player_playhead_time >= 0 && A._lastPlayerWidth >= 0 && A._lastSourceWidth > 0 && A._lastPlayerHeight >= 0 && A._lastSourceHeight > 0) { var D = b.data.player_playhead_time - A._lastPlayheadPosition; if (D < 0) return void (A._lastPlayheadPosition = -1); var N = Math.min(A._lastPlayerWidth / A._lastSourceWidth, A._lastPlayerHeight / A._lastSourceHeight), V = Math.max(0, N - 1), Y = Math.max(0, 1 - N); b.data.view_max_upscale_percentage = Math.max(b.data.view_max_upscale_percentage || 0, V), b.data.view_max_downscale_percentage = Math.max(b.data.view_max_downscale_percentage || 0, Y), y(b.data, "view_total_content_playback_time", D), y(b.data, "view_total_upscaling", V * D), y(b.data, "view_total_downscaling", Y * D) } A._lastPlayheadPosition = -1 }) }), ["playing", "hb"].forEach(function (D) { b.on(D, function () { A._lastPlayheadPosition = b.data.player_playhead_time, A._lastPlayerWidth = b.data.player_width, A._lastPlayerHeight = b.data.player_height, A._lastSourceWidth = b.data.video_source_width, A._lastSourceHeight = b.data.video_source_height }) }) }, eZ && oe(eK.prototype, eZ), eQ && oe(eK, eQ), Object.defineProperty(eK, "prototype", { writable: !1 }), eK); function le(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eb = (ez = function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.isSeeking = !1; var D = -1, n = function () { var N = ea.now(), V = (b.data.viewer_time || N) - (D || N); y(b.data, "view_seek_duration", V), b.data.view_max_seek_time = Math.max(b.data.view_max_seek_time || 0, V), A.isSeeking = !1, D = -1 }; b.on("seeking", function (N, V) { Object.assign(b.data, V), A.isSeeking && V.viewer_time - D <= 2e3 ? D = V.viewer_time : (A.isSeeking && n(), A.isSeeking = !0, D = V.viewer_time, y(b.data, "view_seek_count", 1), b.send("seeking")) }), b.on("seeked", function () { n() }), b.on("viewend", function () { A.isSeeking && (n(), b.send("seeked")), A.isSeeking = !1, D = -1 }) }, eX && le(ez.prototype, eX), eJ && le(ez, eJ), Object.defineProperty(ez, "prototype", { writable: !1 }), ez); function fe(b, A) { return function (b) { if (Array.isArray(b)) return b }(b) || function (b, A) { var D = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != D) { var N, V, Y = [], Z = !0, ee = !1; try { for (D = D.call(b); !(Z = (N = D.next()).done) && (Y.push(N.value), !A || Y.length !== A); Z = !0); } catch (b) { ee = !0, V = b } finally { try { Z || null == D.return || D.return() } finally { if (ee) throw V } } return Y } }(b, A) || function (b, A) { if (b) { if ("string" == typeof b) return pe(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); return "Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D ? Array.from(b) : "Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? pe(b, A) : void 0 } }(b, A) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function pe(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } function _e(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var he = function (b, A) { b.push(A), b.sort(function (b, A) { return b.viewer_time - A.viewer_time }) }, eg = ["adbreakstart", "adrequest", "adresponse", "adplay", "adplaying", "adpause", "adended", "adbreakend", "aderror", "adclicked", "adskipped"], eE = function () { var b, A; function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), this.pm = b, b.on("viewinit", function () { A.isAdBreak = !1, A._currentAdRequestNumber = 0, A._currentAdResponseNumber = 0, A._adRequests = [], A._adResponses = [], A._adHasPlayed = !1, A._wouldBeNewAdPlay = !0, A._prerollPlayTime = void 0 }), eg.forEach(function (D) { return b.on(D, A._updateAdData.bind(A)) }); var a = function () { A.isAdBreak = !1 }; b.on("adbreakstart", function () { A.isAdBreak = !0 }), b.on("play", a), b.on("playing", a), b.on("viewend", a), b.on("adrequest", function (D, N) { N = Object.assign({ ad_request_id: "generatedAdRequestId" + A._currentAdRequestNumber++ }, N), he(A._adRequests, N), y(b.data, "view_ad_request_count"), A.inPrerollPosition() && (b.data.view_preroll_requested = !0, A._adHasPlayed || y(b.data, "view_preroll_request_count")) }), b.on("adresponse", function (D, N) { N = Object.assign({ ad_request_id: "generatedAdRequestId" + A._currentAdResponseNumber++ }, N), he(A._adResponses, N); var V = A.findAdRequest(N.ad_request_id); V && y(b.data, "view_ad_request_time", Math.max(0, N.viewer_time - V.viewer_time)) }), b.on("adplay", function (D, N) { A._adHasPlayed = !0, A._wouldBeNewAdPlay && (A._wouldBeNewAdPlay = !1, y(b.data, "view_ad_played_count")), A.inPrerollPosition() && !b.data.view_preroll_played && (b.data.view_preroll_played = !0, A._adRequests.length > 0 && (b.data.view_preroll_request_time = Math.max(0, N.viewer_time - A._adRequests[0].viewer_time)), b.data.view_start && (b.data.view_startup_preroll_request_time = Math.max(0, N.viewer_time - b.data.view_start)), A._prerollPlayTime = N.viewer_time) }), b.on("adplaying", function (D, N) { A.inPrerollPosition() && void 0 === b.data.view_preroll_load_time && void 0 !== A._prerollPlayTime && (b.data.view_preroll_load_time = N.viewer_time - A._prerollPlayTime, b.data.view_startup_preroll_load_time = N.viewer_time - A._prerollPlayTime) }), b.on("adclicked", function (D, N) { A._wouldBeNewAdPlay || y(b.data, "view_ad_clicked_count") }), b.on("adskipped", function (D, N) { A._wouldBeNewAdPlay || y(b.data, "view_ad_skipped_count") }), b.on("adended", function () { A._wouldBeNewAdPlay = !0 }), b.on("aderror", function () { A._wouldBeNewAdPlay = !0 }) } return b = [{ key: "inPrerollPosition", value: function () { return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3 } }, { key: "findAdRequest", value: function (b) { for (var A = 0; A < this._adRequests.length; A++)if (this._adRequests[A].ad_request_id === b) return this._adRequests[A] } }, { key: "_updateAdData", value: function (b, A) { if (this.inPrerollPosition()) { if (!this.pm.data.view_preroll_ad_tag_hostname && A.ad_tag_url) { var D = fe(v(A.ad_tag_url), 2), N = D[0], V = D[1]; this.pm.data.view_preroll_ad_tag_domain = V, this.pm.data.view_preroll_ad_tag_hostname = N } if (!this.pm.data.view_preroll_ad_asset_hostname && A.ad_asset_url) { var Y = fe(v(A.ad_asset_url), 2), Z = Y[0], ee = Y[1]; this.pm.data.view_preroll_ad_asset_domain = ee, this.pm.data.view_preroll_ad_asset_hostname = Z } } this.pm.data.ad_asset_url = null == A ? void 0 : A.ad_asset_url, this.pm.data.ad_tag_url = null == A ? void 0 : A.ad_tag_url, this.pm.data.ad_creative_id = null == A ? void 0 : A.ad_creative_id, this.pm.data.ad_id = null == A ? void 0 : A.ad_id, this.pm.data.ad_universal_id = null == A ? void 0 : A.ad_universal_id } }], _e(e.prototype, b), A && _e(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function ye(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var ey = (e0 = function e(b) { !function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, e); var A, D, i = function () { b.disableRebufferTracking || A && (y(b.data, "view_waiting_rebuffer_duration", ea.now() - A), A = !1, V().clearInterval(D)) }, N = !1, s = function () { N = !1, i() }; b.on("waiting", function () { N && (b.disableRebufferTracking || (y(b.data, "view_waiting_rebuffer_count", 1), A = ea.now(), D = V().setInterval(function () { if (A) { var D = ea.now(); y(b.data, "view_waiting_rebuffer_duration", D - A), A = D } }, 250))) }), b.on("playing", function () { i(), N = !0 }), b.on("pause", s), b.on("seeking", s) }, e1 && ye(e0.prototype, e1), e2 && ye(e0, e2), Object.defineProperty(e0, "prototype", { writable: !1 }), e0); function we(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eA = (e5 = function e(b) { var A = this; !function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, e); var a = function () { A.lastWallClockTime = ea.now(), b.on("before*", n) }, n = function (D) { var N = ea.now(), V = A.lastWallClockTime; A.lastWallClockTime = N, N - V > 3e4 && (b.emit("devicesleep", { viewer_time: V }), Object.assign(b.data, { viewer_time: V }), b.send("devicesleep"), b.emit("devicewake", { viewer_time: N }), Object.assign(b.data, { viewer_time: N }), b.send("devicewake")) }; b.one("playbackheartbeat", a), b.on("playbackheartbeatend", function () { b.off("before*", n), b.one("playbackheartbeat", a) }) }, e3 && we(e5.prototype, e3), e4 && we(e5, e4), Object.defineProperty(e5, "prototype", { writable: !1 }), e5), ek = D(375), eT = D(655), ew = D.n(eT), eS = "muxData", Pe = function () { var b; try { b = ek.parse(ew().get(eS) || "") } catch (A) { b = {} } return b }, qe = function (b) { try { ew().set(eS, ek.stringify(b), { expires: 365 }) } catch (b) { } }, Se = function () { var b = Pe(); return b.mux_viewer_id = b.mux_viewer_id || i(), b.msn = b.msn || Math.random(), qe(b), { mux_viewer_id: b.mux_viewer_id, mux_sample_number: b.msn } }, Re = function () { var b; switch (Ie()) { case "cellular": b = "cellular"; break; case "ethernet": b = "wired"; break; case "wifi": b = "wifi"; break; case void 0: break; default: b = "other" }return b }, Ie = function () { var b = V().navigator, A = b && (b.connection || b.mozConnection || b.webkitConnection); return A && A.type }; Re.getConnectionFromAPI = Ie; var eD = Ne({ a: "env", b: "beacon", c: "custom", d: "ad", e: "event", f: "experiment", i: "internal", m: "mux", n: "response", p: "player", q: "request", r: "retry", s: "session", t: "timestamp", u: "viewer", v: "video", w: "page", x: "view", y: "sub" }), eI = Ne({ ad: "ad", ag: "aggregate", ap: "api", al: "application", ar: "architecture", as: "asset", au: "autoplay", av: "average", bi: "bitrate", br: "break", bw: "browser", by: "bytes", ca: "cached", cb: "cancel", cc: "codec", cd: "code", cg: "category", ch: "changed", ck: "clicked", cl: "canceled", cn: "config", co: "count", ce: "counter", cp: "complete", cr: "creative", ct: "content", cu: "current", cx: "connection", cz: "context", dg: "downscaling", dm: "domain", dn: "cdn", do: "downscale", dr: "drm", dp: "dropped", du: "duration", dv: "device", ec: "encoding", ed: "edge", en: "end", eg: "engine", em: "embed", er: "error", es: "errorcode", et: "errortext", ee: "event", ev: "events", ex: "expires", ep: "experiments", fa: "failed", fi: "first", fm: "family", ft: "format", fp: "fps", fq: "frequency", fr: "frame", fs: "fullscreen", ha: "has", hb: "holdback", he: "headers", ho: "host", hn: "hostname", ht: "height", id: "id", ii: "init", in: "instance", ip: "ip", is: "is", ke: "key", la: "language", lb: "labeled", le: "level", li: "live", ld: "loaded", lo: "load", ls: "lists", lt: "latency", ma: "max", md: "media", me: "message", mf: "manifest", mi: "mime", ml: "midroll", mm: "min", mn: "manufacturer", mo: "model", mx: "mux", ne: "newest", nm: "name", no: "number", on: "on", os: "os", pa: "paused", pb: "playback", pd: "producer", pe: "percentage", pf: "played", pg: "program", ph: "playhead", pi: "plugin", pl: "preroll", pn: "playing", po: "poster", pr: "preload", ps: "position", pt: "part", py: "property", ra: "rate", rd: "requested", re: "rebuffer", rf: "rendition", rm: "remote", ro: "ratio", rp: "response", rq: "request", rs: "requests", sa: "sample", sd: "skipped", se: "session", sk: "seek", sm: "stream", so: "source", sq: "sequence", sr: "series", st: "start", su: "startup", sv: "server", sw: "software", ta: "tag", tc: "tech", te: "text", tg: "target", th: "throughput", ti: "time", tl: "total", to: "to", tt: "title", ty: "type", ug: "upscaling", un: "universal", up: "upscale", ur: "url", us: "user", va: "variant", vd: "viewed", vi: "video", ve: "version", vw: "view", vr: "viewer", wd: "width", wa: "watch", wt: "waiting" }); function Ne(b) { var A = {}; for (var D in b) b.hasOwnProperty(D) && (A[b[D]] = D); return A } function He(b) { var A = {}, D = {}; return Object.keys(b).forEach(function (N) { var V = !1; if (b.hasOwnProperty(N) && void 0 !== b[N]) { var Y = N.split("_"), Z = Y[0], ee = eD[Z]; ee || (et.info("Data key word `" + Y[0] + "` not expected in " + N), ee = Z + "_"), Y.splice(1).forEach(function (b) { "url" === b && (V = !0), eI[b] ? ee += eI[b] : Number(b) && Math.floor(Number(b)) === Number(b) ? ee += b : (et.info("Data key word `" + b + "` not expected in " + N), ee += "_" + b + "_") }), V ? D[ee] = b[N] : A[ee] = b[N] } }), Object.assign(A, D) } var eM = { maxBeaconSize: 300, maxQueueLength: 3600, baseTimeBetweenBeacons: 1e4, maxPayloadKBSize: 500 }, eC = ["hb", "requestcompleted", "requestfailed", "requestcanceled"], Fe = function (b) { var A = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this._beaconUrl = b || "https://img.litix.io", this._eventQueue = [], this._postInFlight = !1, this._failureCount = 0, this._sendTimeout = !1, this._options = Object.assign({}, eM, A) }; Fe.prototype.queueEvent = function (b, A) { var D = Object.assign({}, A); return (this._eventQueue.length <= this._options.maxQueueLength || "eventrateexceeded" === b) && (this._eventQueue.push(D), this._sendTimeout || this._startBeaconSending(), this._eventQueue.length <= this._options.maxQueueLength) }, Fe.prototype.flushEvents = function () { var b = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; b && 1 === this._eventQueue.length ? this._eventQueue.pop() : (this._eventQueue.length && this._sendBeaconQueue(), this._startBeaconSending()) }, Fe.prototype.destroy = function () { var b = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.destroyed = !0, b ? this._clearBeaconQueue() : this.flushEvents(), V().clearTimeout(this._sendTimeout) }, Fe.prototype._clearBeaconQueue = function () { var b = this._eventQueue.length > this._options.maxBeaconSize ? this._eventQueue.length - this._options.maxBeaconSize : 0, A = this._eventQueue.slice(b); b > 0 && Object.assign(A[A.length - 1], He({ mux_view_message: "event queue truncated" })); var D = this._createPayload(A); We(this._beaconUrl, D, !0, function () { }) }, Fe.prototype._sendBeaconQueue = function () { var b = this; if (!this._postInFlight) { var A = this._eventQueue.slice(0, this._options.maxBeaconSize); this._eventQueue = this._eventQueue.slice(this._options.maxBeaconSize), this._postInFlight = !0; var D = this._createPayload(A), N = ea.now(); We(this._beaconUrl, D, !1, function (D, V) { V ? (b._eventQueue = A.concat(b._eventQueue), b._failureCount += 1, et.info("Error sending beacon: " + V)) : b._failureCount = 0, b._roundTripTime = ea.now() - N, b._postInFlight = !1 }) } }, Fe.prototype._getNextBeaconTime = function () { if (!this._failureCount) return this._options.baseTimeBetweenBeacons; var b = Math.pow(2, this._failureCount - 1); return (1 + (b *= Math.random())) * this._options.baseTimeBetweenBeacons }, Fe.prototype._startBeaconSending = function () { var b = this; V().clearTimeout(this._sendTimeout), this.destroyed || (this._sendTimeout = V().setTimeout(function () { b._eventQueue.length && b._sendBeaconQueue(), b._startBeaconSending() }, this._getNextBeaconTime())) }, Fe.prototype._createPayload = function (b) { var A, D, N, V = this, Y = { transmission_timestamp: Math.round(ea.now()) }; this._roundTripTime && (Y.rtt_ms = Math.round(this._roundTripTime)); var o = function () { N = (A = JSON.stringify({ metadata: Y, events: D || b })).length / 1024 }, s = function () { return N <= V._options.maxPayloadKBSize }; return o(), s() || (et.info("Payload size is too big (" + N + " kb). Removing unnecessary events."), D = b.filter(function (b) { return -1 === eC.indexOf(b.e) }), o()), s() || (et.info("Payload size still too big (" + N + " kb). Cropping fields.."), D.forEach(function (b) { for (var A in b) { var D = b[A]; "string" == typeof D && D.length > 51200 && (b[A] = D.substring(0, 51200)) } }), o()), A }; var We = function (b, A, D, N) { if (D && navigator && navigator.sendBeacon && navigator.sendBeacon(b, A)) N(); else if (V().fetch) V().fetch(b, { method: "POST", body: A, headers: { "Content-Type": "text/plain" }, keepalive: A.length <= 57344 }).then(function (b) { return N(null, b.ok ? null : "Error") }).catch(function (b) { return N(null, b) }); else { if (V().XMLHttpRequest) { var Y = new (V()).XMLHttpRequest; return Y.onreadystatechange = function () { if (4 === Y.readyState) return N(null, 200 !== Y.status ? "error" : void 0) }, Y.open("POST", b), Y.setRequestHeader("Content-Type", "text/plain"), void Y.send(A) } N() } }; function Je(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } function Ke(b, A) { var D = Object.keys(b); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(b); A && (N = N.filter(function (A) { return Object.getOwnPropertyDescriptor(b, A).enumerable })), D.push.apply(D, N) } return D } function ze(b) { for (var A = 1; A < arguments.length; A++) { var D = null != arguments[A] ? arguments[A] : {}; A % 2 ? Ke(Object(D), !0).forEach(function (A) { Ze(b, A, D[A]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(D)) : Ke(Object(D)).forEach(function (A) { Object.defineProperty(b, A, Object.getOwnPropertyDescriptor(D, A)) }) } return b } function Ye(b) { return (Ye = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (b) { return typeof b } : function (b) { return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b })(b) } function $e(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } function Ze(b, A, D) { return A in b ? Object.defineProperty(b, A, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : b[A] = D, b } var ex = ["env_key", "view_id", "view_sequence_number", "player_sequence_number", "beacon_domain", "player_playhead_time", "viewer_time", "mux_api_version", "event", "video_id", "player_instance_id"], eL = ["adplay", "adplaying", "adpause", "adfirstquartile", "admidpoint", "adthirdquartile", "adended", "adresponse", "adrequest"], eR = ["ad_id", "ad_creative_id", "ad_universal_id"], eO = ["viewstart", "error", "ended", "viewend"], eN = function () { var b, A; function e(b, A) { var D, N, Y, Z, ee, et, ea, er, en, eo, es, el, ed, eu, ec, em, eh, ep, ev, e_ = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), Ze(this, "previousBeaconData", null), Ze(this, "lastEventTime", 0), Ze(this, "rateLimited", !1), this.mux = b, this.envKey = A, this.options = e_, this.eventQueue = new Fe((D = this.envKey, Y = (N = this.options).beaconCollectionDomain, Z = N.beaconDomain, Y ? "https://" + Y : (D = D || "inferred").match(/^[a-z0-9]+$/) ? "https://" + D + "." + (Z || "litix.io") : "https://img.litix.io/a.gif")), this.sampleRate = null !== (ee = this.options.sampleRate) && void 0 !== ee ? ee : 1, this.disableCookies = null !== (et = this.options.disableCookies) && void 0 !== et && et, this.respectDoNotTrack = null !== (ea = this.options.respectDoNotTrack) && void 0 !== ea && ea, this.previousBeaconData = null, this.lastEventTime = 0, this.rateLimited = !1, this.pageLevelData = { mux_api_version: this.mux.API_VERSION, mux_embed: this.mux.NAME, mux_embed_version: this.mux.VERSION, viewer_application_name: null === (er = this.options.platform) || void 0 === er ? void 0 : er.name, viewer_application_version: null === (en = this.options.platform) || void 0 === en ? void 0 : en.version, viewer_application_engine: null === (eo = this.options.platform) || void 0 === eo ? void 0 : eo.layout, viewer_device_name: null === (es = this.options.platform) || void 0 === es ? void 0 : es.product, viewer_device_category: "", viewer_device_manufacturer: null === (el = this.options.platform) || void 0 === el ? void 0 : el.manufacturer, viewer_os_family: null === (ed = this.options.platform) || void 0 === ed || null === (eu = ed.os) || void 0 === eu ? void 0 : eu.family, viewer_os_architecture: null === (ec = this.options.platform) || void 0 === ec || null === (em = ec.os) || void 0 === em ? void 0 : em.architecture, viewer_os_version: null === (eh = this.options.platform) || void 0 === eh || null === (ep = eh.os) || void 0 === ep ? void 0 : ep.version, viewer_connection_type: Re(), page_url: null === V() || void 0 === V() || null === (ev = V().location) || void 0 === ev ? void 0 : ev.href }, this.viewerData = this.disableCookies ? {} : Se() } return b = [{ key: "send", value: function (b, A) { var D; if (b && null != A && A.view_id) { if (this.respectDoNotTrack && p()) return et.info("Not sending `" + b + "` because Do Not Track is enabled"); if (!A || "object" !== Ye(A)) return et.error("A data object was expected in send() but was not provided"); var N, V, Y = this.disableCookies ? {} : (N = Pe(), V = ea.now(), N.session_start && (N.sst = N.session_start, delete N.session_start), N.session_id && (N.sid = N.session_id, delete N.session_id), N.session_expires && (N.sex = N.session_expires, delete N.session_expires), (!N.sex || N.sex < V) && (N.sid = i(), N.sst = V), N.sex = V + 15e5, qe(N), { session_id: N.sid, session_start: N.sst, session_expires: N.sex }), Z = ze(ze(ze(ze(ze({}, this.pageLevelData), A), Y), this.viewerData), {}, { event: b, env_key: this.envKey }); Z.user_id && (Z.viewer_user_id = Z.user_id, delete Z.user_id); var ee = (null !== (D = Z.mux_sample_number) && void 0 !== D ? D : 0) >= this.sampleRate, er = He(this._deduplicateBeaconData(b, Z)); if (this.lastEventTime = this.mux.utils.now(), ee) return et.info("Not sending event due to sample rate restriction", b, Z, er); if (this.envKey || et.info("Missing environment key (envKey) - beacons will be dropped if the video source is not a valid mux video URL", b, Z, er), !this.rateLimited) { if (et.info("Sending event", b, Z, er), this.rateLimited = !this.eventQueue.queueEvent(b, er), this.mux.WINDOW_UNLOADING && "viewend" === b) this.eventQueue.destroy(!0); else if (this.mux.WINDOW_HIDDEN && "hb" === b ? this.eventQueue.flushEvents(!0) : eO.indexOf(b) >= 0 && this.eventQueue.flushEvents(), this.rateLimited) return Z.event = "eventrateexceeded", er = He(Z), this.eventQueue.queueEvent(Z.event, er), et.error("Beaconing disabled due to rate limit.") } } } }, { key: "destroy", value: function () { this.eventQueue.destroy(!1) } }, { key: "_deduplicateBeaconData", value: function (b, A) { var D = this, N = {}, V = A.view_id; if ("-1" === V || "viewstart" === b || "viewend" === b || !this.previousBeaconData || this.mux.utils.now() - this.lastEventTime >= 6e5) N = ze({}, A), V && (this.previousBeaconData = N), V && "viewend" === b && (this.previousBeaconData = null); else { var Y = 0 === b.indexOf("request"); Object.entries(A).forEach(function (A) { var V = function (b) { if (Array.isArray(b)) return b }(A) || function (b, A) { var D = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != D) { var N, V, Y = [], Z = !0, ee = !1; try { for (D = D.call(b); !(Z = (N = D.next()).done) && (Y.push(N.value), !A || Y.length !== A); Z = !0); } catch (b) { ee = !0, V = b } finally { try { Z || null == D.return || D.return() } finally { if (ee) throw V } } return Y } }(A, 2) || function (b, A) { if (b) { if ("string" == typeof b) return Je(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); return "Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D ? Array.from(b) : "Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? Je(b, A) : void 0 } }(A, 2) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }(), Z = V[0], ee = V[1]; D.previousBeaconData && (ee !== D.previousBeaconData[Z] || ex.indexOf(Z) > -1 || D.objectHasChanged(Y, Z, ee, D.previousBeaconData[Z]) || D.eventRequiresKey(b, Z)) && (N[Z] = ee, D.previousBeaconData[Z] = ee) }) } return N } }, { key: "objectHasChanged", value: function (b, A, D, N) { return !(!b || 0 !== A.indexOf("request_") || "request_response_headers" !== A && "object" === Ye(D) && "object" === Ye(N) && Object.keys(D || {}).length === Object.keys(N || {}).length) } }, { key: "eventRequiresKey", value: function (b, A) { return "renditionchange" === b && 0 === A.indexOf("video_source_") || !(!eR.includes(A) || !eL.includes(b)) } }], $e(e.prototype, b), A && $e(e, A), Object.defineProperty(e, "prototype", { writable: !1 }), e }(); function it(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eP = (e7 = function e(b) { !function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, e); var A = 0, D = 0, N = 0, V = 0, Y = 0, Z = 0, ee = 0; b.on("requestcompleted", function (Z, ee) { var et, ea, er = ee.request_start, en = ee.request_response_start, eo = ee.request_response_end, es = ee.request_bytes_loaded; if (V++, en ? (et = en - (null != er ? er : 0), ea = (null != eo ? eo : 0) - en) : ea = (null != eo ? eo : 0) - (null != er ? er : 0), ea > 0 && es && es > 0) { var el = es / ea * 8e3; Y++, D += es, N += ea, b.data.view_min_request_throughput = Math.min(b.data.view_min_request_throughput || 1 / 0, el), b.data.view_average_request_throughput = D / N * 8e3, b.data.view_request_count = V, et > 0 && (A += et, b.data.view_max_request_latency = Math.max(b.data.view_max_request_latency || 0, et), b.data.view_average_request_latency = A / Y) } }), b.on("requestfailed", function (A, D) { V++, Z++, b.data.view_request_count = V, b.data.view_request_failed_count = Z }), b.on("requestcanceled", function (A, D) { V++, ee++, b.data.view_request_count = V, b.data.view_request_canceled_count = ee }) }, e8 && it(e7.prototype, e8), e6 && it(e7, e6), Object.defineProperty(e7, "prototype", { writable: !1 }), e7); function ut(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } var eU = (e9 = function e(b) { var A = this; (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, e), b.on("before*", function (D, N) { var V = N.viewer_time, Y = ea.now(), Z = A._lastEventTime; if (A._lastEventTime = Y, Z && Y - Z > 36e5) { var ee = Object.keys(b.data).reduce(function (A, D) { var N, V; return 0 === D.indexOf("video_") ? Object.assign(A, (N = {}, V = b.data[D], D in N ? Object.defineProperty(N, D, { value: V, enumerable: !0, configurable: !0, writable: !0 }) : N[D] = V, N)) : A }, {}); b.mux.log.info("Received event after at least an hour inactivity, creating a new view"), b.emit("viewinit", Object.assign({ viewer_time: V }, ee)), b.playbackHeartbeat._playheadShouldBeProgressing && "play" !== D.type && "adbreakstart" !== D.type && (b.emit("play", { viewer_time: V }), "playing" !== D.type && b.emit("playing", { viewer_time: V })) } }) }, tt && ut(e9.prototype, tt), ta && ut(e9, ta), Object.defineProperty(e9, "prototype", { writable: !1 }), e9); function ct(b) { return (ct = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (b) { return typeof b } : function (b) { return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b })(b) } function pt(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } function _t(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } function ht(b, A) { return (ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (b, A) { return b.__proto__ = A, b })(b, A) } function yt(b) { if (void 0 === b) throw ReferenceError("this hasn't been initialised - super() hasn't been called"); return b } function bt(b) { return (bt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (b) { return b.__proto__ || Object.getPrototypeOf(b) })(b) } var eB = ["viewstart", "ended", "loadstart", "pause", "play", "playing", "ratechange", "waiting", "adplay", "adpause", "adended", "aderror", "adplaying", "adrequest", "adresponse", "adbreakstart", "adbreakend", "adfirstquartile", "admidpoint", "adthirdquartile", "rebufferstart", "rebufferend", "seeked", "error", "hb", "requestcompleted", "requestfailed", "requestcanceled", "renditionchange"], eW = function (b) { !function (b, A) { if ("function" != typeof A && null !== A) throw TypeError("Super expression must either be null or a function"); b.prototype = Object.create(A && A.prototype, { constructor: { value: b, writable: !0, configurable: !0 } }), Object.defineProperty(b, "prototype", { writable: !1 }), A && ht(b, A) }(o, b); var A, D, N, V = (A = function () { if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (b) { return !1 } }(), function () { var b, D = bt(o); if (A) { var N = bt(this).constructor; b = Reflect.construct(D, arguments, N) } else b = D.apply(this, arguments); return function (b, A) { if (A && ("object" === ct(A) || "function" == typeof A)) return A; if (void 0 !== A) throw TypeError("Derived constructors may only return object or undefined"); return yt(b) }(this, b) }); function o(b, A, D) { (function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") })(this, o), (Y = V.call(this)).DOM_CONTENT_LOADED_EVENT_END = er.domContentLoadedEventEnd(), Y.NAVIGATION_START = er.navigationStart(), Y.mux = b, Y.id = A, null !== (N = D) && void 0 !== N && N.beaconDomain && Y.mux.log.warn("The `beaconDomain` setting has been deprecated in favor of `beaconCollectionDomain`. Please change your integration to use `beaconCollectionDomain` instead of `beaconDomain`."), (D = Object.assign({ debug: !1, minimumRebufferDuration: 250, sustainedRebufferThreshold: 1e3, playbackHeartbeatTime: 25, beaconDomain: "litix.io", sampleRate: 1, disableCookies: !1, respectDoNotTrack: !1, disableRebufferTracking: !1, disablePlayheadRebufferTracking: !1, errorTranslator: function (b) { return b } }, D)).data = D.data || {}, D.data.property_key && (D.data.env_key = D.data.property_key, delete D.data.property_key), et.setLevel(D.debug ? "debug" : "warn"), Y.getPlayheadTime = D.getPlayheadTime, Y.getStateData = D.getStateData || function () { return {} }, Y.getAdData = D.getAdData || function () { }, Y.minimumRebufferDuration = D.minimumRebufferDuration, Y.sustainedRebufferThreshold = D.sustainedRebufferThreshold, Y.playbackHeartbeatTime = D.playbackHeartbeatTime, Y.disableRebufferTracking = D.disableRebufferTracking, Y.disableRebufferTracking && Y.mux.log.warn("Disabling rebuffer tracking. This should only be used in specific circumstances as a last resort when your player is known to unreliably track rebuffering."), Y.disablePlayheadRebufferTracking = D.disablePlayheadRebufferTracking, Y.errorTranslator = D.errorTranslator, Y.playbackEventDispatcher = new eN(b, D.data.env_key, D), Y.data = { player_instance_id: i(), mux_sample_rate: D.sampleRate, beacon_domain: D.beaconCollectionDomain || D.beaconDomain }, Y.data.view_sequence_number = 1, Y.data.player_sequence_number = 1, Y.oldEmit = Y.emit, Y.emit = function (b, A) { A = Object.assign({ viewer_time: this.mux.utils.now() }, A), this.oldEmit(b, A) }; var N, Y, Z = (function () { void 0 === this.data.view_start && (this.data.view_start = this.mux.utils.now(), this.emit("viewstart")) }).bind(yt(Y)); Y.on("viewinit", function (b, A) { this._resetVideoData(), this._resetViewData(), this._resetErrorData(), this._updateStateData(), Object.assign(this.data, A), this._initializeViewData(), this.one("play", Z), this.one("adbreakstart", Z) }); var ee = (function (b) { this.emit("viewend"), this.send("viewend"), this.emit("viewinit", b) }).bind(yt(Y)); if (Y.on("videochange", function (b, A) { ee(A) }), Y.on("programchange", function (b, A) { this.data.player_is_paused && this.mux.log.warn("The `programchange` event is intended to be used when the content changes mid playback without the video source changing, however the video is not currently playing. If the video source is changing please use the videochange event otherwise you will lose startup time information."), ee(Object.assign(A, { view_program_changed: !0 })), Z(), this.emit("play"), this.emit("playing") }), Y.on("fragmentchange", function (b, A) { this.currentFragmentPDT = A.currentFragmentPDT, this.currentFragmentStart = A.currentFragmentStart }), Y.on("destroy", Y.destroy), "undefined" != typeof window && "function" == typeof window.addEventListener && "function" == typeof window.removeEventListener) { var d = function () { var b = void 0 !== Y.data.view_start; Y.mux.WINDOW_HIDDEN = "hidden" === document.visibilityState, b && Y.mux.WINDOW_HIDDEN && (Y.data.player_is_paused || Y.emit("hb")) }; window.addEventListener("visibilitychange", d, !1); var c = function (b) { b.persisted || Y.destroy() }; window.addEventListener("pagehide", c, !1), Y.on("destroy", function () { window.removeEventListener("visibilitychange", d), window.removeEventListener("pagehide", c) }) } return Y.on("playerready", function (b, A) { Object.assign(this.data, A) }), eB.forEach(function (b) { Y.on(b, function (A, D) { 0 !== b.indexOf("ad") && this._updateStateData(), Object.assign(this.data, D), this._sanitizeData() }), Y.on("after" + b, function () { ("error" !== b || this.errorTracker.viewErrored) && this.send(b) }) }), Y.on("viewend", function (b, A) { Object.assign(Y.data, A) }), Y.one("playerready", function (b) { var A = this.mux.utils.now(); this.data.player_init_time && (this.data.player_startup_time = A - this.data.player_init_time), !this.mux.PLAYER_TRACKED && this.NAVIGATION_START && (this.mux.PLAYER_TRACKED = !0, (this.data.player_init_time || this.DOM_CONTENT_LOADED_EVENT_END) && (this.data.page_load_time = Math.min(this.data.player_init_time || 1 / 0, this.DOM_CONTENT_LOADED_EVENT_END || 1 / 0) - this.NAVIGATION_START)), this.send("playerready"), delete this.data.player_startup_time, delete this.data.page_load_time }), Y.longResumeTracker = new eU(yt(Y)), Y.errorTracker = new eu(yt(Y)), new eA(yt(Y)), Y.seekingTracker = new eb(yt(Y)), Y.playheadTime = new eh(yt(Y)), Y.playbackHeartbeat = new ed(yt(Y)), new ef(yt(Y)), Y.watchTimeTracker = new ec(yt(Y)), new em(yt(Y)), Y.adTracker = new eE(yt(Y)), new ev(yt(Y)), new ep(yt(Y)), new e_(yt(Y)), new ey(yt(Y)), new eP(yt(Y)), D.hlsjs && Y.addHLSJS(D), D.dashjs && Y.addDashJS(D), Y.emit("viewinit", D.data), Y } return D = [{ key: "destroy", value: function () { this._destroyed || (this._destroyed = !0, void 0 !== this.data.view_start && (this.emit("viewend"), this.send("viewend")), this.playbackEventDispatcher.destroy(), this.removeHLSJS(), this.removeDashJS(), window.clearTimeout(this._heartBeatTimeout)) } }, { key: "send", value: function (b) { if (this.data.view_id) { var A = Object.assign({}, this.data); if (void 0 === A.video_source_is_live && (A.player_source_duration === 1 / 0 || A.video_source_duration === 1 / 0 ? A.video_source_is_live = !0 : (A.player_source_duration > 0 || A.video_source_duration > 0) && (A.video_source_is_live = !1)), A.video_source_is_live || ["player_program_time", "player_manifest_newest_program_time", "player_live_edge_program_time", "player_program_time", "video_holdback", "video_part_holdback", "video_target_duration", "video_part_target_duration"].forEach(function (b) { A[b] = void 0 }), A.video_source_url = A.video_source_url || A.player_source_url, A.video_source_url) { var D, N = function (b) { if (Array.isArray(b)) return b }(D = v(A.video_source_url)) || function (b, A) { var D = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != D) { var N, V, Y = [], Z = !0, ee = !1; try { for (D = D.call(b); !(Z = (N = D.next()).done) && (Y.push(N.value), !A || Y.length !== A); Z = !0); } catch (b) { ee = !0, V = b } finally { try { Z || null == D.return || D.return() } finally { if (ee) throw V } } return Y } }(D, 2) || function (b, A) { if (b) { if ("string" == typeof b) return pt(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); return "Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D ? Array.from(b) : "Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? pt(b, A) : void 0 } }(D, 2) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }(), V = N[0], Y = N[1]; A.video_source_domain = Y, A.video_source_hostname = V } delete A.ad_request_id, this.playbackEventDispatcher.send(b, A), this.data.view_sequence_number++, this.data.player_sequence_number++, this._restartHeartBeat(), "viewend" === b && delete this.data.view_id } } }, { key: "_updateStateData", value: function () { Object.assign(this.data, this.getStateData()), this.playheadTime._updatePlayheadTime(), this._sanitizeData() } }, { key: "_sanitizeData", value: function () { var b = this;["player_width", "player_height", "video_source_width", "video_source_height", "player_playhead_time", "video_source_bitrate"].forEach(function (A) { var D = parseInt(b.data[A], 10); b.data[A] = isNaN(D) ? void 0 : D }), ["player_source_url", "video_source_url"].forEach(function (A) { if (b.data[A]) { var D = b.data[A].toLowerCase(); 0 !== D.indexOf("data:") && 0 !== D.indexOf("blob:") || (b.data[A] = "MSE style URL") } }) } }, { key: "_resetVideoData", value: function (b, A) { var D = this; Object.keys(this.data).forEach(function (b) { 0 === b.indexOf("video_") && delete D.data[b] }) } }, { key: "_resetViewData", value: function () { var b = this; Object.keys(this.data).forEach(function (A) { 0 === A.indexOf("view_") && delete b.data[A] }), this.data.view_sequence_number = 1 } }, { key: "_resetErrorData", value: function (b, A) { delete this.data.player_error_code, delete this.data.player_error_message } }, { key: "_initializeViewData", value: function () { var b = this, A = this.data.view_id = i(), r = function () { A === b.data.view_id && y(b.data, "player_view_count", 1) }; this.data.player_is_paused ? this.one("play", r) : r() } }, { key: "_restartHeartBeat", value: function () { var b = this; window.clearTimeout(this._heartBeatTimeout), this.errorTracker.viewErrored || (this._heartBeatTimeout = window.setTimeout(function () { b.data.player_is_paused || b.emit("hb") }, 1e4)) } }, { key: "addHLSJS", value: function (b) { b.hlsjs ? this.hlsjs ? this.mux.log.warn("An instance of HLS.js is already being monitored for this player.") : (this.hlsjs = b.hlsjs, function (b, A, D) { var N = arguments.length > 4 ? arguments[4] : void 0, V = b.log, Y = b.utils.secondsToMs, o = function (b) { var A, D = parseInt(N.version); return 1 === D && null !== b.programDateTime && (A = b.programDateTime), 0 === D && null !== b.pdt && (A = b.pdt), A }; if (er.exists()) { var s = function (D, N) { return b.emit(A, D, N) }, u = function (b, A) { var D = A.levels, N = A.audioTracks, V = A.url, Y = A.stats, Z = A.networkDetails, ee = A.sessionData, et = {}, ea = {}; D.forEach(function (b, A) { et[A] = { width: b.width, height: b.height, bitrate: b.bitrate, attrs: b.attrs } }), N.forEach(function (b, A) { ea[A] = { name: b.name, language: b.lang, bitrate: b.bitrate } }); var er = x(Y), en = er.bytesLoaded, eo = er.requestStart, es = er.responseStart, el = er.responseEnd; s("requestcompleted", O(O({}, k(ee)), {}, { request_event_type: b, request_bytes_loaded: en, request_start: eo, request_response_start: es, request_response_end: el, request_type: "manifest", request_hostname: h(V), request_response_headers: P(Z), request_rendition_lists: { media: et, audio: ea, video: {} } })) }; D.on(N.Events.MANIFEST_LOADED, u); var l = function (b, A) { var D = A.details, N = A.level, V = A.networkDetails, Z = x(A.stats), ee = Z.bytesLoaded, et = Z.requestStart, ea = Z.responseStart, er = Z.responseEnd, en = D.fragments[D.fragments.length - 1], eo = o(en) + Y(en.duration); s("requestcompleted", { request_event_type: b, request_bytes_loaded: ee, request_start: et, request_response_start: ea, request_response_end: er, request_current_level: N, request_type: "manifest", request_hostname: h(D.url), request_response_headers: P(V), video_holdback: D.holdBack && Y(D.holdBack), video_part_holdback: D.partHoldBack && Y(D.partHoldBack), video_part_target_duration: D.partTarget && Y(D.partTarget), video_target_duration: D.targetduration && Y(D.targetduration), video_source_is_live: D.live, player_manifest_newest_program_time: isNaN(eo) ? void 0 : eo }) }; D.on(N.Events.LEVEL_LOADED, l); var d = function (b, A) { var D = A.details, N = A.networkDetails, V = x(A.stats); s("requestcompleted", { request_event_type: b, request_bytes_loaded: V.bytesLoaded, request_start: V.requestStart, request_response_start: V.responseStart, request_response_end: V.responseEnd, request_type: "manifest", request_hostname: h(D.url), request_response_headers: P(N) }) }; D.on(N.Events.AUDIO_TRACK_LOADED, d); var c = function (b, A) { var N = A.stats, V = A.networkDetails, Y = A.frag, Z = x(N = N || Y.stats), ee = Z.bytesLoaded, et = Z.requestStart, ea = Z.responseStart, er = Z.responseEnd, en = V ? P(V) : void 0, eo = { request_event_type: b, request_bytes_loaded: ee, request_start: et, request_response_start: ea, request_response_end: er, request_hostname: V ? h(V.responseURL) : void 0, request_id: en ? T(en) : void 0, request_response_headers: en, request_media_duration: Y.duration, request_url: null == V ? void 0 : V.responseURL }; "main" === Y.type ? (eo.request_type = "media", eo.request_current_level = Y.level, eo.request_video_width = (D.levels[Y.level] || {}).width, eo.request_video_height = (D.levels[Y.level] || {}).height, eo.request_labeled_bitrate = (D.levels[Y.level] || {}).bitrate) : eo.request_type = Y.type, s("requestcompleted", eo) }; D.on(N.Events.FRAG_LOADED, c); var f = function (b, A) { var D = A.frag, N = D.start; s("fragmentchange", { currentFragmentPDT: o(D), currentFragmentStart: Y(N) }) }; D.on(N.Events.FRAG_CHANGED, f); var p = function (b, A) { var D, V = A.type, Y = A.details, Z = A.response, ee = A.fatal, et = A.frag, ea = A.networkDetails, er = (null == et ? void 0 : et.url) || A.url || "", en = ea ? P(ea) : void 0; Y !== N.ErrorDetails.MANIFEST_LOAD_ERROR && Y !== N.ErrorDetails.MANIFEST_LOAD_TIMEOUT && Y !== N.ErrorDetails.FRAG_LOAD_ERROR && Y !== N.ErrorDetails.FRAG_LOAD_TIMEOUT && Y !== N.ErrorDetails.LEVEL_LOAD_ERROR && Y !== N.ErrorDetails.LEVEL_LOAD_TIMEOUT && Y !== N.ErrorDetails.AUDIO_TRACK_LOAD_ERROR && Y !== N.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT && Y !== N.ErrorDetails.SUBTITLE_LOAD_ERROR && Y !== N.ErrorDetails.SUBTITLE_LOAD_TIMEOUT && Y !== N.ErrorDetails.KEY_LOAD_ERROR && Y !== N.ErrorDetails.KEY_LOAD_TIMEOUT || s("requestfailed", { request_error: Y, request_url: er, request_hostname: h(er), request_id: en ? T(en) : void 0, request_type: Y === N.ErrorDetails.FRAG_LOAD_ERROR || Y === N.ErrorDetails.FRAG_LOAD_TIMEOUT ? "media" : Y === N.ErrorDetails.AUDIO_TRACK_LOAD_ERROR || Y === N.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT ? "audio" : Y === N.ErrorDetails.SUBTITLE_LOAD_ERROR || Y === N.ErrorDetails.SUBTITLE_LOAD_TIMEOUT ? "subtitle" : Y === N.ErrorDetails.KEY_LOAD_ERROR || Y === N.ErrorDetails.KEY_LOAD_TIMEOUT ? "encryption" : "manifest", request_error_code: null == Z ? void 0 : Z.code, request_error_text: null == Z ? void 0 : Z.text }), ee && s("error", { player_error_code: V, player_error_message: Y, player_error_context: "".concat(er ? "url: ".concat(er, "\n") : "") + "".concat(Z && (Z.code || Z.text) ? "response: ".concat(Z.code, ", ").concat(Z.text, "\n") : "") + "".concat(A.reason ? "failure reason: ".concat(A.reason, "\n") : "") + "".concat(A.level ? "level: ".concat(A.level, "\n") : "") + "".concat(A.parent ? "parent stream controller: ".concat(A.parent, "\n") : "") + "".concat(A.buffer ? "buffer length: ".concat(A.buffer, "\n") : "") + "".concat(A.error ? "error: ".concat(A.error, "\n") : "") + "".concat(A.event ? "event: ".concat(A.event, "\n") : "") + "".concat(A.err ? "error message: ".concat(null === (D = A.err) || void 0 === D ? void 0 : D.message, "\n") : "") }) }; D.on(N.Events.ERROR, p); var _ = function (b, A) { var D = A.frag, N = D && D._url || ""; s("requestcanceled", { request_event_type: b, request_url: N, request_type: "media", request_hostname: h(N) }) }; D.on(N.Events.FRAG_LOAD_EMERGENCY_ABORTED, _); var v = function (b, A) { var N = A.level, Y = D.levels[N]; if (Y && Y.attrs && Y.attrs.BANDWIDTH) { var Z, ee = Y.attrs.BANDWIDTH, et = parseFloat(Y.attrs["FRAME-RATE"]); isNaN(et) || (Z = et), ee ? s("renditionchange", { video_source_fps: Z, video_source_bitrate: ee, video_source_width: Y.width, video_source_height: Y.height, video_source_rendition_name: Y.name, video_source_codec: null == Y ? void 0 : Y.videoCodec }) : V.warn("missing BANDWIDTH from HLS manifest parsed by HLS.js") } }; D.on(N.Events.LEVEL_SWITCHED, v), D._stopMuxMonitor = function () { D.off(N.Events.MANIFEST_LOADED, u), D.off(N.Events.LEVEL_LOADED, l), D.off(N.Events.AUDIO_TRACK_LOADED, d), D.off(N.Events.FRAG_LOADED, c), D.off(N.Events.FRAG_CHANGED, f), D.off(N.Events.ERROR, p), D.off(N.Events.FRAG_LOAD_EMERGENCY_ABORTED, _), D.off(N.Events.LEVEL_SWITCHED, v), D.off(N.Events.DESTROYING, D._stopMuxMonitor), delete D._stopMuxMonitor }, D.on(N.Events.DESTROYING, D._stopMuxMonitor) } else V.warn("performance timing not supported. Not tracking HLS.js.") }(this.mux, this.id, b.hlsjs, {}, b.Hls || window.Hls)) : this.mux.log.warn("You must pass a valid hlsjs instance in order to track it.") } }, { key: "removeHLSJS", value: function () { var b; this.hlsjs && ((b = this.hlsjs) && "function" == typeof b._stopMuxMonitor && b._stopMuxMonitor(), this.hlsjs = void 0) } }, { key: "addDashJS", value: function (b) { b.dashjs ? this.dashjs ? this.mux.log.warn("An instance of Dash.js is already being monitored for this player.") : (this.dashjs = b.dashjs, function (b, A, D) { var N = b.log; if (D && D.on) { var V = j(D), i = function (D, N) { return b.emit(A, D, N) }, o = function (b) { var A = b.type, D = (b.data || {}).url; i("requestcompleted", { request_event_type: A, request_start: 0, request_response_start: 0, request_response_end: 0, request_bytes_loaded: -1, request_type: "manifest", request_hostname: h(D), request_url: D }) }; D.on("manifestLoaded", o); var Y = {}, u = function (b) { if ("function" != typeof b.getRequests) return null; var A = b.getRequests({ state: "executed" }); return 0 === A.length ? null : A[A.length - 1] }, d = function (b) { var A = b.type, N = b.chunk, V = b.request, Z = (N || {}).mediaInfo || {}, ee = Z.type, et = Z.bitrateList, ea = {}; (et = et || []).forEach(function (b, A) { ea[A] = {}, ea[A].width = b.width, ea[A].height = b.height, ea[A].bitrate = b.bandwidth, ea[A].attrs = {} }), "video" === ee ? Y.video = ea : "audio" === ee ? Y.audio = ea : Y.media = ea; var er = R(V, D), en = er.requestStart, eo = er.requestResponseStart, es = er.requestResponseEnd, el = er.requestResponseHeaders, ed = er.requestMediaDuration, eu = er.requestHostname, ec = er.requestUrl; i("requestcompleted", { request_event_type: A, request_start: en, request_response_start: eo, request_response_end: es, request_bytes_loaded: -1, request_type: ee + "_init", request_response_headers: el, request_hostname: eu, request_id: er.requestId, request_url: ec, request_media_duration: ed, request_rendition_lists: Y }) }; V >= 4 ? D.on("initFragmentLoaded", d) : D.on("initFragmentLoaded", function (b) { var A = b.type, D = b.fragmentModel, N = b.chunk; d({ type: A, request: u(D), chunk: N }) }); var f = function (b) { var A = b.type, N = b.chunk, V = b.request, Y = N || {}, Z = Y.mediaInfo, ee = Y.start, et = (Z || {}).type, ea = R(V, D), er = ea.requestStart, en = ea.requestResponseStart, eo = ea.requestResponseEnd, es = ea.requestBytesLoaded, el = ea.requestResponseHeaders, ed = ea.requestMediaDuration, eu = ea.requestHostname, ec = ea.requestUrl, em = ea.requestId, eh = I(et, D), ep = eh.currentLevel, ev = eh.renditionWidth, e_ = eh.renditionHeight; i("requestcompleted", { request_event_type: A, request_start: er, request_response_start: en, request_response_end: eo, request_bytes_loaded: es, request_type: et, request_response_headers: el, request_hostname: eu, request_id: em, request_url: ec, request_media_start_time: ee, request_media_duration: ed, request_current_level: ep, request_labeled_bitrate: eh.renditionBitrate, request_video_width: ev, request_video_height: e_ }) }; V >= 4 ? D.on("mediaFragmentLoaded", f) : D.on("mediaFragmentLoaded", function (b) { var A = b.type, D = b.fragmentModel, N = b.chunk; f({ type: A, request: u(D), chunk: N }) }); var Z = { video: void 0, audio: void 0, totalBitrate: void 0 }, _ = function () { if (Z.video && "number" == typeof Z.video.bitrate) { if (Z.video.width && Z.video.height) { var b = Z.video.bitrate; return Z.audio && "number" == typeof Z.audio.bitrate && (b += Z.audio.bitrate), b !== Z.totalBitrate ? (Z.totalBitrate = b, { video_source_bitrate: b, video_source_height: Z.video.height, video_source_width: Z.video.width, video_source_codec: L(Z.video.codec) }) : void 0 } N.warn("have bitrate info for video but missing width/height") } }, v = function (b, A, V) { if ("number" == typeof b.newQuality) { var Y = b.mediaType; if ("audio" === Y || "video" === Y) { var ee = D.getBitrateInfoListFor(Y).find(function (A) { return A.qualityIndex === b.newQuality }); if (ee && "number" == typeof ee.bitrate) { Z[Y] = S(S({}, ee), {}, { codec: D.getCurrentTrackFor(Y).codec }); var et = _(); et && i("renditionchange", et) } else N.warn("missing bitrate info for ".concat(Y)) } } else N.warn("missing evt.newQuality in qualityChangeRendered event", b) }; D.on("qualityChangeRendered", v); var m = function (b) { var A = b.request, D = b.mediaType; i("requestcanceled", { request_event_type: (A = A || {}).type + "_" + A.action, request_url: A.url, request_type: D, request_hostname: h(A.url) }) }; D.on("fragmentLoadingAbandoned", m); var y = function (b) { var A, D, N = b.error, V = (null == N || null === (A = N.data) || void 0 === A ? void 0 : A.request) || {}, Y = (null == N || null === (D = N.data) || void 0 === D ? void 0 : D.response) || {}; 27 === (null == N ? void 0 : N.code) && i("requestfailed", { request_error: V.type + "_" + V.action, request_url: V.url, request_hostname: h(V.url), request_type: V.mediaType, request_error_code: Y.status, request_error_text: Y.statusText }); var Z = "".concat(null != V && V.url ? "url: ".concat(V.url, "\n") : "") + "".concat(null != Y && Y.status || null != Y && Y.statusText ? "response: ".concat(null == Y ? void 0 : Y.status, ", ").concat(null == Y ? void 0 : Y.statusText, "\n") : ""); i("error", { player_error_code: null == N ? void 0 : N.code, player_error_message: null == N ? void 0 : N.message, player_error_context: Z }) }; D.on("error", y), D._stopMuxMonitor = function () { D.off("manifestLoaded", o), D.off("initFragmentLoaded", d), D.off("mediaFragmentLoaded", f), D.off("qualityChangeRendered", v), D.off("error", y), D.off("fragmentLoadingAbandoned", m), delete D._stopMuxMonitor } } else N.warn("Invalid dash.js player reference. Monitoring blocked.") }(this.mux, this.id, b.dashjs)) : this.mux.log.warn("You must pass a valid dashjs instance in order to track it.") } }, { key: "removeDashJS", value: function () { var b; this.dashjs && ((b = this.dashjs) && "function" == typeof b._stopMuxMonitor && b._stopMuxMonitor(), this.dashjs = void 0) } }], _t(o.prototype, D), N && _t(o, N), Object.defineProperty(o, "prototype", { writable: !1 }), o }(el), eF = D(153), eH = D.n(eF); function Ot(b) { return (Ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (b) { return typeof b } : function (b) { return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b })(b) } function Dt(b, A) { return function (b) { if (Array.isArray(b)) return b }(b) || function (b, A) { var D = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != D) { var N, V, Y = [], Z = !0, ee = !1; try { for (D = D.call(b); !(Z = (N = D.next()).done) && (Y.push(N.value), !A || Y.length !== A); Z = !0); } catch (b) { ee = !0, V = b } finally { try { Z || null == D.return || D.return() } finally { if (ee) throw V } } return Y } }(b, A) || function (b, A) { if (b) { if ("string" == typeof b) return xt(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); return "Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D ? Array.from(b) : "Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? xt(b, A) : void 0 } }(b, A) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function xt(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } var eG, eV, ej, eq, e$, eY, eK, eZ, eQ, ez, eX, eJ, e0, e1, e2, e5, e3, e4, e7, e8, e6, e9, tt, ta, ti, tr = ["loadstart", "pause", "play", "playing", "seeking", "seeked", "timeupdate", "ratechange", "stalled", "waiting", "error", "ended"], tn = { 1: "MEDIA_ERR_ABORTED", 2: "MEDIA_ERR_NETWORK", 3: "MEDIA_ERR_DECODE", 4: "MEDIA_ERR_SRC_NOT_SUPPORTED" }; V() && V().WeakMap && (ti = new WeakMap); var Ht = function (b) { return this.buffer = "", this.manifest = { segments: [], serverControl: {}, sessionData: {} }, this.currentUri = {}, this.process(b), this.manifest }; Ht.prototype.process = function (b) { var A; for (this.buffer += b, A = this.buffer.indexOf("\n"); A > -1; A = this.buffer.indexOf("\n"))this.processLine(this.buffer.substring(0, A)), this.buffer = this.buffer.substring(A + 1) }, Ht.prototype.processLine = function (b) { var A = b.indexOf(":"), D = Qt(b, A), N = D[0], V = 2 === D.length ? Bt(D[1]) : void 0; if ("#" !== N[0]) this.currentUri.uri = N, this.manifest.segments.push(this.currentUri), !this.manifest.targetDuration || "duration" in this.currentUri || (this.currentUri.duration = this.manifest.targetDuration), this.currentUri = {}; else switch (N) { case "#EXT-X-TARGETDURATION": if (!isFinite(V) || V < 0) return; this.manifest.targetDuration = V, this.setHoldBack(); break; case "#EXT-X-PART-INF": Mt(this.manifest, D), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), this.setHoldBack(); break; case "#EXT-X-SERVER-CONTROL": Mt(this.manifest, D), this.setHoldBack(); break; case "#EXTINF": 0 === V ? this.currentUri.duration = .01 : V > 0 && (this.currentUri.duration = V); break; case "#EXT-X-PROGRAM-DATE-TIME": var Y = new Date(V); this.manifest.dateTimeString || (this.manifest.dateTimeString = V, this.manifest.dateTimeObject = Y), this.currentUri.dateTimeString = V, this.currentUri.dateTimeObject = Y; break; case "#EXT-X-VERSION": Mt(this.manifest, D); break; case "#EXT-X-SESSION-DATA": var Z = k(Vt(D[1])); Object.assign(this.manifest.sessionData, Z) } }, Ht.prototype.setHoldBack = function () { var b = this.manifest, A = b.serverControl, D = b.targetDuration, N = b.partTargetDuration; if (A) { var V = "holdBack", Y = "partHoldBack", Z = D && 3 * D, ee = N && 2 * N; D && !A.hasOwnProperty(V) && (A[V] = Z), Z && A[V] < Z && (A[V] = Z), N && !A.hasOwnProperty(Y) && (A[Y] = 3 * N), N && A[Y] < ee && (A[Y] = ee) } }; var Mt = function (b, A) { var D, N = Ut(A[0].replace("#EXT-X-", "")); Wt(A[1]) ? (D = {}, D = Object.assign(Gt(A[1]), D)) : D = Bt(A[1]), b[N] = D }, Ut = function (b) { return b.toLowerCase().replace(/-(\w)/g, function (b) { return b[1].toUpperCase() }) }, Bt = function (b) { if ("yes" === b.toLowerCase() || "no" === b.toLowerCase()) return "yes" === b.toLowerCase(); var A = -1 !== b.indexOf(":") ? b : parseFloat(b); return isNaN(A) ? b : A }, Ft = function (b) { var A = {}, D = b.split("="); return D.length > 1 && (A[Ut(D[0])] = Bt(D[1])), A }, Gt = function (b) { for (var A = b.split(","), D = {}, N = 0; A.length > N; N++)D = Object.assign(Ft(A[N]), D); return D }, Wt = function (b) { return b.indexOf("=") > -1 }, Qt = function (b, A) { return -1 === A ? [b] : [b.substring(0, A), b.substring(A + 1)] }, Vt = function (b) { var A = {}; if (b) { var D = b.search(","); return [b.slice(0, D), b.slice(D + 1)].forEach(function (b, D) { for (var N = b.replace(/['"]+/g, "").split("="), V = 0; V < N.length; V++)"DATA-ID" === N[V] && (A["DATA-ID"] = N[1 - V]), "VALUE" === N[V] && (A.VALUE = N[1 - V]) }), { data: A } } }, to = { safeCall: function (b, A, D, N) { var V = N; if (b && "function" == typeof b[A]) try { V = b[A].apply(b, D) } catch (b) { et.info("safeCall error", b) } return V }, safeIncrement: y, getComputedStyle: function (b, A) { var D; if (b && A && V() && "function" == typeof V().getComputedStyle) return ti && ti.has(b) && (D = ti.get(b)), D || (D = V().getComputedStyle(b, null), ti && ti.set(b, D)), D.getPropertyValue(A) }, secondsToMs: function (b) { return Math.floor(1e3 * b) }, assign: Object.assign, headersStringToObject: w, cdnHeadersToRequestId: T, extractHostnameAndDomain: v, extractHostname: h, manifestParser: Ht, generateShortID: o, generateUUID: i, now: ea.now }; function Xt(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } var ts = {}, Zt = function e(b) { var A = arguments; "string" == typeof b ? e.hasOwnProperty(b) ? V().setTimeout(function () { A = Array.prototype.splice.call(A, 1), e[b].apply(null, A) }, 0) : et.warn("`" + b + "` is an unknown task") : "function" == typeof b ? V().setTimeout(function () { b(e) }, 0) : et.warn("`" + b + "` is invalid.") }, tl = { loaded: ea.now(), NAME: "mux-embed", VERSION: "4.30.0", API_VERSION: "2.1", PLAYER_TRACKED: !1, monitor: function (b, A) { return function (b, A, D) { var N = Dt(u(A), 3), V = N[0], Y = N[1], Z = N[2], ee = b.log, et = b.utils.getComputedStyle, ea = b.utils.secondsToMs; if (!V) return ee.error("No element was found with the `" + Y + "` query selector."); if ("video" !== Z && "audio" !== Z) return ee.error("The element of `" + Y + "` was not a media element."); V.mux && (V.mux.destroy(), delete V.mux, ee.warn("Already monitoring this video element, replacing existing event listeners")), (D = Object.assign({ automaticErrorTracking: !0 }, D)).data = Object.assign({ player_software: "HTML5 Video Element", player_mux_plugin_name: "VideoElementMonitor", player_mux_plugin_version: b.VERSION }, D.data), D.getPlayheadTime = function () { return ea(V.currentTime) }, D.getStateData = function () { var b, A, N = this.hlsjs && this.hlsjs.url, Y = this.dashjs && Ot("function" === this.dashjs.getSource) && this.dashjs.getSource(), Z = { player_is_paused: V.paused, player_playhead_time: ea(V.currentTime), player_width: parseInt(et(V, "width")), player_height: parseInt(et(V, "height")), player_autoplay_on: V.autoplay, player_preload_on: V.preload, player_language_code: V.lang, player_is_fullscreen: eH() && !!(eH().fullscreenElement || eH().webkitFullscreenElement || eH().mozFullScreenElement || eH().msFullscreenElement), video_poster_url: V.poster, video_source_url: N || Y || V.currentSrc, video_source_duration: ea(V.duration), video_source_height: V.videoHeight, video_source_width: V.videoWidth, view_dropped_frame_count: null === (b = V) || void 0 === b || null === (A = b.getVideoPlaybackQuality) || void 0 === A ? void 0 : A.call(b).droppedVideoFrames }, ee = D.getPlayheadTime(); if (V.getStartDate && ee > 0) { var er = V.getStartDate(); if (er && "function" == typeof er.getTime && er.getTime()) { var en = er.getTime(); if (Z.player_program_time = en + ee, V.seekable.length > 0) { var eo = en + V.seekable.end(V.seekable.length - 1); Z.player_live_edge_program_time = eo } } } return Z }, V.mux = V.mux || {}, V.mux.deleted = !1, V.mux.emit = function (A, D) { b.emit(Y, A, D) }; var c = function () { ee.error("The monitor for this video element has already been destroyed.") }; V.mux.destroy = function () { Object.keys(V.mux.listeners).forEach(function (b) { V.removeEventListener(b, V.mux.listeners[b], !1) }), delete V.mux.listeners, V.mux.destroy = c, V.mux.swapElement = c, V.mux.emit = c, V.mux.addHLSJS = c, V.mux.addDashJS = c, V.mux.removeHLSJS = c, V.mux.removeDashJS = c, V.mux.deleted = !0, b.emit(Y, "destroy") }, V.mux.swapElement = function (A) { var D = Dt(u(A), 3), N = D[0], Y = D[1], Z = D[2]; return N ? "video" !== Z && "audio" !== Z ? b.log.error("The element of `" + Y + "` was not a media element.") : (N.muxId = V.muxId, delete V.muxId, N.mux = N.mux || {}, N.mux.listeners = Object.assign({}, V.mux.listeners), delete V.mux.listeners, Object.keys(N.mux.listeners).forEach(function (b) { V.removeEventListener(b, N.mux.listeners[b], !1), N.addEventListener(b, N.mux.listeners[b], !1) }), N.mux.swapElement = V.mux.swapElement, N.mux.destroy = V.mux.destroy, delete V.mux, void (V = N)) : b.log.error("No element was found with the `" + Y + "` query selector.") }, V.mux.addHLSJS = function (A) { b.addHLSJS(Y, A) }, V.mux.addDashJS = function (A) { b.addDashJS(Y, A) }, V.mux.removeHLSJS = function () { b.removeHLSJS(Y) }, V.mux.removeDashJS = function () { b.removeDashJS(Y) }, b.init(Y, D), b.emit(Y, "playerready"), V.paused || (b.emit(Y, "play"), V.readyState > 2 && b.emit(Y, "playing")), V.mux.listeners = {}, tr.forEach(function (A) { ("error" !== A || D.automaticErrorTracking) && (V.mux.listeners[A] = function () { var D = {}; if ("error" === A) { if (!V.error || 1 === V.error.code) return; D.player_error_code = V.error.code, D.player_error_message = tn[V.error.code] || V.error.message } b.emit(Y, A, D) }, V.addEventListener(A, V.mux.listeners[A], !1)) }) }(Zt, b, A) }, destroyMonitor: function (b) { var A, D = (function (b) { if (Array.isArray(b)) return b }(A = u(b)) || function (b, A) { var D = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != D) { var N, V, Y = [], Z = !0, ee = !1; try { for (D = D.call(b); !(Z = (N = D.next()).done) && (Y.push(N.value), !A || Y.length !== A); Z = !0); } catch (b) { ee = !0, V = b } finally { try { Z || null == D.return || D.return() } finally { if (ee) throw V } } return Y } }(A, 1) || function (b, A) { if (b) { if ("string" == typeof b) return Xt(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); return "Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D ? Array.from(b) : "Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? Xt(b, A) : void 0 } }(A, 1) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }())[0]; D && D.mux && "function" == typeof D.mux.destroy ? D.mux.destroy() : et.error("A video element monitor for `" + b + "` has not been initialized via `mux.monitor`.") }, addHLSJS: function (b, A) { var D = s(b); ts[D] ? ts[D].addHLSJS(A) : et.error("A monitor for `" + D + "` has not been initialized.") }, addDashJS: function (b, A) { var D = s(b); ts[D] ? ts[D].addDashJS(A) : et.error("A monitor for `" + D + "` has not been initialized.") }, removeHLSJS: function (b) { var A = s(b); ts[A] ? ts[A].removeHLSJS() : et.error("A monitor for `" + A + "` has not been initialized.") }, removeDashJS: function (b) { var A = s(b); ts[A] ? ts[A].removeDashJS() : et.error("A monitor for `" + A + "` has not been initialized.") }, init: function (b, A) { p() && A && A.respectDoNotTrack && et.info("The browser's Do Not Track flag is enabled - Mux beaconing is disabled."); var D = s(b); ts[D] = new eW(Zt, D, A) }, emit: function (b, A, D) { var N = s(b); ts[N] ? (ts[N].emit(A, D), "destroy" === A && delete ts[N]) : et.error("A monitor for `" + N + "` has not been initialized.") }, checkDoNotTrack: p, log: et, utils: to, events: { PLAYER_READY: "playerready", VIEW_INIT: "viewinit", VIDEO_CHANGE: "videochange", PLAY: "play", PAUSE: "pause", PLAYING: "playing", TIME_UPDATE: "timeupdate", SEEKING: "seeking", SEEKED: "seeked", REBUFFER_START: "rebufferstart", REBUFFER_END: "rebufferend", ERROR: "error", ENDED: "ended", RENDITION_CHANGE: "renditionchange", ORIENTATION_CHANGE: "orientationchange", AD_REQUEST: "adrequest", AD_RESPONSE: "adresponse", AD_BREAK_START: "adbreakstart", AD_PLAY: "adplay", AD_PLAYING: "adplaying", AD_PAUSE: "adpause", AD_FIRST_QUARTILE: "adfirstquartile", AD_MID_POINT: "admidpoint", AD_THIRD_QUARTILE: "adthirdquartile", AD_ENDED: "adended", AD_BREAK_END: "adbreakend", AD_ERROR: "aderror", REQUEST_COMPLETED: "requestcompleted", REQUEST_FAILED: "requestfailed", REQUEST_CANCELLED: "requestcanceled" }, WINDOW_HIDDEN: !1, WINDOW_UNLOADING: !1 }; Object.assign(Zt, tl), void 0 !== V() && "function" == typeof V().addEventListener && V().addEventListener("pagehide", function (b) { b.persisted || (Zt.WINDOW_UNLOADING = !0) }, !1); var td = Zt }, 655: function (b, A, D) {
          var N, V; function i(b) {
            return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (b) { return typeof b } : function (b) { return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b })(b);/*!
   * JavaScript Cookie v2.1.3
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   */} !function (Y) { var Z = !1; if (void 0 === (V = "function" == typeof (N = Y) ? N.call(A, D, A, b) : N) || (b.exports = V), Z = !0, "object" === i(A) && (b.exports = Y(), Z = !0), !Z) { var ee = window.Cookies, et = window.Cookies = Y(); et.noConflict = function () { return window.Cookies = ee, et } } }(function () { var e = function () { for (var b = 0, A = {}; b < arguments.length; b++) { var D = arguments[b]; for (var N in D) A[N] = D[N] } return A }; return function t(b) { function a(A, D, N) { var V; if ("undefined" != typeof document) { if (arguments.length > 1) { if ("number" == typeof (N = e({ path: "/" }, a.defaults, N)).expires) { var Y = new Date; Y.setMilliseconds(Y.getMilliseconds() + 864e5 * N.expires), N.expires = Y } try { V = JSON.stringify(D), /^[\{\[]/.test(V) && (D = V) } catch (b) { } return D = b.write ? b.write(D, A) : encodeURIComponent(String(D)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), A = (A = (A = encodeURIComponent(String(A))).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)).replace(/[\(\)]/g, escape), document.cookie = [A, "=", D, N.expires ? "; expires=" + N.expires.toUTCString() : "", N.path ? "; path=" + N.path : "", N.domain ? "; domain=" + N.domain : "", N.secure ? "; secure" : ""].join("") } A || (V = {}); for (var Z = document.cookie ? document.cookie.split("; ") : [], ee = /(%[0-9A-Z]{2})+/g, et = 0; et < Z.length; et++) { var ea = Z[et].split("="), er = ea.slice(1).join("="); '"' === er.charAt(0) && (er = er.slice(1, -1)); try { var en = ea[0].replace(ee, decodeURIComponent); if (er = b.read ? b.read(er, en) : b(er, en) || er.replace(ee, decodeURIComponent), this.json) try { er = JSON.parse(er) } catch (b) { } if (A === en) { V = er; break } A || (V[en] = er) } catch (b) { } } return V } } return a.set = a, a.get = function (b) { return a.call(a, b) }, a.getJSON = function () { return a.apply({ json: !0 }, [].slice.call(arguments)) }, a.defaults = {}, a.remove = function (b, A) { a(b, "", e(A, { expires: -1 })) }, a.withConverter = t, a }(function () { }) })
        }, 153: function (b, A, D) { var N, V = void 0 !== D.g ? D.g : "undefined" != typeof window ? window : {}, Y = D(558); "undefined" != typeof document ? N = document : (N = V["__GLOBAL_DOCUMENT_CACHE@4"]) || (N = V["__GLOBAL_DOCUMENT_CACHE@4"] = Y), b.exports = N }, 48: function (b, A, D) { var N; N = "undefined" != typeof window ? window : void 0 !== D.g ? D.g : "undefined" != typeof self ? self : {}, b.exports = N }, 640: function (b, A, D) { var N, V; void 0 === (V = "function" == typeof (N = function () { var e = function () { }, b = "undefined", A = typeof window !== b && typeof window.navigator !== b && /Trident\/|MSIE /.test(window.navigator.userAgent), D = ["trace", "debug", "info", "warn", "error"]; function n(b, A) { var D = b[A]; if ("function" == typeof D.bind) return D.bind(b); try { return Function.prototype.bind.call(D, b) } catch (A) { return function () { return Function.prototype.apply.apply(D, [b, arguments]) } } } function i() { console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace() } function s(b, A) { for (var N = 0; N < D.length; N++) { var V = D[N]; this[V] = N < b ? e : this.methodFactory(V, b, A) } this.log = this.debug } function u(A, D, N) { return function () { typeof console !== b && (s.call(this, D, N), this[A].apply(this, arguments)) } } function l(D, N, V) { var Y; return "debug" === (Y = D) && (Y = "log"), typeof console !== b && ("trace" === Y && A ? i : void 0 !== console[Y] ? n(console, Y) : void 0 !== console.log ? n(console, "log") : e) || u.apply(this, arguments) } function d(A, N, V) { var Y, Z = this; N = null == N ? "WARN" : N; var ee = "loglevel"; function c() { var A; if (typeof window !== b && ee) { try { A = window.localStorage[ee] } catch (b) { } if (typeof A === b) try { var D = window.document.cookie, N = D.indexOf(encodeURIComponent(ee) + "="); -1 !== N && (A = /^([^;]+)/.exec(D.slice(N))[1]) } catch (b) { } return void 0 === Z.levels[A] && (A = void 0), A } } "string" == typeof A ? ee += ":" + A : "symbol" == typeof A && (ee = void 0), Z.name = A, Z.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }, Z.methodFactory = V || l, Z.getLevel = function () { return Y }, Z.setLevel = function (N, V) { if ("string" == typeof N && void 0 !== Z.levels[N.toUpperCase()] && (N = Z.levels[N.toUpperCase()]), !("number" == typeof N && N >= 0 && N <= Z.levels.SILENT)) throw "log.setLevel() called with invalid level: " + N; if (Y = N, !1 !== V && function (A) { var N = (D[A] || "silent").toUpperCase(); if (typeof window !== b && ee) { try { return void (window.localStorage[ee] = N) } catch (b) { } try { window.document.cookie = encodeURIComponent(ee) + "=" + N + ";" } catch (b) { } } }(N), s.call(Z, N, A), typeof console === b && N < Z.levels.SILENT) return "No console available for logging" }, Z.setDefaultLevel = function (b) { N = b, c() || Z.setLevel(b, !1) }, Z.resetLevel = function () { Z.setLevel(N, !1), function () { if (typeof window !== b && ee) { try { return void window.localStorage.removeItem(ee) } catch (b) { } try { window.document.cookie = encodeURIComponent(ee) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC" } catch (b) { } } }() }, Z.enableAll = function (b) { Z.setLevel(Z.levels.TRACE, b) }, Z.disableAll = function (b) { Z.setLevel(Z.levels.SILENT, b) }; var et = c(); null == et && (et = N), Z.setLevel(et, !1) } var N = new d, V = {}; N.getLogger = function (b) { if ("symbol" != typeof b && "string" != typeof b || "" === b) throw TypeError("You must supply a name when creating a logger."); var A = V[b]; return A || (A = V[b] = new d(b, N.getLevel(), N.methodFactory)), A }; var Y = typeof window !== b ? window.log : void 0; return N.noConflict = function () { return typeof window !== b && window.log === N && (window.log = Y), N }, N.getLoggers = function () { return V }, N.default = N, N }) ? N.call(A, D, A, b) : N) || (b.exports = V) }, 375: function (b, A) { "use strict"; var D = Object.prototype.hasOwnProperty; function a(b) { try { return decodeURIComponent(b.replace(/\+/g, " ")) } catch (b) { return null } } function n(b) { try { return encodeURIComponent(b) } catch (b) { return null } } A.stringify = function (b, A) { var N, V, Y = []; for (V in "string" != typeof (A = A || "") && (A = "?"), b) if (D.call(b, V)) { if ((N = b[V]) || null != N && !isNaN(N) || (N = ""), V = n(V), N = n(N), null === V || null === N) continue; Y.push(V + "=" + N) } return Y.length ? A + Y.join("&") : "" }, A.parse = function (b) { for (var A, D = /([^=?#&]+)=?([^&]*)/g, N = {}; A = D.exec(b);) { var V = a(A[1]), Y = a(A[2]); null === V || null === Y || V in N || (N[V] = Y) } return N } }, 558: function () { }
      }, A = {}; function r(D) { var N = A[D]; if (void 0 !== N) return N.exports; var V = A[D] = { exports: {} }; return b[D].call(V.exports, V, V.exports, r), V.exports } return r.n = function (b) { var A = b && b.__esModule ? function () { return b.default } : function () { return b }; return r.d(A, { a: A }), A }, r.d = function (b, A) { for (var D in A) r.o(A, D) && !r.o(b, D) && Object.defineProperty(b, D, { enumerable: !0, get: A[D] }) }, r.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || Function("return this")() } catch (b) { if ("object" == typeof window) return window } }(), r.o = function (b, A) { return Object.prototype.hasOwnProperty.call(b, A) }, r(80)
    }()
  }, 21468: function () { }, 74049: function (b, A, D) { "use strict"; var N = D(36257); function emptyFunction() { } function emptyFunctionWithReset() { } emptyFunctionWithReset.resetWarningCache = emptyFunction, b.exports = function () { function shim(b, A, D, V, Y, Z) { if (Z !== N) { var ee = Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw ee.name = "Invariant Violation", ee } } function getShim() { return shim } shim.isRequired = shim; var b = { array: shim, bigint: shim, bool: shim, func: shim, number: shim, object: shim, string: shim, symbol: shim, any: shim, arrayOf: getShim, element: shim, elementType: shim, instanceOf: getShim, node: shim, objectOf: getShim, oneOf: getShim, oneOfType: getShim, shape: getShim, exact: getShim, checkPropTypes: emptyFunctionWithReset, resetWarningCache: emptyFunction }; return b.PropTypes = b, b } }, 40507: function (b, A, D) { b.exports = D(74049)() }, 36257: function (b) { "use strict"; b.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED" }, 24608: function (b, A, D) { "use strict"; function _typeof(b) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (b) { return typeof b } : function (b) { return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b })(b) } A.Z = void 0; var N = function (b) { if (b && b.__esModule) return b; if (null === b || "object" !== _typeof(b) && "function" != typeof b) return { default: b }; var A = _getRequireWildcardCache(); if (A && A.has(b)) return A.get(b); var D = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var V in b) if (Object.prototype.hasOwnProperty.call(b, V)) { var Y = N ? Object.getOwnPropertyDescriptor(b, V) : null; Y && (Y.get || Y.set) ? Object.defineProperty(D, V, Y) : D[V] = b[V] } return D.default = b, A && A.set(b, D), D }(D(50959)), V = _interopRequireDefault(D(40507)), Y = _interopRequireDefault(D(26591)); function _interopRequireDefault(b) { return b && b.__esModule ? b : { default: b } } function _getRequireWildcardCache() { if ("function" != typeof WeakMap) return null; var b = new WeakMap; return _getRequireWildcardCache = function () { return b }, b } function _arrayLikeToArray(b, A) { (null == A || A > b.length) && (A = b.length); for (var D = 0, N = Array(A); D < A; D++)N[D] = b[D]; return N } function _extends() { return (_extends = Object.assign || function (b) { for (var A = 1; A < arguments.length; A++) { var D = arguments[A]; for (var N in D) Object.prototype.hasOwnProperty.call(D, N) && (b[N] = D[N]) } return b }).apply(this, arguments) } function ownKeys(b, A) { var D = Object.keys(b); if (Object.getOwnPropertySymbols) { var N = Object.getOwnPropertySymbols(b); A && (N = N.filter(function (A) { return Object.getOwnPropertyDescriptor(b, A).enumerable })), D.push.apply(D, N) } return D } function _objectSpread(b) { for (var A = 1; A < arguments.length; A++) { var D = null != arguments[A] ? arguments[A] : {}; A % 2 ? ownKeys(Object(D), !0).forEach(function (A) { _defineProperty(b, A, D[A]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(D)) : ownKeys(Object(D)).forEach(function (A) { Object.defineProperty(b, A, Object.getOwnPropertyDescriptor(D, A)) }) } return b } function _defineProperties(b, A) { for (var D = 0; D < A.length; D++) { var N = A[D]; N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(b, N.key, N) } } function _setPrototypeOf(b, A) { return (_setPrototypeOf = Object.setPrototypeOf || function (b, A) { return b.__proto__ = A, b })(b, A) } function _assertThisInitialized(b) { if (void 0 === b) throw ReferenceError("this hasn't been initialised - super() hasn't been called"); return b } function _getPrototypeOf(b) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (b) { return b.__proto__ || Object.getPrototypeOf(b) })(b) } function _defineProperty(b, A, D) { return A in b ? Object.defineProperty(b, A, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : b[A] = D, b } var Z = ["onChange", "onOpen", "onClose", "onMonthChange", "onYearChange", "onReady", "onValueUpdate", "onDayCreate"], ee = V.default.oneOfType([V.default.func, V.default.arrayOf(V.default.func)]), et = ["onCreate", "onDestroy"], ea = V.default.func, er = function (b) { !function (b, A) { if ("function" != typeof A && null !== A) throw TypeError("Super expression must either be null or a function"); b.prototype = Object.create(A && A.prototype, { constructor: { value: b, writable: !0, configurable: !0 } }), A && _setPrototypeOf(b, A) }(DateTimePicker, b); var A, D, V, ee = (A = function () { if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (b) { return !1 } }(), function () { var b, D, N = _getPrototypeOf(DateTimePicker); if (A) { var V = _getPrototypeOf(this).constructor; D = Reflect.construct(N, arguments, V) } else D = N.apply(this, arguments); return (b = D) && ("object" === _typeof(b) || "function" == typeof b) ? b : _assertThisInitialized(this) }); function DateTimePicker() { var b; !function (b, A) { if (!(b instanceof A)) throw TypeError("Cannot call a class as a function") }(this, DateTimePicker); for (var A = arguments.length, D = Array(A), N = 0; N < A; N++)D[N] = arguments[N]; return _defineProperty(_assertThisInitialized(b = ee.call.apply(ee, [this].concat(D))), "createFlatpickrInstance", function () { var A = _objectSpread({ onClose: function () { b.node.blur && b.node.blur() } }, b.props.options); A = mergeHooks(A, b.props), b.flatpickr = (0, Y.default)(b.node, A), b.props.hasOwnProperty("value") && b.flatpickr.setDate(b.props.value, !1); var D = b.props.onCreate; D && D(b.flatpickr) }), _defineProperty(_assertThisInitialized(b), "destroyFlatpickrInstance", function () { var A = b.props.onDestroy; A && A(b.flatpickr), b.flatpickr.destroy(), b.flatpickr = null }), _defineProperty(_assertThisInitialized(b), "handleNodeChange", function (A) { b.node = A, b.flatpickr && (b.destroyFlatpickrInstance(), b.createFlatpickrInstance()) }), b } return D = [{ key: "componentDidUpdate", value: function (b) { var A = this.props.options, D = b.options; A = mergeHooks(A, this.props), D = mergeHooks(D, b); for (var N = Object.getOwnPropertyNames(A), V = N.length - 1; V >= 0; V--) { var Y = N[V], ee = A[Y]; ee !== D[Y] && (-1 === Z.indexOf(Y) || Array.isArray(ee) || (ee = [ee]), this.flatpickr.set(Y, ee)) } this.props.hasOwnProperty("value") && !(this.props.value && Array.isArray(this.props.value) && b.value && Array.isArray(b.value) && this.props.value.every(function (A, D) { b[D] })) && this.props.value !== b.value && this.flatpickr.setDate(this.props.value, !1) } }, { key: "componentDidMount", value: function () { this.createFlatpickrInstance() } }, { key: "componentWillUnmount", value: function () { this.destroyFlatpickrInstance() } }, { key: "render", value: function () { var b = this.props, A = b.options, D = b.defaultValue, V = b.value, Y = b.children, ee = b.render, ea = function (b, A) { if (null == b) return {}; var D, N, V = function (b, A) { if (null == b) return {}; var D, N, V = {}, Y = Object.keys(b); for (N = 0; N < Y.length; N++)D = Y[N], A.indexOf(D) >= 0 || (V[D] = b[D]); return V }(b, A); if (Object.getOwnPropertySymbols) { var Y = Object.getOwnPropertySymbols(b); for (N = 0; N < Y.length; N++)D = Y[N], !(A.indexOf(D) >= 0) && Object.prototype.propertyIsEnumerable.call(b, D) && (V[D] = b[D]) } return V }(b, ["options", "defaultValue", "value", "children", "render"]); return (Z.forEach(function (b) { delete ea[b] }), et.forEach(function (b) { delete ea[b] }), ee) ? ee(_objectSpread(_objectSpread({}, ea), {}, { defaultValue: D, value: V }), this.handleNodeChange) : A.wrap ? N.default.createElement("div", _extends({}, ea, { ref: this.handleNodeChange }), Y) : N.default.createElement("input", _extends({}, ea, { defaultValue: D, ref: this.handleNodeChange })) } }], _defineProperties(DateTimePicker.prototype, D), V && _defineProperties(DateTimePicker, V), DateTimePicker }(N.Component); function mergeHooks(b, A) { var D = _objectSpread({}, b); return Z.forEach(function (b) { if (A.hasOwnProperty(b)) { D[b] && !Array.isArray(D[b]) ? D[b] = [D[b]] : D[b] || (D[b] = []); var N, V = Array.isArray(A[b]) ? A[b] : [A[b]]; (N = D[b]).push.apply(N, function (b) { if (Array.isArray(b)) return _arrayLikeToArray(b) }(V) || function (b) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(b)) return Array.from(b) }(V) || function (b, A) { if (b) { if ("string" == typeof b) return _arrayLikeToArray(b, A); var D = Object.prototype.toString.call(b).slice(8, -1); if ("Object" === D && b.constructor && (D = b.constructor.name), "Map" === D || "Set" === D) return Array.from(b); if ("Arguments" === D || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D)) return _arrayLikeToArray(b, A) } }(V) || function () { throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }()) } }), D } _defineProperty(er, "propTypes", { defaultValue: V.default.string, options: V.default.object, onChange: ee, onOpen: ee, onClose: ee, onMonthChange: ee, onYearChange: ee, onReady: ee, onValueUpdate: ee, onDayCreate: ee, onCreate: ea, onDestroy: ea, value: V.default.oneOfType([V.default.string, V.default.array, V.default.object, V.default.number]), children: V.default.node, className: V.default.string, render: V.default.func }), _defineProperty(er, "defaultProps", { options: {} }), A.Z = er }, 8211: function (b, A, D) {
    "use strict"; let N, V; D.d(A, { Z: function () { return sd } }); var Y = D(50959); let Z = { MEDIA_PLAY_REQUEST: "mediaplayrequest", MEDIA_PAUSE_REQUEST: "mediapauserequest", MEDIA_MUTE_REQUEST: "mediamuterequest", MEDIA_UNMUTE_REQUEST: "mediaunmuterequest", MEDIA_VOLUME_REQUEST: "mediavolumerequest", MEDIA_SEEK_REQUEST: "mediaseekrequest", MEDIA_AIRPLAY_REQUEST: "mediaairplayrequest", MEDIA_ENTER_FULLSCREEN_REQUEST: "mediaenterfullscreenrequest", MEDIA_EXIT_FULLSCREEN_REQUEST: "mediaexitfullscreenrequest", MEDIA_PREVIEW_REQUEST: "mediapreviewrequest", MEDIA_ENTER_PIP_REQUEST: "mediaenterpiprequest", MEDIA_EXIT_PIP_REQUEST: "mediaexitpiprequest", MEDIA_ENTER_CAST_REQUEST: "mediaentercastrequest", MEDIA_EXIT_CAST_REQUEST: "mediaexitcastrequest", MEDIA_SHOW_TEXT_TRACKS_REQUEST: "mediashowtexttracksrequest", MEDIA_HIDE_TEXT_TRACKS_REQUEST: "mediahidetexttracksrequest", MEDIA_SHOW_SUBTITLES_REQUEST: "mediashowsubtitlesrequest", MEDIA_DISABLE_SUBTITLES_REQUEST: "mediadisablesubtitlesrequest", MEDIA_TOGGLE_SUBTITLES_REQUEST: "mediatogglesubtitlesrequest", MEDIA_PLAYBACK_RATE_REQUEST: "mediaplaybackraterequest", MEDIA_RENDITION_REQUEST: "mediarenditionrequest", MEDIA_AUDIO_TRACK_REQUEST: "mediaaudiotrackrequest", MEDIA_SEEK_TO_LIVE_REQUEST: "mediaseektoliverequest", REGISTER_MEDIA_STATE_RECEIVER: "registermediastatereceiver", UNREGISTER_MEDIA_STATE_RECEIVER: "unregistermediastatereceiver" }, ee = { MEDIA_CHROME_ATTRIBUTES: "mediachromeattributes", MEDIA_CONTROLLER: "mediacontroller" }, et = { MEDIA_AIRPLAY_UNAVAILABLE: "mediaAirplayUnavailable", MEDIA_FULLSCREEN_UNAVAILABLE: "mediaFullscreenUnavailable", MEDIA_PIP_UNAVAILABLE: "mediaPipUnavailable", MEDIA_CAST_UNAVAILABLE: "mediaCastUnavailable", MEDIA_RENDITION_UNAVAILABLE: "mediaRenditionUnavailable", MEDIA_AUDIO_TRACK_UNAVAILABLE: "mediaAudioTrackUnavailable", MEDIA_PAUSED: "mediaPaused", MEDIA_HAS_PLAYED: "mediaHasPlayed", MEDIA_ENDED: "mediaEnded", MEDIA_MUTED: "mediaMuted", MEDIA_VOLUME_LEVEL: "mediaVolumeLevel", MEDIA_VOLUME: "mediaVolume", MEDIA_VOLUME_UNAVAILABLE: "mediaVolumeUnavailable", MEDIA_IS_PIP: "mediaIsPip", MEDIA_IS_CASTING: "mediaIsCasting", MEDIA_SUBTITLES_LIST: "mediaSubtitlesList", MEDIA_SUBTITLES_SHOWING: "mediaSubtitlesShowing", MEDIA_IS_FULLSCREEN: "mediaIsFullscreen", MEDIA_PLAYBACK_RATE: "mediaPlaybackRate", MEDIA_CURRENT_TIME: "mediaCurrentTime", MEDIA_DURATION: "mediaDuration", MEDIA_SEEKABLE: "mediaSeekable", MEDIA_PREVIEW_TIME: "mediaPreviewTime", MEDIA_PREVIEW_IMAGE: "mediaPreviewImage", MEDIA_PREVIEW_COORDS: "mediaPreviewCoords", MEDIA_LOADING: "mediaLoading", MEDIA_BUFFERED: "mediaBuffered", MEDIA_STREAM_TYPE: "mediaStreamType", MEDIA_TARGET_LIVE_WINDOW: "mediaTargetLiveWindow", MEDIA_TIME_IS_LIVE: "mediaTimeIsLive", MEDIA_RENDITION_LIST: "mediaRenditionList", MEDIA_RENDITION_SELECTED: "mediaRenditionSelected", MEDIA_AUDIO_TRACK_LIST: "mediaAudioTrackList", MEDIA_AUDIO_TRACK_ENABLED: "mediaAudioTrackEnabled" }, ea = Object.entries(et), er = ea.reduce((b, [A, D]) => (b[A] = `${D.toLowerCase()}`, b), {}), en = ea.reduce((b, [A, D]) => (b[A] = `${D.toLowerCase()}`, b), { USER_INACTIVE: "userinactivechange", BREAKPOINTS_CHANGE: "breakpointchange", BREAKPOINTS_COMPUTED: "breakpointscomputed" }); Object.entries(en).reduce((b, [A, D]) => { let N = er[A]; return N && (b[D] = N), b }, { userinactivechange: "userinactive" }); let eo = Object.entries(er).reduce((b, [A, D]) => { let N = en[A]; return N && (b[D] = N), b }, { userinactive: "userinactivechange" }), es = { SUBTITLES: "subtitles", CAPTIONS: "captions", METADATA: "metadata" }, el = { DISABLED: "disabled", SHOWING: "showing" }, ed = { MOUSE: "mouse", TOUCH: "touch" }, eu = { UNAVAILABLE: "unavailable", UNSUPPORTED: "unsupported" }, ec = { LIVE: "live", ON_DEMAND: "on-demand", UNKNOWN: "unknown" }, em = { AUDIO_PLAYER: () => "audio player", VIDEO_PLAYER: () => "video player", VOLUME: () => "volume", SEEK: () => "seek", CLOSED_CAPTIONS: () => "closed captions", PLAYBACK_RATE: ({ playbackRate: b = 1 } = {}) => `current playback rate ${b}`, PLAYBACK_TIME: () => "playback time", MEDIA_LOADING: () => "media loading" }, eh = { PLAY: () => "play", PAUSE: () => "pause", MUTE: () => "mute", UNMUTE: () => "unmute", AIRPLAY: () => "air play", ENTER_CAST: () => "start casting", EXIT_CAST: () => "stop casting", ENTER_FULLSCREEN: () => "enter fullscreen mode", EXIT_FULLSCREEN: () => "exit fullscreen mode", ENTER_PIP: () => "enter picture in picture mode", EXIT_PIP: () => "exit picture in picture mode", SEEK_FORWARD_N_SECS: ({ seekOffset: b = 30 } = {}) => `seek forward ${b} seconds`, SEEK_BACK_N_SECS: ({ seekOffset: b = 30 } = {}) => `seek back ${b} seconds`, SEEK_LIVE: () => "seek to live", PLAYING_LIVE: () => "playing live" }; function stringifyRendition(b) { if (b) { let { id: A, width: D, height: N } = b; return [A, D, N].filter(b => null != b).join(":") } } function parseRendition(b) { if (b) { let [A, D, N] = b.split(":"); return { id: A, width: D, height: N } } } function stringifyAudioTrack(b) { if (b) { let { id: A, kind: D, language: N, label: V } = b; return [A, D, N, V].filter(b => null != b).join(":") } } function parseAudioTrack(b) { if (b) { let [A, D, N, V] = b.split(":"); return { id: A, kind: D, language: N, label: V } } } function constToCamel(b, A = !1) { return b.split("_").map(function (b, D) { return (D || A ? b[0].toUpperCase() : b[0].toLowerCase()) + b.slice(1).toLowerCase() }).join("") } function isNumericString(b) { return "string" == typeof b && !isNaN(b) && !isNaN(parseFloat(b)) } ({ ...em, ...eh }); let delay = b => new Promise(A => setTimeout(A, b)), ep = [{ singular: "hour", plural: "hours" }, { singular: "minute", plural: "minutes" }, { singular: "second", plural: "seconds" }], toTimeUnitPhrase = (b, A) => { let D = 1 === b ? ep[A].singular : ep[A].plural; return `${b} ${D}` }, formatAsTimePhrase = b => { if (!("number" == typeof b && !Number.isNaN(b) && Number.isFinite(b))) return ""; let A = Math.abs(b), D = new Date(0, 0, 0, 0, 0, A, 0), N = [D.getHours(), D.getMinutes(), D.getSeconds()], V = N.map((b, A) => b && toTimeUnitPhrase(b, A)).filter(b => b).join(", "); return `${V}${A !== b ? " remaining" : ""}` }; function formatTime(b, A) { let D = !1; b < 0 && (D = !0, b = 0 - b); let N = Math.floor((b = b < 0 ? 0 : b) % 60), V = Math.floor(b / 60 % 60), Y = Math.floor(b / 3600); return (isNaN(b) || b === 1 / 0) && (Y = V = N = "0"), V = (((Y = Y > 0 || Math.floor(A / 3600) > 0 ? Y + ":" : "") || Math.floor(A / 60 % 60) >= 10) && V < 10 ? "0" + V : V) + ":", (D ? "-" : "") + Y + V + (N = N < 10 ? "0" + N : N) } Object.freeze({ length: 0, start(b) { let A = b >>> 0; if (A >= this.length) throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${A}) is greater than or equal to the maximum bound (${this.length}).`); return 0 }, end(b) { let A = b >>> 0; if (A >= this.length) throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${A}) is greater than or equal to the maximum bound (${this.length}).`); return 0 } }); let updateIconText = (b, A, D = ".value") => { let N = b.querySelector(D); N && (N.textContent = A) }, getAllSlotted = (b, A) => { let D = `slot[name="${A}"]`, N = b.shadowRoot.querySelector(D); return N ? N.children : [] }, getSlotted = (b, A) => getAllSlotted(b, A)[0], containsComposedNode = (b, A) => !!b && !!A && (!!b.contains(A) || containsComposedNode(b, A.getRootNode().host)), closestComposedNode = (b, A) => { if (!b) return null; let D = b.closest(A); return D || closestComposedNode(b.getRootNode().host, A) }; function distance(b, A) { return Math.sqrt(Math.pow(A.x - b.x, 2) + Math.pow(A.y - b.y, 2)) } function getOrInsertCSSRule(b, A) { var D; let N; for (N of b.querySelectorAll("style")) { let b; try { b = null == (D = N.sheet) ? void 0 : D.cssRules } catch { continue } for (let D of null != b ? b : []) if (D.selectorText === A) return D } return (null == N ? void 0 : N.sheet) ? (N.sheet.insertRule(`${A}{}`, N.sheet.cssRules.length), N.sheet.cssRules[N.sheet.cssRules.length - 1]) : { style: { setProperty: () => { }, removeProperty: () => { } } } } function getNumericAttr(b, A, D = Number.NaN) { let N = b.getAttribute(A); return null != N ? +N : D } function setNumericAttr(b, A, D) { let N = +D; if (null == D || Number.isNaN(N)) { b.hasAttribute(A) && b.removeAttribute(A); return } getNumericAttr(b, A, void 0) !== N && b.setAttribute(A, `${N}`) } function getBooleanAttr(b, A) { return b.hasAttribute(A) } function setBooleanAttr(b, A, D) { if (null == D) { b.hasAttribute(A) && b.removeAttribute(A); return } getBooleanAttr(b, A) != D && b.toggleAttribute(A, D) } function getStringAttr(b, A, D = null) { var N; return null != (N = b.getAttribute(A)) ? N : D } function setStringAttr(b, A, D) { if (null == D) { b.hasAttribute(A) && b.removeAttribute(A); return } let N = `${D}`; getStringAttr(b, A, void 0) !== N && b.setAttribute(A, N) } let server_safe_globals_EventTarget = class server_safe_globals_EventTarget { addEventListener() { } removeEventListener() { } dispatchEvent() { return !0 } }; let ev = { createElement: function () { return new e_.HTMLElement }, addEventListener() { }, removeEventListener() { } }, e_ = { ResizeObserver: class { observe() { } unobserve() { } disconnect() { } }, document: ev, HTMLElement: class extends server_safe_globals_EventTarget { }, DocumentFragment: class extends server_safe_globals_EventTarget { }, customElements: { get: function () { }, define: function () { }, whenDefined: function () { } }, CustomEvent: function () { }, getComputedStyle: function () { }, navigator: { languages: [] } }, ef = "undefined" == typeof window || void 0 === window.customElements, eb = Object.keys(e_).every(b => b in globalThis), eg = ef && !eb ? e_ : globalThis, eE = ef && !eb ? ev : globalThis.document; var ey = Object.defineProperty, __defNormalProp = (b, A, D) => A in b ? ey(b, A, { enumerable: !0, configurable: !0, writable: !0, value: D }) : b[A] = D, __publicField = (b, A, D) => (__defNormalProp(b, "symbol" != typeof A ? A + "" : A, D), D), __accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, __privateGet = (b, A, D) => (__accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), __privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, __privateSet = (b, A, D, N) => (__accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let eA = eE.createElement("template"); eA.innerHTML = `
  <style>
    :host {
      font: var(--media-font,
        var(--media-font-weight, bold)
        var(--media-font-size, 14px) /
        var(--media-text-content-height, var(--media-control-height, 24px))
        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
      background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));
      padding: var(--media-control-padding, 10px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
      box-sizing: border-box;
      transition: background .15s linear;
      pointer-events: auto;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
  
    
    :host(:focus-visible) {
      box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);
      outline: 0;
    }
    
    :host(:where(:focus)) {
      box-shadow: none;
      outline: 0;
    }
  
    :host(:hover) {
      background: var(--media-control-hover-background, rgba(50 50 70 / .7));
    }
  
    svg, img, ::slotted(svg), ::slotted(img) {
      width: var(--media-button-icon-width);
      height: var(--media-button-icon-height, var(--media-control-height, 24px));
      transform: var(--media-button-icon-transform);
      transition: var(--media-button-icon-transition);
      fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));
      vertical-align: middle;
      max-width: 100%;
      max-height: 100%;
      min-width: 100%;
    }
  </style>
  `; let MediaChromeButton = class MediaChromeButton extends eg.HTMLElement { constructor(b = {}) { if (super(), __privateAdd(this, tz, void 0), __publicField(this, "preventClick", !1), __privateAdd(this, tX, b => { this.preventClick || this.handleClick(b) }), __privateAdd(this, tJ, b => { let { key: A } = b; if (!this.keysUsed.includes(A)) { this.removeEventListener("keyup", __privateGet(this, tJ)); return } this.preventClick || this.handleClick(b) }), __privateAdd(this, t0, b => { let { metaKey: A, altKey: D, key: N } = b; if (A || D || !this.keysUsed.includes(N)) { this.removeEventListener("keyup", __privateGet(this, tJ)); return } this.addEventListener("keyup", __privateGet(this, tJ), { once: !0 }) }), !this.shadowRoot) { this.attachShadow({ mode: "open" }); let A = eA.content.cloneNode(!0); this.nativeEl = A; let D = b.slotTemplate; D || ((D = eE.createElement("template")).innerHTML = `<slot>${b.defaultContent || ""}</slot>`), this.nativeEl.appendChild(D.content.cloneNode(!0)), this.shadowRoot.appendChild(A) } let { style: A } = getOrInsertCSSRule(this.shadowRoot, ":host"); A.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`) } static get observedAttributes() { return ["disabled", ee.MEDIA_CONTROLLER] } enable() { this.addEventListener("click", __privateGet(this, tX)), this.addEventListener("keydown", __privateGet(this, t0)), this.tabIndex = 0 } disable() { this.removeEventListener("click", __privateGet(this, tX)), this.removeEventListener("keydown", __privateGet(this, t0)), this.removeEventListener("keyup", __privateGet(this, tJ)), this.tabIndex = -1 } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER ? (A && (null == (V = null == (N = __privateGet(this, tz)) ? void 0 : N.unassociateElement) || V.call(N, this), __privateSet(this, tz, null)), D && this.isConnected && (__privateSet(this, tz, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = __privateGet(this, tz)) ? void 0 : Z.associateElement) || et.call(Z, this))) : "disabled" === b && D !== A && (null == D ? this.enable() : this.disable()) } connectedCallback() { var b, A, D; this.hasAttribute("disabled") || this.enable(), this.setAttribute("role", "button"); let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (__privateSet(this, tz, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = __privateGet(this, tz)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; this.disable(), null == (A = null == (b = __privateGet(this, tz)) ? void 0 : b.unassociateElement) || A.call(b, this), __privateSet(this, tz, null) } get keysUsed() { return ["Enter", " "] } handleClick(b) { } }; tz = new WeakMap, tX = new WeakMap, tJ = new WeakMap, t0 = new WeakMap, eg.customElements.get("media-chrome-button") || eg.customElements.define("media-chrome-button", MediaChromeButton); let ek = `<svg aria-hidden="true" viewBox="0 0 26 24">
    <path d="M22.13 3H3.87a.87.87 0 0 0-.87.87v13.26a.87.87 0 0 0 .87.87h3.4L9 16H5V5h16v11h-4l1.72 2h3.4a.87.87 0 0 0 .87-.87V3.87a.87.87 0 0 0-.86-.87Zm-8.75 11.44a.5.5 0 0 0-.76 0l-4.91 5.73a.5.5 0 0 0 .38.83h9.82a.501.501 0 0 0 .38-.83l-4.91-5.73Z"/>
  </svg>
  `, eT = eE.createElement("template"); eT.innerHTML = `
    <slot name="icon">${ek}</slot>
  `, eg.customElements.get("media-airplay-button") || eg.customElements.define("media-airplay-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_AIRPLAY_UNAVAILABLE] } constructor(b = {}) { super({ slotTemplate: eT, ...b }) } connectedCallback() { this.setAttribute("aria-label", eh.AIRPLAY()), super.connectedCallback() } get mediaAirplayUnavailable() { return getStringAttr(this, er.MEDIA_AIRPLAY_UNAVAILABLE) } set mediaAirplayUnavailable(b) { setStringAttr(this, er.MEDIA_AIRPLAY_UNAVAILABLE, b) } handleClick() { let b = new eg.CustomEvent(Z.MEDIA_AIRPLAY_REQUEST, { composed: !0, bubbles: !0 }); this.dispatchEvent(b) } }); let ew = eE.createElement("template"); ew.innerHTML = `
    <style>
    :host([${er.MEDIA_IS_CASTING}]) slot:not([name=exit]):not([name=icon]) {
      display: none !important;
    }
  
    
    :host(:not([${er.MEDIA_IS_CASTING}])) slot:not([name=enter]):not([name=icon]) {
      display: none !important;
    }
    </style>
  
    <slot name="icon">
      <slot name="enter"><svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/></g></svg></slot>
      <slot name="exit"><svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/><path class="cast_caf_icon_boxfill" d="M5,7 L5,8.63 C8,8.6 13.37,14 13.37,17 L19,17 L19,7 Z"/></g></svg></slot>
    </slot>
  `; let updateAriaLabel = b => { let A = null != b.getAttribute(er.MEDIA_IS_CASTING), D = A ? eh.EXIT_CAST() : eh.ENTER_CAST(); b.setAttribute("aria-label", D) }; eg.customElements.get("media-cast-button") || eg.customElements.define("media-cast-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_IS_CASTING, er.MEDIA_CAST_UNAVAILABLE] } constructor(b = {}) { super({ slotTemplate: ew, ...b }) } connectedCallback() { updateAriaLabel(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === er.MEDIA_IS_CASTING && updateAriaLabel(this), super.attributeChangedCallback(b, A, D) } get mediaIsCasting() { return getBooleanAttr(this, er.MEDIA_IS_CASTING) } set mediaIsCasting(b) { setBooleanAttr(this, er.MEDIA_IS_CASTING, b) } get mediaCastUnavailable() { return getStringAttr(this, er.MEDIA_CAST_UNAVAILABLE) } set mediaCastUnavailable(b) { setStringAttr(this, er.MEDIA_CAST_UNAVAILABLE, b) } handleClick() { let b = this.mediaIsCasting ? Z.MEDIA_EXIT_CAST_REQUEST : Z.MEDIA_ENTER_CAST_REQUEST; this.dispatchEvent(new eg.CustomEvent(b, { composed: !0, bubbles: !0 })) } }); var media_gesture_receiver_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_gesture_receiver_privateGet = (b, A, D) => (media_gesture_receiver_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_gesture_receiver_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_gesture_receiver_privateSet = (b, A, D, N) => (media_gesture_receiver_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let eS = eE.createElement("template"); eS.innerHTML = `
  <style>
    :host {
      display: var(--media-control-display, var(--media-gesture-receiver-display, inline-block));
      box-sizing: border-box;
    }
  </style>
  `; let MediaGestureReceiver = class MediaGestureReceiver extends eg.HTMLElement { constructor(b = {}) { if (super(), media_gesture_receiver_privateAdd(this, t1, void 0), !this.shadowRoot) { let A = this.attachShadow({ mode: "open" }), D = eS.content.cloneNode(!0); this.nativeEl = D; let N = b.slotTemplate; N || ((N = eE.createElement("template")).innerHTML = `<slot>${b.defaultContent || ""}</slot>`), this.nativeEl.appendChild(N.content.cloneNode(!0)), A.appendChild(D) } } static get observedAttributes() { return [ee.MEDIA_CONTROLLER, er.MEDIA_PAUSED] } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER && (A && (null == (V = null == (N = media_gesture_receiver_privateGet(this, t1)) ? void 0 : N.unassociateElement) || V.call(N, this), media_gesture_receiver_privateSet(this, t1, null)), D && this.isConnected && (media_gesture_receiver_privateSet(this, t1, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_gesture_receiver_privateGet(this, t1)) ? void 0 : Z.associateElement) || et.call(Z, this))) } connectedCallback() { var b, A, D, N; this.tabIndex = -1, this.setAttribute("aria-hidden", "true"), media_gesture_receiver_privateSet(this, t1, function (b) { var A; let D = b.getAttribute(ee.MEDIA_CONTROLLER); return D ? null == (A = b.getRootNode()) ? void 0 : A.getElementById(D) : closestComposedNode(b, "media-controller") }(this)), this.getAttribute(ee.MEDIA_CONTROLLER) && (null == (A = null == (b = media_gesture_receiver_privateGet(this, t1)) ? void 0 : b.associateElement) || A.call(b, this)), null == (D = media_gesture_receiver_privateGet(this, t1)) || D.addEventListener("pointerdown", this), null == (N = media_gesture_receiver_privateGet(this, t1)) || N.addEventListener("click", this) } disconnectedCallback() { var b, A, D, N; this.getAttribute(ee.MEDIA_CONTROLLER) && (null == (A = null == (b = media_gesture_receiver_privateGet(this, t1)) ? void 0 : b.unassociateElement) || A.call(b, this)), null == (D = media_gesture_receiver_privateGet(this, t1)) || D.removeEventListener("pointerdown", this), null == (N = media_gesture_receiver_privateGet(this, t1)) || N.removeEventListener("click", this), media_gesture_receiver_privateSet(this, t1, null) } handleEvent(b) { var A; let D = null == (A = b.composedPath()) ? void 0 : A[0]; if (["video", "media-controller"].includes(null == D ? void 0 : D.localName)) { if ("pointerdown" === b.type) this._pointerType = b.pointerType; else if ("click" === b.type) { let { clientX: A, clientY: D } = b, { left: N, top: V, width: Y, height: Z } = this.getBoundingClientRect(), ee = A - N, et = D - V; if (ee < 0 || et < 0 || ee > Y || et > Z || 0 === Y && 0 === Z) return; let { pointerType: ea = this._pointerType } = b; if (this._pointerType = void 0, ea === ed.TOUCH) { this.handleTap(b); return } if (ea === ed.MOUSE) { this.handleMouseClick(b); return } } } } get mediaPaused() { return getBooleanAttr(this, er.MEDIA_PAUSED) } set mediaPaused(b) { setBooleanAttr(this, er.MEDIA_PAUSED, b) } handleTap(b) { } handleMouseClick(b) { let A = this.mediaPaused ? Z.MEDIA_PLAY_REQUEST : Z.MEDIA_PAUSE_REQUEST; this.dispatchEvent(new eg.CustomEvent(A, { composed: !0, bubbles: !0 })) } }; t1 = new WeakMap, eg.customElements.get("media-gesture-receiver") || eg.customElements.define("media-gesture-receiver", MediaGestureReceiver); let eD = new WeakMap, getCallbacks = b => { let A = eD.get(b); return A || eD.set(b, A = new Set), A }, eI = new eg.ResizeObserver(b => { for (let A of b) for (let b of getCallbacks(A.target)) b(A) }); function observeResize(b, A) { getCallbacks(b).add(A), eI.observe(b) } function unobserveResize(b, A) { let D = getCallbacks(b); D.delete(A), D.size || eI.unobserve(b) } var eM = Object.defineProperty, media_container_defNormalProp = (b, A, D) => A in b ? eM(b, A, { enumerable: !0, configurable: !0, writable: !0, value: D }) : b[A] = D, media_container_publicField = (b, A, D) => (media_container_defNormalProp(b, "symbol" != typeof A ? A + "" : A, D), D), media_container_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_container_privateGet = (b, A, D) => (media_container_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_container_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_container_privateSet = (b, A, D, N) => (media_container_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), __privateMethod = (b, A, D) => (media_container_accessCheck(b, A, "access private method"), D); let eC = { AUDIO: "audio", AUTOHIDE: "autohide", BREAKPOINTS: "breakpoints", GESTURES_DISABLED: "gesturesdisabled", KEYBOARD_CONTROL: "keyboardcontrol", NO_AUTOHIDE: "noautohide", USER_INACTIVE: "userinactive" }, ex = eE.createElement("template"); ex.innerHTML = `
    <style>
      
      :host([${er.MEDIA_IS_FULLSCREEN}]) ::slotted([slot=media]) {
        outline: none;
      }
  
      :host {
        box-sizing: border-box;
        position: relative;
        display: inline-block;
        line-height: 0;
        background-color: var(--media-background-color, #000);
      }
  
      :host(:not([${eC.AUDIO}])) [part~=layer]:not([part~=media-layer]) {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        display: flex;
        flex-flow: column nowrap;
        align-items: start;
        pointer-events: none;
        background: none;
      }
  
      slot[name=media] {
        display: var(--media-slot-display, contents);
      }
  
      
      :host([${eC.AUDIO}]) slot[name=media] {
        display: var(--media-slot-display, none);
      }
  
      
      :host([${eC.AUDIO}]) [part~=layer][part~=gesture-layer] {
        height: 0;
        display: block;
      }
  
      
      :host(:not([${eC.AUDIO}])[${eC.GESTURES_DISABLED}]) ::slotted([slot=gestures-chrome]),
      :host(:not([${eC.AUDIO}])[${eC.GESTURES_DISABLED}]) media-gesture-receiver[slot=gestures-chrome] {
        display: none;
      }
  
      
      ::slotted(:not([slot=media]):not([slot=poster]):not(media-loading-indicator)) {
        pointer-events: auto;
      }
  
      :host(:not([${eC.AUDIO}])) *[part~=layer][part~=centered-layer] {
        align-items: center;
        justify-content: center;
      }
  
      :host(:not([${eC.AUDIO}])) ::slotted(media-gesture-receiver[slot=gestures-chrome]),
      :host(:not([${eC.AUDIO}])) media-gesture-receiver[slot=gestures-chrome] {
        align-self: stretch;
        flex-grow: 1;
      }
  
      slot[name=middle-chrome] {
        display: inline;
        flex-grow: 1;
        pointer-events: none;
        background: none;
      }
  
      
      ::slotted([slot=media]),
      ::slotted([slot=poster]) {
        width: 100%;
        height: 100%;
      }
  
      
      :host(:not([${eC.AUDIO}])) .spacer {
        flex-grow: 1;
      }
  
      
      :host(:-webkit-full-screen) {
        
        width: 100% !important;
        height: 100% !important;
      }
  
      
      ::slotted(:not([slot=media]):not([${eC.NO_AUTOHIDE}])) {
        opacity: 1;
        transition: opacity 0.25s;
      }
  
      
      :host([${eC.USER_INACTIVE}]:not([${er.MEDIA_PAUSED}]):not([${er.MEDIA_IS_CASTING}]):not([${eC.AUDIO}])) ::slotted(:not([slot=media]):not([${eC.NO_AUTOHIDE}])) {
        opacity: 0;
        transition: opacity 1s;
      }
  
      :host([${eC.USER_INACTIVE}]:not([${er.MEDIA_PAUSED}]):not([${er.MEDIA_IS_CASTING}]):not([${eC.AUDIO}])) ::slotted([slot=media]) {
        cursor: none;
      }
  
      ::slotted(media-control-bar)  {
        align-self: stretch;
      }
  
      
      :host(:not([${eC.AUDIO}])[${er.MEDIA_HAS_PLAYED}]) slot[name=poster] {
        display: none;
      }
    </style>
  
    <slot name="media" part="layer media-layer"></slot>
    <slot name="poster" part="layer poster-layer"></slot>
    <slot name="gestures-chrome" part="layer gesture-layer">
      <media-gesture-receiver slot="gestures-chrome"></media-gesture-receiver>
    </slot>
    <span part="layer vertical-layer">
      <slot name="top-chrome" part="top chrome"></slot>
      <slot name="middle-chrome" part="middle chrome"></slot>
      <slot name="centered-chrome" part="layer centered-layer center centered chrome"></slot>
      
      <slot part="bottom chrome"></slot>
    </span>
  `; let eL = Object.values(er); let MediaContainer = class MediaContainer extends eg.HTMLElement { constructor() { super(), media_container_privateAdd(this, t3), media_container_privateAdd(this, t7), media_container_privateAdd(this, t6), media_container_privateAdd(this, at), media_container_privateAdd(this, ai), media_container_privateAdd(this, t2, 0), media_container_privateAdd(this, t5, void 0), media_container_publicField(this, "breakpointsComputed", !1), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(ex.content.cloneNode(!0))); let b = new MutationObserver(b => { let A = this.media; for (let D of b) "childList" === D.type && (D.removedNodes.forEach(b => { if ("media" == b.slot && D.target == this) { let N = D.previousSibling && D.previousSibling.previousElementSibling; if (N && A) { let A = "media" !== N.slot; for (; null !== (N = N.previousSibling);)"media" == N.slot && (A = !1); A && this.mediaUnsetCallback(b) } else this.mediaUnsetCallback(b) } }), A && D.addedNodes.forEach(b => { b === A && A !== media_container_privateGet(this, t5) && this.handleMediaUpdated(A).then(b => this.mediaSetCallback(b)) })) }); b.observe(this, { childList: !0, subtree: !0 }); let A = !1; observeResize(this, b => { A || (setTimeout(() => { (function (b, A) { var D; if (!b.isConnected) return; let N = null != (D = b.getAttribute(eC.BREAKPOINTS)) ? D : "sm:384 md:576 lg:768 xl:960", V = function (b) { let A = b.split(/\s+/); return Object.fromEntries(A.map(b => b.split(":"))) }(N), Y = Object.keys(V).filter(b => A >= V[b]), Z = !1; if (Object.keys(V).forEach(A => { if (Y.includes(A)) { b.hasAttribute(`breakpoint${A}`) || (b.setAttribute(`breakpoint${A}`, ""), Z = !0); return } b.hasAttribute(`breakpoint${A}`) && (b.removeAttribute(`breakpoint${A}`), Z = !0) }), Z) { let A = new CustomEvent(en.BREAKPOINTS_CHANGE, { detail: Y }); b.dispatchEvent(A) } })(b.target, b.contentRect.width), A = !1, this.breakpointsComputed || (this.breakpointsComputed = !0, this.dispatchEvent(new CustomEvent(en.BREAKPOINTS_COMPUTED, { bubbles: !0, composed: !0 }))) }, 0), A = !0) }); let D = this.querySelector(":scope > slot[slot=media]"); D && D.addEventListener("slotchange", () => { let b = D.assignedElements({ flatten: !0 }); if (!b.length) { this.mediaUnsetCallback(media_container_privateGet(this, t5)); return } this.media && this.media !== media_container_privateGet(this, t5) && this.handleMediaUpdated(this.media).then(b => this.mediaSetCallback(b)) }) } static get observedAttributes() { return [eC.AUTOHIDE, eC.GESTURES_DISABLED].concat(eL).filter(b => ![er.MEDIA_RENDITION_LIST, er.MEDIA_AUDIO_TRACK_LIST].includes(b)) } attributeChangedCallback(b, A, D) { b.toLowerCase() == eC.AUTOHIDE && (this.autohide = D) } get media() { let b = this.querySelector(":scope > [slot=media]"); return (null == b ? void 0 : b.nodeName) == "SLOT" && (b = b.assignedElements({ flatten: !0 })[0]), b } async handleMediaUpdated(b) { return (media_container_privateSet(this, t5, b), b) ? (b.localName.includes("-") && await eg.customElements.whenDefined(b.localName), b) : (media_container_privateSet(this, t5, null), console.error('Media Chrome: Media element set with slot="media" does not appear to be compatible.', b), Promise.reject(b)) } connectedCallback() { var b; let A = null != this.getAttribute(eC.AUDIO), D = A ? em.AUDIO_PLAYER() : em.VIDEO_PLAYER(); this.setAttribute("role", "region"), this.setAttribute("aria-label", D), this.media && this.media !== media_container_privateGet(this, t5) && this.handleMediaUpdated(this.media).then(b => this.mediaSetCallback(b)), this.setAttribute(eC.USER_INACTIVE, ""), this.addEventListener("pointerdown", this), this.addEventListener("pointermove", this), this.addEventListener("pointerup", this), this.addEventListener("mouseleave", this), this.addEventListener("keyup", this), null == (b = eg.window) || b.addEventListener("mouseup", this) } disconnectedCallback() { var b; this.media && this.mediaUnsetCallback(this.media), null == (b = eg.window) || b.removeEventListener("mouseup", this) } mediaSetCallback(b) { } mediaUnsetCallback(b) { } handleEvent(b) { switch (b.type) { case "pointerdown": media_container_privateSet(this, t2, b.timeStamp); break; case "pointermove": __privateMethod(this, t3, t4).call(this, b); break; case "pointerup": __privateMethod(this, t7, t8).call(this, b); break; case "mouseleave": __privateMethod(this, t6, t9).call(this); break; case "mouseup": this.removeAttribute(eC.KEYBOARD_CONTROL); break; case "keyup": __privateMethod(this, ai, ar).call(this), this.setAttribute(eC.KEYBOARD_CONTROL, "") } } set autohide(b) { b = Number(b), this._autohide = isNaN(b) ? 0 : b } get autohide() { return void 0 === this._autohide ? 2 : this._autohide } }; t2 = new WeakMap, t5 = new WeakMap, t3 = new WeakSet, t4 = function (b) { !("mouse" !== b.pointerType && b.timeStamp - media_container_privateGet(this, t2) < 250) && (__privateMethod(this, at, aa).call(this), clearTimeout(this._inactiveTimeout), [this, this.media].includes(b.target) && __privateMethod(this, ai, ar).call(this)) }, t7 = new WeakSet, t8 = function (b) { if ("touch" === b.pointerType) { let A = !this.hasAttribute(eC.USER_INACTIVE);[this, this.media].includes(b.target) && A ? __privateMethod(this, t6, t9).call(this) : __privateMethod(this, ai, ar).call(this) } else b.composedPath().some(b => ["media-play-button", "media-fullscreen-button"].includes(null == b ? void 0 : b.localName)) && __privateMethod(this, ai, ar).call(this) }, t6 = new WeakSet, t9 = function () { if (this.autohide < 0 || this.hasAttribute(eC.USER_INACTIVE)) return; this.setAttribute(eC.USER_INACTIVE, ""); let b = new eg.CustomEvent(en.USER_INACTIVE, { composed: !0, bubbles: !0, detail: !0 }); this.dispatchEvent(b) }, at = new WeakSet, aa = function () { if (!this.hasAttribute(eC.USER_INACTIVE)) return; this.removeAttribute(eC.USER_INACTIVE); let b = new eg.CustomEvent(en.USER_INACTIVE, { composed: !0, bubbles: !0, detail: !1 }); this.dispatchEvent(b) }, ai = new WeakSet, ar = function () { __privateMethod(this, at, aa).call(this), clearTimeout(this._inactiveTimeout), this.autohide < 0 || (this._inactiveTimeout = setTimeout(() => { __privateMethod(this, t6, t9).call(this) }, 1e3 * this.autohide)) }; var attribute_token_list_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, attribute_token_list_privateGet = (b, A, D) => (attribute_token_list_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), attribute_token_list_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, attribute_token_list_privateSet = (b, A, D, N) => (attribute_token_list_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let AttributeTokenList = class AttributeTokenList { constructor(b, A, { defaultValue: D } = { defaultValue: void 0 }) { attribute_token_list_privateAdd(this, ad), attribute_token_list_privateAdd(this, an, void 0), attribute_token_list_privateAdd(this, ao, void 0), attribute_token_list_privateAdd(this, as, void 0), attribute_token_list_privateAdd(this, al, new Set), attribute_token_list_privateSet(this, an, b), attribute_token_list_privateSet(this, ao, A), attribute_token_list_privateSet(this, as, new Set(D)) } [Symbol.iterator]() { return attribute_token_list_privateGet(this, ad, au).values() } get length() { return attribute_token_list_privateGet(this, ad, au).size } get value() { var b; return null != (b = [...attribute_token_list_privateGet(this, ad, au)].join(" ")) ? b : "" } set value(b) { var A; b !== this.value && (attribute_token_list_privateSet(this, al, new Set), this.add(...null != (A = null == b ? void 0 : b.split(" ")) ? A : [])) } toString() { return this.value } item(b) { return [...attribute_token_list_privateGet(this, ad, au)][b] } values() { return attribute_token_list_privateGet(this, ad, au).values() } forEach(b) { attribute_token_list_privateGet(this, ad, au).forEach(b) } add(...b) { var A, D; b.forEach(b => attribute_token_list_privateGet(this, al).add(b)), ("" !== this.value || (null == (A = attribute_token_list_privateGet(this, an)) ? void 0 : A.hasAttribute(`${attribute_token_list_privateGet(this, ao)}`))) && (null == (D = attribute_token_list_privateGet(this, an)) || D.setAttribute(`${attribute_token_list_privateGet(this, ao)}`, `${this.value}`)) } remove(...b) { var A; b.forEach(b => attribute_token_list_privateGet(this, al).delete(b)), null == (A = attribute_token_list_privateGet(this, an)) || A.setAttribute(`${attribute_token_list_privateGet(this, ao)}`, `${this.value}`) } contains(b) { return attribute_token_list_privateGet(this, ad, au).has(b) } toggle(b, A) { return void 0 !== A ? A ? (this.add(b), !0) : (this.remove(b), !1) : this.contains(b) ? (this.remove(b), !1) : (this.add(b), !0) } replace(b, A) { return this.remove(b), this.add(A), b === A } }; an = new WeakMap, ao = new WeakMap, as = new WeakMap, al = new WeakMap, ad = new WeakSet, au = function () { return attribute_token_list_privateGet(this, al).size ? attribute_token_list_privateGet(this, al) : attribute_token_list_privateGet(this, as) }; let splitTextTracksStr = (b = "") => b.split(/\s+/), parseTextTrackStr = (b = "") => { let [A, D, N] = b.split(":"), V = N ? decodeURIComponent(N) : void 0; return { kind: A = "cc" === A ? "captions" : "subtitles", language: D, label: V } }, parseTextTracksStr = (b = "", A = {}) => splitTextTracksStr(b).map(b => { let D = parseTextTrackStr(b); return { ...A, ...D } }), parseTracks = b => Array.isArray(b) ? b.map(b => "string" == typeof b ? parseTextTrackStr(b) : b) : "string" == typeof b ? parseTextTracksStr(b) : [b], formatTextTrackObj = ({ kind: b, label: A, language: D } = { kind: "subtitles" }) => A ? `${"captions" === b ? "cc" : "sb"}:${D}:${encodeURIComponent(A)}` : D, stringifyTextTrackList = (b = []) => Array.prototype.map.call(b, formatTextTrackObj).join(" "), isMatchingPropOf = (b, A) => D => D[b] === A, textTrackObjAsPred = b => { let A = Object.entries(b).map(([b, A]) => isMatchingPropOf(b, A)); return b => A.every(A => A(b)) }, updateTracksModeTo = (b, A = [], D = []) => { let N = parseTracks(D).map(textTrackObjAsPred); Array.from(A).filter(b => N.some(A => A(b))).forEach(A => { A.mode = b }) }, getTextTracksList = (b, A = () => !0) => { if (!(null == b ? void 0 : b.textTracks)) return []; let D = "function" == typeof A ? A : textTrackObjAsPred(A); return Array.from(b.textTracks).filter(D) }, areSubsOn = b => { let A = !!b.getAttribute(er.MEDIA_SUBTITLES_SHOWING); return A }, eR = { enter: "requestFullscreen", exit: "exitFullscreen", rootEvents: ["fullscreenchange"], mediaEvents: [], element: "fullscreenElement", error: "fullscreenerror", enabled: "fullscreenEnabled" }; void 0 === eE.fullscreenElement && (eR.enter = "webkitRequestFullScreen", eR.exit = null != eE.webkitExitFullscreen ? "webkitExitFullscreen" : "webkitCancelFullScreen", eR.rootEvents = ["webkitfullscreenchange"], eR.mediaEvents = ["webkitbeginfullscreen", "webkitendfullscreen"], eR.element = "webkitFullscreenElement", eR.error = "webkitfullscreenerror", eR.enabled = "webkitFullscreenEnabled"); let getTestMediaEl = () => { var b; return N || (N = null == (b = null == eE ? void 0 : eE.createElement) ? void 0 : b.call(eE, "video")) }, hasVolumeSupportAsync = async (b = getTestMediaEl()) => { if (!b) return !1; let A = b.volume; return b.volume = A / 2 + .1, await delay(0), b.volume !== A }, eO = ((b = getTestMediaEl()) => { let A = eE[eR.enabled]; return !A && b && (A = "webkitSupportsFullscreen" in b), A })(), eN = ((b = getTestMediaEl()) => "function" == typeof (null == b ? void 0 : b.requestPictureInPicture))(), eP = !!eg.WebKitPlaybackTargetAvailabilityEvent, eU = !!eg.chrome, eB = hasVolumeSupportAsync().then(b => V = b), eW = Object.values(ec), getSubtitleTracks = b => getTextTracksList(b.media, b => [es.SUBTITLES, es.CAPTIONS].includes(b.kind)).sort((b, A) => b.kind >= A.kind ? 1 : -1), getShowingSubtitleTracks = b => getTextTracksList(b.media, b => b.mode === el.SHOWING && [es.SUBTITLES, es.CAPTIONS].includes(b.kind)), eF = { MEDIA_PAUSED: { get: function (b) { let { media: A } = b; return !A || A.paused }, mediaEvents: ["play", "playing", "pause", "emptied"] }, MEDIA_HAS_PLAYED: { get: function (b) { let { media: A } = b; return !!A && !A.paused }, mediaEvents: ["playing", "emptied"] }, MEDIA_ENDED: { get: function (b) { let { media: A } = b; return !!A && A.ended }, mediaEvents: ["seeked", "ended", "emptied"] }, MEDIA_PLAYBACK_RATE: { get: function (b) { let { media: A } = b; return A && void 0 !== A.playbackRate ? A.playbackRate : 1 }, mediaEvents: ["ratechange", "loadstart"] }, MEDIA_MUTED: { get: function (b) { let { media: A } = b; return !!A && void 0 !== A.muted && A.muted }, mediaEvents: ["volumechange"] }, MEDIA_VOLUME: { get: function (b) { let { media: A } = b; return A && void 0 !== A.volume ? Number(A.volume) : 1 }, mediaEvents: ["volumechange"] }, MEDIA_VOLUME_LEVEL: { get: function (b) { let { media: A } = b, D = "high"; if (!A || void 0 === A.volume) return D; let { muted: N, volume: V } = A; return 0 === V || N ? D = "off" : V < .5 ? D = "low" : V < .75 && (D = "medium"), D }, mediaEvents: ["volumechange"] }, MEDIA_CURRENT_TIME: { get: function (b) { let { media: A } = b; return A && void 0 !== A.currentTime ? A.currentTime : 0 }, mediaEvents: ["playing", "pause", "timeupdate", "loadedmetadata"] }, MEDIA_DURATION: { get: function (b) { let { media: A } = b; return b.hasAttribute("defaultduration") && (!A || !A.duration || Number.isNaN(A.duration) || !Number.isFinite(A.duration)) ? +b.getAttribute("defaultduration") : A && Number.isFinite(A.duration) ? A.duration : Number.NaN }, mediaEvents: ["durationchange", "loadedmetadata", "emptied"] }, MEDIA_SEEKABLE: { get: function (b) { var A; let { media: D } = b; if (!(null == (A = null == D ? void 0 : D.seekable) ? void 0 : A.length)) return; let N = D.seekable.start(0), V = D.seekable.end(D.seekable.length - 1); if (N || V) return [Number(N.toFixed(3)), Number(V.toFixed(3))] }, mediaEvents: ["loadedmetadata", "emptied", "progress"] }, MEDIA_LOADING: { get: function (b) { var A; return (null == (A = b.media) ? void 0 : A.readyState) < 3 }, mediaEvents: ["waiting", "playing", "emptied"] }, MEDIA_BUFFERED: { get: function (b) { var A, D, N; let V = null == (A = b.media) ? void 0 : A.buffered; return Array.from(null != (N = null == (D = b.media) ? void 0 : D.buffered) ? N : []).map((b, A) => [Number(V.start(A)).toFixed(3), Number(V.end(A)).toFixed(3)]) }, mediaEvents: ["progress", "emptied"] }, MEDIA_STREAM_TYPE: { get: function (b) { let { media: A } = b; if (!A) return; let { streamType: D } = A; if (eW.includes(D)) { if (D === ec.UNKNOWN) { let A = b.getAttribute("defaultstreamtype"); return [ec.LIVE, ec.ON_DEMAND].includes(A) ? A : void 0 } return D } let N = A.duration; if (N === 1 / 0) return ec.LIVE; if (Number.isFinite(N)) return ec.ON_DEMAND; { let A = b.getAttribute("defaultstreamtype"); if ([ec.LIVE, ec.ON_DEMAND].includes(A)) return A } }, mediaEvents: ["emptied", "durationchange", "loadedmetadata", "streamtypechange"] }, MEDIA_TARGET_LIVE_WINDOW: { get: function (b) { let { media: A } = b; if (!A) return Number.NaN; let { targetLiveWindow: D } = A, N = eF.MEDIA_STREAM_TYPE.get(b); return (null == D || Number.isNaN(D)) && N === ec.LIVE ? 0 : D }, mediaEvents: ["emptied", "durationchange", "loadedmetadata", "streamtypechange", "targetlivewindowchange"] }, MEDIA_TIME_IS_LIVE: { get: function (b) { let { media: A } = b; if (!A) return !1; if ("number" == typeof A.liveEdgeStart) return !Number.isNaN(A.liveEdgeStart) && A.currentTime >= A.liveEdgeStart; let D = "live" === eF.MEDIA_STREAM_TYPE.get(b); if (!D) return !1; let N = A.seekable; if (!N) return !0; if (!N.length) return !1; let V = b.hasAttribute("liveedgeoffset") ? Number(b.getAttribute("liveedgeoffset")) : 10, Y = N.end(N.length - 1) - V; return A.currentTime >= Y }, mediaEvents: ["playing", "timeupdate", "progress", "waiting", "emptied"] }, MEDIA_IS_FULLSCREEN: { get: function (b, A) { var D, N; let V; let Y = b.media; if (Y && void 0 === eE[eR.element] && "webkitDisplayingFullscreen" in Y) return Y.webkitDisplayingFullscreen && "fullscreen" === Y.webkitPresentationMode; if (A) { let b = eE[eR.element]; V = b ? A.target : null } else V = null != (N = null == (D = function (b) { var A; let D = null == (A = null == b ? void 0 : b.getRootNode) ? void 0 : A.call(b); return D instanceof ShadowRoot || D instanceof Document ? D : null }(b)) ? void 0 : D.fullscreenElement) ? N : eE[eR.element]; return containsComposedNode(b.fullscreenElement, V) }, rootEvents: eR.rootEvents, mediaEvents: eR.mediaEvents }, MEDIA_IS_PIP: { get: function (b, A) { var D; let N = b.media; if (!N) return !1; if (A) return "enterpictureinpicture" == A.type; { let A = null != (D = b.getRootNode().pictureInPictureElement) ? D : eE.pictureInPictureElement; return containsComposedNode(N, A) } }, mediaEvents: ["enterpictureinpicture", "leavepictureinpicture"] }, MEDIA_IS_CASTING: { get: function (b, A) { var D; let { media: N } = b; if (!N) return !1; let V = null == (D = eg.CastableVideoElement) ? void 0 : D.castElement, Y = containsComposedNode(N, V); return (null == A ? void 0 : A.type) === "castchange" && (null == A ? void 0 : A.detail) === "CONNECTING" && (Y = "connecting"), Y }, mediaEvents: ["entercast", "leavecast", "castchange"] }, MEDIA_AIRPLAY_UNAVAILABLE: { get: function (b, A) { if (!eP) return eu.UNSUPPORTED; if (A) { if ("available" === A.availability) return; if ("not-available" === A.availability) return eu.UNAVAILABLE } }, mediaEvents: ["webkitplaybacktargetavailabilitychanged"] }, MEDIA_CAST_UNAVAILABLE: { get: function () { var b; let A = null == (b = eg.CastableVideoElement) ? void 0 : b.castState; return eU && A ? A.includes("CONNECT") ? void 0 : eu.UNAVAILABLE : eu.UNSUPPORTED }, mediaEvents: ["castchange"] }, MEDIA_FULLSCREEN_UNAVAILABLE: { get: function () { return eO ? void 0 : eu.UNAVAILABLE } }, MEDIA_PIP_UNAVAILABLE: { get: function () { return eN ? void 0 : eu.UNSUPPORTED } }, MEDIA_RENDITION_UNAVAILABLE: { get: function (b) { var A; let { media: D } = b; return (null == D ? void 0 : D.videoRenditions) ? (null == (A = D.videoRenditions) ? void 0 : A.length) ? void 0 : eu.UNAVAILABLE : eu.UNSUPPORTED }, mediaEvents: ["emptied", "loadstart"], videoRenditionsEvents: ["addrendition", "removerendition"] }, MEDIA_AUDIO_TRACK_UNAVAILABLE: { get: function (b) { var A, D; let { media: N } = b; return (null == N ? void 0 : N.audioTracks) ? (null != (D = null == (A = N.audioTracks) ? void 0 : A.length) ? D : 0) <= 1 ? eu.UNAVAILABLE : void 0 : eu.UNSUPPORTED }, mediaEvents: ["emptied", "loadstart"], audioTracksEvents: ["addtrack", "removetrack"] }, MEDIA_VOLUME_UNAVAILABLE: { get: function (b) { if (void 0 !== V && !V) return eu.UNSUPPORTED; let { media: A } = b; if (A && void 0 === A.volume) return eu.UNAVAILABLE }, mediaEvents: ["loadstart"] }, MEDIA_SUBTITLES_LIST: { get: function (b) { return getSubtitleTracks(b).map(({ kind: b, label: A, language: D }) => ({ kind: b, label: A, language: D })) }, mediaEvents: ["loadstart"], textTracksEvents: ["addtrack", "removetrack"] }, MEDIA_SUBTITLES_SHOWING: { get: function (b) { return !b.hasAttribute("defaultsubtitles") || b.hasAttribute(er.MEDIA_HAS_PLAYED) || b.hasAttribute(er.MEDIA_SUBTITLES_SHOWING) || eH.MEDIA_TOGGLE_SUBTITLES_REQUEST(void 0, void 0, b), getShowingSubtitleTracks(b).map(({ kind: b, label: A, language: D }) => ({ kind: b, label: A, language: D })) }, mediaEvents: ["loadstart"], textTracksEvents: ["addtrack", "removetrack", "change"] }, MEDIA_RENDITION_LIST: { get: function (b) { var A; let { media: D } = b; return [...null != (A = null == D ? void 0 : D.videoRenditions) ? A : []] }, mediaEvents: ["emptied", "loadstart"], videoRenditionsEvents: ["addrendition", "removerendition"] }, MEDIA_RENDITION_SELECTED: { get: function (b) { var A, D, N; let { media: V } = b; return null == (N = null == (D = null == V ? void 0 : V.videoRenditions) ? void 0 : D[null == (A = V.videoRenditions) ? void 0 : A.selectedIndex]) ? void 0 : N.id }, mediaEvents: ["emptied"], videoRenditionsEvents: ["addrendition", "removerendition", "change"] }, MEDIA_AUDIO_TRACK_LIST: { get: function (b) { var A; let { media: D } = b; return [...null != (A = null == D ? void 0 : D.audioTracks) ? A : []] }, mediaEvents: ["emptied", "loadstart"], audioTracksEvents: ["addtrack", "removetrack"] }, MEDIA_AUDIO_TRACK_ENABLED: { get: function (b) { var A, D; let { media: N } = b; return null == (D = [...null != (A = null == N ? void 0 : N.audioTracks) ? A : []].find(b => b.enabled)) ? void 0 : D.id }, mediaEvents: ["emptied"], audioTracksEvents: ["addtrack", "removetrack", "change"] } }, eH = { MEDIA_PLAY_REQUEST: (b, A, D) => { var N; let V = eF.MEDIA_STREAM_TYPE.get(D), Y = null === D.getAttribute("noautoseektolive"); V == ec.LIVE && Y && eH.MEDIA_SEEK_TO_LIVE_REQUEST(b), null == (N = b.play()) || N.catch(() => { }) }, MEDIA_PAUSE_REQUEST: b => b.pause(), MEDIA_MUTE_REQUEST: b => b.muted = !0, MEDIA_UNMUTE_REQUEST: b => { b.muted = !1, 0 === b.volume && (b.volume = .25) }, MEDIA_VOLUME_REQUEST: (b, A, D) => { let N = A.detail; if (b.volume = N, N > 0 && b.muted && (b.muted = !1), !D.hasAttribute("novolumepref")) try { eg.localStorage.setItem("media-chrome-pref-volume", N.toString()) } catch (b) { } }, MEDIA_ENTER_FULLSCREEN_REQUEST: (b, A, D) => { if (!eO) { console.warn("Fullscreen support is unavailable; not entering fullscreen"); return } eE.pictureInPictureElement && eE.exitPictureInPicture(), D[eR.enter] ? D.fullscreenElement[eR.enter]() : b.webkitEnterFullscreen ? b.webkitEnterFullscreen() : b.requestFullscreen ? b.requestFullscreen() : console.warn("MediaChrome: Fullscreen not supported") }, MEDIA_EXIT_FULLSCREEN_REQUEST: () => { eE[eR.exit]() }, MEDIA_ENTER_PIP_REQUEST: b => { if (!eE.pictureInPictureEnabled) { console.warn("MediaChrome: Picture-in-picture is not enabled"); return } if (!b.requestPictureInPicture) { console.warn("MediaChrome: The current media does not support picture-in-picture"); return } eE[eR.element] && eE[eR.exit](); let warnNotReady = () => { console.warn("MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.") }; b.requestPictureInPicture().catch(A => { if (11 === A.code) { if (0 === b.readyState && "none" === b.preload) { let cleanup = () => { b.removeEventListener("loadedmetadata", tryPip), b.preload = "none" }, tryPip = () => { b.requestPictureInPicture().catch(warnNotReady), cleanup() }; b.addEventListener("loadedmetadata", tryPip), b.preload = "metadata", setTimeout(() => { 0 === b.readyState && warnNotReady(), cleanup() }, 1e3) } else throw A } else throw A }) }, MEDIA_EXIT_PIP_REQUEST: () => { eE.pictureInPictureElement && eE.exitPictureInPicture() }, MEDIA_ENTER_CAST_REQUEST: b => { var A; (null == (A = eg.CastableVideoElement) ? void 0 : A.castEnabled) && (eE[eR.element] && eE[eR.exit](), b.requestCast()) }, MEDIA_EXIT_CAST_REQUEST: async () => { var b; (null == (b = eg.CastableVideoElement) ? void 0 : b.castElement) && eg.CastableVideoElement.exitCast() }, MEDIA_SEEK_REQUEST: (b, A) => { let D = A.detail; (b.readyState > 0 || void 0 === b.readyState) && (b.currentTime = D) }, MEDIA_PLAYBACK_RATE_REQUEST: (b, A) => { b.playbackRate = A.detail }, MEDIA_PREVIEW_REQUEST: (b, A, D) => { var N; if (!b) return; let V = A.detail; null === V && D.propagateMediaState(er.MEDIA_PREVIEW_TIME, void 0), D.propagateMediaState(er.MEDIA_PREVIEW_TIME, V); let [Y] = getTextTracksList(b, { kind: es.METADATA, label: "thumbnails" }); if (!(Y && Y.cues)) return; if (null === V) { D.propagateMediaState(er.MEDIA_PREVIEW_IMAGE, void 0), D.propagateMediaState(er.MEDIA_PREVIEW_COORDS, void 0); return } let Z = Array.prototype.find.call(Y.cues, b => b.startTime >= V); if (!Z) return; let ee = /'^(?:[a-z]+:)?\/\//i.test(Z.text) ? void 0 : null == (N = b.querySelector('track[label="thumbnails"]')) ? void 0 : N.src, et = new URL(Z.text, ee), ea = new URLSearchParams(et.hash).get("#xywh"); D.propagateMediaState(er.MEDIA_PREVIEW_IMAGE, et.href), D.propagateMediaState(er.MEDIA_PREVIEW_COORDS, ea.split(",")) }, MEDIA_SHOW_SUBTITLES_REQUEST: (b, A, D) => { var N; let V = getSubtitleTracks(D), { detail: Y = [] } = A, Z = parseTracks(Y), ee = null == (N = Z[0]) ? void 0 : N.language; !ee || (null == D ? void 0 : D.hasAttribute("nosubtitleslangpref")) || eg.localStorage.setItem("media-chrome-pref-subtitles-lang", ee), updateTracksModeTo(el.SHOWING, V, Z) }, MEDIA_DISABLE_SUBTITLES_REQUEST: (b, A, D) => { let N = getSubtitleTracks(D), { detail: V = [] } = A; updateTracksModeTo(el.DISABLED, N, V) }, MEDIA_TOGGLE_SUBTITLES_REQUEST: (b, A, D) => { let { detail: N } = null != A ? A : {}, V = getSubtitleTracks(D), Y = getShowingSubtitleTracks(D), Z = !!Y.length; if (V.length && (!Z || !N) && (Z || !1 !== N)) { if (Z) updateTracksModeTo(el.DISABLED, V, Y); else { let b = V[0]; if (!(null == D ? void 0 : D.hasAttribute("nosubtitleslangpref"))) { let A = eg.localStorage.getItem("media-chrome-pref-subtitles-lang"), D = A ? [A, ...eg.navigator.languages] : eg.navigator.languages, N = V.filter(b => D.some(A => b.language.toLowerCase().startsWith(A.split("-")[0]))).sort((b, A) => { let N = D.findIndex(A => b.language.toLowerCase().startsWith(A.split("-")[0])), V = D.findIndex(b => A.language.toLowerCase().startsWith(b.split("-")[0])); return N - V }); N[0] && (b = N[0]) } let { language: A, label: N, kind: Y } = b; updateTracksModeTo(el.SHOWING, V, [{ language: A, label: N, kind: Y }]) } } }, MEDIA_AIRPLAY_REQUEST: b => { if (b) { if (!(b.webkitShowPlaybackTargetPicker && eg.WebKitPlaybackTargetAvailabilityEvent)) { console.warn("received a request to select AirPlay but AirPlay is not supported in this environment"); return } b.webkitShowPlaybackTargetPicker() } }, MEDIA_SEEK_TO_LIVE_REQUEST: b => { let A = b.seekable; if (!A) { console.warn("MediaController: Media element does not support seeking to live."); return } if (!A.length) { console.warn("MediaController: Media is unable to seek to live."); return } b.currentTime = A.end(A.length - 1) }, MEDIA_RENDITION_REQUEST: (b, A) => { if (!(null == b ? void 0 : b.videoRenditions)) { console.warn("MediaController: Rendition selection not supported by this media."); return } let D = A.detail, N = [...b.videoRenditions].findIndex(b => b.id == D); b.videoRenditions.selectedIndex != N && (b.videoRenditions.selectedIndex = N) }, MEDIA_AUDIO_TRACK_REQUEST: (b, A) => { if (!(null == b ? void 0 : b.audioTracks)) { console.warn("MediaController: Audio track selection not supported by this media."); return } let D = A.detail; for (let A of b.audioTracks) A.enabled = D == A.id } }; var media_controller_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_controller_privateGet = (b, A, D) => (media_controller_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_controller_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_controller_privateSet = (b, A, D, N) => (media_controller_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_controller_privateMethod = (b, A, D) => (media_controller_accessCheck(b, A, "access private method"), D); let eG = ["ArrowLeft", "ArrowRight", "Enter", " ", "f", "m", "k", "c"], eV = { DEFAULT_SUBTITLES: "defaultsubtitles", DEFAULT_STREAM_TYPE: "defaultstreamtype", DEFAULT_DURATION: "defaultduration", FULLSCREEN_ELEMENT: "fullscreenelement", HOTKEYS: "hotkeys", KEYS_USED: "keysused", NO_HOTKEYS: "nohotkeys" }; let MediaController = class MediaController extends MediaContainer { constructor() { super(), media_controller_privateAdd(this, ap), media_controller_privateAdd(this, a_), media_controller_privateAdd(this, ac, new AttributeTokenList(this, eV.HOTKEYS)), media_controller_privateAdd(this, am, void 0), media_controller_privateAdd(this, ah, void 0), void 0 === eF.MEDIA_VOLUME_UNAVAILABLE.get(this) && eB.then(() => { this.propagateMediaState(er.MEDIA_VOLUME_UNAVAILABLE, eF.MEDIA_VOLUME_UNAVAILABLE.get(this)) }), this.mediaStateReceivers = [], this.associatedElementSubscriptions = new Map, this.associateElement(this), Object.keys(eH).forEach(b => { let A = `_handle${constToCamel(b, !0)}`; this[A] = A => { if (A.stopPropagation(), !this.media) { console.warn("MediaController: No media available."); return } eH[b](this.media, A, this) }, this.addEventListener(Z[b], this[A]) }), this._mediaStatePropagators = {}, Object.keys(eF).forEach(b => { this._mediaStatePropagators[b] = A => { this.propagateMediaState(et[b], eF[b].get(this, A)) } }) } static get observedAttributes() { return super.observedAttributes.concat(eV.NO_HOTKEYS, eV.HOTKEYS, eV.DEFAULT_STREAM_TYPE, eV.DEFAULT_SUBTITLES, eV.DEFAULT_DURATION) } get fullscreenElement() { var b; return null != (b = media_controller_privateGet(this, am)) ? b : this } set fullscreenElement(b) { this.hasAttribute(eV.FULLSCREEN_ELEMENT) && this.removeAttribute(eV.FULLSCREEN_ELEMENT), media_controller_privateSet(this, am, b) } attributeChangedCallback(b, A, D) { var N; if (super.attributeChangedCallback(b, A, D), b === eV.NO_HOTKEYS) D !== A && "" === D ? (this.hasAttribute(eV.HOTKEYS) && console.warn("Both `hotkeys` and `nohotkeys` have been set. All hotkeys will be disabled."), this.disableHotkeys()) : D !== A && null === D && this.enableHotkeys(); else if (b === eV.HOTKEYS) media_controller_privateGet(this, ac).value = D; else if (b === eV.DEFAULT_SUBTITLES && D !== A && "" === D) this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_TOGGLE_SUBTITLES_REQUEST, { composed: !0, bubbles: !0, detail: !0 })); else if (b === eV.DEFAULT_STREAM_TYPE) this.propagateMediaState(et.MEDIA_STREAM_TYPE); else if (b === eV.FULLSCREEN_ELEMENT) { let b = D ? null == (N = media_controller_privateGet(this, ah)) ? void 0 : N.getElementById(D) : void 0; media_controller_privateSet(this, am, b) } } connectedCallback() { super.connectedCallback(), media_controller_privateSet(this, ah, this.getRootNode()), this.enableHotkeys() } disconnectedCallback() { super.disconnectedCallback(), this.disableHotkeys(), this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_TOGGLE_SUBTITLES_REQUEST, { composed: !0, bubbles: !0, detail: !1 })) } mediaSetCallback(b) { if (super.mediaSetCallback(b), b.hasAttribute("tabindex") || (b.tabIndex = -1), Object.keys(eF).forEach(A => { let { mediaEvents: D, rootEvents: N, textTracksEvents: V, videoRenditionsEvents: Y, audioTracksEvents: Z } = eF[A], ee = this._mediaStatePropagators[A]; null == D || D.forEach(A => { b.addEventListener(A, ee), ee() }), null == N || N.forEach(b => { var A; null == (A = media_controller_privateGet(this, ah)) || A.addEventListener(b, ee), ee() }), null == V || V.forEach(A => { var D; null == (D = b.textTracks) || D.addEventListener(A, ee), ee() }), null == Y || Y.forEach(A => { var D; null == (D = b.videoRenditions) || D.addEventListener(A, ee), ee() }), null == Z || Z.forEach(A => { var D; null == (D = b.audioTracks) || D.addEventListener(A, ee), ee() }) }), !this.hasAttribute("novolumepref")) try { let A = eg.localStorage.getItem("media-chrome-pref-volume"); null !== A && (b.volume = A) } catch (b) { console.debug("Error getting volume pref", b) } } mediaUnsetCallback(b) { super.mediaUnsetCallback(b), Object.keys(eF).forEach(A => { let { mediaEvents: D, rootEvents: N, textTracksEvents: V, videoRenditionsEvents: Y, audioTracksEvents: Z } = eF[A], ee = this._mediaStatePropagators[A]; null == D || D.forEach(A => { b.removeEventListener(A, ee) }), null == N || N.forEach(b => { var A; null == (A = media_controller_privateGet(this, ah)) || A.removeEventListener(b, ee) }), null == V || V.forEach(A => { var D; null == (D = b.textTracks) || D.removeEventListener(A, ee) }), null == Y || Y.forEach(A => { var D; null == (D = b.videoRenditions) || D.removeEventListener(A, ee), ee() }), null == Z || Z.forEach(A => { var D; null == (D = b.audioTracks) || D.removeEventListener(A, ee), ee() }) }), this.propagateMediaState(et.MEDIA_PAUSED, !0) } propagateMediaState(b, A) { let D = getStateValue(this.mediaStateReceivers, b); if (propagateMediaState(this.mediaStateReceivers, b, A), D === getStateValue(this.mediaStateReceivers, b)) return; let N = b.toLowerCase(), V = new eg.CustomEvent(eo[N], { composed: !0, bubbles: !0, detail: A }); this.dispatchEvent(V) } associateElement(b) { if (!b) return; let { associatedElementSubscriptions: A } = this; if (A.has(b)) return; let D = this.registerMediaStateReceiver.bind(this), N = this.unregisterMediaStateReceiver.bind(this), V = monitorForMediaStateReceivers(b, D, N); Object.keys(Z).forEach(A => { b.addEventListener(Z[A], this[`_handle${constToCamel(A, !0)}`]) }), A.set(b, V) } unassociateElement(b) { if (!b) return; let { associatedElementSubscriptions: A } = this; if (!A.has(b)) return; let D = A.get(b); D(), A.delete(b), Object.keys(Z).forEach(A => { b.removeEventListener(Z[A], this[`_handle${constToCamel(A, !0)}`]) }) } registerMediaStateReceiver(b) { if (!b) return; let A = this.mediaStateReceivers, D = A.indexOf(b); D > -1 || (A.push(b), Object.keys(eF).forEach(A => { let D = eF[A]; propagateMediaState([b], et[A], D.get(this)) })) } unregisterMediaStateReceiver(b) { let A = this.mediaStateReceivers, D = A.indexOf(b); D < 0 || A.splice(D, 1) } enableHotkeys() { this.addEventListener("keydown", media_controller_privateMethod(this, a_, af)) } disableHotkeys() { this.removeEventListener("keydown", media_controller_privateMethod(this, a_, af)), this.removeEventListener("keyup", media_controller_privateMethod(this, ap, av)) } get hotkeys() { return media_controller_privateGet(this, ac) } keyboardShortcutHandler(b) { var A, D, N, V; let Y, ee, et, ea; let en = (null != (V = null != (N = null == (A = b.target.getAttribute(eV.KEYS_USED)) ? void 0 : A.split(" ")) ? N : null == (D = b.target) ? void 0 : D.keysUsed) ? V : []).map(b => "Space" === b ? " " : b).filter(Boolean); if (!en.includes(b.key) && !media_controller_privateGet(this, ac).contains(`no${b.key.toLowerCase()}`) && !(" " === b.key && media_controller_privateGet(this, ac).contains("nospace"))) switch (b.key) { case " ": case "k": Y = null != this.getAttribute(er.MEDIA_PAUSED) ? Z.MEDIA_PLAY_REQUEST : Z.MEDIA_PAUSE_REQUEST, this.dispatchEvent(new eg.CustomEvent(Y, { composed: !0, bubbles: !0 })); break; case "m": Y = "off" === this.getAttribute(er.MEDIA_VOLUME_LEVEL) ? Z.MEDIA_UNMUTE_REQUEST : Z.MEDIA_MUTE_REQUEST, this.dispatchEvent(new eg.CustomEvent(Y, { composed: !0, bubbles: !0 })); break; case "f": Y = null != this.getAttribute(er.MEDIA_IS_FULLSCREEN) ? Z.MEDIA_EXIT_FULLSCREEN_REQUEST : Z.MEDIA_ENTER_FULLSCREEN_REQUEST, this.dispatchEvent(new eg.CustomEvent(Y, { composed: !0, bubbles: !0 })); break; case "c": this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_TOGGLE_SUBTITLES_REQUEST, { composed: !0, bubbles: !0 })); break; case "ArrowLeft": et = Math.max(((ee = this.getAttribute(er.MEDIA_CURRENT_TIME)) && !Number.isNaN(+ee) ? +ee : 0) - 10, 0), ea = new eg.CustomEvent(Z.MEDIA_SEEK_REQUEST, { composed: !0, bubbles: !0, detail: et }), this.dispatchEvent(ea); break; case "ArrowRight": et = Math.max(((ee = this.getAttribute(er.MEDIA_CURRENT_TIME)) && !Number.isNaN(+ee) ? +ee : 0) + 10, 0), ea = new eg.CustomEvent(Z.MEDIA_SEEK_REQUEST, { composed: !0, bubbles: !0, detail: et }), this.dispatchEvent(ea) } } }; ac = new WeakMap, am = new WeakMap, ah = new WeakMap, ap = new WeakSet, av = function (b) { let { key: A } = b; if (!eG.includes(A)) { this.removeEventListener("keyup", media_controller_privateMethod(this, ap, av)); return } this.keyboardShortcutHandler(b) }, a_ = new WeakSet, af = function (b) { let { metaKey: A, altKey: D, key: N } = b; if (A || D || !eG.includes(N)) { this.removeEventListener("keyup", media_controller_privateMethod(this, ap, av)); return } [" ", "ArrowLeft", "ArrowRight"].includes(N) && !(media_controller_privateGet(this, ac).contains(`no${N.toLowerCase()}`) || " " === N && media_controller_privateGet(this, ac).contains("nospace")) && b.preventDefault(), this.addEventListener("keyup", media_controller_privateMethod(this, ap, av), { once: !0 }) }; let ej = Object.values(er), eq = Object.values(et), getMediaUIAttributesFrom = b => { var A, D, N, V; let { observedAttributes: Y } = b.constructor; !Y && (null == (A = b.nodeName) ? void 0 : A.includes("-")) && (eg.customElements.upgrade(b), { observedAttributes: Y } = b.constructor); let Z = null == (V = null == (N = null == (D = null == b ? void 0 : b.getAttribute) ? void 0 : D.call(b, ee.MEDIA_CHROME_ATTRIBUTES)) ? void 0 : N.split) ? void 0 : V.call(N, /\s+/); return Array.isArray(Y || Z) ? (Y || Z).filter(b => ej.includes(b)) : [] }, hasMediaUIProps = b => { var A, D; return (null == (A = b.nodeName) ? void 0 : A.includes("-")) && eg.customElements.get(null == (D = b.nodeName) ? void 0 : D.toLowerCase()) && !(b instanceof eg.customElements.get(b.nodeName.toLowerCase())) && eg.customElements.upgrade(b), eq.some(A => A in b) }, isMediaStateReceiver = b => hasMediaUIProps(b) || !!getMediaUIAttributesFrom(b).length, serializeTuple = b => { var A; return null == (A = null == b ? void 0 : b.join) ? void 0 : A.call(b, ":") }, e$ = { [er.MEDIA_SUBTITLES_LIST]: stringifyTextTrackList, [er.MEDIA_SUBTITLES_SHOWING]: stringifyTextTrackList, [er.MEDIA_SEEKABLE]: serializeTuple, [er.MEDIA_BUFFERED]: b => null == b ? void 0 : b.map(serializeTuple).join(" "), [er.MEDIA_PREVIEW_COORDS]: b => null == b ? void 0 : b.join(" "), [er.MEDIA_RENDITION_LIST]: function (b) { return null == b ? void 0 : b.map(stringifyRendition).join(" ") }, [er.MEDIA_AUDIO_TRACK_LIST]: function (b) { return null == b ? void 0 : b.map(stringifyAudioTrack).join(" ") } }, setAttr = async (b, A, D) => { var N, V; if (b.isConnected || await delay(0), "boolean" == typeof D || null == D) return setBooleanAttr(b, A, D); if ("number" == typeof D) return setNumericAttr(b, A, D); if ("string" == typeof D) return setStringAttr(b, A, D); if (Array.isArray(D) && !D.length) return b.removeAttribute(A); let Y = null != (V = null == (N = e$[A]) ? void 0 : N.call(e$, D)) ? V : D; return b.setAttribute(A, Y) }, isMediaSlotElementDescendant = b => { var A; return !!(null == (A = b.closest) ? void 0 : A.call(b, '*[slot="media"]')) }, traverseForMediaStateReceivers = (b, A) => { if (isMediaSlotElementDescendant(b)) return; let traverseForMediaStateReceiversSync = (b, A) => { var D, N; isMediaStateReceiver(b) && A(b); let { children: V = [] } = null != b ? b : {}, Y = null != (N = null == (D = null == b ? void 0 : b.shadowRoot) ? void 0 : D.children) ? N : [], Z = [...V, ...Y]; Z.forEach(b => traverseForMediaStateReceivers(b, A)) }, D = null == b ? void 0 : b.nodeName.toLowerCase(); if (D.includes("-") && !isMediaStateReceiver(b)) { eg.customElements.whenDefined(D).then(() => { traverseForMediaStateReceiversSync(b, A) }); return } traverseForMediaStateReceiversSync(b, A) }, propagateMediaState = (b, A, D) => { b.forEach(b => { if (A in b) { b[A] = D; return } let N = getMediaUIAttributesFrom(b), V = A.toLowerCase(); N.includes(V) && setAttr(b, V, D) }) }, getStateValue = (b, A) => { for (let D of b) { if (A in D) return D[A]; let b = getMediaUIAttributesFrom(D), N = A.toLowerCase(); if (b.includes(N)) return D.getAttribute(N) } }, monitorForMediaStateReceivers = (b, A, D) => { traverseForMediaStateReceivers(b, A); let registerMediaStateReceiverHandler = b => { var D; let N = null != (D = null == b ? void 0 : b.composedPath()[0]) ? D : b.target; A(N) }, unregisterMediaStateReceiverHandler = b => { var A; let N = null != (A = null == b ? void 0 : b.composedPath()[0]) ? A : b.target; D(N) }; b.addEventListener(Z.REGISTER_MEDIA_STATE_RECEIVER, registerMediaStateReceiverHandler), b.addEventListener(Z.UNREGISTER_MEDIA_STATE_RECEIVER, unregisterMediaStateReceiverHandler); let N = [], slotChangeHandler = b => { let V = b.target; "media" !== V.name && (N.forEach(b => traverseForMediaStateReceivers(b, D)), (N = [...V.assignedElements({ flatten: !0 })]).forEach(b => traverseForMediaStateReceivers(b, A))) }; b.addEventListener("slotchange", slotChangeHandler); let V = new MutationObserver(b => { b.forEach(b => { let { addedNodes: N = [], removedNodes: V = [], type: Y, target: Z, attributeName: et } = b; "childList" === Y ? (Array.prototype.forEach.call(N, b => traverseForMediaStateReceivers(b, A)), Array.prototype.forEach.call(V, b => traverseForMediaStateReceivers(b, D))) : "attributes" === Y && et === ee.MEDIA_CHROME_ATTRIBUTES && (isMediaStateReceiver(Z) ? A(Z) : D(Z)) }) }); return V.observe(b, { childList: !0, attributes: !0, subtree: !0 }), () => { traverseForMediaStateReceivers(b, D), b.removeEventListener("slotchange", slotChangeHandler), V.disconnect(), b.removeEventListener(Z.REGISTER_MEDIA_STATE_RECEIVER, registerMediaStateReceiverHandler), b.removeEventListener(Z.UNREGISTER_MEDIA_STATE_RECEIVER, unregisterMediaStateReceiverHandler) } }; eg.customElements.get("media-controller") || eg.customElements.define("media-controller", MediaController); var media_chrome_range_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_chrome_range_privateGet = (b, A, D) => (media_chrome_range_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_chrome_range_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_chrome_range_privateSet = (b, A, D, N) => (media_chrome_range_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_chrome_range_privateMethod = (b, A, D) => (media_chrome_range_accessCheck(b, A, "access private method"), D); let eY = eE.createElement("template"); eY.innerHTML = `
    <style>
      :host {
        --_focus-box-shadow: var(--media-focus-box-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));
        --_media-range-padding: var(--media-range-padding, var(--media-control-padding, 10px));
  
        box-shadow: var(--_focus-visible-box-shadow, none);
        background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));
        height: calc(var(--media-control-height, 24px) + 2 * var(--_media-range-padding));
        display: inline-flex;
        align-items: center;
        
        vertical-align: middle;
        box-sizing: border-box;
        position: relative;
        width: 100px;
        transition: background .15s linear;
        cursor: pointer;
        pointer-events: auto;
        touch-action: none; 
        z-index: 1; 
      }
  
      
      input[type=range]:focus {
        outline: 0;
      }
      input[type=range]:focus::-webkit-slider-runnable-track {
        outline: 0;
      }
  
      :host(:hover) {
        background: var(--media-control-hover-background, rgb(50 50 70 / .7));
      }
  
      #leftgap {
        padding-left: var(--media-range-padding-left, var(--_media-range-padding));
      }
  
      #rightgap {
        padding-right: var(--media-range-padding-right, var(--_media-range-padding));
      }
  
      #startpoint,
      #endpoint {
        position: absolute;
      }
  
      #endpoint {
        right: 0;
      }
  
      #container {
        
        width: var(--media-range-track-width, 100%);
        transform: translate(var(--media-range-track-translate-x, 0px), var(--media-range-track-translate-y, 0px));
        position: relative;
        height: 100%;
        display: flex;
        align-items: center;
        min-width: 40px;
      }
  
      #range {
        
        display: var(--media-time-range-hover-display, block);
        bottom: var(--media-time-range-hover-bottom, -7px);
        height: var(--media-time-range-hover-height, max(100% + 7px, 25px));
        width: 100%;
        position: absolute;
        cursor: pointer;
  
        -webkit-appearance: none; 
        -webkit-tap-highlight-color: transparent;
        background: transparent; 
        margin: 0;
        z-index: 1;
      }
  
      @media (hover: hover) {
        #range {
          bottom: var(--media-time-range-hover-bottom, -5px);
          height: var(--media-time-range-hover-height, max(100% + 5px, 20px));
        }
      }
  
      
      
      #range::-webkit-slider-thumb {
        -webkit-appearance: none;
        background: transparent;
        width: .1px;
        height: .1px;
      }
  
      
      #range::-moz-range-thumb {
        background: transparent;
        border: transparent;
        width: .1px;
        height: .1px;
      }
  
      #appearance {
        height: var(--media-range-track-height, 4px);
        display: flex;
        flex-direction: column;
        justify-content: center;
        width: 100%;
        position: absolute;
      }
  
      #background,
      #track {
        border-radius: var(--media-range-track-border-radius, 1px);
        position: absolute;
        width: 100%;
        height: 100%;
      }
  
      #background {
        background: var(--media-range-track-background, rgb(255 255 255 / .2));
        backdrop-filter: var(--media-range-track-background-backdrop-filter);
        -webkit-backdrop-filter: var(--media-range-track-background-backdrop-filter);
      }
  
      #track {
        border: var(--media-range-track-border, none);
        outline: var(--media-range-track-outline);
        outline-offset: var(--media-range-track-outline-offset);
        backdrop-filter: var(--media-range-track-backdrop-filter);
        -webkit-backdrop-filter: var(--media-range-track-backdrop-filter);
        box-shadow: var(--media-range-track-box-shadow, none);
        overflow: hidden;
      }
  
      #progress {
        background: var(--media-range-bar-color, var(--media-primary-color, rgb(238 238 238)));
        border-radius: var(--media-range-track-border-radius, 1px);
        transition: var(--media-range-track-transition);
        position: absolute;
        height: 100%;
      }
  
      #highlight {
        border-radius: var(--media-range-track-border-radius, 1px);
        position: absolute;
        height: 100%;
      }
  
      #pointer {
        background: var(--media-range-track-pointer-background);
        border-right: var(--media-range-track-pointer-border-right);
        border-radius: var(--media-range-track-border-radius, 1px);
        transition: visibility .25s, opacity .25s;
        visibility: hidden;
        opacity: 0;
        position: absolute;
        height: 100%;
      }
  
      :host(:hover) #pointer {
        transition: visibility .5s, opacity .5s;
        visibility: visible;
        opacity: 1;
      }
  
      #thumb {
        width: var(--media-range-thumb-width, 10px);
        height: var(--media-range-thumb-height, 10px);
        margin-left: calc(var(--media-range-thumb-width, 10px) / -2);
        border: var(--media-range-thumb-border, none);
        border-radius: var(--media-range-thumb-border-radius, 10px);
        background: var(--media-range-thumb-background, var(--media-primary-color, rgb(238 238 238)));
        box-shadow: var(--media-range-thumb-box-shadow, 1px 1px 1px transparent);
        transition: var(--media-range-thumb-transition);
        transform: var(--media-range-thumb-transform, none);
        opacity: var(--media-range-thumb-opacity, 1);
        position: absolute;
        left: 0;
        cursor: pointer;
      }
  
      :host([disabled]) #thumb {
        background-color: #777;
      }
    </style>
    <div id="leftgap"></div>
    <div id="container">
      <div id="startpoint"></div>
      <div id="endpoint"></div>
      <div id="appearance">
        <div id="background"></div>
        <div id="track">
          <div id="highlight"></div>
          <div id="pointer"></div>
          <div id="progress"></div>
        </div>
        <div id="thumb"></div>
      </div>
      <input id="range" type="range" min="0" max="1" step="any" value="0">
    </div>
    <div id="rightgap"></div>
  `; let MediaChromeRange = class MediaChromeRange extends eg.HTMLElement { constructor() { super(), media_chrome_range_privateAdd(this, aT), media_chrome_range_privateAdd(this, aS), media_chrome_range_privateAdd(this, aI), media_chrome_range_privateAdd(this, aC), media_chrome_range_privateAdd(this, aL), media_chrome_range_privateAdd(this, aO), media_chrome_range_privateAdd(this, aP), media_chrome_range_privateAdd(this, ab, void 0), media_chrome_range_privateAdd(this, ag, void 0), media_chrome_range_privateAdd(this, aE, void 0), media_chrome_range_privateAdd(this, ay, void 0), media_chrome_range_privateAdd(this, aA, () => { if (this.range.matches(":focus-visible")) { let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host"); b.setProperty("--_focus-visible-box-shadow", "var(--_focus-box-shadow)") } }), media_chrome_range_privateAdd(this, ak, () => { let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host"); b.removeProperty("--_focus-visible-box-shadow") }), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(eY.content.cloneNode(!0))); let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host"); b.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`), this.container = this.shadowRoot.querySelector("#container"), media_chrome_range_privateSet(this, aE, this.shadowRoot.querySelector("#startpoint")), media_chrome_range_privateSet(this, ay, this.shadowRoot.querySelector("#endpoint")), this.range = this.shadowRoot.querySelector("#range") } static get observedAttributes() { return ["disabled", "aria-disabled", ee.MEDIA_CONTROLLER] } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER ? (A && (null == (V = null == (N = media_chrome_range_privateGet(this, ab)) ? void 0 : N.unassociateElement) || V.call(N, this), media_chrome_range_privateSet(this, ab, null)), D && this.isConnected && (media_chrome_range_privateSet(this, ab, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_chrome_range_privateGet(this, ab)) ? void 0 : Z.associateElement) || et.call(Z, this))) : ("disabled" === b || "aria-disabled" === b && A !== D) && (null == D ? (this.range.removeAttribute(b), media_chrome_range_privateMethod(this, aT, aw).call(this)) : (this.range.setAttribute(b, D), media_chrome_range_privateMethod(this, aS, aD).call(this))) } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_chrome_range_privateSet(this, ab, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_chrome_range_privateGet(this, ab)) ? void 0 : A.associateElement) || D.call(A, this)), this.updateBar(), this.shadowRoot.addEventListener("focusin", media_chrome_range_privateGet(this, aA)), this.shadowRoot.addEventListener("focusout", media_chrome_range_privateGet(this, ak)), media_chrome_range_privateMethod(this, aT, aw).call(this) } disconnectedCallback() { var b, A; media_chrome_range_privateMethod(this, aS, aD).call(this), null == (A = null == (b = media_chrome_range_privateGet(this, ab)) ? void 0 : b.unassociateElement) || A.call(b, this), media_chrome_range_privateSet(this, ab, null), this.shadowRoot.removeEventListener("focusin", media_chrome_range_privateGet(this, aA)), this.shadowRoot.removeEventListener("focusout", media_chrome_range_privateGet(this, ak)) } updatePointerBar(b) { let A = this.range.getBoundingClientRect(), D = (b.clientX - A.left) / A.width; D = 100 * Math.max(0, Math.min(1, D)); let { style: N } = getOrInsertCSSRule(this.shadowRoot, "#pointer"); N.setProperty("width", `${D}%`) } updateBar() { let b = 100 * this.range.valueAsNumber, A = getOrInsertCSSRule(this.shadowRoot, "#progress"), D = getOrInsertCSSRule(this.shadowRoot, "#thumb"); A.style.setProperty("width", `${b}%`), D.style.setProperty("left", `${b}%`) } get dragging() { return this.hasAttribute("dragging") } handleEvent(b) { switch (b.type) { case "input": this.updateBar(); break; case "pointerenter": media_chrome_range_privateMethod(this, aC, ax).call(this, b); break; case "pointerdown": media_chrome_range_privateMethod(this, aI, aM).call(this, b); break; case "pointermove": media_chrome_range_privateMethod(this, aP, aU).call(this, b); break; case "pointerup": media_chrome_range_privateMethod(this, aL, aR).call(this); break; case "pointerleave": media_chrome_range_privateMethod(this, aO, aN).call(this) } } get keysUsed() { return ["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"] } }; ab = new WeakMap, ag = new WeakMap, aE = new WeakMap, ay = new WeakMap, aA = new WeakMap, ak = new WeakMap, aT = new WeakSet, aw = function () { this.hasAttribute("disabled") || (this.addEventListener("input", this), this.addEventListener("pointerdown", this), this.addEventListener("pointerenter", this)) }, aS = new WeakSet, aD = function () { var b, A; this.removeEventListener("input", this), this.removeEventListener("pointerdown", this), this.removeEventListener("pointerenter", this), null == (b = eg.window) || b.removeEventListener("pointerup", this), null == (A = eg.window) || A.removeEventListener("pointermove", this) }, aI = new WeakSet, aM = function (b) { var A; media_chrome_range_privateSet(this, ag, b.composedPath().includes(this.range)), null == (A = eg.window) || A.addEventListener("pointerup", this) }, aC = new WeakSet, ax = function (b) { var A; "mouse" !== b.pointerType && media_chrome_range_privateMethod(this, aI, aM).call(this, b), this.addEventListener("pointerleave", this), null == (A = eg.window) || A.addEventListener("pointermove", this) }, aL = new WeakSet, aR = function () { var b; null == (b = eg.window) || b.removeEventListener("pointerup", this), this.toggleAttribute("dragging", !1), this.range.disabled = this.hasAttribute("disabled") }, aO = new WeakSet, aN = function () { var b; this.removeEventListener("pointerleave", this), null == (b = eg.window) || b.removeEventListener("pointermove", this), this.toggleAttribute("dragging", !1), this.range.disabled = this.hasAttribute("disabled") }, aP = new WeakSet, aU = function (b) { if (this.toggleAttribute("dragging", 1 === b.buttons || "mouse" !== b.pointerType), this.updatePointerBar(b), this.dragging && ("mouse" !== b.pointerType || !media_chrome_range_privateGet(this, ag))) { this.range.disabled = !0; let A = function (b, A, D, N) { let V = distance(D, N), Y = distance(D, { x: b, y: A }), Z = distance(N, { x: b, y: A }); return Y > V || Z > V ? Y > Z ? 1 : 0 : Y / V }(b.clientX, b.clientY, media_chrome_range_privateGet(this, aE).getBoundingClientRect(), media_chrome_range_privateGet(this, ay).getBoundingClientRect()); A = Math.max(0, Math.min(1, A)), this.range.valueAsNumber = A, this.range.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })) } }, eg.customElements.get("media-chrome-range") || eg.customElements.define("media-chrome-range", MediaChromeRange); var media_control_bar_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_control_bar_privateGet = (b, A, D) => (media_control_bar_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_control_bar_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_control_bar_privateSet = (b, A, D, N) => (media_control_bar_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let eK = eE.createElement("template"); eK.innerHTML = `
    <style>
      :host {
        
        box-sizing: border-box;
        display: var(--media-control-display, var(--media-control-bar-display, inline-flex));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        --media-loading-indicator-icon-height: 44px;
      }
  
      ::slotted(media-time-range),
      ::slotted(media-volume-range) {
        min-height: 100%;
      }
  
      ::slotted(media-time-range),
      ::slotted(media-clip-selector) {
        flex-grow: 1;
      }
    </style>
  
    <slot></slot>
  `; let MediaControlBar = class MediaControlBar extends eg.HTMLElement { constructor() { super(), media_control_bar_privateAdd(this, aB, void 0), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(eK.content.cloneNode(!0))) } static get observedAttributes() { return [ee.MEDIA_CONTROLLER] } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER && (A && (null == (V = null == (N = media_control_bar_privateGet(this, aB)) ? void 0 : N.unassociateElement) || V.call(N, this), media_control_bar_privateSet(this, aB, null)), D && this.isConnected && (media_control_bar_privateSet(this, aB, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_control_bar_privateGet(this, aB)) ? void 0 : Z.associateElement) || et.call(Z, this))) } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_control_bar_privateSet(this, aB, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_control_bar_privateGet(this, aB)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; null == (A = null == (b = media_control_bar_privateGet(this, aB)) ? void 0 : b.unassociateElement) || A.call(b, this), media_control_bar_privateSet(this, aB, null) } }; aB = new WeakMap, eg.customElements.get("media-control-bar") || eg.customElements.define("media-control-bar", MediaControlBar); var media_text_display_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_text_display_privateGet = (b, A, D) => (media_text_display_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_text_display_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_text_display_privateSet = (b, A, D, N) => (media_text_display_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let eZ = eE.createElement("template"); eZ.innerHTML = `
    <style>
      :host {
        font: var(--media-font,
          var(--media-font-weight, normal)
          var(--media-font-size, 14px) /
          var(--media-text-content-height, var(--media-control-height, 24px))
          var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        background: var(--media-text-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7))));
        padding: var(--media-control-padding, 10px);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        vertical-align: middle;
        box-sizing: border-box;
        text-align: center;
        pointer-events: auto;
      }
  
      
      :host(:focus-visible) {
        box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);
        outline: 0;
      }
  
      
      :host(:where(:focus)) {
        box-shadow: none;
        outline: 0;
      }
    </style>
    <slot></slot>
  `; let MediaTextDisplay = class MediaTextDisplay extends eg.HTMLElement { constructor() { super(), media_text_display_privateAdd(this, aW, void 0), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(eZ.content.cloneNode(!0))); let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host"); b.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`) } static get observedAttributes() { return [ee.MEDIA_CONTROLLER] } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER && (A && (null == (V = null == (N = media_text_display_privateGet(this, aW)) ? void 0 : N.unassociateElement) || V.call(N, this), media_text_display_privateSet(this, aW, null)), D && this.isConnected && (media_text_display_privateSet(this, aW, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_text_display_privateGet(this, aW)) ? void 0 : Z.associateElement) || et.call(Z, this))) } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_text_display_privateSet(this, aW, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_text_display_privateGet(this, aW)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; null == (A = null == (b = media_text_display_privateGet(this, aW)) ? void 0 : b.unassociateElement) || A.call(b, this), media_text_display_privateSet(this, aW, null) } }; aW = new WeakMap, eg.customElements.get("media-text-display") || eg.customElements.define("media-text-display", MediaTextDisplay); var media_duration_display_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_duration_display_privateGet = (b, A, D) => (media_duration_display_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_duration_display_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_duration_display_privateSet = (b, A, D, N) => (media_duration_display_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); aF = new WeakMap, eg.customElements.get("media-duration-display") || eg.customElements.define("media-duration-display", class extends MediaTextDisplay { constructor() { super(), media_duration_display_privateAdd(this, aF, void 0), media_duration_display_privateSet(this, aF, this.shadowRoot.querySelector("slot")), media_duration_display_privateGet(this, aF).textContent = formatTime(0) } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_DURATION] } attributeChangedCallback(b, A, D) { b === er.MEDIA_DURATION && (media_duration_display_privateGet(this, aF).textContent = formatTime(D)), super.attributeChangedCallback(b, A, D) } get mediaDuration() { return getNumericAttr(this, er.MEDIA_DURATION) } set mediaDuration(b) { setNumericAttr(this, er.MEDIA_DURATION, b) } }); var media_time_display_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_time_display_privateGet = (b, A, D) => (media_time_display_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_time_display_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_time_display_privateSet = (b, A, D, N) => (media_time_display_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let eQ = { REMAINING: "remaining", SHOW_DURATION: "showduration", NO_TOGGLE: "notoggle" }, ez = [...Object.values(eQ), er.MEDIA_CURRENT_TIME, er.MEDIA_DURATION, er.MEDIA_SEEKABLE], eX = ["Enter", " "], eJ = "&nbsp;/&nbsp;", formatTimesLabel = (b, { timesSep: A = eJ } = {}) => { var D, N, V, Y; let Z = b.hasAttribute(eQ.REMAINING), ee = b.hasAttribute(eQ.SHOW_DURATION), et = null != (D = b.mediaCurrentTime) ? D : 0, [, ea] = null != (N = b.mediaSeekable) ? N : [], er = null != (Y = null != (V = b.mediaDuration) ? V : ea) ? Y : 0, en = Z ? formatTime(0 - (er - et)) : formatTime(et); return ee ? `${en}${A}${formatTime(er)}` : en }, updateAriaValueText = b => { var A; let D = b.mediaCurrentTime, [, N] = null != (A = b.mediaSeekable) ? A : [], V = b.mediaDuration || N; if (null == D || null == V) { b.setAttribute("aria-valuetext", "video not loaded, unknown time."); return } let Y = b.hasAttribute(eQ.REMAINING), Z = b.hasAttribute(eQ.SHOW_DURATION), ee = Y ? formatAsTimePhrase(0 - (V - D)) : formatAsTimePhrase(D); if (!Z) { b.setAttribute("aria-valuetext", ee); return } let et = formatAsTimePhrase(V), ea = `${ee} of ${et}`; b.setAttribute("aria-valuetext", ea) }; aH = new WeakMap, eg.customElements.get("media-time-display") || eg.customElements.define("media-time-display", class extends MediaTextDisplay { constructor() { super(), media_time_display_privateAdd(this, aH, void 0), media_time_display_privateSet(this, aH, this.shadowRoot.querySelector("slot")), media_time_display_privateGet(this, aH).innerHTML = `${formatTimesLabel(this)}`; let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host(:hover:not([notoggle]))"); b.setProperty("cursor", "pointer"), b.setProperty("background", "var(--media-control-hover-background, rgba(50 50 70 / .7))") } static get observedAttributes() { return [...super.observedAttributes, ...ez, "disabled"] } connectedCallback() { this.hasAttribute("disabled") || this.enable(), this.setAttribute("role", "progressbar"), this.setAttribute("aria-label", em.PLAYBACK_TIME()); let keyUpHandler = b => { let { key: A } = b; if (!eX.includes(A)) { this.removeEventListener("keyup", keyUpHandler); return } this.toggleTimeDisplay() }; this.addEventListener("keydown", b => { let { metaKey: A, altKey: D, key: N } = b; if (A || D || !eX.includes(N)) { this.removeEventListener("keyup", keyUpHandler); return } this.addEventListener("keyup", keyUpHandler) }), this.addEventListener("click", this.toggleTimeDisplay), super.connectedCallback() } toggleTimeDisplay() { this.noToggle || (this.hasAttribute("remaining") ? this.removeAttribute("remaining") : this.setAttribute("remaining", "")) } disconnectedCallback() { this.disable(), super.disconnectedCallback() } attributeChangedCallback(b, A, D) { ez.includes(b) ? this.update() : "disabled" === b && D !== A && (null == D ? this.enable() : this.disable()), super.attributeChangedCallback(b, A, D) } enable() { this.tabIndex = 0 } disable() { this.tabIndex = -1 } get remaining() { return getBooleanAttr(this, eQ.REMAINING) } set remaining(b) { setBooleanAttr(this, eQ.REMAINING, b) } get showDuration() { return getBooleanAttr(this, eQ.SHOW_DURATION) } set showDuration(b) { setBooleanAttr(this, eQ.SHOW_DURATION, b) } get noToggle() { return getBooleanAttr(this, eQ.NO_TOGGLE) } set noToggle(b) { setBooleanAttr(this, eQ.NO_TOGGLE, b) } get mediaDuration() { return getNumericAttr(this, er.MEDIA_DURATION) } set mediaDuration(b) { setNumericAttr(this, er.MEDIA_DURATION, b) } get mediaCurrentTime() { return getNumericAttr(this, er.MEDIA_CURRENT_TIME) } set mediaCurrentTime(b) { setNumericAttr(this, er.MEDIA_CURRENT_TIME, b) } get mediaSeekable() { let b = this.getAttribute(er.MEDIA_SEEKABLE); if (b) return b.split(":").map(b => +b) } set mediaSeekable(b) { if (null == b) { this.removeAttribute(er.MEDIA_SEEKABLE); return } this.setAttribute(er.MEDIA_SEEKABLE, b.join(":")) } update() { let b = formatTimesLabel(this); updateAriaValueText(this), b !== media_time_display_privateGet(this, aH).innerHTML && (media_time_display_privateGet(this, aH).innerHTML = b) } }); let e0 = `<svg aria-hidden="true" viewBox="0 0 26 24">
    <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>
  </svg>`, e1 = `<svg aria-hidden="true" viewBox="0 0 26 24">
    <path d="M17.73 14.09a1.4 1.4 0 0 1-1 .37 1.579 1.579 0 0 1-1.27-.58A3 3 0 0 1 15 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34A2.89 2.89 0 0 0 19 9.07a3 3 0 0 0-2.14-.78 3.14 3.14 0 0 0-2.42 1 3.91 3.91 0 0 0-.93 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.17 3.17 0 0 0 1.07-1.74l-1.4-.45c-.083.43-.3.822-.62 1.12Zm-7.22 0a1.43 1.43 0 0 1-1 .37 1.58 1.58 0 0 1-1.27-.58A3 3 0 0 1 7.76 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34a2.81 2.81 0 0 0-.74-1.32 2.94 2.94 0 0 0-2.13-.78 3.18 3.18 0 0 0-2.43 1 4 4 0 0 0-.92 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.23 3.23 0 0 0 1.07-1.74l-1.4-.45a2.06 2.06 0 0 1-.6 1.07Zm12.32-8.41a2.59 2.59 0 0 0-2.3-2.51C18.72 3.05 15.86 3 13 3c-2.86 0-5.72.05-7.53.17a2.59 2.59 0 0 0-2.3 2.51c-.23 4.207-.23 8.423 0 12.63a2.57 2.57 0 0 0 2.3 2.5c1.81.13 4.67.19 7.53.19 2.86 0 5.72-.06 7.53-.19a2.57 2.57 0 0 0 2.3-2.5c.23-4.207.23-8.423 0-12.63Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.14-.21-8.29 0-12.43a1.11 1.11 0 0 1 .91-1.11C7.24 4.56 10 4.49 13 4.49s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.14.21 8.29 0 12.43Z"/>
  </svg>`, e2 = eE.createElement("template"); e2.innerHTML = `
    <style>
      :host([aria-checked="true"]) slot[name=off] {
        display: none !important;
      }
  
      
      :host(:not([aria-checked="true"])) slot[name=on] {
        display: none !important;
      }
    </style>
  
    <slot name="icon">
      <slot name="on">${e0}</slot>
      <slot name="off">${e1}</slot>
    </slot>
  `; let updateAriaChecked = b => { b.setAttribute("aria-checked", areSubsOn(b)) }, getSubtitlesListAttr = (b, A) => { let D = b.getAttribute(A); return D ? parseTextTracksStr(D) : [] }, setSubtitlesListAttr = (b, A, D) => { if (!(null == D ? void 0 : D.length)) { b.removeAttribute(A); return } let N = stringifyTextTrackList(D), V = b.getAttribute(A); V !== N && b.setAttribute(A, N) }; eg.customElements.get("media-captions-button") || eg.customElements.define("media-captions-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_SUBTITLES_LIST, er.MEDIA_SUBTITLES_SHOWING] } constructor(b = {}) { super({ slotTemplate: e2, ...b }), this._captionsReady = !1 } connectedCallback() { super.connectedCallback(), this.setAttribute("role", "switch"), this.setAttribute("aria-label", em.CLOSED_CAPTIONS()), updateAriaChecked(this) } attributeChangedCallback(b, A, D) { b === er.MEDIA_SUBTITLES_SHOWING && updateAriaChecked(this), super.attributeChangedCallback(b, A, D) } get mediaSubtitlesList() { return getSubtitlesListAttr(this, er.MEDIA_SUBTITLES_LIST) } set mediaSubtitlesList(b) { setSubtitlesListAttr(this, er.MEDIA_SUBTITLES_LIST, b) } get mediaSubtitlesShowing() { return getSubtitlesListAttr(this, er.MEDIA_SUBTITLES_SHOWING) } set mediaSubtitlesShowing(b) { setSubtitlesListAttr(this, er.MEDIA_SUBTITLES_SHOWING, b) } handleClick() { this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_TOGGLE_SUBTITLES_REQUEST, { composed: !0, bubbles: !0 })) } }); let e5 = { SEEK_OFFSET: "seekoffset" }, e3 = eE.createElement("template"); e3.innerHTML = `
    <slot name="icon"><svg aria-hidden="true" viewBox="0 0 20 24"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class="text value" transform="translate(8.9 19.87)">30</text><path d="M10 6V3l5.61 4L10 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 10 6Z"/></svg></slot>
  `, eg.customElements.get("media-seek-forward-button") || eg.customElements.define("media-seek-forward-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_CURRENT_TIME, e5.SEEK_OFFSET] } constructor(b = {}) { super({ slotTemplate: e3, ...b }) } connectedCallback() { this.seekOffset = getNumericAttr(this, e5.SEEK_OFFSET, 30), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === e5.SEEK_OFFSET && (this.seekOffset = getNumericAttr(this, e5.SEEK_OFFSET, 30)), super.attributeChangedCallback(b, A, D) } get seekOffset() { return getNumericAttr(this, e5.SEEK_OFFSET, 30) } set seekOffset(b) { setNumericAttr(this, e5.SEEK_OFFSET, b), this.setAttribute("aria-label", eh.SEEK_FORWARD_N_SECS({ seekOffset: this.seekOffset })), updateIconText(getSlotted(this, "icon"), this.seekOffset) } get mediaCurrentTime() { return getNumericAttr(this, er.MEDIA_CURRENT_TIME, 0) } set mediaCurrentTime(b) { setNumericAttr(this, er.MEDIA_CURRENT_TIME, b) } handleClick() { let b = this.mediaCurrentTime + this.seekOffset, A = new eg.CustomEvent(Z.MEDIA_SEEK_REQUEST, { composed: !0, bubbles: !0, detail: b }); this.dispatchEvent(A) } }); let e4 = `<svg aria-hidden="true" viewBox="0 0 26 24">
    <path d="M16 3v2.5h3.5V9H22V3h-6ZM4 9h2.5V5.5H10V3H4v6Zm15.5 9.5H16V21h6v-6h-2.5v3.5ZM6.5 15H4v6h6v-2.5H6.5V15Z"/>
  </svg>`, e7 = `<svg aria-hidden="true" viewBox="0 0 26 24">
    <path d="M18.5 6.5V3H16v6h6V6.5h-3.5ZM16 21h2.5v-3.5H22V15h-6v6ZM4 17.5h3.5V21H10v-6H4v2.5Zm3.5-11H4V9h6V3H7.5v3.5Z"/>
  </svg>`, e8 = eE.createElement("template"); e8.innerHTML = `
    <style>
    :host([${er.MEDIA_IS_FULLSCREEN}]) slot:not([name=exit]):not([name=icon]) {
      display: none !important;
    }
  
    
    :host(:not([${er.MEDIA_IS_FULLSCREEN}])) slot:not([name=enter]):not([name=icon]) {
      display: none !important;
    }
    </style>
  
    <slot name="icon">
      <slot name="enter">${e4}</slot>
      <slot name="exit">${e7}</slot>
    </slot>
  `; let media_fullscreen_button_updateAriaLabel = b => { let A = b.mediaIsFullscreen ? eh.EXIT_FULLSCREEN() : eh.ENTER_FULLSCREEN(); b.setAttribute("aria-label", A) }; eg.customElements.get("media-fullscreen-button") || eg.customElements.define("media-fullscreen-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_IS_FULLSCREEN, er.MEDIA_FULLSCREEN_UNAVAILABLE] } constructor(b = {}) { super({ slotTemplate: e8, ...b }) } connectedCallback() { media_fullscreen_button_updateAriaLabel(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === er.MEDIA_IS_FULLSCREEN && media_fullscreen_button_updateAriaLabel(this), super.attributeChangedCallback(b, A, D) } get mediaFullscreenUnavailable() { return getStringAttr(this, er.MEDIA_FULLSCREEN_UNAVAILABLE) } set mediaFullscreenUnavailable(b) { setStringAttr(this, er.MEDIA_FULLSCREEN_UNAVAILABLE, b) } get mediaIsFullscreen() { return getBooleanAttr(this, er.MEDIA_IS_FULLSCREEN) } set mediaIsFullscreen(b) { setBooleanAttr(this, er.MEDIA_IS_FULLSCREEN, b) } handleClick() { let b = this.mediaIsFullscreen ? Z.MEDIA_EXIT_FULLSCREEN_REQUEST : Z.MEDIA_ENTER_FULLSCREEN_REQUEST; this.dispatchEvent(new eg.CustomEvent(b, { composed: !0, bubbles: !0 })) } }); let { MEDIA_TIME_IS_LIVE: e6, MEDIA_PAUSED: e9 } = er, { MEDIA_SEEK_TO_LIVE_REQUEST: tt, MEDIA_PLAY_REQUEST: ta } = Z, ti = eE.createElement("template"); ti.innerHTML = `
    <style>
  
    slot[name=indicator] > *,
    :host ::slotted([slot=indicator]) {
      
      min-width: auto;
      fill: var(--media-live-button-icon-color, rgb(140, 140, 140));
      color: var(--media-live-button-icon-color, rgb(140, 140, 140));
    }
  
    :host([${e6}]:not([${e9}])) slot[name=indicator] > *,
    :host([${e6}]:not([${e9}])) ::slotted([slot=indicator]) {
      fill: var(--media-live-button-indicator-color, rgb(255, 0, 0));
      color: var(--media-live-button-indicator-color, rgb(255, 0, 0));
    }
  
    :host([${e6}]:not([${e9}])) {
      cursor: not-allowed;
    }
  
    </style>
  
    <slot name="indicator"><svg viewBox="0 0 6 12"><circle cx="3" cy="6" r="2"></circle></svg></slot>
    
    <slot name="spacer">&nbsp;</slot><slot name="text">LIVE</slot>
  `; let updateAriaAttributes = b => { let A = b.mediaPaused || !b.mediaTimeIsLive, D = A ? eh.SEEK_LIVE() : eh.PLAYING_LIVE(); b.setAttribute("aria-label", D), A ? b.removeAttribute("aria-disabled") : b.setAttribute("aria-disabled", "true") }; eg.customElements.get("media-live-button") || eg.customElements.define("media-live-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, e9, e6] } constructor(b = {}) { super({ slotTemplate: ti, ...b }) } connectedCallback() { updateAriaAttributes(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { super.attributeChangedCallback(b, A, D), updateAriaAttributes(this) } get mediaPaused() { return getBooleanAttr(this, er.MEDIA_PAUSED) } set mediaPaused(b) { setBooleanAttr(this, er.MEDIA_PAUSED, b) } get mediaTimeIsLive() { return getBooleanAttr(this, er.MEDIA_TIME_IS_LIVE) } set mediaTimeIsLive(b) { setBooleanAttr(this, er.MEDIA_TIME_IS_LIVE, b) } handleClick() { (this.mediaPaused || !this.mediaTimeIsLive) && (this.dispatchEvent(new eg.CustomEvent(tt, { composed: !0, bubbles: !0 })), this.hasAttribute(e9) && this.dispatchEvent(new eg.CustomEvent(ta, { composed: !0, bubbles: !0 }))) } }); let { MEDIA_VOLUME_LEVEL: tr } = er, tn = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M16.5 12A4.5 4.5 0 0 0 14 8v2.18l2.45 2.45a4.22 4.22 0 0 0 .05-.63Zm2.5 0a6.84 6.84 0 0 1-.54 2.64L20 16.15A8.8 8.8 0 0 0 21 12a9 9 0 0 0-7-8.77v2.06A7 7 0 0 1 19 12ZM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25A6.92 6.92 0 0 1 14 18.7v2.06A9 9 0 0 0 17.69 19l2 2.05L21 19.73l-9-9L4.27 3ZM12 4 9.91 6.09 12 8.18V4Z"/>
  </svg>`, to = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4Z"/>
  </svg>`, ts = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4ZM14 3.23v2.06a7 7 0 0 1 0 13.42v2.06a9 9 0 0 0 0-17.54Z"/>
  </svg>`, tl = eE.createElement("template"); tl.innerHTML = `
    <style>
    
    :host(:not([${tr}])) slot:not([name=high]):not([name=icon]), 
    :host([${tr}=high]) slot:not([name=high]):not([name=icon]) {
      display: none !important;
    }
  
    :host([${tr}=off]) slot:not([name=off]):not([name=icon]) {
      display: none !important;
    }
  
    :host([${tr}=low]) slot:not([name=low]):not([name=icon]) {
      display: none !important;
    }
  
    :host([${tr}=medium]) slot:not([name=medium]):not([name=icon]) {
      display: none !important;
    }
    </style>
  
    <slot name="icon">
      <slot name="off">${tn}</slot>
      <slot name="low">${to}</slot>
      <slot name="medium">${to}</slot>
      <slot name="high">${ts}</slot>
    </slot>
  `; let media_mute_button_updateAriaLabel = b => { let A = "off" === b.mediaVolumeLevel, D = A ? eh.UNMUTE() : eh.MUTE(); b.setAttribute("aria-label", D) }; eg.customElements.get("media-mute-button") || eg.customElements.define("media-mute-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_VOLUME_LEVEL] } constructor(b = {}) { super({ slotTemplate: tl, ...b }) } connectedCallback() { media_mute_button_updateAriaLabel(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === er.MEDIA_VOLUME_LEVEL && media_mute_button_updateAriaLabel(this), super.attributeChangedCallback(b, A, D) } get mediaVolumeLevel() { return getStringAttr(this, er.MEDIA_VOLUME_LEVEL) } set mediaVolumeLevel(b) { setStringAttr(this, er.MEDIA_VOLUME_LEVEL, b) } handleClick() { let b = "off" === this.mediaVolumeLevel ? Z.MEDIA_UNMUTE_REQUEST : Z.MEDIA_MUTE_REQUEST; this.dispatchEvent(new eg.CustomEvent(b, { composed: !0, bubbles: !0 })) } }); let td = `<svg aria-hidden="true" viewBox="0 0 28 24">
    <path d="M24 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Zm-1 16H5V5h18v14Zm-3-8h-7v5h7v-5Z"/>
  </svg>`, tu = eE.createElement("template"); tu.innerHTML = `
    <style>
    :host([${er.MEDIA_IS_PIP}]) slot:not([name=exit]):not([name=icon]) {
      display: none !important;
    }
  
    
    :host(:not([${er.MEDIA_IS_PIP}])) slot:not([name=enter]):not([name=icon]) {
      display: none !important;
    }
    </style>
  
    <slot name="icon">
      <slot name="enter">${td}</slot>
      <slot name="exit">${td}</slot>
    </slot>
  `; let media_pip_button_updateAriaLabel = b => { let A = b.mediaIsPip ? eh.EXIT_PIP() : eh.ENTER_PIP(); b.setAttribute("aria-label", A) }; eg.customElements.get("media-pip-button") || eg.customElements.define("media-pip-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_IS_PIP, er.MEDIA_PIP_UNAVAILABLE] } constructor(b = {}) { super({ slotTemplate: tu, ...b }) } connectedCallback() { media_pip_button_updateAriaLabel(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === er.MEDIA_IS_PIP && media_pip_button_updateAriaLabel(this), super.attributeChangedCallback(b, A, D) } get mediaPipUnavailable() { return getStringAttr(this, er.MEDIA_PIP_UNAVAILABLE) } set mediaPipUnavailable(b) { setStringAttr(this, er.MEDIA_PIP_UNAVAILABLE, b) } get mediaIsPip() { return getBooleanAttr(this, er.MEDIA_IS_PIP) } set mediaIsPip(b) { setBooleanAttr(this, er.MEDIA_IS_PIP, b) } handleClick() { let b = this.mediaIsPip ? Z.MEDIA_EXIT_PIP_REQUEST : Z.MEDIA_ENTER_PIP_REQUEST; this.dispatchEvent(new eg.CustomEvent(b, { composed: !0, bubbles: !0 })) } }); let tc = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="m6 21 15-9L6 3v18Z"/>
  </svg>`, tm = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M6 20h4V4H6v16Zm8-16v16h4V4h-4Z"/>
  </svg>`, th = eE.createElement("template"); th.innerHTML = `
    <style>
    :host([${er.MEDIA_PAUSED}]) slot[name=pause] {
      display: none !important;
    }
  
    :host(:not([${er.MEDIA_PAUSED}])) slot[name=play] {
      display: none !important;
    }
    </style>
  
    <slot name="icon">
      <slot name="play">${tc}</slot>
      <slot name="pause">${tm}</slot>
    </slot>
  `; let media_play_button_updateAriaLabel = b => { let A = b.mediaPaused ? eh.PLAY() : eh.PAUSE(); b.setAttribute("aria-label", A) }; eg.customElements.get("media-play-button") || eg.customElements.define("media-play-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_PAUSED, er.MEDIA_ENDED] } constructor(b = {}) { super({ slotTemplate: th, ...b }) } connectedCallback() { media_play_button_updateAriaLabel(this), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === er.MEDIA_PAUSED && media_play_button_updateAriaLabel(this), super.attributeChangedCallback(b, A, D) } get mediaPaused() { return getBooleanAttr(this, er.MEDIA_PAUSED) } set mediaPaused(b) { setBooleanAttr(this, er.MEDIA_PAUSED, b) } handleClick() { let b = this.mediaPaused ? Z.MEDIA_PLAY_REQUEST : Z.MEDIA_PAUSE_REQUEST; this.dispatchEvent(new eg.CustomEvent(b, { composed: !0, bubbles: !0 })) } }); var media_playback_rate_button_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_playback_rate_button_privateGet = (b, A, D) => (media_playback_rate_button_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_playback_rate_button_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }; let tp = { RATES: "rates" }, tv = [1, 1.2, 1.5, 1.7, 2], t_ = eE.createElement("template"); t_.innerHTML = `
    <style>
      :host {
        min-width: 5ch;
        padding: var(--media-control-padding, 10px 5px);
      }
    </style>
    <span id="container"></span>
  `, aG = new WeakMap, eg.customElements.get("media-playback-rate-button") || eg.customElements.define("media-playback-rate-button", class extends MediaChromeButton { constructor(b = {}) { super({ slotTemplate: t_, ...b }), media_playback_rate_button_privateAdd(this, aG, new AttributeTokenList(this, tp.RATES, { defaultValue: tv })), this.container = this.shadowRoot.querySelector("#container"), this.container.innerHTML = "1x" } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_PLAYBACK_RATE, tp.RATES] } attributeChangedCallback(b, A, D) { if (super.attributeChangedCallback(b, A, D), b === tp.RATES && (media_playback_rate_button_privateGet(this, aG).value = D), b === er.MEDIA_PLAYBACK_RATE) { let b = D ? +D : Number.NaN, A = Number.isNaN(b) ? 1 : b; this.container.innerHTML = `${A}x`, this.setAttribute("aria-label", em.PLAYBACK_RATE({ playbackRate: A })) } } get rates() { return media_playback_rate_button_privateGet(this, aG) } set rates(b) { b ? Array.isArray(b) && (media_playback_rate_button_privateGet(this, aG).value = b.join(" ")) : media_playback_rate_button_privateGet(this, aG).value = "" } get mediaPlaybackRate() { return getNumericAttr(this, er.MEDIA_PLAYBACK_RATE, 1) } set mediaPlaybackRate(b) { setNumericAttr(this, er.MEDIA_PLAYBACK_RATE, b) } handleClick() { var b, A; let D = Array.from(this.rates.values(), b => +b).sort((b, A) => b - A), N = null != (A = null != (b = D.find(b => b > this.mediaPlaybackRate)) ? b : D[0]) ? A : 1, V = new eg.CustomEvent(Z.MEDIA_PLAYBACK_RATE_REQUEST, { composed: !0, bubbles: !0, detail: N }); this.dispatchEvent(V) } }); let tf = { PLACEHOLDER_SRC: "placeholdersrc", SRC: "src" }, tb = eE.createElement("template"); tb.innerHTML = `
    <style>
      :host {
        pointer-events: none;
        display: var(--media-poster-image-display, inline-block);
        box-sizing: border-box;
      }
  
      img {
        max-width: 100%;
        max-height: 100%;
        min-width: 100%;
        min-height: 100%;
        background-repeat: no-repeat;
        background-position: var(--media-poster-image-background-position, var(--media-object-position, center));
        background-size: var(--media-poster-image-background-size, var(--media-object-fit, contain));
        object-fit: var(--media-object-fit, contain);
        object-position: var(--media-object-position, center);
      }
    </style>
  
    <img part="poster img" aria-hidden="true" id="image"/>
  `; let unsetBackgroundImage = b => { b.style.removeProperty("background-image") }, setBackgroundImage = (b, A) => { b.style["background-image"] = `url('${A}')` }; let MediaPosterImage = class MediaPosterImage extends eg.HTMLElement { static get observedAttributes() { return [tf.PLACEHOLDER_SRC, tf.SRC] } constructor() { super(), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(tb.content.cloneNode(!0))), this.image = this.shadowRoot.querySelector("#image") } attributeChangedCallback(b, A, D) { b === tf.SRC && (null == D ? this.image.removeAttribute(tf.SRC) : this.image.setAttribute(tf.SRC, D)), b === tf.PLACEHOLDER_SRC && (null == D ? unsetBackgroundImage(this.image) : setBackgroundImage(this.image, D)) } get placeholderSrc() { return getStringAttr(this, tf.PLACEHOLDER_SRC) } set placeholderSrc(b) { setStringAttr(this, tf.SRC, b) } get src() { return getStringAttr(this, tf.SRC) } set src(b) { setStringAttr(this, tf.SRC, b) } }; eg.customElements.get("media-poster-image") || eg.customElements.define("media-poster-image", MediaPosterImage); let tg = { SEEK_OFFSET: "seekoffset" }, tE = eE.createElement("template"); tE.innerHTML = `
    <slot name="icon"><svg aria-hidden="true" viewBox="0 0 20 24"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class="text value" transform="translate(2.18 19.87)">30</text><path d="M10 6V3L4.37 7 10 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 10 6Z"/></svg></slot>
  `, eg.customElements.get("media-seek-backward-button") || eg.customElements.define("media-seek-backward-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_CURRENT_TIME, tg.SEEK_OFFSET] } constructor(b = {}) { super({ slotTemplate: tE, ...b }) } connectedCallback() { this.seekOffset = getNumericAttr(this, tg.SEEK_OFFSET, 30), super.connectedCallback() } attributeChangedCallback(b, A, D) { b === tg.SEEK_OFFSET && (this.seekOffset = getNumericAttr(this, tg.SEEK_OFFSET, 30)), super.attributeChangedCallback(b, A, D) } get seekOffset() { return getNumericAttr(this, tg.SEEK_OFFSET, 30) } set seekOffset(b) { setNumericAttr(this, tg.SEEK_OFFSET, b), this.setAttribute("aria-label", eh.SEEK_BACK_N_SECS({ seekOffset: this.seekOffset })), updateIconText(getSlotted(this, "icon"), this.seekOffset) } get mediaCurrentTime() { return getNumericAttr(this, er.MEDIA_CURRENT_TIME, 0) } set mediaCurrentTime(b) { setNumericAttr(this, er.MEDIA_CURRENT_TIME, b) } handleClick() { let b = Math.max(this.mediaCurrentTime - this.seekOffset, 0), A = new eg.CustomEvent(Z.MEDIA_SEEK_REQUEST, { composed: !0, bubbles: !0, detail: b }); this.dispatchEvent(A) } }); var media_preview_time_display_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_preview_time_display_privateGet = (b, A, D) => (media_preview_time_display_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_preview_time_display_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_preview_time_display_privateSet = (b, A, D, N) => (media_preview_time_display_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); aV = new WeakMap, eg.customElements.get("media-preview-time-display") || eg.customElements.define("media-preview-time-display", class extends MediaTextDisplay { constructor() { super(), media_preview_time_display_privateAdd(this, aV, void 0), media_preview_time_display_privateSet(this, aV, this.shadowRoot.querySelector("slot")), media_preview_time_display_privateGet(this, aV).textContent = formatTime(0) } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_PREVIEW_TIME] } attributeChangedCallback(b, A, D) { b === er.MEDIA_PREVIEW_TIME && null != D && (media_preview_time_display_privateGet(this, aV).textContent = formatTime(D)), super.attributeChangedCallback(b, A, D) } get mediaPreviewTime() { return getNumericAttr(this, er.MEDIA_PREVIEW_TIME) } set mediaPreviewTime(b) { setNumericAttr(this, er.MEDIA_PREVIEW_TIME, b) } }); var media_preview_thumbnail_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_preview_thumbnail_privateGet = (b, A, D) => (media_preview_thumbnail_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_preview_thumbnail_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_preview_thumbnail_privateSet = (b, A, D, N) => (media_preview_thumbnail_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let ty = eE.createElement("template"); ty.innerHTML = `
    <style>
      :host {
        box-sizing: border-box;
        display: var(--media-control-display, var(--media-preview-thumbnail-display, inline-block));
        overflow: hidden;
      }
  
      img {
        display: none;
        position: relative;
      }
    </style>
    <img crossorigin loading="eager" decoding="async">
  `; let MediaPreviewThumbnail = class MediaPreviewThumbnail extends eg.HTMLElement { constructor() { super(), media_preview_thumbnail_privateAdd(this, aj, void 0), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(ty.content.cloneNode(!0))) } static get observedAttributes() { return [ee.MEDIA_CONTROLLER, er.MEDIA_PREVIEW_IMAGE, er.MEDIA_PREVIEW_COORDS] } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_preview_thumbnail_privateSet(this, aj, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_preview_thumbnail_privateGet(this, aj)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; null == (A = null == (b = media_preview_thumbnail_privateGet(this, aj)) ? void 0 : b.unassociateElement) || A.call(b, this), media_preview_thumbnail_privateSet(this, aj, null) } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et;[er.MEDIA_PREVIEW_IMAGE, er.MEDIA_PREVIEW_COORDS].includes(b) && this.update(), b === ee.MEDIA_CONTROLLER && (A && (null == (V = null == (N = media_preview_thumbnail_privateGet(this, aj)) ? void 0 : N.unassociateElement) || V.call(N, this), media_preview_thumbnail_privateSet(this, aj, null)), D && this.isConnected && (media_preview_thumbnail_privateSet(this, aj, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_preview_thumbnail_privateGet(this, aj)) ? void 0 : Z.associateElement) || et.call(Z, this))) } get mediaPreviewImage() { return getStringAttr(this, er.MEDIA_PREVIEW_IMAGE) } set mediaPreviewImage(b) { setStringAttr(this, er.MEDIA_PREVIEW_IMAGE, b) } get mediaPreviewCoords() { let b = this.getAttribute(er.MEDIA_PREVIEW_COORDS); if (b) return b.split(/\s+/).map(b => +b) } set mediaPreviewCoords(b) { if (!b) { this.removeAttribute(er.MEDIA_PREVIEW_COORDS); return } this.setAttribute(er.MEDIA_PREVIEW_COORDS, b.join(" ")) } update() { let b = this.mediaPreviewCoords, A = this.mediaPreviewImage; if (!(b && A)) return; let [D, N, V, Y] = b, Z = A.split("#")[0], ee = getComputedStyle(this), { maxWidth: et, maxHeight: ea, minWidth: er, minHeight: en } = ee, eo = Math.min(parseInt(et) / V, parseInt(ea) / Y), es = Math.max(parseInt(er) / V, parseInt(en) / Y), el = eo < 1, ed = el ? eo : es > 1 ? es : 1, { style: eu } = getOrInsertCSSRule(this.shadowRoot, ":host"), ec = getOrInsertCSSRule(this.shadowRoot, "img").style, em = this.shadowRoot.querySelector("img"), eh = el ? "min" : "max"; eu.setProperty(`${eh}-width`, "initial", "important"), eu.setProperty(`${eh}-height`, "initial", "important"), eu.width = `${V * ed}px`, eu.height = `${Y * ed}px`; let resize = () => { ec.width = `${this.imgWidth * ed}px`, ec.height = `${this.imgHeight * ed}px`, ec.display = "block" }; em.src !== Z && (em.onload = () => { this.imgWidth = em.naturalWidth, this.imgHeight = em.naturalHeight, resize() }, em.src = Z, resize()), resize(), ec.transform = `translate(-${D * ed}px, -${N * ed}px)` } }; aj = new WeakMap, eg.customElements.get("media-preview-thumbnail") || eg.customElements.define("media-preview-thumbnail", MediaPreviewThumbnail); var range_animation_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, range_animation_privateGet = (b, A, D) => (range_animation_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), range_animation_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, range_animation_privateSet = (b, A, D, N) => (range_animation_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), __privateWrapper = (b, A, D, N) => ({ set _(value) { range_animation_privateSet(b, A, value, D) }, get _() { return range_animation_privateGet(b, A, N) } }); let RangeAnimation = class RangeAnimation { constructor(b, A, D) { range_animation_privateAdd(this, aq, void 0), range_animation_privateAdd(this, a$, void 0), range_animation_privateAdd(this, aY, void 0), range_animation_privateAdd(this, aK, void 0), range_animation_privateAdd(this, aZ, void 0), range_animation_privateAdd(this, aQ, void 0), range_animation_privateAdd(this, az, void 0), range_animation_privateAdd(this, aX, void 0), range_animation_privateAdd(this, aJ, 0), range_animation_privateAdd(this, a0, (b = performance.now()) => { range_animation_privateSet(this, aJ, requestAnimationFrame(range_animation_privateGet(this, a0))), range_animation_privateSet(this, aK, performance.now() - range_animation_privateGet(this, aY)); let A = 1e3 / this.fps; if (range_animation_privateGet(this, aK) > A) { range_animation_privateSet(this, aY, b - range_animation_privateGet(this, aK) % A); let D = 1e3 / ((b - range_animation_privateGet(this, a$)) / ++__privateWrapper(this, aZ)._), N = (b - range_animation_privateGet(this, aQ)) / 1e3 / this.duration, V = range_animation_privateGet(this, az) + N * this.playbackRate, Y = V - range_animation_privateGet(this, aq).valueAsNumber; Y > 0 ? range_animation_privateSet(this, aX, this.playbackRate / this.duration / D) : (range_animation_privateSet(this, aX, .995 * range_animation_privateGet(this, aX)), V = range_animation_privateGet(this, aq).valueAsNumber + range_animation_privateGet(this, aX)), this.callback(V) } }), range_animation_privateSet(this, aq, b), this.callback = A, this.fps = D } start() { 0 === range_animation_privateGet(this, aJ) && (range_animation_privateSet(this, aY, performance.now()), range_animation_privateSet(this, a$, range_animation_privateGet(this, aY)), range_animation_privateSet(this, aZ, 0), range_animation_privateGet(this, a0).call(this)) } stop() { 0 !== range_animation_privateGet(this, aJ) && (cancelAnimationFrame(range_animation_privateGet(this, aJ)), range_animation_privateSet(this, aJ, 0)) } update({ start: b, duration: A, playbackRate: D }) { let N = b - range_animation_privateGet(this, aq).valueAsNumber; (N > 0 || N < -.03) && this.callback(b), range_animation_privateSet(this, az, b), range_animation_privateSet(this, aQ, performance.now()), this.duration = A, this.playbackRate = D } }; aq = new WeakMap, a$ = new WeakMap, aY = new WeakMap, aK = new WeakMap, aZ = new WeakMap, aQ = new WeakMap, az = new WeakMap, aX = new WeakMap, aJ = new WeakMap, a0 = new WeakMap; var media_time_range_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_time_range_privateGet = (b, A, D) => (media_time_range_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_time_range_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_time_range_privateSet = (b, A, D, N) => (media_time_range_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_time_range_privateMethod = (b, A, D) => (media_time_range_accessCheck(b, A, "access private method"), D); let media_time_range_updateAriaValueText = b => { let A = b.range, D = formatAsTimePhrase(+calcTimeFromRangeValue(b)), N = formatAsTimePhrase(+b.mediaSeekableEnd), V = D && N ? `${D} of ${N}` : "video not loaded, unknown time."; A.setAttribute("aria-valuetext", V) }, tA = eE.createElement("template"); tA.innerHTML = `
    <style>
      :host {
        --media-preview-border-radius: 3px;
        --media-box-padding-left: 10px;
        --media-box-padding-right: 10px;
      }
  
      #highlight {
        background: var(--media-time-range-buffered-color, rgb(255 255 255 / .4));
      }
  
      #preview-rail,
      #current-rail {
        
        width: 1%;
        position: absolute;
        left: 0;
        bottom: 100%;
        pointer-events: none;
      }
  
      [part~="box"] {
        
        position: absolute;
        bottom: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        transform: translateX(-50%);
      }
  
      [part~="preview-box"] {
        transition-property: var(--media-preview-transition-property, visibility, opacity);
        transition-duration: var(--media-preview-transition-duration-out, .25s);
        transition-delay: var(--media-preview-transition-delay-out, 0s);
        visibility: hidden;
        opacity: 0;
      }
  
      :host(:is([${er.MEDIA_PREVIEW_IMAGE}], [${er.MEDIA_PREVIEW_TIME}])[dragging]) [part~="preview-box"] {
        transition-duration: var(--media-preview-transition-duration-in, .5s);
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        visibility: visible;
        opacity: 1;
      }
  
      @media (hover: hover) {
        :host(:is([${er.MEDIA_PREVIEW_IMAGE}], [${er.MEDIA_PREVIEW_TIME}]):hover) [part~="preview-box"] {
          transition-duration: var(--media-preview-transition-duration-in, .5s);
          transition-delay: var(--media-preview-transition-delay-in, .25s);
          visibility: visible;
          opacity: 1;
        }
      }
  
      media-preview-thumbnail,
      ::slotted(media-preview-thumbnail) {
        visibility: hidden;
        
        transition: visibility 0s .25s;
        transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));
        background: var(--media-preview-thumbnail-background, var(--media-preview-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)))));
        box-shadow: var(--media-preview-thumbnail-box-shadow, 0 0 4px rgb(0 0 0 / .2));
        max-width: var(--media-preview-thumbnail-max-width, 180px);
        max-height: var(--media-preview-thumbnail-max-height, 160px);
        min-width: var(--media-preview-thumbnail-min-width, 120px);
        min-height: var(--media-preview-thumbnail-min-height, 80px);
        border: var(--media-preview-thumbnail-border);
        border-radius: var(--media-preview-thumbnail-border-radius,
          var(--media-preview-border-radius) var(--media-preview-border-radius) 0 0);
      }
  
      :host([${er.MEDIA_PREVIEW_IMAGE}][dragging]) media-preview-thumbnail,
      :host([${er.MEDIA_PREVIEW_IMAGE}][dragging]) ::slotted(media-preview-thumbnail) {
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        visibility: visible;
      }
  
      @media (hover: hover) {
        :host([${er.MEDIA_PREVIEW_IMAGE}]:hover) media-preview-thumbnail,
        :host([${er.MEDIA_PREVIEW_IMAGE}]:hover) ::slotted(media-preview-thumbnail) {
          transition-delay: var(--media-preview-transition-delay-in, .25s);
          visibility: visible;
        }
  
        :host([${er.MEDIA_PREVIEW_TIME}]:hover) {
          --media-time-range-hover-display: block;
        }
      }
  
      media-preview-time-display,
      ::slotted(media-preview-time-display) {
        min-width: 0;
        
        transition: min-width 0s, border-radius 0s;
        transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));
        background: var(--media-preview-time-background, var(--media-preview-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)))));
        border-radius: var(--media-preview-time-border-radius,
          var(--media-preview-border-radius) var(--media-preview-border-radius)
          var(--media-preview-border-radius) var(--media-preview-border-radius));
        padding: var(--media-preview-time-padding, 1px 10px 0);
        margin: var(--media-preview-time-margin, 0 0 10px);
        text-shadow: var(--media-preview-time-text-shadow, 0 0 4px rgb(0 0 0 / .75));
      }
  
      :host([${er.MEDIA_PREVIEW_IMAGE}]) media-preview-time-display,
      :host([${er.MEDIA_PREVIEW_IMAGE}]) ::slotted(media-preview-time-display) {
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        min-width: 100%;
        border-radius: var(--media-preview-time-border-radius,
          0 0 var(--media-preview-border-radius) var(--media-preview-border-radius));
      }
    </style>
    <div id="preview-rail">
      <slot name="preview" part="box preview-box">
        <media-preview-thumbnail></media-preview-thumbnail>
        <media-preview-time-display></media-preview-time-display>
      </slot>
    </div>
    <div id="current-rail">
      <slot name="current" part="box current-box">
        
      </slot>
    </div>
  `; let calcRangeValueFromTime = (b, A = b.mediaCurrentTime) => { if (Number.isNaN(b.mediaSeekableEnd)) return 0; let D = (A - b.mediaSeekableStart) / (b.mediaSeekableEnd - b.mediaSeekableStart); return Math.max(0, Math.min(D, 1)) }, calcTimeFromRangeValue = (b, A = b.range.valueAsNumber) => Number.isNaN(b.mediaSeekableEnd) ? 0 : A * (b.mediaSeekableEnd - b.mediaSeekableStart) + b.mediaSeekableStart; a1 = new WeakMap, a2 = new WeakMap, a5 = new WeakMap, a3 = new WeakMap, a4 = new WeakMap, a7 = new WeakMap, a8 = new WeakMap, a6 = new WeakSet, a9 = function () { media_time_range_privateMethod(this, ia, ii).call(this) ? media_time_range_privateGet(this, a2).start() : media_time_range_privateGet(this, a2).stop() }, ia = new WeakSet, ii = function () { return this.isConnected && function (b, A = 3) { if (b.checkVisibility) return b.checkVisibility({ checkOpacity: !0, checkVisibilityCSS: !0 }); let D = b; for (; D && A > 0;) { let b = getComputedStyle(D); if ("0" === b.opacity || "hidden" === b.visibility || "none" === b.display) return !1; D = D.parentElement, A-- } return !0 }(this) && !this.mediaPaused && !this.mediaLoading && !this.mediaEnded }, ir = new WeakMap, io = new WeakSet, is = function (b, A) { var D; let N = `${1e4 * A}%`, V = b.offsetWidth; if (!V) return N; let Y = null != (D = this.getAttribute("bounds") ? closestComposedNode(this, `#${this.getAttribute("bounds")}`) : this.parentElement) ? D : this, Z = this.range.getBoundingClientRect(), ee = Y.getBoundingClientRect(), et = (media_time_range_privateGet(this, a7) - (Z.left - ee.left - V / 2)) / Z.width * 100, ea = (ee.right - Z.left - V / 2 - media_time_range_privateGet(this, a8)) / Z.width * 100; return Number.isNaN(et) || (N = `max(${100 * et}%, ${N})`), Number.isNaN(ea) || (N = `min(${N}, ${100 * ea}%)`), N }, il = new WeakSet, id = function (b) { let A = [...media_time_range_privateGet(this, a5)].some(A => b.composedPath().includes(A)); if (!this.dragging && (A || !b.composedPath().includes(this))) { media_time_range_privateMethod(this, iu, ic).call(this, null); return } let D = this.mediaDuration; if (!D) return; let N = this.range.getBoundingClientRect(), V = (b.clientX - N.left) / N.width; V = Math.max(0, Math.min(1, V)); let Y = media_time_range_privateMethod(this, io, is).call(this, media_time_range_privateGet(this, a3), V), { style: Z } = getOrInsertCSSRule(this.shadowRoot, "#preview-rail"); Z.transform = `translateX(${Y})`, media_time_range_privateMethod(this, iu, ic).call(this, V * D) }, iu = new WeakSet, ic = function (b) { this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_PREVIEW_REQUEST, { composed: !0, bubbles: !0, detail: b })) }, im = new WeakSet, ih = function () { media_time_range_privateGet(this, a2).stop(); let b = calcTimeFromRangeValue(this); this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_SEEK_REQUEST, { composed: !0, bubbles: !0, detail: b })) }, eg.customElements.get("media-time-range") || eg.customElements.define("media-time-range", class extends MediaChromeRange { constructor() { super(), media_time_range_privateAdd(this, a6), media_time_range_privateAdd(this, ia), media_time_range_privateAdd(this, io), media_time_range_privateAdd(this, il), media_time_range_privateAdd(this, iu), media_time_range_privateAdd(this, im), media_time_range_privateAdd(this, a1, void 0), media_time_range_privateAdd(this, a2, void 0), media_time_range_privateAdd(this, a5, void 0), media_time_range_privateAdd(this, a3, void 0), media_time_range_privateAdd(this, a4, void 0), media_time_range_privateAdd(this, a7, void 0), media_time_range_privateAdd(this, a8, void 0), media_time_range_privateAdd(this, ir, b => { this.dragging || (this.range.valueAsNumber = b, this.updateBar()) }), this.container.appendChild(tA.content.cloneNode(!0)), media_time_range_privateSet(this, a5, this.shadowRoot.querySelectorAll('[part~="box"]')), media_time_range_privateSet(this, a3, this.shadowRoot.querySelector('[part~="preview-box"]')), media_time_range_privateSet(this, a4, this.shadowRoot.querySelector('[part~="current-box"]')); let b = getComputedStyle(this); media_time_range_privateSet(this, a7, parseInt(b.getPropertyValue("--media-box-padding-left"))), media_time_range_privateSet(this, a8, parseInt(b.getPropertyValue("--media-box-padding-right"))), media_time_range_privateSet(this, a2, new RangeAnimation(this.range, media_time_range_privateGet(this, ir), 60)) } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_PAUSED, er.MEDIA_DURATION, er.MEDIA_SEEKABLE, er.MEDIA_CURRENT_TIME, er.MEDIA_PREVIEW_IMAGE, er.MEDIA_PREVIEW_TIME, er.MEDIA_BUFFERED, er.MEDIA_PLAYBACK_RATE, er.MEDIA_LOADING, er.MEDIA_ENDED] } connectedCallback() { var b; super.connectedCallback(), this.range.setAttribute("aria-label", em.SEEK()), media_time_range_privateMethod(this, a6, a9).call(this), media_time_range_privateSet(this, a1, this.getRootNode()), null == (b = media_time_range_privateGet(this, a1)) || b.addEventListener("transitionstart", this) } disconnectedCallback() { var b; super.disconnectedCallback(), media_time_range_privateMethod(this, a6, a9).call(this), null == (b = media_time_range_privateGet(this, a1)) || b.removeEventListener("transitionstart", this), media_time_range_privateSet(this, a1, null) } attributeChangedCallback(b, A, D) { super.attributeChangedCallback(b, A, D), A != D && (b === er.MEDIA_CURRENT_TIME || b === er.MEDIA_PAUSED || b === er.MEDIA_ENDED || b === er.MEDIA_LOADING || b === er.MEDIA_DURATION || b === er.MEDIA_SEEKABLE ? (media_time_range_privateGet(this, a2).update({ start: calcRangeValueFromTime(this), duration: this.mediaSeekableEnd - this.mediaSeekableStart, playbackRate: this.mediaPlaybackRate }), media_time_range_privateMethod(this, a6, a9).call(this), media_time_range_updateAriaValueText(this)) : b === er.MEDIA_BUFFERED && this.updateBufferedBar()) } get mediaPaused() { return getBooleanAttr(this, er.MEDIA_PAUSED) } set mediaPaused(b) { setBooleanAttr(this, er.MEDIA_PAUSED, b) } get mediaLoading() { return getBooleanAttr(this, er.MEDIA_LOADING) } set mediaLoading(b) { setBooleanAttr(this, er.MEDIA_LOADING, b) } get mediaDuration() { return getNumericAttr(this, er.MEDIA_DURATION) } set mediaDuration(b) { setNumericAttr(this, er.MEDIA_DURATION, b) } get mediaCurrentTime() { return getNumericAttr(this, er.MEDIA_CURRENT_TIME) } set mediaCurrentTime(b) { setNumericAttr(this, er.MEDIA_CURRENT_TIME, b) } get mediaPlaybackRate() { return getNumericAttr(this, er.MEDIA_PLAYBACK_RATE, 1) } set mediaPlaybackRate(b) { setNumericAttr(this, er.MEDIA_PLAYBACK_RATE, b) } get mediaBuffered() { let b = this.getAttribute(er.MEDIA_BUFFERED); return b ? b.split(" ").map(b => b.split(":").map(b => +b)) : [] } set mediaBuffered(b) { if (!b) { this.removeAttribute(er.MEDIA_BUFFERED); return } let A = b.map(b => b.join(":")).join(" "); this.setAttribute(er.MEDIA_BUFFERED, A) } get mediaSeekable() { let b = this.getAttribute(er.MEDIA_SEEKABLE); if (b) return b.split(":").map(b => +b) } set mediaSeekable(b) { if (null == b) { this.removeAttribute(er.MEDIA_SEEKABLE); return } this.setAttribute(er.MEDIA_SEEKABLE, b.join(":")) } get mediaSeekableEnd() { var b; let [, A = this.mediaDuration] = null != (b = this.mediaSeekable) ? b : []; return A } get mediaSeekableStart() { var b; let [A = 0] = null != (b = this.mediaSeekable) ? b : []; return A } get mediaPreviewImage() { return getStringAttr(this, er.MEDIA_PREVIEW_IMAGE) } set mediaPreviewImage(b) { setStringAttr(this, er.MEDIA_PREVIEW_IMAGE, b) } get mediaPreviewTime() { return getNumericAttr(this, er.MEDIA_PREVIEW_TIME) } set mediaPreviewTime(b) { setNumericAttr(this, er.MEDIA_PREVIEW_TIME, b) } get mediaEnded() { return getBooleanAttr(this, er.MEDIA_ENDED) } set mediaEnded(b) { setBooleanAttr(this, er.MEDIA_ENDED, b) } updateBar() { super.updateBar(), this.updateBufferedBar(), this.updateCurrentBox() } updateBufferedBar() { var b; let A; let D = this.mediaBuffered; if (!D.length) return; if (this.mediaEnded) A = 1; else { let N = this.mediaCurrentTime, [, V = this.mediaSeekableStart] = null != (b = D.find(([b, A]) => b <= N && N <= A)) ? b : []; A = calcRangeValueFromTime(this, V) } let { style: N } = getOrInsertCSSRule(this.shadowRoot, "#highlight"); N.setProperty("width", `${100 * A}%`) } updateCurrentBox() { if (!media_time_range_privateGet(this, a4).assignedElements().length) return; let b = media_time_range_privateMethod(this, io, is).call(this, media_time_range_privateGet(this, a4), this.range.valueAsNumber), { style: A } = getOrInsertCSSRule(this.shadowRoot, "#current-rail"); A.transform = `translateX(${b})` } handleEvent(b) { switch (super.handleEvent(b), b.type) { case "input": media_time_range_privateMethod(this, im, ih).call(this); break; case "pointermove": media_time_range_privateMethod(this, il, id).call(this, b); break; case "pointerup": case "pointerleave": media_time_range_privateMethod(this, iu, ic).call(this, null); break; case "transitionstart": containsComposedNode(b.target, this) && setTimeout(() => media_time_range_privateMethod(this, a6, a9).call(this), 0) } } }); var media_loading_indicator_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_loading_indicator_privateGet = (b, A, D) => (media_loading_indicator_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_loading_indicator_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_loading_indicator_privateSet = (b, A, D, N) => (media_loading_indicator_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let tk = { LOADING_DELAY: "loadingdelay" }, tT = eE.createElement("template"), tw = `
  <svg aria-hidden="true" viewBox="0 0 100 100">
    <path d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
      <animateTransform
         attributeName="transform"
         attributeType="XML"
         type="rotate"
         dur="1s"
         from="0 50 50"
         to="360 50 50"
         repeatCount="indefinite" />
    </path>
  </svg>
  `; tT.innerHTML = `
  <style>
  :host {
    display: var(--media-control-display, var(--media-loading-indicator-display, inline-block));
    vertical-align: middle;
    box-sizing: border-box;
    --_loading-indicator-delay: var(--media-loading-indicator-transition-delay, 500ms);
  }
  
  #status {
    color: rgba(0,0,0,0);
    width: 0px;
    height: 0px;
  }
  
  :host slot[name=icon] > *,
  :host ::slotted([slot=icon]) {
    opacity: var(--media-loading-indicator-opacity, 0);
    transition: opacity 0.15s;
  }
  
  :host([${er.MEDIA_LOADING}]:not([${er.MEDIA_PAUSED}])) slot[name=icon] > *,
  :host([${er.MEDIA_LOADING}]:not([${er.MEDIA_PAUSED}])) ::slotted([slot=icon]) {
    opacity: var(--media-loading-indicator-opacity, 1);
    transition: opacity 0.15s var(--_loading-indicator-delay);
  }
  
  :host #status {
    visibility: var(--media-loading-indicator-opacity, hidden);
    transition: visibility 0.15s;
  }
  
  :host([${er.MEDIA_LOADING}]:not([${er.MEDIA_PAUSED}])) #status {
    visibility: var(--media-loading-indicator-opacity, visible);
    transition: visibility 0.15s var(--_loading-indicator-delay);
  }
  
  svg, img, ::slotted(svg), ::slotted(img) {
    width: var(--media-loading-indicator-icon-width);
    height: var(--media-loading-indicator-icon-height, 100px);
    fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));
    vertical-align: middle;
  }
  </style>
  
  <slot name="icon">${tw}</slot>
  <div id="status" role="status" aria-live="polite">${em.MEDIA_LOADING()}</div>
  `; let MediaLoadingIndicator = class MediaLoadingIndicator extends eg.HTMLElement { constructor() { if (super(), media_loading_indicator_privateAdd(this, ip, void 0), media_loading_indicator_privateAdd(this, iv, 500), media_loading_indicator_privateAdd(this, i_, void 0), !this.shadowRoot) { let b = this.attachShadow({ mode: "open" }), A = tT.content.cloneNode(!0); b.appendChild(A) } let { style: b } = getOrInsertCSSRule(this.shadowRoot, ":host"); media_loading_indicator_privateSet(this, i_, b) } static get observedAttributes() { return [ee.MEDIA_CONTROLLER, er.MEDIA_PAUSED, er.MEDIA_LOADING, tk.LOADING_DELAY] } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === tk.LOADING_DELAY && A !== D ? this.loadingDelay = Number(D) : b === ee.MEDIA_CONTROLLER && (A && (null == (V = null == (N = media_loading_indicator_privateGet(this, ip)) ? void 0 : N.unassociateElement) || V.call(N, this), media_loading_indicator_privateSet(this, ip, null)), D && this.isConnected && (media_loading_indicator_privateSet(this, ip, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_loading_indicator_privateGet(this, ip)) ? void 0 : Z.associateElement) || et.call(Z, this))) } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_loading_indicator_privateSet(this, ip, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_loading_indicator_privateGet(this, ip)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; null == (A = null == (b = media_loading_indicator_privateGet(this, ip)) ? void 0 : b.unassociateElement) || A.call(b, this), media_loading_indicator_privateSet(this, ip, null) } get loadingDelay() { return media_loading_indicator_privateGet(this, iv) } set loadingDelay(b) { media_loading_indicator_privateSet(this, iv, b), media_loading_indicator_privateGet(this, i_).setProperty("--_loading-indicator-delay", `var(--media-loading-indicator-transition-delay, ${b}ms)`) } get mediaPaused() { return getBooleanAttr(this, er.MEDIA_PAUSED) } set mediaPaused(b) { setBooleanAttr(this, er.MEDIA_PAUSED, b) } get mediaLoading() { return getBooleanAttr(this, er.MEDIA_LOADING) } set mediaLoading(b) { setBooleanAttr(this, er.MEDIA_LOADING, b) } }; ip = new WeakMap, iv = new WeakMap, i_ = new WeakMap, eg.customElements.get("media-loading-indicator") || eg.customElements.define("media-loading-indicator", MediaLoadingIndicator); let toVolume = b => b.mediaMuted ? 0 : b.mediaVolume, formatAsPercentString = ({ value: b }) => `${Math.round(100 * b)}%`; eg.customElements.get("media-volume-range") || eg.customElements.define("media-volume-range", class extends MediaChromeRange { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_VOLUME, er.MEDIA_MUTED, er.MEDIA_VOLUME_UNAVAILABLE] } constructor() { super(), this.range.addEventListener("input", () => { let b = this.range.value, A = new eg.CustomEvent(Z.MEDIA_VOLUME_REQUEST, { composed: !0, bubbles: !0, detail: b }); this.dispatchEvent(A) }) } connectedCallback() { super.connectedCallback(), this.range.setAttribute("aria-label", em.VOLUME()) } attributeChangedCallback(b, A, D) { super.attributeChangedCallback(b, A, D), (b === er.MEDIA_VOLUME || b === er.MEDIA_MUTED) && (this.range.valueAsNumber = toVolume(this), this.range.setAttribute("aria-valuetext", formatAsPercentString(this.range)), this.updateBar()) } get mediaVolume() { return getNumericAttr(this, er.MEDIA_VOLUME, 1) } set mediaVolume(b) { setNumericAttr(this, er.MEDIA_VOLUME, b) } get mediaMuted() { return getBooleanAttr(this, er.MEDIA_MUTED) } set mediaMuted(b) { setBooleanAttr(this, er.MEDIA_MUTED, b) } get mediaVolumeUnavailable() { return getStringAttr(this, er.MEDIA_VOLUME_UNAVAILABLE) } set mediaVolumeUnavailable(b) { setStringAttr(this, er.MEDIA_VOLUME_UNAVAILABLE, b) } }); var media_chrome_listbox_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_chrome_listbox_privateGet = (b, A, D) => (media_chrome_listbox_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_chrome_listbox_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_chrome_listbox_privateSet = (b, A, D, N) => (media_chrome_listbox_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_chrome_listbox_privateMethod = (b, A, D) => (media_chrome_listbox_accessCheck(b, A, "access private method"), D); let tS = `
  <svg aria-hidden="true" viewBox="0 1 24 24" part="select-indicator indicator">
    <path d="m10 15.17 9.193-9.191 1.414 1.414-10.606 10.606-6.364-6.364 1.414-1.414 4.95 4.95Z"/>
  </svg>`; function createOption(b, A, D) { let N = eE.createElement("media-chrome-option"); N.part.add("option"), N.value = A, N.selected = D; let V = eE.createElement("span"); return V.textContent = b, N.append(V), N } function createIndicator(b, A) { let D = b.querySelector(`:scope > [slot="${A}"]`); return ((null == D ? void 0 : D.nodeName) == "SLOT" && (D = D.assignedElements({ flatten: !0 })[0]), D) ? ((D = D.cloneNode(!0)).removeAttribute("slot"), D) : b.shadowRoot.querySelector(`[name="${A}"] > svg`).cloneNode(!0) } let tD = eE.createElement("template"); tD.innerHTML = `
  <style>
    :host {
      font: var(--media-font,
        var(--media-font-weight, normal)
        var(--media-font-size, 15px) /
        var(--media-text-content-height, var(--media-control-height, 24px))
        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
      background: var(--media-listbox-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));
      border-radius: var(--media-listbox-border-radius);
      display: inline-flex;
      flex-direction: column;
      position: relative;
      box-sizing: border-box;
    }
  
    ::slotted([slot="header"]) {
      padding: .4em 1.4em;
      border-bottom: 1px solid rgb(255 255 255 / .25);
    }
  
    #container {
      gap: var(--media-listbox-gap);
      display: flex;
      flex-direction: var(--media-listbox-flex-direction, column);
      overflow: hidden auto;
      padding-block: .5em;
    }
  
    media-chrome-option {
      padding-inline: .7em 1.4em;
    }
  
    media-chrome-option > span {
      margin-inline: .5ch;
    }
  
    [part~="indicator"] {
      fill: var(--media-option-indicator-fill, var(--media-icon-color, var(--media-primary-color, rgb(238 238 238))));
      height: var(--media-option-indicator-height, 1.25em);
      vertical-align: var(--media-option-indicator-vertical-align, text-top);
    }
  
    [part~="select-indicator"] {
      display: var(--media-option-select-indicator-display);
      visibility: hidden;
    }
  
    [aria-selected="true"] > [part~="select-indicator"] {
      visibility: visible;
    }
  </style>
  <style id="layout-row" media="width:0">
  
    ::slotted([slot="header"]) {
      padding: .4em .5em;
    }
  
    #container {
      gap: var(--media-listbox-gap, .25em);
      flex-direction: var(--media-listbox-flex-direction, row);
      padding-inline: .5em;
    }
  
    media-chrome-option {
      padding: .3em .24em;
    }
  
    media-chrome-option[aria-selected="true"] {
      background: var(--media-option-selected-background, rgb(255 255 255 / .2));
    }
  
    [part~="select-indicator"] {
      display: var(--media-option-select-indicator-display, none);
    }
  </style>
  <slot name="header"></slot>
  <slot id="container"></slot>
  <slot name="select-indicator" hidden>${tS}</slot>
  `; let MediaChromeListbox = class MediaChromeListbox extends eg.HTMLElement { constructor(b = {}) { super(), media_chrome_listbox_privateAdd(this, ik), media_chrome_listbox_privateAdd(this, iD), media_chrome_listbox_privateAdd(this, iM), media_chrome_listbox_privateAdd(this, ix), media_chrome_listbox_privateAdd(this, iR), media_chrome_listbox_privateAdd(this, iN), media_chrome_listbox_privateAdd(this, ib, void 0), media_chrome_listbox_privateAdd(this, ig, ""), media_chrome_listbox_privateAdd(this, iE, null), media_chrome_listbox_privateAdd(this, iy, !1), media_chrome_listbox_privateAdd(this, iA, b => { this.handleClick(b) }), media_chrome_listbox_privateAdd(this, iw, b => { let { key: A } = b; if ("Escape" === A) { this.removeEventListener("keyup", media_chrome_listbox_privateGet(this, iw)); return } if ("Meta" === A) { media_chrome_listbox_privateSet(this, iy, !1); return } media_chrome_listbox_privateMethod(this, ik, iT).call(this, b) }), media_chrome_listbox_privateAdd(this, iS, b => { let { key: A, altKey: D } = b; if (D) { this.removeEventListener("keyup", media_chrome_listbox_privateGet(this, iw)); return } if ("Meta" === A) { media_chrome_listbox_privateSet(this, iy, !0); return } if (this.keysUsed.includes(A) && b.preventDefault(), media_chrome_listbox_privateGet(this, iy) && this.keysUsed.includes(A)) { media_chrome_listbox_privateMethod(this, ik, iT).call(this, b); return } this.addEventListener("keyup", media_chrome_listbox_privateGet(this, iw), { once: !0 }) }), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.nativeEl = tD.content.cloneNode(!0), b.slotTemplate && this.nativeEl.append(b.slotTemplate.content.cloneNode(!0)), this.shadowRoot.append(this.nativeEl)), this.container = this.shadowRoot.querySelector("#container"), this.container.addEventListener("slotchange", b => { for (let A of b.target.assignedNodes({ flatten: !0 })) 3 === A.nodeType && "" === A.textContent.trim() && A.remove() }) } static get observedAttributes() { return ["disabled", "style", ee.MEDIA_CONTROLLER] } static formatOptionText(b) { return b } formatOptionText(b, A) { return this.constructor.formatOptionText(b, A) } get options() { var b; let A = this.querySelectorAll("media-chrome-option"); return A.length || (A = null == (b = this.container) ? void 0 : b.querySelectorAll("media-chrome-option")), Array.from(A) } get selectedOptions() { return this.options.filter(b => b.selected) } get value() { var b, A; return null != (A = null == (b = this.selectedOptions[0]) ? void 0 : b.value) ? A : "" } set value(b) { let A = this.options.find(A => A.value === b); A && media_chrome_listbox_privateMethod(this, ix, iL).call(this, A) } focus() { var b; null == (b = this.selectedOptions[0]) || b.focus() } enable() { this.addEventListener("click", media_chrome_listbox_privateGet(this, iA)), this.addEventListener("keydown", media_chrome_listbox_privateGet(this, iS)) } disable() { this.removeEventListener("click", media_chrome_listbox_privateGet(this, iA)), this.removeEventListener("keyup", media_chrome_listbox_privateGet(this, iw)) } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; "style" === b && D !== A ? media_chrome_listbox_privateMethod(this, iD, iI).call(this) : b === ee.MEDIA_CONTROLLER ? (A && (null == (V = null == (N = media_chrome_listbox_privateGet(this, ib)) ? void 0 : N.unassociateElement) || V.call(N, this), media_chrome_listbox_privateSet(this, ib, null)), D && this.isConnected && (media_chrome_listbox_privateSet(this, ib, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_chrome_listbox_privateGet(this, ib)) ? void 0 : Z.associateElement) || et.call(Z, this))) : "disabled" === b && D !== A && (null == D ? this.enable() : this.disable()) } connectedCallback() { var b, A, D; media_chrome_listbox_privateMethod(this, iD, iI).call(this), this.hasAttribute("disabled") || this.enable(), this.hasAttribute("role") || this.setAttribute("role", "listbox"); let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_chrome_listbox_privateSet(this, ib, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_chrome_listbox_privateGet(this, ib)) ? void 0 : A.associateElement) || D.call(A, this)) } disconnectedCallback() { var b, A; this.disable(), null == (A = null == (b = media_chrome_listbox_privateGet(this, ib)) ? void 0 : b.unassociateElement) || A.call(b, this), media_chrome_listbox_privateSet(this, ib, null) } get keysUsed() { return ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"] } handleSelection(b, A) { let D = media_chrome_listbox_privateMethod(this, iM, iC).call(this, b); D && media_chrome_listbox_privateMethod(this, ix, iL).call(this, D, A) } handleMovement(b) { let A; let { key: D } = b, N = this.options, V = media_chrome_listbox_privateMethod(this, iM, iC).call(this, b); switch (V || (V = N.filter(b => "0" === b.getAttribute("tabindex"))[0]), D) { case "ArrowDown": (null == (A = V.nextElementSibling) ? void 0 : A.hasAttribute("disabled")) && (A = A.nextElementSibling); break; case "ArrowUp": (null == (A = V.previousElementSibling) ? void 0 : A.hasAttribute("disabled")) && (A = A.previousElementSibling); break; case "Home": A = N[0]; break; case "End": A = N[N.length - 1]; break; default: A = media_chrome_listbox_privateMethod(this, iR, iO).call(this, D) }A && (N.forEach(b => b.setAttribute("tabindex", "-1")), A.setAttribute("tabindex", "0"), A.focus()) } handleClick(b) { let A = media_chrome_listbox_privateMethod(this, iM, iC).call(this, b); !A || A.hasAttribute("disabled") || (this.options.forEach(b => b.setAttribute("tabindex", "-1")), A.setAttribute("tabindex", "0"), this.handleSelection(b, this.hasAttribute("aria-multiselectable") && "true" === this.getAttribute("aria-multiselectable"))) } }; ib = new WeakMap, ig = new WeakMap, iE = new WeakMap, iy = new WeakMap, iA = new WeakMap, ik = new WeakSet, iT = function (b) { let { key: A } = b; "Enter" === A || " " === A ? this.handleSelection(b, this.hasAttribute("aria-multiselectable") && "true" === this.getAttribute("aria-multiselectable")) : this.handleMovement(b) }, iw = new WeakMap, iS = new WeakMap, iD = new WeakSet, iI = function () { var b; let A = this.shadowRoot.querySelector("#layout-row"), D = (null == (b = getComputedStyle(this).getPropertyValue("--media-listbox-layout")) ? void 0 : b.trim()) === "row"; A.setAttribute("media", D ? "" : "width:0") }, iM = new WeakSet, iC = function (b) { let A = b.composedPath(), D = A.findIndex(b => "MEDIA-CHROME-OPTION" === b.nodeName); return A[D] }, ix = new WeakSet, iL = function (b, A) { let D = [...this.selectedOptions]; this.hasAttribute("aria-multiselectable") && "true" === this.getAttribute("aria-multiselectable") || this.options.forEach(b => b.selected = !1), A ? b.selected = !b.selected : b.selected = !0, this.selectedOptions.some((b, A) => b != D[A]) && this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 })) }, iR = new WeakSet, iO = function (b) { media_chrome_listbox_privateMethod(this, iN, iP).call(this); let A = this.options, D = A.findIndex(b => "0" === b.getAttribute("tabindex")); media_chrome_listbox_privateSet(this, ig, media_chrome_listbox_privateGet(this, ig) + b); let N = media_chrome_listbox_privateGet(this, ig).split("").every(A => A === b), V = A.slice(D + (N ? 1 : 0)).filter(b => b.textContent.toLowerCase().startsWith(media_chrome_listbox_privateGet(this, ig))), Y = A.slice(0, D - (N ? 1 : 0)).filter(b => b.textContent.toLowerCase().startsWith(media_chrome_listbox_privateGet(this, ig))), Z = [], ee = []; N && (Z = A.slice(D + (N ? 1 : 0)).filter(A => A.textContent.startsWith(b)), ee = A.slice(0, D - (N ? 1 : 0)).filter(A => A.textContent.startsWith(b))); let et = [...V, ...Y, ...Z, ...ee]; return et[0] }, iN = new WeakSet, iP = function () { clearTimeout(media_chrome_listbox_privateGet(this, iE)), media_chrome_listbox_privateSet(this, iE, null), media_chrome_listbox_privateSet(this, iE, setTimeout(() => { media_chrome_listbox_privateSet(this, ig, ""), media_chrome_listbox_privateSet(this, iE, null) }, 500)) }, eg.customElements.get("media-chrome-listbox") || eg.customElements.define("media-chrome-listbox", MediaChromeListbox); var media_chrome_option_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_chrome_option_privateGet = (b, A, D) => (media_chrome_option_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_chrome_option_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_chrome_option_privateSet = (b, A, D, N) => (media_chrome_option_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_chrome_option_privateMethod = (b, A, D) => (media_chrome_option_accessCheck(b, A, "access private method"), D); let tI = eE.createElement("template"); tI.innerHTML = `
  <style>
    :host {
      cursor: pointer;
      display: block;
      line-height: revert;
      white-space: nowrap;
      white-space-collapse: collapse;
      text-wrap: nowrap;
      padding: .4em .5em;
      transition: var(--media-option-transition);
      outline: var(--media-option-outline, 0);
      outline-offset: var(--media-option-outline-offset, -1px);
    }
  
    :host(:focus-visible) {
      box-shadow: var(--media-option-focus-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));
      outline: var(--media-option-hover-outline, 0);
      outline-offset: var(--media-option-hover-outline-offset,  var(--media-option-outline-offset, -1px));
    }
  
    :host(:hover) {
      cursor: pointer;
      background: var(--media-option-hover-background, rgb(82 82 122 / .8));
      outline: var(--media-option-hover-outline);
      outline-offset: var(--media-option-hover-outline-offset,  var(--media-option-outline-offset, -1px));
    }
  
    :host([aria-selected="true"]) {
      background: var(--media-option-selected-background);
    }
  
    :host([disabled]) {
      pointer-events: none;
      color: rgba(255, 255, 255, .3);
    }
  </style>
  <slot></slot>
  `; let tM = { VALUE: "value", SELECTED: "selected", DISABLED: "disabled" }; let MediaChromeOption = class MediaChromeOption extends eg.HTMLElement { constructor() { super(), media_chrome_option_privateAdd(this, iW), media_chrome_option_privateAdd(this, iU, !1), media_chrome_option_privateAdd(this, iB, void 0), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(tI.content.cloneNode(!0))) } static get observedAttributes() { return [tM.DISABLED, tM.SELECTED, tM.VALUE] } get value() { var b; return null != (b = this.getAttribute(tM.VALUE)) ? b : this.text } set value(b) { this.setAttribute(tM.VALUE, b) } get text() { var b; return (null != (b = this.textContent) ? b : "").trim() } get selected() { return "true" === this.getAttribute("aria-selected") } set selected(b) { media_chrome_option_privateSet(this, iU, !0), this.setAttribute("aria-selected", b ? "true" : "false"), b ? this.part.add("option-selected") : this.part.remove("option-selected") } enable() { this.hasAttribute("tabindex") || this.setAttribute("tabindex", -1), this.hasAttribute("aria-selected") || this.setAttribute("aria-selected", "false") } disable() { this.removeAttribute("tabindex") } attributeChangedCallback(b, A, D) { b !== tM.SELECTED || media_chrome_option_privateGet(this, iU) ? b === tM.DISABLED && D !== A && (null == D ? this.enable() : this.disable()) : this.setAttribute("aria-selected", null != D ? "true" : "false") } connectedCallback() { this.hasAttribute(tM.DISABLED) || this.enable(), this.setAttribute("role", "option"), media_chrome_option_privateSet(this, iB, function closestOptionsContainer(b, A) { if (!b) return null; let { host: D } = b.getRootNode(); return !A && D ? closestOptionsContainer(b, D) : (null == A ? void 0 : A.options) ? A : closestOptionsContainer(A, null == A ? void 0 : A.parentNode) }(this, this.parentNode)), media_chrome_option_privateMethod(this, iW, iF).call(this) } disconnectedCallback() { this.disable(), media_chrome_option_privateMethod(this, iW, iF).call(this), media_chrome_option_privateSet(this, iB, null) } handleClick() { } }; iU = new WeakMap, iB = new WeakMap, iW = new WeakSet, iF = function () { var b; let A = null == (b = media_chrome_option_privateGet(this, iB)) ? void 0 : b.options; if (!A) return; let D = A.filter(b => "true" === b.getAttribute("aria-selected")).pop(); D || (D = A[0]), "true" !== media_chrome_option_privateGet(this, iB).getAttribute("aria-multiselectable") && A.forEach(b => { b.setAttribute("tabindex", "-1"), b.setAttribute("aria-selected", "false") }), null == D || D.setAttribute("tabindex", "0"), null == D || D.setAttribute("aria-selected", "true") }, eg.customElements.get("media-chrome-option") || eg.customElements.define("media-chrome-option", MediaChromeOption); var media_chrome_selectmenu_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_chrome_selectmenu_privateGet = (b, A, D) => (media_chrome_selectmenu_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_chrome_selectmenu_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_chrome_selectmenu_privateSet = (b, A, D, N) => (media_chrome_selectmenu_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_chrome_selectmenu_privateMethod = (b, A, D) => (media_chrome_selectmenu_accessCheck(b, A, "access private method"), D); let tC = eE.createElement("template"); tC.innerHTML = `
    <style>
    :host {
      font: var(--media-font,
        var(--media-font-weight, normal)
        var(--media-font-size, 15px) /
        var(--media-text-content-height, var(--media-control-height, 24px))
        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
      display: inline-flex;
      position: relative;
      flex-shrink: .5;
    }
  
    [name=listbox]::slotted(*),
    [part=listbox] {
      position: absolute;
      bottom: 100%;
      max-height: 300px;
      transition: var(--media-selectmenu-transition-in,
        visibility 0s, transform .15s ease-out, opacity .15s ease-out);
      transform: var(--media-listbox-transform-in, translateY(0) scale(1));
      visibility: visible;
      opacity: 1;
    }
  
    [name=listbox][hidden]::slotted(*),
    [hidden] [part=listbox] {
      transition: var(--media-selectmenu-transition-out,
        visibility .15s ease-out, transform .15s ease-out, opacity .15s ease-out);
      transform: var(--media-listbox-transform-out, translateY(2px) scale(.99));
      visibility: hidden;
      opacity: 0;
      pointer-events: none;
    }
  
    slot[name=listbox][hidden] {
      display: block;
    }
    </style>
  
    <slot name="button">
      <media-chrome-button aria-haspopup="listbox" part="button">
        <slot name="button-content"></slot>
      </media-chrome-button>
    </slot>
    <slot name="listbox" hidden>
      <media-chrome-listbox id="listbox" part="listbox">
        <slot></slot>
      </media-chrome-listbox>
    </slot>
  `; let MediaChromeSelectMenu = class MediaChromeSelectMenu extends eg.HTMLElement { constructor() { var b; super(), media_chrome_selectmenu_privateAdd(this, iz), media_chrome_selectmenu_privateAdd(this, iJ), media_chrome_selectmenu_privateAdd(this, i1), media_chrome_selectmenu_privateAdd(this, iH, void 0), media_chrome_selectmenu_privateAdd(this, iG, void 0), media_chrome_selectmenu_privateAdd(this, iV, void 0), media_chrome_selectmenu_privateAdd(this, ij, void 0), media_chrome_selectmenu_privateAdd(this, iq, void 0), media_chrome_selectmenu_privateAdd(this, i$, b => { let { key: A } = b; if (!this.keysUsed.includes(A)) { this.removeEventListener("keyup", media_chrome_selectmenu_privateGet(this, i$)); return } let D = b.composedPath().includes(media_chrome_selectmenu_privateGet(this, iG)); D && ("Enter" === A || " " === A) ? media_chrome_selectmenu_privateMethod(this, iz, iX).call(this) : "Escape" === A && media_chrome_selectmenu_privateMethod(this, i1, i2).call(this) }), media_chrome_selectmenu_privateAdd(this, iY, b => { let { metaKey: A, altKey: D, key: N } = b; if (A || D || !this.keysUsed.includes(N)) { this.removeEventListener("keyup", media_chrome_selectmenu_privateGet(this, i$)); return } b.preventDefault(), this.addEventListener("keyup", media_chrome_selectmenu_privateGet(this, i$), { once: !0 }) }), media_chrome_selectmenu_privateAdd(this, iK, b => { b.composedPath().includes(this) || media_chrome_selectmenu_privateMethod(this, i1, i2).call(this) }), media_chrome_selectmenu_privateAdd(this, iZ, b => { b.composedPath().includes(media_chrome_selectmenu_privateGet(this, iG)) && media_chrome_selectmenu_privateMethod(this, iz, iX).call(this) }), media_chrome_selectmenu_privateAdd(this, iQ, () => { media_chrome_selectmenu_privateMethod(this, i1, i2).call(this) }), media_chrome_selectmenu_privateAdd(this, i5, () => { if (0 === media_chrome_selectmenu_privateGet(this, ij).offsetWidth) return; let b = media_chrome_selectmenu_privateGet(this, ij).offsetWidth, A = media_chrome_selectmenu_privateGet(this, iG).getBoundingClientRect(); if (this.hasAttribute("mediacontroller") || media_chrome_selectmenu_privateGet(this, iG).hasAttribute("mediacontroller") || media_chrome_selectmenu_privateGet(this, ij).hasAttribute("mediacontroller")) { media_chrome_selectmenu_privateGet(this, ij).style.zIndex = "1", media_chrome_selectmenu_privateGet(this, ij).style.bottom = "unset", media_chrome_selectmenu_privateGet(this, ij).style.right = null, media_chrome_selectmenu_privateGet(this, ij).style.left = "0", media_chrome_selectmenu_privateGet(this, ij).style.top = `${A.height}px`; return } let D = getBoundsElement(this), N = D.getBoundingClientRect(), V = A.x + b, Y = Math.max(A.right - V, A.right - N.right); media_chrome_selectmenu_privateGet(this, ij).style.left = null, media_chrome_selectmenu_privateGet(this, ij).style.right = `${Y}px`, media_chrome_selectmenu_privateGet(this, ij).style.maxHeight = `${N.height - A.height}px` }), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(tC.content.cloneNode(!0))); let { style: A } = getOrInsertCSSRule(this.shadowRoot, ":host"); A.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`), null == (b = this.init) || b.call(this), media_chrome_selectmenu_privateSet(this, iG, this.shadowRoot.querySelector("[part=button]")), media_chrome_selectmenu_privateSet(this, ij, this.shadowRoot.querySelector("[part=listbox]")), media_chrome_selectmenu_privateSet(this, iV, this.shadowRoot.querySelector("slot[name=button]")), media_chrome_selectmenu_privateGet(this, iV).addEventListener("slotchange", () => { let b = media_chrome_selectmenu_privateGet(this, iV).assignedElements()[0]; if (!b) return; media_chrome_selectmenu_privateSet(this, iG, b), media_chrome_selectmenu_privateGet(this, iG).preventClick = !0; let A = this.hasAttribute("disabled") || media_chrome_selectmenu_privateGet(this, iG).hasAttribute("disabled"); A ? this.disable() : (this.enable(), media_chrome_selectmenu_privateGet(this, iG).setAttribute("aria-haspopup", "listbox")) }), media_chrome_selectmenu_privateSet(this, iq, this.shadowRoot.querySelector("slot[name=listbox]")), media_chrome_selectmenu_privateGet(this, iq).addEventListener("slotchange", () => { media_chrome_selectmenu_privateSet(this, ij, media_chrome_selectmenu_privateGet(this, iq).assignedElements()[0] || media_chrome_selectmenu_privateGet(this, ij)) }) } static get observedAttributes() { return ["disabled", ee.MEDIA_CONTROLLER] } enable() { media_chrome_selectmenu_privateGet(this, iG).toggleAttribute("disabled", !1), this.addEventListener("change", media_chrome_selectmenu_privateGet(this, iQ)), this.addEventListener("keydown", media_chrome_selectmenu_privateGet(this, iY)), this.addEventListener("click", media_chrome_selectmenu_privateGet(this, iZ)), eE.addEventListener("click", media_chrome_selectmenu_privateGet(this, iK)) } disable() { media_chrome_selectmenu_privateGet(this, iG).toggleAttribute("disabled", !0), this.removeEventListener("change", media_chrome_selectmenu_privateGet(this, iQ)), this.removeEventListener("keydown", media_chrome_selectmenu_privateGet(this, iY)), this.removeEventListener("keyup", media_chrome_selectmenu_privateGet(this, i$)), this.removeEventListener("click", media_chrome_selectmenu_privateGet(this, iZ)), eE.removeEventListener("click", media_chrome_selectmenu_privateGet(this, iK)) } attributeChangedCallback(b, A, D) { var N, V, Y, Z, et; b === ee.MEDIA_CONTROLLER ? (A && (null == (V = null == (N = media_chrome_selectmenu_privateGet(this, iH)) ? void 0 : N.unassociateElement) || V.call(N, this), media_chrome_selectmenu_privateSet(this, iH, null), media_chrome_selectmenu_privateGet(this, ij).removeAttribute(ee.MEDIA_CONTROLLER)), D && this.isConnected && (media_chrome_selectmenu_privateSet(this, iH, null == (Y = this.getRootNode()) ? void 0 : Y.getElementById(D)), null == (et = null == (Z = media_chrome_selectmenu_privateGet(this, iH)) ? void 0 : Z.associateElement) || et.call(Z, this), media_chrome_selectmenu_privateGet(this, ij).setAttribute(ee.MEDIA_CONTROLLER, D))) : "disabled" === b && D !== A && (null == D ? this.enable() : this.disable()) } connectedCallback() { var b, A, D; let N = this.getAttribute(ee.MEDIA_CONTROLLER); N && (media_chrome_selectmenu_privateSet(this, iH, null == (b = this.getRootNode()) ? void 0 : b.getElementById(N)), null == (D = null == (A = media_chrome_selectmenu_privateGet(this, iH)) ? void 0 : A.associateElement) || D.call(A, this), media_chrome_selectmenu_privateGet(this, ij).setAttribute(ee.MEDIA_CONTROLLER, N)), this.hasAttribute("disabled") || this.enable(), media_chrome_selectmenu_privateGet(this, iq).hidden || observeResize(getBoundsElement(this), media_chrome_selectmenu_privateGet(this, i5)) } disconnectedCallback() { var b, A; unobserveResize(getBoundsElement(this), media_chrome_selectmenu_privateGet(this, i5)), this.disable(), null == (A = null == (b = media_chrome_selectmenu_privateGet(this, iH)) ? void 0 : b.unassociateElement) || A.call(b, this), media_chrome_selectmenu_privateSet(this, iH, null), media_chrome_selectmenu_privateGet(this, ij).removeAttribute(ee.MEDIA_CONTROLLER) } get keysUsed() { return ["Enter", "Escape", " ", "ArrowUp", "ArrowDown", "f", "c", "k", "m"] } }; function getBoundsElement(b) { var A; return null != (A = b.getAttribute("bounds") ? closestComposedNode(b, `#${b.getAttribute("bounds")}`) : function (b) { var A; let D = b.getAttribute(ee.MEDIA_CONTROLLER); return D ? null == (A = b.getRootNode()) ? void 0 : A.getElementById(D) : closestComposedNode(b, "media-controller") }(b) || b.parentElement) ? A : b } iH = new WeakMap, iG = new WeakMap, iV = new WeakMap, ij = new WeakMap, iq = new WeakMap, i$ = new WeakMap, iY = new WeakMap, iK = new WeakMap, iZ = new WeakMap, iQ = new WeakMap, iz = new WeakSet, iX = function () { media_chrome_selectmenu_privateGet(this, iq).hidden ? media_chrome_selectmenu_privateMethod(this, iJ, i0).call(this) : media_chrome_selectmenu_privateMethod(this, i1, i2).call(this) }, iJ = new WeakSet, i0 = function () { media_chrome_selectmenu_privateGet(this, iq).hidden && (media_chrome_selectmenu_privateGet(this, iq).hidden = !1, media_chrome_selectmenu_privateGet(this, iG).setAttribute("aria-expanded", "true"), media_chrome_selectmenu_privateGet(this, i5).call(this), media_chrome_selectmenu_privateGet(this, ij).focus(), observeResize(getBoundsElement(this), media_chrome_selectmenu_privateGet(this, i5))) }, i1 = new WeakSet, i2 = function () { if (media_chrome_selectmenu_privateGet(this, iq).hidden) return; unobserveResize(getBoundsElement(this), media_chrome_selectmenu_privateGet(this, i5)); let b = function getActiveElement(b = document) { var A; let D = null == b ? void 0 : b.activeElement; return D ? null != (A = getActiveElement(D.shadowRoot)) ? A : D : null }(); media_chrome_selectmenu_privateGet(this, iq).hidden = !0, media_chrome_selectmenu_privateGet(this, iG).setAttribute("aria-expanded", "false"), containsComposedNode(media_chrome_selectmenu_privateGet(this, ij), b) && media_chrome_selectmenu_privateGet(this, iG).focus() }, i5 = new WeakMap, eg.customElements.get("media-chrome-selectmenu") || eg.customElements.define("media-chrome-selectmenu", MediaChromeSelectMenu); var media_captions_listbox_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_captions_listbox_privateGet = (b, A, D) => (media_captions_listbox_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_captions_listbox_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_captions_listbox_privateSet = (b, A, D, N) => (media_captions_listbox_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_captions_listbox_privateMethod = (b, A, D) => (media_captions_listbox_accessCheck(b, A, "access private method"), D); let tx = `
  <svg aria-hidden="true" viewBox="0 0 26 24" part="captions-indicator indicator">
    <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>
  </svg>`, tL = eE.createElement("template"); tL.innerHTML = `
    <slot name="captions-indicator" hidden>${tx}</slot>
  `, i3 = new WeakMap, i4 = new WeakSet, i7 = function () { var b; if (media_captions_listbox_privateGet(this, i3) === JSON.stringify(this.mediaSubtitlesList)) return; media_captions_listbox_privateSet(this, i3, JSON.stringify(this.mediaSubtitlesList)); let A = this.shadowRoot.querySelector("#container"); A.textContent = ""; let D = !this.value, N = createOption(this.formatOptionText("Off"), "off", D); N.prepend(createIndicator(this, "select-indicator")), A.append(N); let V = this.mediaSubtitlesList; for (let D of V) { let N = createOption(this.formatOptionText(D.label, D), formatTextTrackObj(D), this.value == formatTextTrackObj(D)); N.prepend(createIndicator(this, "select-indicator")); let V = null != (b = D.kind) ? b : "subs"; "captions" === V && N.append(createIndicator(this, "captions-indicator")), A.append(N) } }, i8 = new WeakSet, i6 = function () { let b = this.mediaSubtitlesShowing, A = this.getAttribute(er.MEDIA_SUBTITLES_SHOWING), D = this.value !== A; if ((null == b ? void 0 : b.length) && D && this.dispatchEvent(new eg.CustomEvent(Z.MEDIA_DISABLE_SUBTITLES_REQUEST, { composed: !0, bubbles: !0, detail: b })), !this.value || !D) return; let N = new eg.CustomEvent(Z.MEDIA_SHOW_SUBTITLES_REQUEST, { composed: !0, bubbles: !0, detail: this.value }); this.dispatchEvent(N) }; let media_captions_listbox_getSubtitlesListAttr = (b, A) => { let D = b.getAttribute(A); return D ? parseTextTracksStr(D) : [] }, media_captions_listbox_setSubtitlesListAttr = (b, A, D) => { if (!(null == D ? void 0 : D.length)) { b.removeAttribute(A); return } let N = stringifyTextTrackList(D), V = b.getAttribute(A); V !== N && b.setAttribute(A, N) }; eg.customElements.get("media-captions-listbox") || eg.customElements.define("media-captions-listbox", class extends MediaChromeListbox { constructor() { super({ slotTemplate: tL }), media_captions_listbox_privateAdd(this, i4), media_captions_listbox_privateAdd(this, i8), media_captions_listbox_privateAdd(this, i3, void 0) } static get observedAttributes() { return [...super.observedAttributes, "aria-multiselectable", er.MEDIA_SUBTITLES_LIST, er.MEDIA_SUBTITLES_SHOWING] } attributeChangedCallback(b, A, D) { super.attributeChangedCallback(b, A, D), b === er.MEDIA_SUBTITLES_LIST && A !== D ? media_captions_listbox_privateMethod(this, i4, i7).call(this) : b === er.MEDIA_SUBTITLES_SHOWING && A !== D ? this.value = D : "aria-multiselectable" === b && (this.removeAttribute("aria-multiselectable"), console.warn("Captions List doesn't currently support multiple selections. You can enable multiple items via the media.textTracks API.")) } connectedCallback() { super.connectedCallback(), this.addEventListener("change", media_captions_listbox_privateMethod(this, i8, i6)) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("change", media_captions_listbox_privateMethod(this, i8, i6)) } get mediaSubtitlesList() { return media_captions_listbox_getSubtitlesListAttr(this, er.MEDIA_SUBTITLES_LIST) } set mediaSubtitlesList(b) { media_captions_listbox_setSubtitlesListAttr(this, er.MEDIA_SUBTITLES_LIST, b) } get mediaSubtitlesShowing() { return media_captions_listbox_getSubtitlesListAttr(this, er.MEDIA_SUBTITLES_SHOWING) } set mediaSubtitlesShowing(b) { media_captions_listbox_setSubtitlesListAttr(this, er.MEDIA_SUBTITLES_SHOWING, b) } }), eg.customElements.get("media-captions-selectmenu") || eg.customElements.define("media-captions-selectmenu", class extends MediaChromeSelectMenu { init() { let b = eE.createElement("media-captions-button"); b.part.add("button"), b.preventClick = !0; let A = eE.createElement("media-captions-listbox"); A.part.add("listbox"), A.setAttribute("exportparts", "option, option-selected, indicator"); let D = this.shadowRoot.querySelector("slot[name=button]"), N = this.shadowRoot.querySelector("slot[name=listbox]"); D.textContent = "", N.textContent = "", D.append(b), N.append(A) } }); var media_playback_rate_listbox_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_playback_rate_listbox_privateGet = (b, A, D) => (media_playback_rate_listbox_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_playback_rate_listbox_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_playback_rate_listbox_privateMethod = (b, A, D) => (media_playback_rate_listbox_accessCheck(b, A, "access private method"), D); let tR = { RATES: "rates" }; i9 = new WeakMap, rt = new WeakSet, ra = function () { let b = this.shadowRoot.querySelector("#container"); for (let A of (b.textContent = "", this.rates)) { let D = createOption(this.formatOptionText(`${A}x`, A), A, this.mediaPlaybackRate == A); D.prepend(createIndicator(this, "select-indicator")), b.append(D) } }, ri = new WeakSet, rr = function () { if (!this.value) return; let b = new eg.CustomEvent(Z.MEDIA_PLAYBACK_RATE_REQUEST, { composed: !0, bubbles: !0, detail: this.value }); this.dispatchEvent(b) }, eg.customElements.get("media-playback-rate-listbox") || eg.customElements.define("media-playback-rate-listbox", class extends MediaChromeListbox { constructor() { super(), media_playback_rate_listbox_privateAdd(this, rt), media_playback_rate_listbox_privateAdd(this, ri), media_playback_rate_listbox_privateAdd(this, i9, new AttributeTokenList(this, tR.RATES, { defaultValue: tv })), media_playback_rate_listbox_privateMethod(this, rt, ra).call(this) } static get observedAttributes() { return [...super.observedAttributes, "aria-multiselectable", er.MEDIA_PLAYBACK_RATE, tR.RATES] } attributeChangedCallback(b, A, D) { super.attributeChangedCallback(b, A, D), b === er.MEDIA_PLAYBACK_RATE && A != D ? this.value = D : b === tR.RATES && A != D && (media_playback_rate_listbox_privateGet(this, i9).value = D, media_playback_rate_listbox_privateMethod(this, rt, ra).call(this)) } get rates() { return media_playback_rate_listbox_privateGet(this, i9) } set rates(b) { b ? Array.isArray(b) && (media_playback_rate_listbox_privateGet(this, i9).value = b.join(" ")) : media_playback_rate_listbox_privateGet(this, i9).value = "", media_playback_rate_listbox_privateMethod(this, rt, ra).call(this) } get mediaPlaybackRate() { return getNumericAttr(this, er.MEDIA_PLAYBACK_RATE, 1) } set mediaPlaybackRate(b) { setNumericAttr(this, er.MEDIA_PLAYBACK_RATE, b) } connectedCallback() { super.connectedCallback(), this.addEventListener("change", media_playback_rate_listbox_privateMethod(this, ri, rr)) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("change", media_playback_rate_listbox_privateMethod(this, ri, rr)) } }), eg.customElements.get("media-playback-rate-selectmenu") || eg.customElements.define("media-playback-rate-selectmenu", class extends MediaChromeSelectMenu { init() { let b = eE.createElement("media-playback-rate-button"); b.part.add("button"), b.preventClick = !0; let A = eE.createElement("media-playback-rate-listbox"); A.part.add("listbox"), A.setAttribute("exportparts", "option, option-selected, indicator"); let D = this.shadowRoot.querySelector("slot[name=button]"), N = this.shadowRoot.querySelector("slot[name=listbox]"); D.textContent = "", N.textContent = "", D.append(b), N.append(A) } }); var media_rendition_listbox_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_rendition_listbox_privateGet = (b, A, D) => (media_rendition_listbox_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_rendition_listbox_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_rendition_listbox_privateSet = (b, A, D, N) => (media_rendition_listbox_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_rendition_listbox_privateMethod = (b, A, D) => (media_rendition_listbox_accessCheck(b, A, "access private method"), D); rn = new WeakMap, ro = new WeakMap, rs = new WeakSet, rl = function () { if (media_rendition_listbox_privateGet(this, ro) === JSON.stringify(this.mediaRenditionList)) return; media_rendition_listbox_privateSet(this, ro, JSON.stringify(this.mediaRenditionList)); let b = this.mediaRenditionList.sort((b, A) => A.height - b.height), A = this.shadowRoot.querySelector("#container"); A.textContent = ""; let D = !this.mediaRenditionSelected; for (let N of b) { let b = this.formatOptionText(`${Math.min(N.width, N.height)}p`, N), V = createOption(b, `${N.id}`, N.selected && !D); V.prepend(createIndicator(this, "select-indicator")), A.append(V) } let N = createOption(this.formatOptionText("Auto"), "auto", D); N.prepend(createIndicator(this, "select-indicator")), A.append(N) }, rd = new WeakSet, ru = function () { if (null == this.value) return; let b = new eg.CustomEvent(Z.MEDIA_RENDITION_REQUEST, { composed: !0, bubbles: !0, detail: this.value }); this.dispatchEvent(b) }, eg.customElements.get("media-rendition-listbox") || eg.customElements.define("media-rendition-listbox", class extends MediaChromeListbox { constructor() { super(...arguments), media_rendition_listbox_privateAdd(this, rs), media_rendition_listbox_privateAdd(this, rd), media_rendition_listbox_privateAdd(this, rn, []), media_rendition_listbox_privateAdd(this, ro, void 0) } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_RENDITION_LIST, er.MEDIA_RENDITION_SELECTED] } attributeChangedCallback(b, A, D) { (super.attributeChangedCallback(b, A, D), b === er.MEDIA_RENDITION_SELECTED && A !== D) ? this.value = null != D ? D : "auto" : b === er.MEDIA_RENDITION_LIST && A !== D && (media_rendition_listbox_privateSet(this, rn, null == D ? void 0 : D.split(/\s+/).map(parseRendition)), media_rendition_listbox_privateMethod(this, rs, rl).call(this)) } connectedCallback() { super.connectedCallback(), this.addEventListener("change", media_rendition_listbox_privateMethod(this, rd, ru)) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("change", media_rendition_listbox_privateMethod(this, rd, ru)) } get mediaRenditionList() { return media_rendition_listbox_privateGet(this, rn) } set mediaRenditionList(b) { media_rendition_listbox_privateSet(this, rn, b), media_rendition_listbox_privateMethod(this, rs, rl).call(this) } get mediaRenditionSelected() { return getStringAttr(this, er.MEDIA_RENDITION_SELECTED) } set mediaRenditionSelected(b) { setStringAttr(this, er.MEDIA_RENDITION_SELECTED, b) } }); let tO = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M13.5 2.5h2v6h-2v-2h-11v-2h11v-2Zm4 2h4v2h-4v-2Zm-12 4h2v6h-2v-2h-3v-2h3v-2Zm4 2h12v2h-12v-2Zm1 4h2v6h-2v-2h-8v-2h8v-2Zm4 2h7v2h-7v-2Z" />
  </svg>`, tN = eE.createElement("template"); tN.innerHTML = `
    <slot name="icon">${tO}</slot>
  `, eg.customElements.get("media-rendition-button") || eg.customElements.define("media-rendition-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_RENDITION_SELECTED, er.MEDIA_RENDITION_UNAVAILABLE] } constructor() { super({ slotTemplate: tN }) } get mediaRenditionSelected() { return getStringAttr(this, er.MEDIA_RENDITION_SELECTED) } set mediaRenditionSelected(b) { setStringAttr(this, er.MEDIA_RENDITION_SELECTED, b) } }), eg.customElements.get("media-rendition-selectmenu") || eg.customElements.define("media-rendition-selectmenu", class extends MediaChromeSelectMenu { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_RENDITION_SELECTED, er.MEDIA_RENDITION_UNAVAILABLE] } init() { let b = eE.createElement("media-rendition-button"); b.part.add("button"), b.preventClick = !0; let A = eE.createElement("media-rendition-listbox"); A.part.add("listbox"), A.setAttribute("exportparts", "option, option-selected, indicator"); let D = this.shadowRoot.querySelector("slot[name=button]"), N = this.shadowRoot.querySelector("slot[name=listbox]"); D.textContent = "", N.textContent = "", D.append(b), N.append(A) } }); var media_audio_track_listbox_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_audio_track_listbox_privateGet = (b, A, D) => (media_audio_track_listbox_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_audio_track_listbox_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_audio_track_listbox_privateSet = (b, A, D, N) => (media_audio_track_listbox_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_audio_track_listbox_privateMethod = (b, A, D) => (media_audio_track_listbox_accessCheck(b, A, "access private method"), D); rc = new WeakMap, rm = new WeakMap, rh = new WeakSet, rp = function () { if (media_audio_track_listbox_privateGet(this, rm) === JSON.stringify(this.mediaAudioTrackList)) return; media_audio_track_listbox_privateSet(this, rm, JSON.stringify(this.mediaAudioTrackList)); let b = this.mediaAudioTrackList, A = this.shadowRoot.querySelector("#container"); for (let D of (A.textContent = "", b)) { let b = this.formatOptionText(D.label, D), N = createOption(b, `${D.id}`, D.enabled); N.prepend(createIndicator(this, "select-indicator")), A.append(N) } }, rv = new WeakSet, r_ = function () { if (null == this.value) return; let b = new eg.CustomEvent(Z.MEDIA_AUDIO_TRACK_REQUEST, { composed: !0, bubbles: !0, detail: this.value }); this.dispatchEvent(b) }, eg.customElements.get("media-audio-track-listbox") || eg.customElements.define("media-audio-track-listbox", class extends MediaChromeListbox { constructor() { super(...arguments), media_audio_track_listbox_privateAdd(this, rh), media_audio_track_listbox_privateAdd(this, rv), media_audio_track_listbox_privateAdd(this, rc, []), media_audio_track_listbox_privateAdd(this, rm, void 0) } static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_AUDIO_TRACK_LIST, er.MEDIA_AUDIO_TRACK_ENABLED] } attributeChangedCallback(b, A, D) { (super.attributeChangedCallback(b, A, D), b === er.MEDIA_AUDIO_TRACK_ENABLED && A !== D) ? this.value = D : b === er.MEDIA_AUDIO_TRACK_LIST && A !== D && (media_audio_track_listbox_privateSet(this, rc, null == D ? void 0 : D.split(/\s+/).map(parseAudioTrack)), media_audio_track_listbox_privateMethod(this, rh, rp).call(this)) } connectedCallback() { super.connectedCallback(), this.addEventListener("change", media_audio_track_listbox_privateMethod(this, rv, r_)) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("change", media_audio_track_listbox_privateMethod(this, rv, r_)) } get mediaAudioTrackList() { return media_audio_track_listbox_privateGet(this, rc) } set mediaAudioTrackList(b) { media_audio_track_listbox_privateSet(this, rc, b), media_audio_track_listbox_privateMethod(this, rh, rp).call(this) } get mediaAudioTrackEnabled() { return getStringAttr(this, er.MEDIA_AUDIO_TRACK_ENABLED) } set mediaAudioTrackEnabled(b) { setStringAttr(this, er.MEDIA_AUDIO_TRACK_ENABLED, b) } }); let tP = `<svg aria-hidden="true" viewBox="0 0 24 24">
    <path d="M11 17H9.5V7H11v10Zm-3-3H6.5v-4H8v4Zm6-5h-1.5v6H14V9Zm3 7h-1.5V8H17v8Z"/>
    <path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-2 0a8 8 0 1 0-16 0 8 8 0 0 0 16 0Z"/>
  </svg>`, tU = eE.createElement("template"); tU.innerHTML = `
    <slot name="icon">${tP}</slot>
  `, eg.customElements.get("media-audio-track-button") || eg.customElements.define("media-audio-track-button", class extends MediaChromeButton { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_AUDIO_TRACK_ENABLED, er.MEDIA_AUDIO_TRACK_UNAVAILABLE] } constructor() { super({ slotTemplate: tU }) } get mediaAudioTrackEnabled() { return getStringAttr(this, er.MEDIA_AUDIO_TRACK_ENABLED) } set mediaAudioTrackEnabled(b) { setStringAttr(this, er.MEDIA_AUDIO_TRACK_ENABLED, b) } }), eg.customElements.get("media-audio-track-selectmenu") || eg.customElements.define("media-audio-track-selectmenu", class extends MediaChromeSelectMenu { static get observedAttributes() { return [...super.observedAttributes, er.MEDIA_AUDIO_TRACK_ENABLED, er.MEDIA_AUDIO_TRACK_UNAVAILABLE] } init() { let b = eE.createElement("media-audio-track-button"); b.part.add("button"), b.preventClick = !0; let A = eE.createElement("media-audio-track-listbox"); A.part.add("listbox"), A.setAttribute("exportparts", "option, option-selected, indicator"); let D = this.shadowRoot.querySelector("slot[name=button]"), N = this.shadowRoot.querySelector("slot[name=listbox]"); D.textContent = "", N.textContent = "", D.append(b), N.append(A) } }); var tB = D(5943), tW = D(94836).ZP, tF = class extends Error { constructor(b, A = tF.MEDIA_ERR_CUSTOM, D, N) { var V; super(b), this.name = "MediaError", this.code = A, this.context = N, this.fatal = null != D ? D : A >= tF.MEDIA_ERR_NETWORK && A <= tF.MEDIA_ERR_ENCRYPTED, this.message || (this.message = null != (V = tF.defaultMessages[this.code]) ? V : "") } }; tF.MEDIA_ERR_ABORTED = 1, tF.MEDIA_ERR_NETWORK = 2, tF.MEDIA_ERR_DECODE = 3, tF.MEDIA_ERR_SRC_NOT_SUPPORTED = 4, tF.MEDIA_ERR_ENCRYPTED = 5, tF.MEDIA_ERR_CUSTOM = 100, tF.defaultMessages = { 1: "You aborted the media playback", 2: "A network error caused the media download to fail.", 3: "A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.", 4: "An unsupported error occurred. The server or network failed, or your browser does not support this format.", 5: "The media is encrypted and there are no keys to decrypt it." }; var ue = b => null == b, I = (b, A) => !ue(A) && b in A, tH = { ANY: "any", MUTED: "muted" }, tG = { ON_DEMAND: "on-demand", LIVE: "live", UNKNOWN: "unknown" }, tV = { MSE: "mse", NATIVE: "native" }, tj = { HEADER: "header", QUERY: "query", NONE: "none" }, tq = Object.values(tj), t$ = { M3U8: "application/vnd.apple.mpegurl", MP4: "video/mp4" }, tY = { HLS: t$.M3U8 }; Object.keys(tY), [...Object.values(t$)]; var M = (b, A, D, N, V = b) => { V.addEventListener(A, D, N), b.addEventListener("teardown", () => { V.removeEventListener(A, D) }, { once: !0 }) }, F = b => { let A = b.indexOf("?"); return A < 0 ? [b] : [b.slice(0, A), b.slice(A)] }, L = b => { let A = b.type; if (A) { let b = A.toUpperCase(); return I(b, tY) ? tY[b] : A } let { src: D } = b; return D ? pe(D) : "" }, h = b => "VOD" === b ? tG.ON_DEMAND : tG.LIVE, w = b => "EVENT" === b ? Number.POSITIVE_INFINITY : "VOD" === b ? Number.NaN : 0, pe = b => { let A = ""; try { A = new URL(b).pathname } catch { console.error("invalid url") } let D = A.lastIndexOf("."); if (D < 0) return ""; let N = A.slice(D + 1).toUpperCase(); return I(N, t$) ? t$[N] : "" }, tK = Object.values(tH), W = b => "boolean" == typeof b || "string" == typeof b && tK.includes(b), B = ({ autoplay: b }, A, D) => { let N = !1, V = !1, Y = W(b) ? b : !!b, s = () => { N || M(A, "playing", () => { N = !0 }, { once: !0 }) }; if (s(), M(A, "loadstart", () => { N = !1, s(), H(A, Y) }, { once: !0 }), M(A, "loadstart", () => { D || (V = !Number.isFinite(A.duration)), H(A, Y) }, { once: !0 }), D && D.once(tW.Events.LEVEL_LOADED, (b, A) => { var D; V = null != (D = A.details.live) && D }), !Y) { let d = () => { !V || (null != D && D.liveSyncPosition ? A.currentTime = D.liveSyncPosition : Number.isFinite(A.seekable.end(0)) && (A.currentTime = A.seekable.end(0))) }; D && M(A, "play", () => { "metadata" === A.preload ? D.once(tW.Events.LEVEL_UPDATED, d) : d() }, { once: !0 }) } return b => { N || H(A, Y = W(b) ? b : !!b) } }, H = (b, A) => { if (!A) return; let D = b.muted, r = () => b.muted = D; switch (A) { case tH.ANY: b.play().catch(() => { b.muted = !0, b.play().catch(r) }); break; case tH.MUTED: b.muted = !0, b.play().catch(r); break; default: b.play().catch(() => { }) } }, K = ({ preload: b, src: A }, D, N) => { let o = b => { null != b && ["", "none", "metadata", "auto"].includes(b) ? D.setAttribute("preload", b) : D.removeAttribute("preload") }; if (!N) return o(b), o; let V = !1, Y = !1, Z = N.config.maxBufferLength, ee = N.config.maxBufferSize, c = b => { o(b); let A = null != b ? b : D.preload; Y || "none" === A || ("metadata" === A ? (N.config.maxBufferLength = 1, N.config.maxBufferSize = 1) : (N.config.maxBufferLength = Z, N.config.maxBufferSize = ee), p()) }, p = () => { !V && A && (V = !0, N.loadSource(A)) }; return M(D, "play", () => { Y = !0, N.config.maxBufferLength = Z, N.config.maxBufferSize = ee, p() }, { once: !0 }), c(b), c }; function _(b, A, D, N, V) { let Y = document.createElement("track"); return Y.kind = A, Y.label = D, N && (Y.srclang = N), V && (Y.id = V), Y.track.mode = ["subtitles", "captions"].includes(A) ? "disabled" : "hidden", Y.setAttribute("data-removeondestroy", ""), b.append(Y), Y.track } var tZ = "cuepoints", tQ = Object.freeze({ label: tZ }), C = (b, { label: A = tZ } = tQ) => { var D; return null == (D = Array.from(b.querySelectorAll("track")).find(b => b.track.label === A && "metadata" === b.track.kind)) ? void 0 : D.track }; async function $(b, A, D = tQ) { let N = C(b, D); if (!N) { let { label: A = tZ } = D; (N = _(b, "metadata", A)).mode = "hidden", await new Promise(b => setTimeout(() => b(void 0), 0)) } return "hidden" !== N.mode && (N.mode = "hidden"), [...A].sort(({ time: b }, { time: A }) => A - b).forEach(({ time: A, value: D }) => { var V, Y; let Z = Array.prototype.findIndex.call(null == N ? void 0 : N.cues, b => b.startTime >= A), ee = null == (V = null == N ? void 0 : N.cues) ? void 0 : V[Z], et = ee ? ee.startTime : Number.isFinite(b.duration) ? b.duration : Number.MAX_SAFE_INTEGER, ea = null == (Y = null == N ? void 0 : N.cues) ? void 0 : Y[Z - 1]; ea && (ea.endTime = A); let er = new VTTCue(A, et, JSON.stringify(null != D ? D : null)); N.addCue(er) }), N } var z = b => ({ time: b.startTime, value: JSON.parse(b.text) }); function X(b, A = { label: tZ }) { var D, N; let V = C(b, A); if (!(null != (D = null == V ? void 0 : V.activeCues) && D.length)) return; let { currentTime: Y } = b; return z(Array.prototype.find.call(null != (N = V.activeCues) ? N : [], ({ startTime: b, endTime: A }) => b <= Y && A > Y)) } async function G(b, A = tQ) { return new Promise(D => { M(b, "loadstart", async () => { let N = await $(b, [], A); M(b, "cuechange", () => { let A = X(b); if (A) { let D = new CustomEvent("cuepointchange", { composed: !0, bubbles: !0, detail: A }); b.dispatchEvent(D) } }, {}, N), D(N) }) }) } var tz, tX, tJ, t0, t1, t2, t5, t3, t4, t7, t8, t6, t9, at, aa, ai, ar, an, ao, as, al, ad, au, ac, am, ah, ap, av, a_, af, ab, ag, aE, ay, aA, ak, aT, aw, aS, aD, aI, aM, aC, ax, aL, aR, aO, aN, aP, aU, aB, aW, aF, aH, aG, aV, aj, aq, a$, aY, aK, aZ, aQ, az, aX, aJ, a0, a1, a2, a5, a3, a4, a7, a8, a6, a9, ia, ii, ir, io, is, il, id, iu, ic, im, ih, ip, iv, i_, ib, ig, iE, iy, iA, ik, iT, iw, iS, iD, iI, iM, iC, ix, iL, iR, iO, iN, iP, iU, iB, iW, iF, iH, iG, iV, ij, iq, i$, iY, iK, iZ, iQ, iz, iX, iJ, i0, i1, i2, i5, i3, i4, i7, i8, i6, i9, rt, ra, ri, rr, rn, ro, rs, rl, rd, ru, rc, rm, rh, rp, rv, r_, rf, rb, rg, ge = async b => fetch(b).then(b => b.text()).then(b => {
      let A = b.split(`
  `).find((b, A, D) => A && D[A - 1].startsWith("#EXT-X-STREAM-INF")); return fetch(A).then(b => b.text()).then(b => b.split(`
  `))
    }), Me = b => { var A, D, N; let V = null == (D = (null != (A = b.find(b => b.startsWith("#EXT-X-PLAYLIST-TYPE"))) ? A : "").split(":")[1]) ? void 0 : D.trim(), Y = h(V), Z = w(V), ee; if (Y === tG.LIVE) { let A = b.find(b => b.startsWith("#EXT-X-PART-INF")); if (A) ee = 2 * +A.split(":")[1].split("=")[1]; else { let A = b.find(b => b.startsWith("#EXT-X-TARGETDURATION")), D = null == (N = null == A ? void 0 : A.split(":")) ? void 0 : N[1]; ee = 3 * +(null != D ? D : 6) } } return { streamType: Y, targetLiveWindow: Z, liveEdgeStartOffset: ee } }, ve = async (b, A) => A === t$.MP4 ? { streamType: tG.ON_DEMAND, targetLiveWindow: Number.NaN, liveEdgeStartOffset: void 0 } : A === t$.M3U8 ? Me(await ge(b)) : (console.error(`Media type ${A} is an unrecognized or unsupported type for src ${b}.`), { streamType: void 0, targetLiveWindow: void 0, liveEdgeStartOffset: void 0 }), J = async (b, A, D = L({ src: b })) => { var N, V, Y; let { streamType: Z, targetLiveWindow: ee, liveEdgeStartOffset: et } = await ve(b, D); (null != (N = ry.get(A)) ? N : {}).liveEdgeStartOffset = et, (null != (V = ry.get(A)) ? V : {}).targetLiveWindow = ee, A.dispatchEvent(new CustomEvent("targetlivewindowchange", { composed: !0, bubbles: !0 })), (null != (Y = ry.get(A)) ? Y : {}).streamType = Z, A.dispatchEvent(new CustomEvent("streamtypechange", { composed: !0, bubbles: !0 })) }, be = b => { var A; let D = b.type, N = h(D), V = w(D), Y, Z = !!(null != (A = b.partList) && A.length); return N === tG.LIVE && (Y = Z ? 2 * b.partTarget : 3 * b.targetduration), { streamType: N, targetLiveWindow: V, liveEdgeStartOffset: Y, lowLatency: Z } }, ke = (b, A, D) => { var N, V, Y, Z, ee, et, ea, er; let { streamType: en, targetLiveWindow: eo, liveEdgeStartOffset: es, lowLatency: el } = be(b); if (en === tG.LIVE) { el ? (D.config.backBufferLength = null != (N = D.userConfig.backBufferLength) ? N : 4, D.config.maxFragLookUpTolerance = null != (V = D.userConfig.maxFragLookUpTolerance) ? V : .001, D.config.abrBandWidthUpFactor = null != (Y = D.userConfig.abrBandWidthUpFactor) ? Y : D.config.abrBandWidthFactor) : D.config.backBufferLength = null != (Z = D.userConfig.backBufferLength) ? Z : 8; let b = Object.freeze({ get length() { return A.seekable.length }, start: b => A.seekable.start(b), end(b) { var N; return b > this.length ? A.seekable.end(b) : null != (N = D.liveSyncPosition) ? N : A.seekable.end(b) } }); (null != (ee = ry.get(A)) ? ee : {}).seekable = b } (null != (et = ry.get(A)) ? et : {}).liveEdgeStartOffset = es, (null != (ea = ry.get(A)) ? ea : {}).targetLiveWindow = eo, A.dispatchEvent(new CustomEvent("targetlivewindowchange", { composed: !0, bubbles: !0 })), (null != (er = ry.get(A)) ? er : {}).streamType = en, A.dispatchEvent(new CustomEvent("streamtypechange", { composed: !0, bubbles: !0 })) }, rE = -1 !== (null != (rb = null == (rf = null == globalThis ? void 0 : globalThis.navigator) ? void 0 : rf.userAgent) ? rb : "").toLowerCase().indexOf("android"), ry = new WeakMap, rA = "mux.com", rk = null == (rg = tW.isSupported) ? void 0 : rg.call(tW), kt = () => tB.utils.now(), rT = tB.utils.generateUUID, xt = (b, { domain: A = rA, maxResolution: D = "" } = {}) => { if (!b) return; let [N, V = ""] = F(b), Y = new URL(`https://stream.${A}/${N}.m3u8${V}`); return D && Y.searchParams.set("max_resolution", D), Y.toString() }, Ae = b => { if (!b) return; let [A] = b.split("?"); return A || void 0 }, Se = b => { if (!b || !b.startsWith("https://stream.")) return; let [A] = new URL(b).pathname.slice(1).split(".m3u8"); return A || void 0 }, Ce = b => { var A, D, N; return null != (A = null == b ? void 0 : b.metadata) && A.video_id ? b.metadata.video_id : ae(b) && null != (N = null != (D = Ae(b.playbackId)) ? D : Se(b.src)) ? N : b.src }, Lt = b => { var A; return null == (A = ry.get(b)) ? void 0 : A.error }, Et = b => { var A, D; return null != (D = null == (A = ry.get(b)) ? void 0 : A.streamType) ? D : tG.UNKNOWN }, Pt = b => { var A, D; return null != (D = null == (A = ry.get(b)) ? void 0 : A.targetLiveWindow) ? D : Number.NaN }, Ie = b => { var A, D; return null != (D = null == (A = ry.get(b)) ? void 0 : A.seekable) ? D : b.seekable }, At = b => { var A; let D = null == (A = ry.get(b)) ? void 0 : A.liveEdgeStartOffset; if ("number" != typeof D) return Number.NaN; let N = Ie(b); return N.length ? N.end(N.length - 1) - D : Number.NaN }, De = (b, A, D = .001) => Math.abs(b - A) <= D, re = (b, A, D = .001) => b > A || De(b, A, D), he = b => b.paused && re(b.currentTime, b.duration), we = (b, A) => b.loop || A ? b.ended : b.ended || he(b), St = (b, A, D) => { He(A, D); let { metadata: N = {} } = b, { view_session_id: V = rT() } = N, Y = Ce(b); N.view_session_id = V, N.video_id = Y, b.metadata = N, ry.set(A, {}); let Z = _e(b, A); Re(b, A, Z), Oe(b, A, Z), G(A); let ee = B(b, A, Z), et = K(b, A, Z); return { engine: Z, setAutoplay: ee, setPreload: et } }, He = (b, A) => { let D = null == A ? void 0 : A.engine; D && (D.detachMedia(), D.destroy()), (null == b ? void 0 : b.mux) && !b.mux.deleted && (b.mux.destroy(), delete b.mux), b && (b.removeAttribute("src"), b.load(), b.removeEventListener("error", se), b.removeEventListener("error", R), b.removeEventListener("durationchange", ie), ry.delete(b), b.dispatchEvent(new Event("teardown"))) }; function oe(b, A) { var D; let N = L(b); if (N !== t$.M3U8) return !0; let V = !N || null == (D = A.canPlayType(N)) || D, { preferPlayback: Y } = b, Z = Y === tV.MSE, ee = Y === tV.NATIVE; return V && (ee || !(rk && (Z || rE))) } var _e = (b, A) => { let { debug: D, streamType: N, startTime: V = -1, metadata: Y, preferCmcd: Z } = b, ee = L(b) === t$.M3U8, et = oe(b, A); if (ee && !et && rk) { let b = Ne(N), A = Z !== tj.NONE ? { useHeaders: Z === tj.HEADER, sessionId: null == Y ? void 0 : Y.view_session_id, contentId: null == Y ? void 0 : Y.video_id } : void 0; return new tW({ debug: D, startPosition: V, cmcd: A, backBufferLength: 30, renderTextTracksNatively: !1, liveDurationInfinity: !0, capLevelToPlayerSize: !0, capLevelOnFPSDrop: !0, ...b }) } }, Ne = b => b === tG.LIVE ? { backBufferLength: 8 } : {}, ae = ({ playbackId: b, src: A, customDomain: D }) => { if (b) return !0; if ("string" != typeof A) return !1; let N = null == window ? void 0 : window.location.href, V = new URL(A, N).hostname.toLocaleLowerCase(); return V.includes(rA) || !!D && V.includes(D.toLocaleLowerCase()) }, Re = (b, A, D) => { var N; let { envKey: V } = b, Y = ae(b); if (V || Y) { let { playerInitTime: Y, playerSoftwareName: Z, playerSoftwareVersion: ee, beaconCollectionDomain: et, debug: ea, disableCookies: er } = b, en = { ...b.metadata, video_title: (null == (N = null == b ? void 0 : b.metadata) ? void 0 : N.video_title) || void 0 }; tB.monitor(A, { debug: ea, beaconCollectionDomain: et, hlsjs: D, Hls: D ? tW : void 0, automaticErrorTracking: !1, errorTranslator: A => "string" != typeof A.player_error_code && ("function" == typeof b.errorTranslator ? b.errorTranslator(A) : A), disableCookies: er, data: { ...V ? { env_key: V } : {}, player_software_name: Z, player_software: Z, player_software_version: ee, player_init_time: Y, ...en } }) } }, Oe = (b, A, D) => { var N; let V = oe(b, A), { src: Y } = b; if (A && V) { let D = L(b); "string" == typeof Y ? ("none" === A.preload ? M(A, "loadstart", () => J(Y, A, D)) : J(Y, A, D), A.setAttribute("src", Y), b.startTime && ((null != (N = ry.get(A)) ? N : {}).startTime = b.startTime, A.addEventListener("durationchange", ie, { once: !0 }))) : A.removeAttribute("src"), A.addEventListener("error", se), A.addEventListener("error", R), A.addEventListener("emptied", () => { A.querySelectorAll("track[data-removeondestroy]").forEach(b => { b.remove() }) }, { once: !0 }); let i = () => { A.ended || !we(A) || A.dispatchEvent(new Event("ended")) }; M(A, "pause", i), M(A, "seeked", i), M(A, "play", () => { A.ended || !re(A.currentTime, A.duration) || (A.currentTime = A.seekable.start(0)) }) } else D && Y ? (D.once(tW.Events.LEVEL_LOADED, (b, N) => { ke(N.details, A, D) }), D.on(tW.Events.ERROR, (b, D) => { let N = { [tW.ErrorTypes.NETWORK_ERROR]: tF.MEDIA_ERR_NETWORK, [tW.ErrorTypes.MEDIA_ERROR]: tF.MEDIA_ERR_DECODE }, V = new tF("", N[D.type]); V.fatal = D.fatal, V.data = D, A.dispatchEvent(new CustomEvent("error", { detail: V })) }), A.addEventListener("error", R), function (b, A) { var D; if (!("videoTracks" in b)) return; let N = new WeakMap; A.on(tW.Events.MANIFEST_PARSED, function (A, D) { i(); let V = b.addVideoTrack("main"); for (let [b, A] of (V.selected = !0, D.levels.entries())) { let D = V.addRendition(A.url[0], A.width, A.height, A.videoCodec, A.bitrate); N.set(A, `${b}`), D.id = `${b}` } }), A.on(tW.Events.AUDIO_TRACKS_UPDATED, function (A, D) { for (let A of (s(), D.audioTracks)) { let D = A.default ? "main" : "alternative", N = b.addAudioTrack(D, A.name, A.lang); N.id = `${A.id}`, A.default && (N.enabled = !0) } }), b.audioTracks.addEventListener("change", () => { var D; let N = +(null == (D = [...b.audioTracks].find(b => b.enabled)) ? void 0 : D.id), V = A.audioTracks.map(b => b.id); N != A.audioTrack && V.includes(N) && (A.audioTrack = N) }), A.on(tW.Events.LEVELS_UPDATED, function (A, D) { var V; let Y = b.videoTracks[null != (V = b.videoTracks.selectedIndex) ? V : 0]; if (!Y) return; let Z = D.levels.map(b => N.get(b)); for (let A of b.videoRenditions) A.id && !Z.includes(A.id) && Y.removeRendition(A) }); let o = D => { let N = b.currentTime, V = !1, l = (b, A) => { V || (V = !Number.isFinite(A.endOffset)) }; A.on(tW.Events.BUFFER_FLUSHING, l), A.nextLevel = D, A.off(tW.Events.BUFFER_FLUSHING, l), V || A.trigger(tW.Events.BUFFER_FLUSHING, { startOffset: N + 10, endOffset: 1 / 0, type: "video" }) }; null == (D = b.videoRenditions) || D.addEventListener("change", b => { let D = b.target.selectedIndex; D != A.nextLevel && o(D) }); let a = () => { for (let A of b.videoTracks) b.removeVideoTrack(A) }, s = () => { for (let A of b.audioTracks) b.removeAudioTrack(A) }, i = () => { a(), s() }; A.once(tW.Events.DESTROYING, i) }(b, D), function (b, A) { A.on(tW.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (D, { tracks: N }) => { N.forEach(D => { var N; let V = null != (N = D.subtitleTrack) ? N : D.closedCaptions, Y = A.subtitleTracks.findIndex(({ lang: b, name: A, type: N }) => b == (null == V ? void 0 : V.lang) && A === D.label && N.toLowerCase() === D.kind); _(b, D.kind, D.label, null == V ? void 0 : V.lang, `${D.kind}${Y}`) }) }); let n = () => { var D; if (!A.subtitleTracks.length) return; let N = Array.from(b.textTracks).find(b => b.id && "showing" === b.mode && ["subtitles", "captions"].includes(b.kind)), V = `${null == (D = A.subtitleTracks[A.subtitleTrack]) ? void 0 : D.type.toLowerCase()}${A.subtitleTrack}`; if (N && (A.subtitleTrack < 0 || (null == N ? void 0 : N.id) !== V)) { let b = A.subtitleTracks.findIndex(({ lang: b, name: A, type: D }) => b == N.language && A === N.label && D.toLowerCase() === N.kind); A.subtitleTrack = b } N && (null == N ? void 0 : N.id) === V && N.cues && Array.from(N.cues).forEach(b => { N.addCue(b) }) }; b.textTracks.addEventListener("change", n), A.on(tW.Events.CUES_PARSED, (A, { track: D, cues: N }) => { let V = b.textTracks.getTrackById(D); if (!V) return; let Y = "disabled" === V.mode; Y && (V.mode = "hidden"), N.forEach(b => { var A; null != (A = V.cues) && A.getCueById(b.id) || V.addCue(b) }), Y && (V.mode = "disabled") }), A.once(tW.Events.DESTROYING, () => { b.textTracks.removeEventListener("change", n), b.querySelectorAll("track[data-removeondestroy]").forEach(b => { b.remove() }) }); let r = () => { Array.from(b.textTracks).forEach(A => { var D, N; if (!["subtitles", "caption"].includes(A.kind) && "thumbnails" === A.label) { if (!(null != (D = A.cues) && D.length)) { let A = b.querySelector('track[label="thumbnails"]'), D = null != (N = null == A ? void 0 : A.getAttribute("src")) ? N : ""; null == A || A.removeAttribute("src"), setTimeout(() => { null == A || A.setAttribute("src", D) }, 0) } "hidden" !== A.mode && (A.mode = "hidden") } }) }; A.once(tW.Events.MANIFEST_LOADED, r), A.once(tW.Events.MEDIA_ATTACHED, r) }(A, D), D.attachMedia(A)) : console.error("It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.") }; function ie(b) { var A; let D = b.target, N = null == (A = ry.get(D)) ? void 0 : A.startTime; if (N && function (b, A, D) { A && D > A && (D = A); for (let A = 0; A < b.length; A++)if (b.start(A) <= D && b.end(A) >= D) return !0; return !1 }(D.seekable, D.duration, N)) { let b = "auto" === D.preload; b && (D.preload = "none"), D.currentTime = N, b && (D.preload = "auto") } } async function se(b) { if (!b.isTrusted) return; b.stopImmediatePropagation(); let A = b.target; if (!(null != A && A.error)) return; let { message: D, code: N } = A.error, V = new tF(D, N); if (A.src && (N !== tF.MEDIA_ERR_DECODE || void 0 !== N)) try { let { status: b } = await fetch(A.src); V.data = { response: { code: b } } } catch { } A.dispatchEvent(new CustomEvent("error", { detail: V })) } function R(b) { var A, D; if (!(b instanceof CustomEvent) || !(b.detail instanceof tF)) return; let N = b.target, V = b.detail; V && V.fatal && ((null != (A = ry.get(N)) ? A : {}).error = V, null == (D = N.mux) || D.emit("error", { player_error_code: V.code, player_error_message: V.message, player_error_context: V.context })) } var rw = Object.defineProperty, ei = (b, A, D) => A in b ? rw(b, A, { enumerable: !0, configurable: !0, writable: !0, value: D }) : b[A] = D, dist_f = (b, A, D) => (ei(b, "symbol" != typeof A ? A + "" : A, D), D), dist_ne = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, r = (b, A, D) => (dist_ne(b, A, "read from private field"), D ? D.call(b) : A.get(b)), c = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, d = (b, A, D, N) => (dist_ne(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), T = (b, A, D) => (dist_ne(b, A, "access private method"), D), rS = class { addEventListener() { } removeEventListener() { } dispatchEvent(b) { return !0 } }; "undefined" == typeof DocumentFragment && (globalThis.DocumentFragment = class extends rS { }); var rD, rI = class extends rS { }, rM = class { constructor(b, A = {}) { c(this, rD, void 0), d(this, rD, null == A ? void 0 : A.detail) } get detail() { return r(this, rD) } initCustomEvent() { } }; rD = new WeakMap; var rC = { document: { createElement: function (b, A) { return new rI } }, DocumentFragment, customElements: { get(b) { }, define(b, A, D) { }, upgrade(b) { }, whenDefined: b => Promise.resolve(rI) }, CustomEvent: rM, EventTarget: rS, HTMLElement: rI, HTMLVideoElement: class extends rS { } }, rx = "undefined" == typeof window || void 0 === globalThis.customElements, rL = rx ? rC : globalThis; rx && rC.document; var rR = (() => { try { return "0.16.5" } catch { } return "UNKNOWN" })(), dist_Ie = b => { var A, D, N, V, Y, Z, ee, et, ea, er, en, eo, es, el, ed, eu, ec, em, eh, ep, ev, e_, ef, eb, eg, eE, ey, eA, ek, eT, ew, eS, eD, eI, eM, eC, ex, eL, eR, eO; return A = class extends b { constructor() { super(), c(this, ey), c(this, ek), c(this, ew), c(this, eD), c(this, eM), c(this, ex), c(this, eR), dist_f(this, "castEnabled", !1), c(this, ev, { paused: !1 }), c(this, e_, void 0), c(this, ef, {}), c(this, eb, void 0), c(this, eg, void 0), c(this, eE, void 0), A.instances.add(this), T(this, eM, eC).call(this) } static get castElement() { return r(A, D) } static get castEnabled() { return r(A, N) } static get castState() { var b; return null == (b = r(A, ea, er)) ? void 0 : b.getCastState() } static async exitCast() { try { await r(A, ea, er).endCurrentSession(!0) } catch (b) { console.error(b); return } } get castPlayer() { if (A.castElement === this) return r(this, e_) } attributeChangedCallback(b) { if (this.castPlayer) switch (b) { case "cast-stream-type": case "cast-src": this.load() } } async requestCast(b = {}) { T(A, eh, ep).call(A, b), d(A, D, this), Object.entries(r(this, ef)).forEach(([b, A]) => { r(this, e_).controller.addEventListener(b, A) }); try { await r(A, ea, er).requestSession() } catch { d(A, D, void 0); return } r(this, ev).paused = super.paused, super.pause(), this.muted = super.muted; try { await this.load() } catch (b) { console.error(b) } } async load() { var b, D; if (!this.castPlayer) return super.load(); let N = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType), V = [...this.querySelectorAll("track")].filter(({ kind: b, src: A }) => A && ("subtitles" === b || "captions" === b)), Y = [], Z = 0; V.length && (N.tracks = V.map(b => { let A = ++Z; 0 === Y.length && "showing" === b.track.mode && Y.push(A); let D = new chrome.cast.media.Track(A, chrome.cast.media.TrackType.TEXT); return D.trackContentId = b.src, D.trackContentType = "text/vtt", D.subtype = "captions" === b.kind ? chrome.cast.media.TextTrackType.CAPTIONS : chrome.cast.media.TextTrackType.SUBTITLES, D.name = b.label, D.language = b.srclang, D })), "live" === this.castStreamType ? N.streamType = chrome.cast.media.StreamType.LIVE : N.streamType = chrome.cast.media.StreamType.BUFFERED, N.metadata = new chrome.cast.media.GenericMediaMetadata, N.metadata.title = this.title, N.metadata.images = [{ url: this.poster }]; let ee = new chrome.cast.media.LoadRequest(N); ee.currentTime = null != (b = super.currentTime) ? b : 0, ee.autoplay = !r(this, ev).paused, ee.activeTrackIds = Y, await (null == (D = r(A, en, eo)) ? void 0 : D.loadMedia(ee)), this.dispatchEvent(new Event("volumechange")) } play() { var b; if (this.castPlayer) { this.castPlayer.isPaused && (null == (b = this.castPlayer.controller) || b.playOrPause()); return } return super.play() } pause() { var b; if (this.castPlayer) { this.castPlayer.isPaused || null == (b = this.castPlayer.controller) || b.playOrPause(); return } super.pause() } get castSrc() { var b, A, D; return null != (D = null != (A = this.getAttribute("cast-src")) ? A : null == (b = this.querySelector("source")) ? void 0 : b.src) ? D : this.currentSrc } set castSrc(b) { this.castSrc != b && this.setAttribute("cast-src", `${b}`) } get castContentType() { var b; return null != (b = this.getAttribute("cast-content-type")) ? b : void 0 } set castContentType(b) { this.setAttribute("cast-content-type", `${b}`) } get castStreamType() { var b, A; return null != (A = null != (b = this.getAttribute("cast-stream-type")) ? b : this.streamType) ? A : void 0 } set castStreamType(b) { this.setAttribute("cast-stream-type", `${b}`) } get readyState() { if (this.castPlayer) switch (this.castPlayer.playerState) { case chrome.cast.media.PlayerState.IDLE: return 0; case chrome.cast.media.PlayerState.BUFFERING: return 2; default: return 3 }return super.readyState } get paused() { return this.castPlayer ? this.castPlayer.isPaused : super.paused } get muted() { var b; return this.castPlayer ? null == (b = this.castPlayer) ? void 0 : b.isMuted : super.muted } set muted(b) { var A; if (this.castPlayer) { (b && !this.castPlayer.isMuted || !b && this.castPlayer.isMuted) && (null == (A = this.castPlayer.controller) || A.muteOrUnmute()); return } super.muted = b } get volume() { var b, A; return this.castPlayer ? null != (A = null == (b = this.castPlayer) ? void 0 : b.volumeLevel) ? A : 1 : super.volume } set volume(b) { var A; if (this.castPlayer) { this.castPlayer.volumeLevel = b, null == (A = this.castPlayer.controller) || A.setVolumeLevel(); return } super.volume = b } get duration() { var b, A; return this.castPlayer && r(this, ey, eA) ? null != (A = null == (b = this.castPlayer) ? void 0 : b.duration) ? A : NaN : super.duration } get currentTime() { var b, A; return this.castPlayer && r(this, ey, eA) ? null != (A = null == (b = this.castPlayer) ? void 0 : b.currentTime) ? A : 0 : super.currentTime } set currentTime(b) { var A; if (this.castPlayer) { this.castPlayer.currentTime = b, null == (A = this.castPlayer.controller) || A.seek(); return } super.currentTime = b } get onentercast() { return r(this, eb) } set onentercast(b) { r(this, eb) && (this.removeEventListener("entercast", r(this, eb)), d(this, eb, null)), "function" == typeof b && (d(this, eb, b), this.addEventListener("entercast", b)) } get onleavecast() { return r(this, eg) } set onleavecast(b) { r(this, eg) && (this.removeEventListener("leavecast", r(this, eg)), d(this, eg, null)), "function" == typeof b && (d(this, eg, b), this.addEventListener("leavecast", b)) } get oncastchange() { return r(this, eE) } set oncastchange(b) { r(this, eE) && (this.removeEventListener("castchange", r(this, eE)), d(this, eE, null)), "function" == typeof b && (d(this, eE, b), this.addEventListener("castchange", b)) } }, D = new WeakMap, N = new WeakMap, V = new WeakMap, Y = new WeakSet, Z = function () { return "undefined" != typeof chrome && chrome.cast && chrome.cast.isAvailable }, ee = new WeakSet, et = function () { return "undefined" != typeof cast && cast.framework }, ea = new WeakSet, er = function () { if (r(A, ee, et)) return cast.framework.CastContext.getInstance() }, en = new WeakSet, eo = function () { var b; return null == (b = r(A, ea, er)) ? void 0 : b.getCurrentSession() }, es = new WeakSet, el = function () { var b; return null == (b = r(A, en, eo)) ? void 0 : b.getSessionObj().media[0] }, ed = new WeakSet, eu = function (b) { return new Promise((D, N) => { r(A, es, el).editTracksInfo(b, D, N) }) }, ec = new WeakSet, em = function (b) { return new Promise((D, N) => { r(A, es, el).getStatus(b, D, N) }) }, eh = new WeakSet, ep = function (b) { return r(A, ea, er).setOptions({ receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID, autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED, androidReceiverCompatible: !1, language: "en-US", resumeSavedSession: !0, ...b }) }, ev = new WeakMap, e_ = new WeakMap, ef = new WeakMap, eb = new WeakMap, eg = new WeakMap, eE = new WeakMap, ey = new WeakSet, eA = function () { var b; return null == (b = this.castPlayer) ? void 0 : b.isMediaLoaded }, ek = new WeakSet, eT = function () { r(A, D) === this && (Object.entries(r(this, ef)).forEach(([b, A]) => { r(this, e_).controller.removeEventListener(b, A) }), d(A, D, void 0), this.muted = r(this, e_).isMuted, this.currentTime = r(this, e_).savedPlayerState.currentTime, !1 === r(this, e_).savedPlayerState.isPaused && this.play()) }, ew = new WeakSet, eS = function () { this.dispatchEvent(new CustomEvent("castchange", { detail: r(A, ea, er).getCastState() })) }, eD = new WeakSet, eI = async function () { var b; let { SESSION_RESUMED: N } = cast.framework.SessionState; if (r(A, ea, er).getSessionState() === N && this.castSrc === (null == (b = r(A, es, el)) ? void 0 : b.media.contentId)) { d(A, D, this), Object.entries(r(this, ef)).forEach(([b, A]) => { r(this, e_).controller.addEventListener(b, A) }); try { await T(A, ec, em).call(A, new chrome.cast.media.GetStatusRequest) } catch (b) { console.error(b) } r(this, ef)[cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED](), r(this, ef)[cast.framework.RemotePlayerEventType.PLAYER_STATE_CHANGED]() } }, eM = new WeakSet, eC = function () { !r(A, ee, et) || this.castEnabled || (this.castEnabled = !0, T(A, eh, ep).call(A), this.textTracks.addEventListener("change", T(this, eR, eO).bind(this)), T(this, ew, eS).call(this), d(this, e_, new cast.framework.RemotePlayer), new cast.framework.RemotePlayerController(r(this, e_)), d(this, ef, { [cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value: b }) => { !1 === b && T(this, ek, eT).call(this), this.dispatchEvent(new Event(b ? "entercast" : "leavecast")) }, [cast.framework.RemotePlayerEventType.DURATION_CHANGED]: () => { this.dispatchEvent(new Event("durationchange")) }, [cast.framework.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => { this.dispatchEvent(new Event("volumechange")) }, [cast.framework.RemotePlayerEventType.IS_MUTED_CHANGED]: () => { this.dispatchEvent(new Event("volumechange")) }, [cast.framework.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => { r(this, ey, eA) && this.dispatchEvent(new Event("timeupdate")) }, [cast.framework.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => { this.dispatchEvent(new Event("resize")) }, [cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => { this.dispatchEvent(new Event(this.paused ? "pause" : "play")) }, [cast.framework.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => { var b, A; (null == (b = this.castPlayer) ? void 0 : b.playerState) !== chrome.cast.media.PlayerState.PAUSED && this.dispatchEvent(new Event({ [chrome.cast.media.PlayerState.PLAYING]: "playing", [chrome.cast.media.PlayerState.BUFFERING]: "waiting", [chrome.cast.media.PlayerState.IDLE]: "emptied" }[null == (A = this.castPlayer) ? void 0 : A.playerState])) }, [cast.framework.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => { r(this, ey, eA) && (await Promise.resolve(), T(this, ex, eL).call(this)) } })) }, ex = new WeakSet, eL = function () { T(this, eR, eO).call(this) }, eR = new WeakSet, eO = async function () { var b, D, N, V, Y, Z; if (!this.castPlayer) return; let ee = (null != (D = null == (b = r(this, e_).mediaInfo) ? void 0 : b.tracks) ? D : []).filter(({ type: b }) => b === chrome.cast.media.TrackType.TEXT), et = [...this.textTracks].filter(({ kind: b }) => "subtitles" === b || "captions" === b), ea = ee.map(({ language: b, name: A, trackId: D }) => { var N; let { mode: V } = null != (N = et.find(D => D.language === b && D.label === A)) ? N : {}; return !!V && { mode: V, trackId: D } }).filter(Boolean), er = ea.filter(({ mode: b }) => "showing" !== b).map(({ trackId: b }) => b), es = ea.find(({ mode: b }) => "showing" === b), el = null != (Y = null == (V = null == (N = r(A, en, eo)) ? void 0 : N.getSessionObj().media[0]) ? void 0 : V.activeTrackIds) ? Y : [], ec = el; if (el.length && (ec = ec.filter(b => !er.includes(b))), null != es && es.trackId && (ec = [...ec, es.trackId]), Z = ec = [...new Set(ec)], !(el.length === Z.length && el.every(b => Z.includes(b)))) try { let b = new chrome.cast.media.EditTracksInfoRequest(ec); await T(A, ed, eu).call(A, b) } catch (b) { console.error(b) } }, c(A, Y), c(A, ee), c(A, ea), c(A, en), c(A, es), c(A, ed), c(A, ec), c(A, eh), dist_f(A, "observedAttributes", ["cast-src", "cast-content-type", "cast-stream-type"]), dist_f(A, "instances", new Set), c(A, D, void 0), c(A, N, !1), dist_f(A, "initCast", () => { r(A, Y, Z) ? r(A, ee, et) ? r(A, V).call(A, chrome.cast.isAvailable) : customElements.whenDefined("google-cast-button").then(() => r(A, V).call(A, chrome.cast.isAvailable)) : globalThis.__onGCastApiAvailable = () => { customElements.whenDefined("google-cast-button").then(() => r(A, V).call(A, chrome.cast.isAvailable)) } }), c(A, V, b => { if (b) { d(A, N, !0); let { CAST_STATE_CHANGED: b } = cast.framework.CastContextEventType; r(A, ea, er).addEventListener(b, b => { A.instances.forEach(A => T(A, ew, eS).call(A, b)) }); let { SESSION_STATE_CHANGED: D } = cast.framework.CastContextEventType; r(A, ea, er).addEventListener(D, b => { A.instances.forEach(A => T(A, eD, eI).call(A, b)) }), A.instances.forEach(b => T(b, eM, eC).call(b)) } }), A }, rO = globalThis.HTMLVideoElement ? dist_Ie(HTMLVideoElement) : dist_Ie(Object); globalThis.customElements && !globalThis.customElements.get("castable-video") && (customElements.define("castable-video", rO, { extends: "video" }), globalThis.CastableVideoElement = rO), rO.initCast(); var rN, rP = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting", "waitingforkey", "resize", "enterpictureinpicture", "leavepictureinpicture", "webkitbeginfullscreen", "webkitendfullscreen", "webkitpresentationmodechanged"], rU = null == (rN = globalThis.document) ? void 0 : rN.createElement("template"); rU && (rU.innerHTML = `
      <style>
        :host {
          display: inline-block;
          line-height: 0;
        }
  
        audio {
          max-width: 100%;
          max-height: 100%;
          min-width: 100%;
          min-height: 100%;
        }
      </style>
      <slot></slot>
    `); var rB, rW = null == (rB = globalThis.document) ? void 0 : rB.createElement("template"); rW && (rW.innerHTML = `
      <style>
        :host {
          display: inline-block;
          line-height: 0;
        }
  
        video {
          max-width: 100%;
          max-height: 100%;
          min-width: 100%;
          min-height: 100%;
          object-fit: var(--media-object-fit, contain);
          object-position: var(--media-object-position, 50% 50%);
        }
  
        video::-webkit-media-text-track-container {
          transform: var(--media-webkit-text-track-transform);
          transition: var(--media-webkit-text-track-transition);
        }
      </style>
      <slot></slot>
    `); var zt = (b, { tag: A, is: D }) => { var N, V, Y, Z, ee, et, ea, er, en, eo, es, el, ed; let eu = null == (N = globalThis.document) ? void 0 : N.createElement(A, { is: D }), ec = eu ? function (b) { let A = []; for (let D = Object.getPrototypeOf(b); D && D !== HTMLElement.prototype; D = Object.getPrototypeOf(D))A.push(...Object.getOwnPropertyNames(D)); return A }(eu) : []; return V = class extends b { constructor() { super(), c(this, er), c(this, eo), c(this, el), c(this, et, void 0), c(this, ea, void 0), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.append(this.constructor.template.content.cloneNode(!0))) } static get observedAttributes() { var b, A; return T(V, Z, ee).call(V), [...null != (A = null == (b = null == eu ? void 0 : eu.constructor) ? void 0 : b.observedAttributes) ? A : [], "autopictureinpicture", "disablepictureinpicture", "disableremoteplayback", "autoplay", "controls", "controlslist", "crossorigin", "loop", "muted", "playsinline", "poster", "preload", "src"] } get nativeEl() { var b, D; return null != (D = null != (b = r(this, ea)) ? b : this.shadowRoot.querySelector(A)) ? D : this.querySelector(A) } set nativeEl(b) { d(this, ea, b) } get defaultMuted() { return this.hasAttribute("muted") } set defaultMuted(b) { this.toggleAttribute("muted", !!b) } get src() { return this.getAttribute("src") } set src(b) { this.setAttribute("src", `${b}`) } get preload() { var b, A; return null != (A = this.getAttribute("preload")) ? A : null == (b = this.nativeEl) ? void 0 : b.preload } set preload(b) { this.setAttribute("preload", `${b}`) } attributeChangedCallback(b, A, D) { T(this, er, en).call(this), T(this, el, ed).call(this, b, A, D) } connectedCallback() { T(this, er, en).call(this) } }, Y = new WeakMap, Z = new WeakSet, ee = function () { if (r(this, Y)) return; d(this, Y, !0); let b = new Set(this.observedAttributes); for (let A of (b.delete("muted"), ec)) if (!(A in this.prototype)) { if ("function" == typeof eu[A]) this.prototype[A] = function (...b) { return T(this, er, en).call(this), this.call ? this.call(A, ...b) : this.nativeEl[A].apply(this.nativeEl, b) }; else { let D = { get() { var D, N, V; T(this, er, en).call(this); let Y = A.toLowerCase(); if (b.has(Y)) { let b = this.getAttribute(Y); return null !== b && ("" === b || b) } return null != (V = null == (D = this.get) ? void 0 : D.call(this, A)) ? V : null == (N = this.nativeEl) ? void 0 : N[A] } }; A !== A.toUpperCase() && (D.set = function (D) { T(this, er, en).call(this); let N = A.toLowerCase(); if (b.has(N)) { !0 === D || !1 === D || null == D ? this.toggleAttribute(N, !!D) : this.setAttribute(N, D); return } if (this.set) { this.set(A, D); return } this.nativeEl[A] = D }), Object.defineProperty(this.prototype, A, D) } } }, et = new WeakMap, ea = new WeakMap, er = new WeakSet, en = function () { var b, N; if (r(this, et)) return; if (d(this, et, !0), !this.nativeEl) { let b = document.createElement(A, { is: D }); b.part = A, this.shadowRoot.append(b) } for (let b of (this.nativeEl.muted = this.hasAttribute("muted"), ec)) T(this, eo, es).call(this, b); let V = new Map, Y = this.shadowRoot.querySelector("slot:not([name])"); for (let A of (null == Y || Y.addEventListener("slotchange", () => { let b = new Map(V); Y.assignedElements().filter(b => ["track", "source"].includes(b.localName)).forEach(A => { var D, N; b.delete(A); let Y = V.get(A); Y || (Y = A.cloneNode(), V.set(A, Y)), null == (N = (D = this.nativeEl).append) || N.call(D, Y) }), b.forEach(b => b.remove()) }), this.constructor.Events)) null == (N = (b = this.shadowRoot).addEventListener) || N.call(b, A, b => { b.target === this.nativeEl && this.dispatchEvent(new CustomEvent(b.type, { detail: b.detail })) }, !0) }, eo = new WeakSet, es = function (b) { if (Object.prototype.hasOwnProperty.call(this, b)) { let A = this[b]; delete this[b], this[b] = A } }, el = new WeakSet, ed = function (b, A, D) { var N, V, Y, Z;["id", "class"].includes(b) || (null === D ? null == (V = (N = this.nativeEl).removeAttribute) || V.call(N, b) : null == (Z = (Y = this.nativeEl).setAttribute) || Z.call(Y, b, D)) }, c(V, Z), dist_f(V, "Events", rP), dist_f(V, "template", A.endsWith("audio") ? rU : rW), c(V, Y, void 0), V }; globalThis.document && zt(HTMLElement, { tag: "video" }), globalThis.document && zt(HTMLElement, { tag: "audio" }); var rF = class extends Event { constructor(b, A) { super(b), dist_f(this, "track"), this.track = A.track } }, rH = new WeakMap; function o(b) { var A; let D; return null != (A = rH.get(b)) ? A : ((D = rH.get(b)) || rH.set(b, D = {}), Object.assign(D, {})) } function Xt(b, A) { let D = b.videoTracks; o(A).media = b, o(A).renditionSet || (o(A).renditionSet = new Set); let N = o(D).trackSet; N.add(A); let V = N.size - 1; V in rY.prototype || Object.defineProperty(rY.prototype, V, { get() { return [...o(this).trackSet][V] } }), queueMicrotask(() => { D.dispatchEvent(new rF("addtrack", { track: A })) }) } function Jt(b) { var A; let D = null == (A = o(b).media) ? void 0 : A.videoTracks; D && (o(D).trackSet.delete(b), queueMicrotask(() => { D.dispatchEvent(new rF("removetrack", { track: b })) })) } var rG, rV, rj, rq, r$, rY = class extends EventTarget { constructor() { super(), c(this, rq), c(this, rG, void 0), c(this, rV, void 0), c(this, rj, void 0), o(this).trackSet = new Set } [Symbol.iterator]() { return r(this, rq, r$).values() } get length() { return r(this, rq, r$).size } getTrackById(b) { var A; return null != (A = [...r(this, rq, r$)].find(A => A.id === b)) ? A : null } get selectedIndex() { return [...r(this, rq, r$)].findIndex(b => b.selected) } get onaddtrack() { return r(this, rG) } set onaddtrack(b) { r(this, rG) && (this.removeEventListener("addtrack", r(this, rG)), d(this, rG, void 0)), "function" == typeof b && (d(this, rG, b), this.addEventListener("addtrack", b)) } get onremovetrack() { return r(this, rV) } set onremovetrack(b) { r(this, rV) && (this.removeEventListener("removetrack", r(this, rV)), d(this, rV, void 0)), "function" == typeof b && (d(this, rV, b), this.addEventListener("removetrack", b)) } get onchange() { return r(this, rj) } set onchange(b) { r(this, rj) && (this.removeEventListener("change", r(this, rj)), d(this, rj, void 0)), "function" == typeof b && (d(this, rj, b), this.addEventListener("change", b)) } }; rG = new WeakMap, rV = new WeakMap, rj = new WeakMap, rq = new WeakSet, r$ = function () { return o(this).trackSet }; var rK = class extends Event { constructor(b, A) { super(b), dist_f(this, "rendition"), this.rendition = A.rendition } }; function ut(b) { return [...o(b).media.videoTracks].filter(b => b.selected).flatMap(b => [...o(b).renditionSet]) } var rZ, rQ, rz, rX = class extends EventTarget { constructor() { super(...arguments), c(this, rZ, void 0), c(this, rQ, void 0), c(this, rz, void 0) } [Symbol.iterator]() { return ut(this).values() } get length() { return ut(this).length } getRenditionById(b) { var A; return null != (A = ut(this).find(A => `${A.id}` == `${b}`)) ? A : null } get selectedIndex() { return ut(this).findIndex(b => b.selected) } set selectedIndex(b) { for (let [A, D] of ut(this).entries()) D.selected = A === b } get onaddrendition() { return r(this, rZ) } set onaddrendition(b) { r(this, rZ) && (this.removeEventListener("addrendition", r(this, rZ)), d(this, rZ, void 0)), "function" == typeof b && (d(this, rZ, b), this.addEventListener("addrendition", b)) } get onremoverendition() { return r(this, rQ) } set onremoverendition(b) { r(this, rQ) && (this.removeEventListener("removerendition", r(this, rQ)), d(this, rQ, void 0)), "function" == typeof b && (d(this, rQ, b), this.addEventListener("removerendition", b)) } get onchange() { return r(this, rz) } set onchange(b) { r(this, rz) && (this.removeEventListener("change", r(this, rz)), d(this, rz, void 0)), "function" == typeof b && (d(this, rz, b), this.addEventListener("change", b)) } }; rZ = new WeakMap, rQ = new WeakMap, rz = new WeakMap; var rJ, r0 = class { constructor() { dist_f(this, "src"), dist_f(this, "id"), dist_f(this, "width"), dist_f(this, "height"), dist_f(this, "bitrate"), dist_f(this, "frameRate"), dist_f(this, "codec"), c(this, rJ, !1) } get selected() { return r(this, rJ) } set selected(b) { var A; let D; r(this, rJ) !== b && (d(this, rJ, b), A = this, (D = o(A).media.videoRenditions) && !o(D).changeRequested && (o(D).changeRequested = !0, queueMicrotask(() => { delete o(D).changeRequested, o(A).track.selected && D.dispatchEvent(new Event("change")) }))) } }; rJ = new WeakMap; var r1, r2 = class { constructor() { dist_f(this, "id"), dist_f(this, "kind"), dist_f(this, "label", ""), dist_f(this, "language", ""), dist_f(this, "sourceBuffer"), c(this, r1, !1) } addRendition(b, A, D, N, V, Y) { var Z; let ee, et, ea, er = new r0; return er.src = b, er.width = A, er.height = D, er.frameRate = Y, er.bitrate = V, er.codec = N, Z = this, ee = o(Z).media.videoRenditions, o(er).media = o(Z).media, o(er).track = Z, (et = o(Z).renditionSet).add(er), (ea = et.size - 1) in rX.prototype || Object.defineProperty(rX.prototype, ea, { get() { return ut(this)[ea] } }), queueMicrotask(() => { Z.selected && ee.dispatchEvent(new rK("addrendition", { rendition: er })) }), er } removeRendition(b) { let A, D; A = o(b).media.videoRenditions, D = o(b).track, o(D).renditionSet.delete(b), queueMicrotask(() => { o(b).track.selected && A.dispatchEvent(new rK("removerendition", { rendition: b })) }) } get selected() { return r(this, r1) } set selected(b) { r(this, r1) !== b && (d(this, r1, b), !0 === b && function (b) { var A; let D = null != (A = o(b).media.videoTracks) ? A : [], N = !1; for (let A of D) A !== b && (A.selected = !1, N = !0); if (N) { if (o(D).changeRequested) return; o(D).changeRequested = !0, queueMicrotask(() => { delete o(D).changeRequested, D.dispatchEvent(new Event("change")) }) } }(this)) } }; function mt(b) { return [...o(b).media.audioTracks].filter(b => b.enabled).flatMap(b => [...o(b).renditionSet]) } r1 = new WeakMap; var r5, r3, r4, r7 = class extends EventTarget { constructor() { super(...arguments), c(this, r5, void 0), c(this, r3, void 0), c(this, r4, void 0) } [Symbol.iterator]() { return mt(this).values() } get length() { return mt(this).length } getRenditionById(b) { var A; return null != (A = mt(this).find(A => `${A.id}` == `${b}`)) ? A : null } get selectedIndex() { return mt(this).findIndex(b => b.selected) } set selectedIndex(b) { for (let [A, D] of mt(this).entries()) D.selected = A === b } get onaddrendition() { return r(this, r5) } set onaddrendition(b) { r(this, r5) && (this.removeEventListener("addrendition", r(this, r5)), d(this, r5, void 0)), "function" == typeof b && (d(this, r5, b), this.addEventListener("addrendition", b)) } get onremoverendition() { return r(this, r3) } set onremoverendition(b) { r(this, r3) && (this.removeEventListener("removerendition", r(this, r3)), d(this, r3, void 0)), "function" == typeof b && (d(this, r3, b), this.addEventListener("removerendition", b)) } get onchange() { return r(this, r4) } set onchange(b) { r(this, r4) && (this.removeEventListener("change", r(this, r4)), d(this, r4, void 0)), "function" == typeof b && (d(this, r4, b), this.addEventListener("change", b)) } }; r5 = new WeakMap, r3 = new WeakMap, r4 = new WeakMap; var r8, r6 = class { constructor() { dist_f(this, "src"), dist_f(this, "id"), dist_f(this, "bitrate"), dist_f(this, "codec"), c(this, r8, !1) } get selected() { return r(this, r8) } set selected(b) { var A; let D; r(this, r8) !== b && (d(this, r8, b), A = this, (D = o(A).media.audioRenditions) && !o(D).changeRequested && (o(D).changeRequested = !0, queueMicrotask(() => { delete o(D).changeRequested, o(A).track.enabled && D.dispatchEvent(new Event("change")) }))) } }; function Zt(b, A) { let D = b.audioTracks; o(A).media = b, o(A).renditionSet || (o(A).renditionSet = new Set); let N = o(D).trackSet; N.add(A); let V = N.size - 1; V in no.prototype || Object.defineProperty(no.prototype, V, { get() { return [...o(this).trackSet][V] } }), queueMicrotask(() => { D.dispatchEvent(new rF("addtrack", { track: A })) }) } function dist_te(b) { var A; let D = null == (A = o(b).media) ? void 0 : A.audioTracks; D && (o(D).trackSet.delete(b), queueMicrotask(() => { D.dispatchEvent(new rF("removetrack", { track: b })) })) } r8 = new WeakMap; var r9, nt, ni, nr, nn, no = class extends EventTarget { constructor() { super(), c(this, nr), c(this, r9, void 0), c(this, nt, void 0), c(this, ni, void 0), o(this).trackSet = new Set } [Symbol.iterator]() { return r(this, nr, nn).values() } get length() { return r(this, nr, nn).size } getTrackById(b) { var A; return null != (A = [...r(this, nr, nn)].find(A => A.id === b)) ? A : null } get onaddtrack() { return r(this, r9) } set onaddtrack(b) { r(this, r9) && (this.removeEventListener("addtrack", r(this, r9)), d(this, r9, void 0)), "function" == typeof b && (d(this, r9, b), this.addEventListener("addtrack", b)) } get onremovetrack() { return r(this, nt) } set onremovetrack(b) { r(this, nt) && (this.removeEventListener("removetrack", r(this, nt)), d(this, nt, void 0)), "function" == typeof b && (d(this, nt, b), this.addEventListener("removetrack", b)) } get onchange() { return r(this, ni) } set onchange(b) { r(this, ni) && (this.removeEventListener("change", r(this, ni)), d(this, ni, void 0)), "function" == typeof b && (d(this, ni, b), this.addEventListener("change", b)) } }; r9 = new WeakMap, nt = new WeakMap, ni = new WeakMap, nr = new WeakSet, nn = function () { return o(this).trackSet }; var ns, nl = class { constructor() { dist_f(this, "id"), dist_f(this, "kind"), dist_f(this, "label", ""), dist_f(this, "language", ""), dist_f(this, "sourceBuffer"), c(this, ns, !1) } addRendition(b, A, D) { var N; let V, Y, Z, ee = new r6; return ee.src = b, ee.codec = A, ee.bitrate = D, N = this, V = o(N).media.audioRenditions, o(ee).media = o(N).media, o(ee).track = N, (Y = o(N).renditionSet).add(ee), (Z = Y.size - 1) in r7.prototype || Object.defineProperty(r7.prototype, Z, { get() { return mt(this)[Z] } }), queueMicrotask(() => { N.enabled && V.dispatchEvent(new rK("addrendition", { rendition: ee })) }), ee } removeRendition(b) { let A, D; A = o(b).media.audioRenditions, D = o(b).track, o(D).renditionSet.delete(b), queueMicrotask(() => { o(b).track.enabled && A.dispatchEvent(new rK("removerendition", { rendition: b })) }) } get enabled() { return r(this, ns) } set enabled(b) { let A; r(this, ns) !== b && (d(this, ns, b), (A = o(this).media.audioTracks) && !o(A).changeRequested && (o(A).changeRequested = !0, queueMicrotask(() => { delete o(A).changeRequested, A.dispatchEvent(new Event("change")) }))) } }; ns = new WeakMap; var nd = dist_ee(globalThis.HTMLMediaElement, "video"), nu = dist_ee(globalThis.HTMLMediaElement, "audio"); function dist_ee(b, A) { var D; if (null != b && b.prototype) return null == (D = Object.getOwnPropertyDescriptor(b.prototype, `${A}Tracks`)) ? void 0 : D.get } rP.push("castchange", "entercast", "leavecast"); var nc, nm, nh, np, nv, n_, nf, nb, ng, nE = function (b) { if (!(null != b && b.prototype)) return b; let A = dist_ee(b, "video"); (!A || `${A}`.includes("[native code]")) && Object.defineProperty(b.prototype, "videoTracks", { get() { return function (b) { var A; let D = o(b).videoTracks; if (!D && (D = new rY, o(b).videoTracks = D, nd)) { let N = nd.call(null != (A = b.nativeEl) ? A : b); for (let A of N) Xt(b, A); N.addEventListener("change", () => { D.dispatchEvent(new Event("change")) }), N.addEventListener("addtrack", A => { if ([...D].some(b => b instanceof r2)) { for (let b of N) Jt(b); return } Xt(b, A.track) }), N.addEventListener("removetrack", b => { Jt(b.track) }) } return D }(this) } }); let D = dist_ee(b, "audio"); (!D || `${D}`.includes("[native code]")) && Object.defineProperty(b.prototype, "audioTracks", { get() { return function (b) { var A; let D = o(b).audioTracks; if (!D && (D = new no, o(b).audioTracks = D, nu)) { let N = nu.call(null != (A = b.nativeEl) ? A : b); for (let A of N) Zt(b, A); N.addEventListener("change", () => { D.dispatchEvent(new Event("change")) }), N.addEventListener("addtrack", A => { if ([...D].some(b => b instanceof nl)) { for (let b of N) dist_te(b); return } Zt(b, A.track) }), N.addEventListener("removetrack", b => { dist_te(b.track) }) } return D }(this) } }), "addVideoTrack" in b.prototype || (b.prototype.addVideoTrack = function (b, A = "", D = "") { let N = new r2; return N.kind = b, N.label = A, N.language = D, Xt(this, N), N }), "removeVideoTrack" in b.prototype || (b.prototype.removeVideoTrack = Jt), "addAudioTrack" in b.prototype || (b.prototype.addAudioTrack = function (b, A = "", D = "") { let N = new nl; return N.kind = b, N.label = A, N.language = D, Zt(this, N), N }), "removeAudioTrack" in b.prototype || (b.prototype.removeAudioTrack = dist_te), "videoRenditions" in b.prototype || Object.defineProperty(b.prototype, "videoRenditions", { get() { return n(this) } }); let n = b => { let A = o(b).videoRenditions; return A || (o(A = new rX).media = b, o(b).videoRenditions = A), A }; "audioRenditions" in b.prototype || Object.defineProperty(b.prototype, "audioRenditions", { get() { return a(this) } }); let a = b => { let A = o(b).audioRenditions; return A || (o(A = new r7).media = b, o(b).audioRenditions = A), A }; return b }(zt(rL.HTMLElement, { tag: "video", is: "castable-video" })), ny = { BEACON_COLLECTION_DOMAIN: "beacon-collection-domain", CUSTOM_DOMAIN: "custom-domain", DEBUG: "debug", DISABLE_COOKIES: "disable-cookies", ENV_KEY: "env-key", MAX_RESOLUTION: "max-resolution", METADATA_URL: "metadata-url", PLAYBACK_ID: "playback-id", PLAYER_SOFTWARE_NAME: "player-software-name", PLAYER_SOFTWARE_VERSION: "player-software-version", PREFER_CMCD: "prefer-cmcd", PREFER_PLAYBACK: "prefer-playback", START_TIME: "start-time", STREAM_TYPE: "stream-type", TARGET_LIVE_WINDOW: "target-live-window", LIVE_EDGE_OFFSET: "live-edge-offset", TYPE: "type" }, nA = Object.values(ny), nk = class extends nE { constructor() { super(), c(this, nb), c(this, nc, void 0), c(this, nm, void 0), c(this, nh, void 0), c(this, np, {}), c(this, nv, void 0), c(this, n_, void 0), c(this, nf, void 0), d(this, nh, kt()) } static get observedAttributes() { var b; return [...nA, ...null != (b = nE.observedAttributes) ? b : []] } get preferCmcd() { var b; return null != (b = this.getAttribute(ny.PREFER_CMCD)) ? b : void 0 } set preferCmcd(b) { b !== this.preferCmcd && (b ? tq.includes(b) ? this.setAttribute(ny.PREFER_CMCD, b) : console.warn(`Invalid value for preferCmcd. Must be one of ${tq.join()}`) : this.removeAttribute(ny.PREFER_CMCD)) } get playerInitTime() { return r(this, nh) } get playerSoftwareName() { var b; return null != (b = r(this, n_)) ? b : "mux-video" } set playerSoftwareName(b) { d(this, n_, b) } get playerSoftwareVersion() { var b; return null != (b = r(this, nv)) ? b : rR } set playerSoftwareVersion(b) { d(this, nv, b) } get _hls() { var b; return null == (b = r(this, nc)) ? void 0 : b.engine } get mux() { var b; return null == (b = this.nativeEl) ? void 0 : b.mux } get error() { var b; return null != (b = Lt(this.nativeEl)) ? b : null } get errorTranslator() { return r(this, nf) } set errorTranslator(b) { d(this, nf, b) } get src() { return this.getAttribute("src") } set src(b) { b !== this.src && (null == b ? this.removeAttribute("src") : this.setAttribute("src", b)) } get type() { var b; return null != (b = this.getAttribute(ny.TYPE)) ? b : void 0 } set type(b) { b !== this.type && (b ? this.setAttribute(ny.TYPE, b) : this.removeAttribute(ny.TYPE)) } get autoplay() { let b = this.getAttribute("autoplay"); return null !== b && ("" === b || b) } set autoplay(b) { b !== this.autoplay && (b ? this.setAttribute("autoplay", "string" == typeof b ? b : "") : this.removeAttribute("autoplay")) } get preload() { let b = this.getAttribute("preload"); return "" === b ? "auto" : ["none", "metadata", "auto"].includes(b) ? b : super.preload } set preload(b) { b != this.getAttribute("preload") && (["", "none", "metadata", "auto"].includes(b) ? this.setAttribute("preload", b) : this.removeAttribute("preload")) } get debug() { return null != this.getAttribute(ny.DEBUG) } set debug(b) { b !== this.debug && (b ? this.setAttribute(ny.DEBUG, "") : this.removeAttribute(ny.DEBUG)) } get disableCookies() { return this.hasAttribute(ny.DISABLE_COOKIES) } set disableCookies(b) { b !== this.disableCookies && (b ? this.setAttribute(ny.DISABLE_COOKIES, "") : this.removeAttribute(ny.DISABLE_COOKIES)) } get startTime() { let b = this.getAttribute(ny.START_TIME); if (null == b) return; let A = +b; return Number.isNaN(A) ? void 0 : A } set startTime(b) { b !== this.startTime && (null == b ? this.removeAttribute(ny.START_TIME) : this.setAttribute(ny.START_TIME, `${b}`)) } get playbackId() { var b; return null != (b = this.getAttribute(ny.PLAYBACK_ID)) ? b : void 0 } set playbackId(b) { b !== this.playbackId && (b ? this.setAttribute(ny.PLAYBACK_ID, b) : this.removeAttribute(ny.PLAYBACK_ID)) } get maxResolution() { var b; return null != (b = this.getAttribute(ny.MAX_RESOLUTION)) ? b : void 0 } set maxResolution(b) { b !== this.maxResolution && (b ? this.setAttribute(ny.MAX_RESOLUTION, b) : this.removeAttribute(ny.MAX_RESOLUTION)) } get customDomain() { var b; return null != (b = this.getAttribute(ny.CUSTOM_DOMAIN)) ? b : void 0 } set customDomain(b) { b !== this.customDomain && (b ? this.setAttribute(ny.CUSTOM_DOMAIN, b) : this.removeAttribute(ny.CUSTOM_DOMAIN)) } get ended() { return we(this.nativeEl, this._hls) } get envKey() { var b; return null != (b = this.getAttribute(ny.ENV_KEY)) ? b : void 0 } set envKey(b) { b !== this.envKey && (b ? this.setAttribute(ny.ENV_KEY, b) : this.removeAttribute(ny.ENV_KEY)) } get beaconCollectionDomain() { var b; return null != (b = this.getAttribute(ny.BEACON_COLLECTION_DOMAIN)) ? b : void 0 } set beaconCollectionDomain(b) { b !== this.beaconCollectionDomain && (b ? this.setAttribute(ny.BEACON_COLLECTION_DOMAIN, b) : this.removeAttribute(ny.BEACON_COLLECTION_DOMAIN)) } get streamType() { var b; return null != (b = this.getAttribute(ny.STREAM_TYPE)) ? b : Et(this.nativeEl) } set streamType(b) { b !== this.streamType && (b ? this.setAttribute(ny.STREAM_TYPE, b) : this.removeAttribute(ny.STREAM_TYPE)) } get targetLiveWindow() { return this.hasAttribute(ny.TARGET_LIVE_WINDOW) ? +this.getAttribute(ny.TARGET_LIVE_WINDOW) : Pt(this.nativeEl) } set targetLiveWindow(b) { b != this.targetLiveWindow && (null == b ? this.removeAttribute(ny.TARGET_LIVE_WINDOW) : this.setAttribute(ny.TARGET_LIVE_WINDOW, `${+b}`)) } get liveEdgeStart() { var b, A; if (this.hasAttribute(ny.LIVE_EDGE_OFFSET)) { let { liveEdgeOffset: D } = this, N = null != (b = this.nativeEl.seekable.end(0)) ? b : 0; return Math.max(null != (A = this.nativeEl.seekable.start(0)) ? A : 0, N - D) } return At(this.nativeEl) } get liveEdgeOffset() { if (this.hasAttribute(ny.LIVE_EDGE_OFFSET)) return +this.getAttribute(ny.LIVE_EDGE_OFFSET) } set liveEdgeOffset(b) { b != this.targetLiveWindow && (null == b ? this.removeAttribute(ny.LIVE_EDGE_OFFSET) : this.setAttribute(ny.LIVE_EDGE_OFFSET, `${+b}`)) } get seekable() { return Ie(this.nativeEl) } async addCuePoints(b) { return $(this.nativeEl, b) } get activeCuePoint() { return X(this.nativeEl) } get cuePoints() { return function (b, A = { label: tZ }) { let D = C(b, A); return null != D && D.cues ? Array.from(D.cues, b => z(b)) : [] }(this.nativeEl) } getStartDate() { return function (b, A) { if (A) { let D = A.playingDate; if (null != D) return new Date(D.getTime() - 1e3 * b.currentTime) } return "function" == typeof b.getStartDate ? b.getStartDate() : new Date(NaN) }(this.nativeEl, this._hls) } get currentPdt() { return function (b, A) { if (A && A.playingDate) return A.playingDate; if ("function" == typeof b.getStartDate) { let A = b.getStartDate(); return new Date(A.getTime() + 1e3 * b.currentTime) } return new Date(NaN) }(this.nativeEl, this._hls) } get preferPlayback() { let b = this.getAttribute(ny.PREFER_PLAYBACK); if (b === tV.MSE || b === tV.NATIVE) return b } set preferPlayback(b) { b !== this.preferPlayback && (b === tV.MSE || b === tV.NATIVE ? this.setAttribute(ny.PREFER_PLAYBACK, b) : this.removeAttribute(ny.PREFER_PLAYBACK)) } get metadata() { return { ...this.getAttributeNames().filter(b => b.startsWith("metadata-") && ![ny.METADATA_URL].includes(b)).reduce((b, A) => { let D = this.getAttribute(A); return null != D && (b[A.replace(/^metadata-/, "").replace(/-/g, "_")] = D), b }, {}), ...r(this, np) } } set metadata(b) { d(this, np, null != b ? b : {}), this.mux && this.mux.emit("hb", r(this, np)) } load() { d(this, nc, St(this, this.nativeEl, r(this, nc))) } unload() { He(this.nativeEl, r(this, nc)), d(this, nc, void 0) } attributeChangedCallback(b, A, D) { var N, V; switch (nE.observedAttributes.includes(b) && !["src", "autoplay", "preload"].includes(b) && super.attributeChangedCallback(b, A, D), b) { case ny.PLAYER_SOFTWARE_NAME: this.playerSoftwareName = null != D ? D : void 0; break; case ny.PLAYER_SOFTWARE_VERSION: this.playerSoftwareVersion = null != D ? D : void 0; break; case "src": { let b = !!A, N = !!D; !b && N ? T(this, nb, ng).call(this) : b && !N ? this.unload() : b && N && (this.unload(), T(this, nb, ng).call(this)); break } case "autoplay": if (D === A) break; null == (N = r(this, nc)) || N.setAutoplay(this.autoplay); break; case "preload": if (D === A) break; null == (V = r(this, nc)) || V.setPreload(D); break; case ny.PLAYBACK_ID: this.src = xt(null != D ? D : void 0, { maxResolution: this.maxResolution, domain: this.customDomain }); break; case ny.DEBUG: { let b = this.debug; this.mux && console.info("Cannot toggle debug mode of mux data after initialization. Make sure you set all metadata to override before setting the src."), this._hls && (this._hls.config.debug = b); break } case ny.METADATA_URL: D && fetch(D).then(b => b.json()).then(b => this.metadata = b).catch(() => console.error(`Unable to load or parse metadata JSON from metadata-url ${D}!`)); break; case ny.STREAM_TYPE: (null == D || D !== A) && this.dispatchEvent(new CustomEvent("streamtypechange", { composed: !0, bubbles: !0 })); break; case ny.TARGET_LIVE_WINDOW: (null == D || D !== A) && this.dispatchEvent(new CustomEvent("targetlivewindowchange", { composed: !0, bubbles: !0, detail: this.targetLiveWindow })) } } connectedCallback() { var b; null == (b = super.connectedCallback) || b.call(this), this.nativeEl && this.src && !r(this, nc) && T(this, nb, ng).call(this) } disconnectedCallback() { this.unload() } }; nc = new WeakMap, nm = new WeakMap, nh = new WeakMap, np = new WeakMap, nv = new WeakMap, n_ = new WeakMap, nf = new WeakMap, nb = new WeakSet, ng = async function () { r(this, nm) || (await d(this, nm, Promise.resolve()), d(this, nm, null), this.load()) }, rL.customElements.get("mux-video") || (rL.customElements.define("mux-video", nk), rL.MuxVideoElement = nk); var nT = Object.defineProperty, template_parts_defNormalProp = (b, A, D) => A in b ? nT(b, A, { enumerable: !0, configurable: !0, writable: !0, value: D }) : b[A] = D, template_parts_publicField = (b, A, D) => (template_parts_defNormalProp(b, "symbol" != typeof A ? A + "" : A, D), D), template_parts_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, template_parts_privateGet = (b, A, D) => (template_parts_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), template_parts_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, template_parts_privateSet = (b, A, D, N) => (template_parts_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D); let nw = { processCallback(b, A, D) { if (D) { for (let [b, N] of A) if (b in D) { let A = D[b]; "boolean" == typeof A && N instanceof AttrPart && "boolean" == typeof N.element[N.attributeName] ? N.booleanValue = A : "function" == typeof A && N instanceof AttrPart ? N.element[N.attributeName] = A : N.value = A } } } }; let TemplateInstance = class TemplateInstance extends eg.DocumentFragment { constructor(b, A, D = nw) { var N; super(), template_parts_privateAdd(this, nW, void 0), template_parts_privateAdd(this, nF, void 0), this.append(b.content.cloneNode(!0)), template_parts_privateSet(this, nW, parse(this)), template_parts_privateSet(this, nF, D), null == (N = D.createCallback) || N.call(D, this, template_parts_privateGet(this, nW), A), D.processCallback(this, template_parts_privateGet(this, nW), A) } update(b) { template_parts_privateGet(this, nF).processCallback(this, template_parts_privateGet(this, nW), b) } }; nW = new WeakMap, nF = new WeakMap; let parse = (b, A = []) => { let D, N; for (let V of b.attributes || []) if (V.value.includes("{{")) { let Y = new AttrPartList; for ([D, N] of tokenize(V.value)) if (D) { let D = new AttrPart(b, V.name, V.namespaceURI); Y.append(D), A.push([N, D]) } else Y.append(N); V.value = Y.toString() } for (let V of b.childNodes) if (1 !== V.nodeType || V instanceof HTMLTemplateElement) { if (1 === V.nodeType || V.data.includes("{{")) { let Y = []; if (V.data) for ([D, N] of tokenize(V.data)) if (D) { let D = new ChildNodePart(b); Y.push(D), A.push([N, D]) } else Y.push(new Text(N)); else if (V instanceof HTMLTemplateElement) { let D = new InnerTemplatePart(b, V); Y.push(D), A.push([D.expression, D]) } V.replaceWith(...Y.flatMap(b => b.replacementNodes || [b])) } } else parse(V, A); return A }, nS = {}, tokenize = b => { let A = "", D = 0, N = nS[b], V = 0, Y; if (N) return N; for (N = []; Y = b[V]; V++)"{" === Y && "{" === b[V + 1] && "\\" !== b[V - 1] && b[V + 2] && 1 == ++D ? (A && N.push([0, A]), A = "", V++) : "}" !== Y || "}" !== b[V + 1] || "\\" === b[V - 1] || --D ? A += Y || "" : (N.push([1, A.trim()]), A = "", V++); return A && N.push([0, (D > 0 ? "{{" : "") + A]), nS[b] = N }; let Part = class Part { get value() { return "" } set value(b) { } toString() { return this.value } }; let nD = new WeakMap; let AttrPartList = class AttrPartList { constructor() { template_parts_privateAdd(this, nH, []) } [Symbol.iterator]() { return template_parts_privateGet(this, nH).values() } get length() { return template_parts_privateGet(this, nH).length } item(b) { return template_parts_privateGet(this, nH)[b] } append(...b) { for (let A of b) A instanceof AttrPart && nD.set(A, this), template_parts_privateGet(this, nH).push(A) } toString() { return template_parts_privateGet(this, nH).join("") } }; nH = new WeakMap; let AttrPart = class AttrPart extends Part { constructor(b, A, D) { super(), template_parts_privateAdd(this, n$), template_parts_privateAdd(this, nG, ""), template_parts_privateAdd(this, nV, void 0), template_parts_privateAdd(this, nj, void 0), template_parts_privateAdd(this, nq, void 0), template_parts_privateSet(this, nV, b), template_parts_privateSet(this, nj, A), template_parts_privateSet(this, nq, D) } get attributeName() { return template_parts_privateGet(this, nj) } get attributeNamespace() { return template_parts_privateGet(this, nq) } get element() { return template_parts_privateGet(this, nV) } get value() { return template_parts_privateGet(this, nG) } set value(b) { template_parts_privateGet(this, nG) !== b && (template_parts_privateSet(this, nG, b), template_parts_privateGet(this, n$, nY) && 1 !== template_parts_privateGet(this, n$, nY).length ? template_parts_privateGet(this, nV).setAttributeNS(template_parts_privateGet(this, nq), template_parts_privateGet(this, nj), template_parts_privateGet(this, n$, nY)) : null == b ? template_parts_privateGet(this, nV).removeAttributeNS(template_parts_privateGet(this, nq), template_parts_privateGet(this, nj)) : template_parts_privateGet(this, nV).setAttributeNS(template_parts_privateGet(this, nq), template_parts_privateGet(this, nj), b)) } get booleanValue() { return template_parts_privateGet(this, nV).hasAttributeNS(template_parts_privateGet(this, nq), template_parts_privateGet(this, nj)) } set booleanValue(b) { if (template_parts_privateGet(this, n$, nY) && 1 !== template_parts_privateGet(this, n$, nY).length) throw new DOMException("Value is not fully templatized"); this.value = b ? "" : null } }; nG = new WeakMap, nV = new WeakMap, nj = new WeakMap, nq = new WeakMap, n$ = new WeakSet, nY = function () { return nD.get(this) }; let ChildNodePart = class ChildNodePart extends Part { constructor(b, A) { super(), template_parts_privateAdd(this, nK, void 0), template_parts_privateAdd(this, nZ, void 0), template_parts_privateSet(this, nK, b), template_parts_privateSet(this, nZ, A ? [...A] : [new Text]) } get replacementNodes() { return template_parts_privateGet(this, nZ) } get parentNode() { return template_parts_privateGet(this, nK) } get nextSibling() { return template_parts_privateGet(this, nZ)[template_parts_privateGet(this, nZ).length - 1].nextSibling } get previousSibling() { return template_parts_privateGet(this, nZ)[0].previousSibling } get value() { return template_parts_privateGet(this, nZ).map(b => b.textContent).join("") } set value(b) { this.replace(b) } replace(...b) { let A = b.flat().flatMap(b => null == b ? [new Text] : b.forEach ? [...b] : 11 === b.nodeType ? [...b.childNodes] : b.nodeType ? [b] : [new Text(b)]); A.length || A.push(new Text), template_parts_privateSet(this, nZ, function (b, A, D, N = null) { let V = 0, Y, Z, ee, et = D.length, ea = A.length; for (; V < et && V < ea && A[V] == D[V];)V++; for (; V < et && V < ea && D[et - 1] == A[ea - 1];)N = D[--ea, --et]; if (V == ea) for (; V < et;)b.insertBefore(D[V++], N); if (V == et) for (; V < ea;)b.removeChild(A[V++]); else { for (Y = A[V]; V < et;)ee = D[V++], Z = Y ? Y.nextSibling : N, Y == ee ? Y = Z : V < et && D[V] == Z ? (b.replaceChild(ee, Y), Y = Z) : b.insertBefore(ee, Y); for (; Y != N;)Z = Y.nextSibling, b.removeChild(Y), Y = Z } return D }(template_parts_privateGet(this, nZ)[0].parentNode, template_parts_privateGet(this, nZ), A, this.nextSibling)) } }; nK = new WeakMap, nZ = new WeakMap; let InnerTemplatePart = class InnerTemplatePart extends ChildNodePart { constructor(b, A) { let D = A.getAttribute("directive") || A.getAttribute("type"), N = A.getAttribute("expression") || A.getAttribute(D) || ""; N.startsWith("{{") && (N = N.trim().slice(2, -2).trim()), super(b), template_parts_publicField(this, "directive"), this.expression = N, this.template = A, this.directive = D } }; let nI = { string: b => String(b) }; let PartialTemplate = class PartialTemplate { constructor(b) { this.template = b, this.state = void 0 } }; let nM = new WeakMap, nC = new WeakMap, nx = { partial: (b, A) => { A[b.expression] = new PartialTemplate(b.template) }, if: (b, A) => { var D; if (evaluateExpression(b.expression, A)) { if (nM.get(b) !== b.template) { nM.set(b, b.template); let D = new TemplateInstance(b.template, A, nR); b.replace(D), nC.set(b, D) } else null == (D = nC.get(b)) || D.update(A) } else b.replace(""), nM.delete(b), nC.delete(b) } }, nL = Object.keys(nx), nR = { processCallback(b, A, D) { var N, V; if (D) for (let [b, Y] of A) { if (Y instanceof InnerTemplatePart) { if (!Y.directive) { let b = nL.find(b => Y.template.hasAttribute(b)); b && (Y.directive = b, Y.expression = Y.template.getAttribute(b)) } null == (N = nx[Y.directive]) || N.call(nx, Y, D); continue } let A = evaluateExpression(b, D); if (A instanceof PartialTemplate) { nM.get(Y) !== A.template ? (nM.set(Y, A.template), A = new TemplateInstance(A.template, A.state, nR), Y.value = A, nC.set(Y, A)) : null == (V = nC.get(Y)) || V.update(A.state); continue } A ? (Y instanceof AttrPart && Y.attributeName.startsWith("aria-") && (A = String(A)), Y instanceof AttrPart ? "boolean" == typeof A ? Y.booleanValue = A : "function" == typeof A ? Y.element[Y.attributeName] = A : Y.value = A : (Y.value = A, nM.delete(Y), nC.delete(Y))) : Y instanceof AttrPart ? Y.value = void 0 : (Y.value = void 0, nM.delete(Y), nC.delete(Y)) } } }, nO = { "!": b => !b, "!!": b => !!b, "==": (b, A) => b == A, "!=": (b, A) => b != A, ">": (b, A) => b > A, ">=": (b, A) => b >= A, "<": (b, A) => b < A, "<=": (b, A) => b <= A, "??": (b, A) => null != b ? b : A, "|": (b, A) => { var D; return null == (D = nI[A]) ? void 0 : D.call(nI, b) } }; function evaluateExpression(b, A = {}) { var D, N, V, Y, Z, ee, et; let ea = (function (b, A) { let D, N, V, Y = []; for (; b;) { for (let Y in V = null, D = b.length, A) (N = A[Y].exec(b)) && N.index < D && (V = { token: N[0], type: Y, matches: N.slice(1) }, D = N.index); D && Y.push({ token: b.substr(0, D), type: void 0 }), V && Y.push(V), b = b.substr(D + (V ? V.token.length : 0)) } return Y })(b, { boolean: /true|false/, number: /-?\d+\.?\d*/, string: /(["'])((?:\\.|[^\\])*?)\1/, operator: /[!=><][=!]?|\?\?|\|/, ws: /\s+/, param: /[$a-z_][$\w]*/i }).filter(({ type: b }) => "ws" !== b); if (0 === ea.length || ea.some(({ type: b }) => !b)) return invalidExpression(b); if ((null == (D = ea[0]) ? void 0 : D.token) === ">") { let D = A[null == (N = ea[1]) ? void 0 : N.token]; if (!D) return invalidExpression(b); let ee = { ...A }; D.state = ee; let et = ea.slice(2); for (let b = 0; b < et.length; b += 3) { let D = null == (V = et[b]) ? void 0 : V.token, N = null == (Y = et[b + 1]) ? void 0 : Y.token, ea = null == (Z = et[b + 2]) ? void 0 : Z.token; D && "=" === N && (ee[D] = getParamValue(ea, A)) } return D } if (1 === ea.length) return isValidParam(ea[0]) ? getParamValue(ea[0].token, A) : invalidExpression(b); if (2 === ea.length) { let D = null == (ee = ea[0]) ? void 0 : ee.token, N = nO[D]; if (!N || !isValidParam(ea[1])) return invalidExpression(b); let V = getParamValue(ea[1].token, A); return N(V) } if (3 === ea.length) { let D = null == (et = ea[1]) ? void 0 : et.token, N = nO[D]; if (!N || !isValidParam(ea[0]) || !isValidParam(ea[2])) return invalidExpression(b); let V = getParamValue(ea[0].token, A); if ("|" === D) return N(V, ea[2].token); let Y = getParamValue(ea[2].token, A); return N(V, Y) } } function invalidExpression(b) { return console.warn(`Warning: invalid expression \`${b}\``), !1 } function isValidParam({ type: b }) { return ["number", "boolean", "string", "param"].includes(b) } function getParamValue(b, A) { let D = b[0], N = b.slice(-1); return "true" === b || "false" === b ? "true" === b : D === N && ["'", '"'].includes(D) ? b.slice(1, -1) : isNumericString(b) ? parseFloat(b) : A[b] } var nN = Object.defineProperty, media_theme_element_defNormalProp = (b, A, D) => A in b ? nN(b, A, { enumerable: !0, configurable: !0, writable: !0, value: D }) : b[A] = D, media_theme_element_publicField = (b, A, D) => (media_theme_element_defNormalProp(b, "symbol" != typeof A ? A + "" : A, D), D), media_theme_element_accessCheck = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, media_theme_element_privateGet = (b, A, D) => (media_theme_element_accessCheck(b, A, "read from private field"), D ? D.call(b) : A.get(b)), media_theme_element_privateAdd = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, media_theme_element_privateSet = (b, A, D, N) => (media_theme_element_accessCheck(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), media_theme_element_privateMethod = (b, A, D) => (media_theme_element_accessCheck(b, A, "access private method"), D); let nP = { mediatargetlivewindow: "targetlivewindow", mediastreamtype: "streamtype" }, nU = eE.createElement("template"); nU.innerHTML = `
    <style>
      :host {
        display: inline-block;
        line-height: 0;
      }
  
      media-controller {
        width: 100%;
        height: 100%;
      }
  
      media-controller:not([mediasubtitleslist]) media-captions-selectmenu,
      media-captions-button:not([mediasubtitleslist]),
      media-rendition-selectmenu[mediarenditionunavailable],
      media-audio-track-selectmenu[mediaaudiotrackunavailable],
      media-volume-range[mediavolumeunavailable],
      media-airplay-button[mediaairplayunavailable],
      media-fullscreen-button[mediafullscreenunavailable],
      media-cast-button[mediacastunavailable],
      media-pip-button[mediapipunavailable] {
        display: none;
      }
    </style>
  `; let MediaThemeElement = class MediaThemeElement extends eg.HTMLElement { constructor() { super(), media_theme_element_privateAdd(this, nJ), media_theme_element_privateAdd(this, n1), media_theme_element_publicField(this, "renderRoot"), media_theme_element_publicField(this, "renderer"), media_theme_element_privateAdd(this, nQ, void 0), media_theme_element_privateAdd(this, nz, void 0), media_theme_element_privateAdd(this, nX, void 0), this.shadowRoot ? this.renderRoot = this.shadowRoot : (this.renderRoot = this.attachShadow({ mode: "open" }), this.createRenderer()); let b = new MutationObserver(b => { var A; (!this.mediaController || (null == (A = this.mediaController) ? void 0 : A.breakpointsComputed)) && b.some(b => { let A = b.target; return A === this || "media-controller" === A.localName && !!(nP[b.attributeName] || b.attributeName.startsWith("breakpoint")) }) && this.render() }); b.observe(this, { attributes: !0 }), b.observe(this.renderRoot, { attributes: !0, subtree: !0 }), this.addEventListener(en.BREAKPOINTS_COMPUTED, this.render), media_theme_element_privateMethod(this, nJ, n0).call(this, "template") } get mediaController() { return this.renderRoot.querySelector("media-controller") } get template() { var b; return null != (b = media_theme_element_privateGet(this, nQ)) ? b : this.constructor.template } set template(b) { media_theme_element_privateSet(this, nX, null), media_theme_element_privateSet(this, nQ, b), this.createRenderer() } get props() { var b, A, D; let N = [...Array.from(null != (A = null == (b = this.mediaController) ? void 0 : b.attributes) ? A : []).filter(({ name: b }) => nP[b] || b.startsWith("breakpoint")), ...Array.from(this.attributes)], V = {}; for (let b of N) { let A = null != (D = nP[b.name]) ? D : b.name.replace(/[-_]([a-z])/g, (b, A) => A.toUpperCase()), { value: N } = b; null != N ? (isNumericString(N) && (N = parseFloat(N)), V[A] = "" === N || N) : V[A] = !1 } return V } attributeChangedCallback(b, A, D) { "template" === b && A != D && media_theme_element_privateMethod(this, n1, n2).call(this) } connectedCallback() { media_theme_element_privateMethod(this, n1, n2).call(this) } createRenderer() { this.template && this.template !== media_theme_element_privateGet(this, nz) && (media_theme_element_privateSet(this, nz, this.template), this.renderer = new TemplateInstance(this.template, this.props, this.constructor.processor), this.renderRoot.textContent = "", this.renderRoot.append(nU.content.cloneNode(!0), this.renderer)) } render() { var b; null == (b = this.renderer) || b.update(this.props) } }; async function request(b) { let A = await fetch(b); if (200 !== A.status) throw Error(`Failed to load resource: the server responded with a status of ${A.status}`); return A.text() } nQ = new WeakMap, nz = new WeakMap, nX = new WeakMap, nJ = new WeakSet, n0 = function (b) { if (Object.prototype.hasOwnProperty.call(this, b)) { let A = this[b]; delete this[b], this[b] = A } }, n1 = new WeakSet, n2 = function () { var b; let A = this.getAttribute("template"); if (!A || A === media_theme_element_privateGet(this, nX)) return; let D = this.getRootNode(), N = null == (b = null == D ? void 0 : D.getElementById) ? void 0 : b.call(D, A); if (N) { media_theme_element_privateSet(this, nX, A), media_theme_element_privateSet(this, nQ, N), this.createRenderer(); return } (function (b) { if (!/^(\/|\.\/|https?:\/\/)/.test(b)) return !1; let A = /^https?:\/\//.test(b) ? void 0 : location.origin; try { new URL(b, A) } catch (b) { return !1 } return !0 })(A) && (media_theme_element_privateSet(this, nX, A), request(A).then(b => { let A = eE.createElement("template"); A.innerHTML = b, media_theme_element_privateSet(this, nQ, A), this.createRenderer() }).catch(console.error)) }, media_theme_element_publicField(MediaThemeElement, "template"), media_theme_element_publicField(MediaThemeElement, "observedAttributes", ["template"]), media_theme_element_publicField(MediaThemeElement, "processor", nR), eg.customElements.get("media-theme") || eg.customElements.define("media-theme", MediaThemeElement); var mux_player_dist_Oe = (b, A, D) => { if (!A.has(b)) throw TypeError("Cannot " + D) }, u = (b, A, D) => (mux_player_dist_Oe(b, A, "read from private field"), D ? D.call(b) : A.get(b)), dist_b = (b, A, D) => { if (A.has(b)) throw TypeError("Cannot add the same private member more than once"); A instanceof WeakSet ? A.add(b) : A.set(b, D) }, dist_x = (b, A, D, N) => (mux_player_dist_Oe(b, A, "write to private field"), N ? N.call(b, D) : A.set(b, D), D), mux_player_dist_f = (b, A, D) => (mux_player_dist_Oe(b, A, "access private method"), D), nB = class { addEventListener() { } removeEventListener() { } dispatchEvent(b) { return !0 } }; "undefined" == typeof DocumentFragment && (globalThis.DocumentFragment = class extends nB { }); var nW, nF, nH, nG, nV, nj, nq, n$, nY, nK, nZ, nQ, nz, nX, nJ, n0, n1, n2, n5, n3 = class extends nB { }, n4 = class { constructor(b, A = {}) { dist_b(this, n5, void 0), dist_x(this, n5, null == A ? void 0 : A.detail) } get detail() { return u(this, n5) } initCustomEvent() { } }; n5 = new WeakMap; var n7 = { document: { createElement: function (b, A) { return new n3 } }, DocumentFragment, customElements: { get(b) { }, define(b, A, D) { }, upgrade(b) { }, whenDefined: b => Promise.resolve(n3) }, CustomEvent: n4, EventTarget: nB, HTMLElement: n3, HTMLVideoElement: class extends nB { } }, n8 = "undefined" == typeof window || void 0 === globalThis.customElements, n6 = n8 ? n7 : globalThis, n9 = n8 ? n7.document : globalThis.document, ot = { code: "en" }; function l(b, A = !0) { var D; let N = A && null != (D = null == ot ? void 0 : ot[b]) ? D : b, V = A ? ot.code : "en"; return new oa(N, V) } var oa = class { constructor(b, A = null != (oi = ot.code) ? oi : "en") { this.message = b, this.locale = A } format(b) { return this.message.replace(/\{(\w+)\}/g, (A, D) => { var N; return null != (N = b[D]) ? N : "" }) } toString() { return this.message } }; function mux_player_dist_le(b) { return b.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function mux_player_dist_me(b) { return b.replace(/[-_]([a-z])/g, (b, A) => A.toUpperCase()) } function dist_R(b) { if (null == b) return; let A = +b; return Number.isNaN(A) ? void 0 : A } function dist_ue(b) { let A = (function (b) { let A = {}; for (let D in b) null != b[D] && (A[D] = b[D]); return new URLSearchParams(A) })(b).toString(); return A ? "?" + A : "" } function dist_N(b) { let A = (null != b ? b : "").split(".")[1]; return A ? JSON.parse(decodeURIComponent(atob(A.replace(/-/g, "+").replace(/_/g, "/")).split("").map(function (b) { return "%" + ("00" + b.charCodeAt(0).toString(16)).slice(-2) }).join(""))) : {} } var oi, or, on, oo, mux_player_dist_Ce = (b, A) => !!b && !!A && (!!b.contains(A) || mux_player_dist_Ce(b, A.getRootNode().host)), os = "mux.com", ol = (() => { try { return "1.15.0" } catch { } return "UNKNOWN" })(), dist_Ne = (b, { maxResolution: A, token: D, domain: N = os } = {}) => { let V = D ? { token: D } : { redundant_streams: !0, ...A ? { max_resolution: A } : {} }; return `https://stream.${N}/${b}.m3u8${dist_ue(V)}` }, dt = (b, { token: A, thumbnailTime: D, domain: N = os } = {}) => { let V = null == A ? D : void 0, { aud: Y } = dist_N(A); if (!(A && "t" !== Y)) return `https://image.${N}/${b}/thumbnail.webp${dist_ue({ token: A, time: V })}` }, dist_lt = (b, { token: A, domain: D = os } = {}) => { let { aud: N } = dist_N(A); if (!(A && "s" !== N)) return `https://image.${D}/${b}/storyboard.vtt${dist_ue({ token: A, format: "webp" })}` }, dist_Q = b => { if (b) { if ([tG.LIVE, tG.ON_DEMAND].includes(b)) return b; if (null != b && b.includes("live")) return tG.LIVE } }, od = { crossorigin: "crossOrigin", playsinline: "playsInline" }, ou = class { constructor(b, A) { dist_b(this, or, void 0), dist_b(this, on, void 0), dist_b(this, oo, []), dist_x(this, or, b), dist_x(this, on, A) } [Symbol.iterator]() { return u(this, oo).values() } get length() { return u(this, oo).length } get value() { var b; return null != (b = u(this, oo).join(" ")) ? b : "" } set value(b) { var A; b !== this.value && (dist_x(this, oo, []), this.add(...null != (A = null == b ? void 0 : b.split(" ")) ? A : [])) } toString() { return this.value } item(b) { return u(this, oo)[b] } values() { return u(this, oo).values() } keys() { return u(this, oo).keys() } forEach(b) { u(this, oo).forEach(b) } add(...b) { var A, D; b.forEach(b => { this.contains(b) || u(this, oo).push(b) }), ("" !== this.value || null != (A = u(this, or)) && A.hasAttribute(`${u(this, on)}`)) && null != (D = u(this, or)) && D.setAttribute(`${u(this, on)}`, `${this.value}`) } remove(...b) { var A; b.forEach(b => { u(this, oo).splice(u(this, oo).indexOf(b), 1) }), null == (A = u(this, or)) || A.setAttribute(`${u(this, on)}`, `${this.value}`) } contains(b) { return u(this, oo).includes(b) } toggle(b, A) { return void 0 !== A ? A ? (this.add(b), !0) : (this.remove(b), !1) : this.contains(b) ? (this.remove(b), !1) : (this.add(b), !0) } replace(b, A) { this.remove(b), this.add(A) } }; or = new WeakMap, on = new WeakMap, oo = new WeakMap; var oc = `[mux-player ${ol}]`; function mux_player_dist_B(...b) { console.warn(oc, ...b) } function dist_S(...b) { console.error(oc, ...b) } function dist_Be(b) {
      var A; let D = null != (A = b.message) ? A : ""; b.context && (D += ` ${b.context}`), b.file && (D += ` ${l("Read more: ")}
  https://github.com/muxinc/elements/blob/main/errors/${b.file}`), mux_player_dist_B(D)
    } var om = { AUTOPLAY: "autoplay", CROSSORIGIN: "crossorigin", LOOP: "loop", MUTED: "muted", PLAYSINLINE: "playsinline", PRELOAD: "preload" }, oh = { VOLUME: "volume", PLAYBACKRATE: "playbackrate", MUTED: "muted" }, op = Object.freeze({ length: 0, start(b) { let A = b >>> 0; if (A >= this.length) throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${A}) is greater than or equal to the maximum bound (${this.length}).`); return 0 }, end(b) { let A = b >>> 0; if (A >= this.length) throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${A}) is greater than or equal to the maximum bound (${this.length}).`); return 0 } }), ov = rP.filter(b => "error" !== b), o_ = Object.values(om).filter(b => ![om.PLAYSINLINE].includes(b)), of = Object.values(oh); function mux_player_dist_X(b, A) { return b.media ? b.media.getAttribute(A) : b.getAttribute(A) } var ob = class extends n6.HTMLElement { static get observedAttributes() { return [...o_, ...of] } constructor() { super(), this.querySelectorAll(":scope > track").forEach(b => { var A; null == (A = this.media) || A.append(b.cloneNode()) }), new MutationObserver(b => { for (let A of b) "childList" === A.type && (A.removedNodes.forEach(b => { var A, D; let N = null == (A = this.media) ? void 0 : A.querySelector(`track[src="${b.src}"]`); N && (null == (D = this.media) || D.removeChild(N)) }), A.addedNodes.forEach(b => { var A; null == (A = this.media) || A.append(b.cloneNode()) })) }).observe(this, { childList: !0, subtree: !0 }) } attributeChangedCallback(b, A, D) { var N, V; switch (b) { case oh.MUTED: this.media && (this.media.muted = null != D, this.media.defaultMuted = null != D); return; case oh.VOLUME: { let b = null != (N = dist_R(D)) ? N : 1; this.media && (this.media.volume = b); return } case oh.PLAYBACKRATE: { let b = null != (V = dist_R(D)) ? V : 1; this.media && (this.media.playbackRate = b, this.media.defaultPlaybackRate = b); return } } } play() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.play()) ? A : Promise.reject() } pause() { var b; null == (b = this.media) || b.pause() } requestCast(b) { var A; return null == (A = this.media) ? void 0 : A.requestCast(b) } get media() { var b; return null == (b = this.shadowRoot) ? void 0 : b.querySelector("mux-video") } get audioTracks() { return this.media.audioTracks } get videoTracks() { return this.media.videoTracks } get audioRenditions() { return this.media.audioRenditions } get videoRenditions() { return this.media.videoRenditions } get paused() { var b, A; return null == (A = null == (b = this.media) ? void 0 : b.paused) || A } get duration() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.duration) ? A : NaN } get ended() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.ended) && A } get buffered() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.buffered) ? A : op } get seekable() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.seekable) ? A : op } get readyState() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.readyState) ? A : 0 } get videoWidth() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.videoWidth) ? A : 0 } get videoHeight() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.videoHeight) ? A : 0 } get currentTime() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.currentTime) ? A : 0 } set currentTime(b) { this.media && (this.media.currentTime = Number(b)) } get volume() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.volume) ? A : 1 } set volume(b) { this.media && (this.media.volume = Number(b)) } get playbackRate() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.playbackRate) ? A : 1 } set playbackRate(b) { this.media && (this.media.playbackRate = Number(b)) } get defaultPlaybackRate() { var b; return null != (b = dist_R(this.getAttribute(oh.PLAYBACKRATE))) ? b : 1 } set defaultPlaybackRate(b) { null != b ? this.setAttribute(oh.PLAYBACKRATE, `${b}`) : this.removeAttribute(oh.PLAYBACKRATE) } get crossOrigin() { return mux_player_dist_X(this, om.CROSSORIGIN) } set crossOrigin(b) { this.setAttribute(om.CROSSORIGIN, `${b}`) } get autoplay() { return null != mux_player_dist_X(this, om.AUTOPLAY) } set autoplay(b) { b ? this.setAttribute(om.AUTOPLAY, "string" == typeof b ? b : "") : this.removeAttribute(om.AUTOPLAY) } get loop() { return null != mux_player_dist_X(this, om.LOOP) } set loop(b) { b ? this.setAttribute(om.LOOP, "") : this.removeAttribute(om.LOOP) } get muted() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.muted) && A } set muted(b) { this.media && (this.media.muted = !!b) } get defaultMuted() { return null != mux_player_dist_X(this, om.MUTED) } set defaultMuted(b) { b ? this.setAttribute(om.MUTED, "") : this.removeAttribute(om.MUTED) } get playsInline() { return null != mux_player_dist_X(this, om.PLAYSINLINE) } set playsInline(b) { dist_S("playsInline is set to true by default and is not currently supported as a setter.") } get preload() { return this.media ? this.media.preload : this.getAttribute("preload") } set preload(b) { ["", "none", "metadata", "auto"].includes(b) ? this.setAttribute(om.PRELOAD, b) : this.removeAttribute(om.PRELOAD) } }, og = `:host {
    --media-control-display: var(--controls);
    --media-loading-indicator-display: var(--loading-indicator);
    --media-dialog-display: var(--dialog);
    --media-play-button-display: var(--play-button);
    --media-live-button-display: var(--live-button);
    --media-seek-backward-button-display: var(--seek-backward-button);
    --media-seek-forward-button-display: var(--seek-forward-button);
    --media-mute-button-display: var(--mute-button);
    --media-captions-button-display: var(--captions-button);
    --media-captions-selectmenu-display: var(--captions-selectmenu, var(--media-captions-button-display));
    --media-rendition-selectmenu-display: var(--rendition-selectmenu);
    --media-audio-track-selectmenu-display: var(--audio-track-selectmenu);
    --media-airplay-button-display: var(--airplay-button);
    --media-pip-button-display: var(--pip-button);
    --media-fullscreen-button-display: var(--fullscreen-button);
    --media-cast-button-display: var(--cast-button);
    --media-playback-rate-button-display: var(--playback-rate-button);
    --media-volume-range-display: var(--volume-range);
    --media-time-range-display: var(--time-range);
    --media-time-display-display: var(--time-display);
    --media-duration-display-display: var(--duration-display);
    --media-title-display-display: var(--title-display);
  
    display: inline-block;
    width: 100%;
    line-height: 0;
  }
  
  /* Hide custom elements that are not defined yet */
  :not(:defined) {
    display: none;
  }
  
  a {
    color: #fff;
    font-size: 0.9em;
    text-decoration: underline;
  }
  
  media-theme {
    width: 100%;
    height: 100%;
    direction: ltr;
  }
  
  media-poster-image {
    width: 100%;
    height: 100%;
  }
  
  media-poster-image:not([src]):not([placeholdersrc]) {
    display: none;
  }
  
  ::part(top),
  [part~='top'] {
    --media-control-display: var(--controls, var(--top-controls));
    --media-play-button-display: var(--play-button, var(--top-play-button));
    --media-live-button-display: var(--live-button, var(--top-live-button));
    --media-seek-backward-button-display: var(--seek-backward-button, var(--top-seek-backward-button));
    --media-seek-forward-button-display: var(--seek-forward-button, var(--top-seek-forward-button));
    --media-mute-button-display: var(--mute-button, var(--top-mute-button));
    --media-captions-button-display: var(--captions-button, var(--top-captions-button));
    --media-captions-selectmenu-display: var(
      --captions-selectmenu,
      var(--media-captions-button-display, var(--top-captions-selectmenu))
    );
    --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--top-rendition-selectmenu));
    --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--top-audio-track-selectmenu));
    --media-airplay-button-display: var(--airplay-button, var(--top-airplay-button));
    --media-pip-button-display: var(--pip-button, var(--top-pip-button));
    --media-fullscreen-button-display: var(--fullscreen-button, var(--top-fullscreen-button));
    --media-cast-button-display: var(--cast-button, var(--top-cast-button));
    --media-playback-rate-button-display: var(--playback-rate-button, var(--top-playback-rate-button));
    --media-volume-range-display: var(--volume-range, var(--top-volume-range));
    --media-time-range-display: var(--time-range, var(--top-time-range));
    --media-time-display-display: var(--time-display, var(--top-time-display));
    --media-duration-display-display: var(--duration-display, var(--top-duration-display));
    --media-title-display-display: var(--title-display, var(--top-title-display));
  }
  
  ::part(center),
  [part~='center'] {
    --media-control-display: var(--controls, var(--center-controls));
    --media-play-button-display: var(--play-button, var(--center-play-button));
    --media-live-button-display: var(--live-button, var(--center-live-button));
    --media-seek-backward-button-display: var(--seek-backward-button, var(--center-seek-backward-button));
    --media-seek-forward-button-display: var(--seek-forward-button, var(--center-seek-forward-button));
    --media-mute-button-display: var(--mute-button, var(--center-mute-button));
    --media-captions-button-display: var(--captions-button, var(--center-captions-button));
    --media-captions-selectmenu-display: var(
      --captions-selectmenu,
      var(--media-captions-button-display, var(--center-captions-selectmenu))
    );
    --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--center-rendition-selectmenu));
    --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--center-audio-track-selectmenu));
    --media-airplay-button-display: var(--airplay-button, var(--center-airplay-button));
    --media-pip-button-display: var(--pip-button, var(--center-pip-button));
    --media-fullscreen-button-display: var(--fullscreen-button, var(--center-fullscreen-button));
    --media-cast-button-display: var(--cast-button, var(--center-cast-button));
    --media-playback-rate-button-display: var(--playback-rate-button, var(--center-playback-rate-button));
    --media-volume-range-display: var(--volume-range, var(--center-volume-range));
    --media-time-range-display: var(--time-range, var(--center-time-range));
    --media-time-display-display: var(--time-display, var(--center-time-display));
    --media-duration-display-display: var(--duration-display, var(--center-duration-display));
  }
  
  ::part(bottom),
  [part~='bottom'] {
    --media-control-display: var(--controls, var(--bottom-controls));
    --media-play-button-display: var(--play-button, var(--bottom-play-button));
    --media-live-button-display: var(--live-button, var(--bottom-live-button));
    --media-seek-backward-button-display: var(--seek-backward-button, var(--bottom-seek-backward-button));
    --media-seek-forward-button-display: var(--seek-forward-button, var(--bottom-seek-forward-button));
    --media-mute-button-display: var(--mute-button, var(--bottom-mute-button));
    --media-captions-button-display: var(--captions-button, var(--bottom-captions-button));
    --media-captions-selectmenu-display: var(
      --captions-selectmenu,
      var(--media-captions-button-display, var(--bottom-captions-selectmenu))
    );
    --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--bottom-rendition-selectmenu));
    --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--bottom-audio-track-selectmenu));
    --media-airplay-button-display: var(--airplay-button, var(--bottom-airplay-button));
    --media-pip-button-display: var(--pip-button, var(--bottom-pip-button));
    --media-fullscreen-button-display: var(--fullscreen-button, var(--bottom-fullscreen-button));
    --media-cast-button-display: var(--cast-button, var(--bottom-cast-button));
    --media-playback-rate-button-display: var(--playback-rate-button, var(--bottom-playback-rate-button));
    --media-volume-range-display: var(--volume-range, var(--bottom-volume-range));
    --media-time-range-display: var(--time-range, var(--bottom-time-range));
    --media-time-display-display: var(--time-display, var(--bottom-time-display));
    --media-duration-display-display: var(--duration-display, var(--bottom-duration-display));
    --media-title-display-display: var(--title-display, var(--bottom-title-display));
  }
  `, oE = `
    :host {
      z-index: 100;
      display: var(--media-dialog-display, flex);
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      box-sizing: border-box;
      color: #fff;
      line-height: 18px;
      font-family: Arial, sans-serif;
      padding: var(--media-dialog-backdrop-padding, 0);
      background: var(--media-dialog-backdrop-background,
        linear-gradient(to bottom, rgba(20, 20, 30, 0.7) 50%, rgba(20, 20, 30, 0.9))
      );
      /* Needs to use !important to prevent overwrite of media-chrome */
      transition: var(--media-dialog-transition-open, visibility .2s, opacity .2s) !important;
      transform: var(--media-dialog-transform-open, none) !important;
      visibility: visible !important;
      opacity: 1 !important;
      pointer-events: auto !important;
    }
  
    :host(:not([open])) {
      /* Needs to use !important to prevent overwrite of media-chrome */
      transition: var(--media-dialog-transition-close, visibility .1s, opacity .1s) !important;
      transform: var(--media-dialog-transform-close, none) !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }
  
    :focus-visible {
      box-shadow: 0 0 0 2px rgba(27, 127, 204, 0.9);
    }
  
    .dialog {
      position: relative;
      box-sizing: border-box;
      background: var(--media-dialog-background, none);
      padding: var(--media-dialog-padding, 10px);
      width: min(320px, 100%);
      word-wrap: break-word;
      max-height: 100%;
      overflow: auto;
      text-align: center;
      line-height: 1.4;
    }
  `, oy = n9.createElement("template"); oy.innerHTML = `
    <style>
      ${oE}
    </style>
  
    <div class="dialog">
      <slot></slot>
    </div>
  `; var oA = class extends n6.HTMLElement { constructor() { var b; super(), this.attachShadow({ mode: "open" }), null == (b = this.shadowRoot) || b.appendChild(this.constructor.template.content.cloneNode(!0)) } show() { this.setAttribute("open", ""), this.dispatchEvent(new CustomEvent("open", { composed: !0, bubbles: !0 })), dist_gt(this) } close() { this.hasAttribute("open") && (this.removeAttribute("open"), this.dispatchEvent(new CustomEvent("close", { composed: !0, bubbles: !0 })), this._previouslyFocusedElement instanceof HTMLElement && this._previouslyFocusedElement.focus()) } attributeChangedCallback(b, A, D) { "open" === b && A !== D && (null != D ? this.show() : this.close()) } connectedCallback() { this.hasAttribute("role") || this.setAttribute("role", "dialog"), this.hasAttribute("open") && dist_gt(this) } }; function dist_gt(b) { let A = new CustomEvent("initfocus", { composed: !0, bubbles: !0, cancelable: !0 }); if (b.dispatchEvent(A), A.defaultPrevented) return; let D = b.querySelector("[autofocus]:not([disabled])"); !D && b.tabIndex >= 0 && (D = b), D || (D = function dist_vt(b) { let A = ["button", "input", "keygen", "select", "textarea"].map(function (b) { return b + ":not([disabled])" }); A.push('[tabindex]:not([disabled]):not([tabindex=""])'); let D = null == b ? void 0 : b.querySelector(A.join(", ")); if (!D && "attachShadow" in Element.prototype) { let A = (null == b ? void 0 : b.querySelectorAll("*")) || []; for (let b = 0; b < A.length && !(A[b].tagName && A[b].shadowRoot && (D = dist_vt(A[b].shadowRoot))); b++); } return D }(b.shadowRoot)), b._previouslyFocusedElement = n9.activeElement, n9.activeElement instanceof HTMLElement && n9.activeElement.blur(), b.addEventListener("transitionend", () => { D instanceof HTMLElement && D.focus({ preventScroll: !0 }) }, { once: !0 }) } oA.styles = oE, oA.template = oy, oA.observedAttributes = ["open"], n6.customElements.get("media-dialog") || (n6.customElements.define("media-dialog", oA), n6.MediaDialog = oA); var ok = oA, oT = n9.createElement("template"); oT.innerHTML = `
    <style>
      ${ok.styles}
  
      .close {
        background: none;
        color: inherit;
        border: none;
        padding: 0;
        font: inherit;
        cursor: pointer;
        outline: inherit;
        width: 28px;
        height: 28px;
        position: absolute;
        top: 1rem;
        right: 1rem;
      }
    </style>
  
    <div class="dialog">
      <slot></slot>
    </div>
  
    <slot name="close">
      <button class="close" tabindex="0">
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </slot>
  `; var ow = class extends ok { constructor() { var b, A; super(), null == (A = null == (b = this.shadowRoot) ? void 0 : b.querySelector(".close")) || A.addEventListener("click", () => { this.close() }) } }; ow.template = oT, n6.customElements.get("mxp-dialog") || (n6.customElements.define("mxp-dialog", ow), n6.MxpDialog = ow); var oS = new WeakMap, oD = class { constructor(b, A) { this.element = b, this.type = A, this.element.addEventListener(this.type, this); let D = oS.get(this.element); D && D.set(this.type, this) } set(b) { if ("function" == typeof b) this.handleEvent = b.bind(this.element); else if ("object" == typeof b && "function" == typeof b.handleEvent) this.handleEvent = b.handleEvent.bind(b); else { this.element.removeEventListener(this.type, this); let b = oS.get(this.element); b && b.delete(this.type) } } static for(b) { oS.has(b.element) || oS.set(b.element, new Map); let A = b.attributeName.slice(2), D = oS.get(b.element); return D && D.has(A) ? D.get(A) : new oD(b.element, A) } }, oI = new Map, oM = new WeakMap, oC = new WeakMap, ox = class { constructor(b, A, D) { this.strings = b, this.values = A, this.processor = D, this.stringsKey = this.strings.join("\x01") } get template() { if (oI.has(this.stringsKey)) return oI.get(this.stringsKey); { let b = n9.createElement("template"), A = this.strings.length - 1; return b.innerHTML = this.strings.reduce((b, D, N) => b + D + (N < A ? `{{ ${N} }}` : ""), ""), oI.set(this.stringsKey, b), b } } renderInto(b) { var A; let D = this.template; if (oM.get(b) !== D) { oM.set(b, D); let A = new TemplateInstance(D, this.values, this.processor); oC.set(b, A), b instanceof ChildNodePart ? b.replace(...A.children) : b.appendChild(A); return } let N = oC.get(b); null == (A = null == N ? void 0 : N.update) || A.call(N, this.values) } }, oL = { processCallback(b, A, D) { var N, V, Y; if (D) for (let [b, Z] of A) { b in D && (function (b, A) { if (b instanceof AttrPart && A instanceof Element) { let D = b.element; return D[b.attributeName] !== A && (b.element.removeAttributeNS(b.attributeNamespace, b.attributeName), D[b.attributeName] = A), !0 } return !1 }(V = Z, Y = null != (N = D[b]) ? N : "") || function (b, A) { if ("boolean" == typeof A && b instanceof AttrPart) { let D = b.attributeNamespace; return A !== b.element.hasAttributeNS(D, b.attributeName) && (b.booleanValue = A), !0 } return !1 }(V, Y) || V instanceof AttrPart && V.attributeName.startsWith("on") && (oD.for(V).set(Y), V.element.removeAttributeNS(V.attributeNamespace, V.attributeName), 1) || !1 === Y && V instanceof ChildNodePart && (V.replace(""), 1) || Y instanceof ox && V instanceof ChildNodePart && (Y.renderInto(V), 1) || Y instanceof DocumentFragment && V instanceof ChildNodePart && (Y.childNodes.length && V.replace(...Y.childNodes), 1) || function (b, A) { if (b instanceof AttrPart) { let D = b.attributeNamespace, N = b.element.getAttributeNS(D, b.attributeName); return String(A) !== N && (b.value = String(A)) } b.value = String(A) }(V, Y)) } } }; function dist_L(b, ...A) { return new ox(b, A, oL) } var mux_player_dist_xt = b => dist_L`
    <style>
      ${og}
    </style>
    ${sa(b)}
  `, na = b => { let A = b.hotKeys ? `${b.hotKeys}` : ""; return "live" === dist_Q(b.streamType) && (A += " noarrowleft noarrowright"), A }, sa = b => {
        var A, D, N, V, Y, Z, ee, et, ea, er, en, eo, es, el, ed, eu, ec, em, eh, ep, ev, e_, ef, eb, eg, eE, ey, eA, ek, eT, ew, eS, eD, eI, eM; let eC; return dist_L`
    <media-theme
      template="${b.themeTemplate || !1}"
      defaultstreamtype="${null != (A = b.defaultStreamType) && A}"
      hotkeys="${na(b) || !1}"
      nohotkeys="${b.noHotKeys || !b.hasSrc || b.isDialogOpen || !1}"
      noautoseektolive="${!!(null != (D = b.streamType) && D.includes(tG.LIVE)) && 0 !== b.targetLiveWindow}"
      novolumepref="${b.novolumepref || !1}"
      disabled="${!b.hasSrc || b.isDialogOpen}"
      audio="${null != (N = b.audio) && N}"
      style="${null != (eM = { "--media-primary-color": b.primaryColor, "--media-secondary-color": b.secondaryColor }, eC = "", Object.entries(eM).forEach(([b, A]) => { null != A && (eC += `${mux_player_dist_le(b)}: ${A}; `) }), V = eC ? eC.trim() : void 0) && V}"
      defaultsubtitles="${!b.defaultHiddenCaptions}"
      forwardseekoffset="${null != (Y = b.forwardSeekOffset) && Y}"
      backwardseekoffset="${null != (Z = b.backwardSeekOffset) && Z}"
      playbackrates="${null != (ee = b.playbackRates) && ee}"
      defaultshowremainingtime="${null != (et = b.defaultShowRemainingTime) && et}"
      hideduration="${null != (ea = b.hideDuration) && ea}"
      title="${null != (er = b.title) && er}"
      exportparts="top, center, bottom, layer, media-layer, poster-layer, vertical-layer, centered-layer, gesture-layer, controller, poster, live, play, button, seek-backward, seek-forward, mute, captions, airplay, pip, fullscreen, cast, playback-rate, volume, range, time, display, control-bar"
    >
      <mux-video
        slot="media"
        target-live-window="${null != (en = b.targetLiveWindow) && en}"
        stream-type="${null != (eo = dist_Q(b.streamType)) && eo}"
        crossorigin="${null != (es = b.crossOrigin) ? es : ""}"
        playsinline
        autoplay="${null != (el = b.autoplay) && el}"
        muted="${null != (ed = b.muted) && ed}"
        loop="${null != (eu = b.loop) && eu}"
        preload="${null != (ec = b.preload) && ec}"
        debug="${null != (em = b.debug) && em}"
        prefer-cmcd="${null != (eh = b.preferCmcd) && eh}"
        disable-cookies="${null != (ep = b.disableCookies) && ep}"
        prefer-playback="${null != (ev = b.preferPlayback) && ev}"
        start-time="${null != b.startTime && b.startTime}"
        beacon-collection-domain="${null != (e_ = b.beaconCollectionDomain) && e_}"
        player-software-name="${null != (ef = b.playerSoftwareName) && ef}"
        player-software-version="${null != (eb = b.playerSoftwareVersion) && eb}"
        env-key="${null != (eg = b.envKey) && eg}"
        custom-domain="${null != (eE = b.customDomain) && eE}"
        src="${b.src ? b.src : !!b.playbackId && dist_Ne(b.playbackId, { maxResolution: b.maxResolution, domain: b.customDomain, token: b.tokens.playback })}"
        cast-src="${b.src ? b.src : !!b.playbackId && dist_Ne(b.playbackId, { maxResolution: b.maxResolution, domain: b.customDomain, token: b.tokens.playback })}"
        exportparts="video"
      >
        ${b.storyboard ? dist_L`<track label="thumbnails" default kind="metadata" src="${b.storyboard}" />` : dist_L``}
      </mux-video>
      <slot name="poster" slot="poster">
        <media-poster-image
          part="poster"
          exportparts="poster, img"
          src="${"" !== b.poster && null != (ey = b.poster) && ey}"
          placeholdersrc="${null != (eA = b.placeholder) && eA}"
        ></media-poster-image>
      </slot>
      <mxp-dialog
        no-auto-hide
        open="${null != (ek = b.isDialogOpen) && ek}"
        onclose="${b.onCloseErrorDialog}"
        oninitfocus="${b.onInitFocusDialog}"
      >
        ${null != (eT = b.dialog) && eT.title ? dist_L`<h3>${b.dialog.title}</h3>` : dist_L``}
        <p>
          ${null == (ew = b.dialog) ? void 0 : ew.message}
          ${null != (eS = b.dialog) && eS.linkUrl ? dist_L`<a
                href="${b.dialog.linkUrl}"
                target="_blank"
                rel="external noopener"
                aria-label="${null != (eD = b.dialog.linkText) ? eD : ""} ${l("(opens in a new window)")}"
                >${null != (eI = b.dialog.linkText) ? eI : b.dialog.linkUrl}</a
              >`: dist_L``}
        </p>
      </mxp-dialog>
    </media-theme>
  `}; function dist_ye(b, A, D, N, V) { var Y, Z, ee; let et = {}, ea = {}; switch (b.code) { case tF.MEDIA_ERR_NETWORK: switch (et.title = l("Network Error", V), et.message = b.message, null == (Y = b.data) ? void 0 : Y.response.code) { case 412: et.title = l("Video is not currently available", V), et.message = l("The live stream or video file are not yet ready.", V), ea.message = l("This playback-id may belong to a live stream that is not currently active or an asset that is not ready.", V), ea.file = "412-not-playable.md"; break; case 404: et.title = l("Video does not exist", V), et.message = "", ea.message = l("This playback-id does not exist. You may have used an Asset ID or an ID from a different resource.", V), ea.file = "404-not-found.md"; break; case 403: { if (et.title = l("Invalid playback URL", V), et.message = l("The video URL or playback-token are formatted with incorrect or incomplete information.", V), ea.message = l("403 error trying to access this playback URL. If this is a signed URL, you might need to provide a playback-token.", V), ea.file = "missing-signed-tokens.md", !N) break; let { exp: b, aud: A, sub: Y } = dist_N(N), Z = Date.now() > 1e3 * b, ee = Y !== D, er = "v" !== A, en = { timeStyle: "medium", dateStyle: "medium" }; if (Z) { et.title = l("Video URL has expired", V), et.message = l("The videos secured playback-token has expired.", V), ea.message = l("The videos secured playback-token has expired.", V), ea.context = l("Expired at: {expiredDate}. Current time: {currentDate}.", V).format({ expiredDate: new Intl.DateTimeFormat(ot.code, en).format(1e3 * b), currentDate: new Intl.DateTimeFormat(ot.code, en).format(Date.now()) }), ea.file = "403-expired-token.md"; break } if (ee) { et.title = l("Video URL is formatted incorrectly", V), et.message = l("The videos playback ID does not match the one encoded in the playback-token.", V), ea.message = l("The videos playback ID does not match the one encoded in the playback-token.", V), ea.context = l("Specified playback ID: {playbackId} and the playback ID encoded in the playback-token: {tokenPlaybackId}", V).format({ playbackId: D, tokenPlaybackId: Y }), ea.file = "403-playback-id-mismatch.md"; break } if (er) { et.title = l("Video URL is formatted incorrectly", V), et.message = l("The playback-token is formatted with incorrect information.", V), ea.message = l("The playback-token is formatted with incorrect information.", V), ea.context = l("The playback-token has an incorrect aud value: {tokenType}. aud value should be v.", V).format({ tokenType: A }), ea.file = "403-incorrect-aud-value.md"; break } ea.message = l("403 error trying to access this playback URL. If this is a signed playback ID, the token might not have been generated correctly.", V), ea.file = "403-malformatted-token.md" } }break; case tF.MEDIA_ERR_DECODE: { let { message: A } = b; et = { title: l("Media Error", V), message: A }, ea.file = "media-decode-error.md"; break } case tF.MEDIA_ERR_SRC_NOT_SUPPORTED: { let Y = null == (ee = null == (Z = b.data) ? void 0 : Z.response) ? void 0 : ee.code; if (Y >= 400 && Y < 500) { b.code = tF.MEDIA_ERR_NETWORK, b.data = { response: { code: Y } }, { dialog: et, devlog: ea } = dist_ye(b, A, D, N); break } et = { title: l("Source Not Supported", V), message: b.message }, ea.file = "media-src-not-supported.md"; break } default: et = { title: l("Error", V), message: b.message } }return A && (et = { title: l("Your device appears to be offline", V), message: l("Check your internet connection and try reloading this video.", V) }), { dialog: et, devlog: ea } } var oR = `<!-- prettier-ignore -->
  <template id="media-theme-classic">
    <style>
      :host {
        --_primary-color: var(--media-primary-color, white);
        --_secondary-color: var(--media-secondary-color, rgb(0 0 0 / .75));
  
        --media-icon-color: var(--_primary-color);
        --media-range-thumb-background: var(--_primary-color);
        --media-range-bar-color: var(--_primary-color);
        --media-control-background: var(--_secondary-color);
        --media-control-hover-background: var(--_secondary-color);
        --media-time-range-buffered-color: rgba(255, 255, 255, 0.4);
        --media-range-track-background:
          linear-gradient(rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)),
          linear-gradient(rgba(20, 20, 30, 0.7), rgba(20, 20, 30, 0.7));
        --media-preview-thumbnail-border: 0;
        --media-preview-thumbnail-border-radius: 2px 2px 0 0;
        --media-preview-time-border-radius: 0 0 2px 2px;
        --media-preview-time-margin: 0 0 8px;
        --media-preview-time-text-shadow: none;
        --media-listbox-border-radius: 2px;
        --media-listbox-transform-in: translateY(-8px) scale(1);
        --media-listbox-transform-out: translateY(-6px) scale(.99);
        --media-option-hover-background: rgba(255, 255, 255, 0.28);
  
        color: var(--_primary-color);
        display: inline-block;
        width: 100%;
        height: 100%;
      }
  
      :host([audio]) {
        --media-preview-time-border-radius: 3px;
        --media-preview-time-margin: 0 0 5px;
        --media-preview-time-text-shadow: none;
      }
  
      :host([audio]) ::slotted([slot='media']) {
        height: 0px;
      }
  
      :host([audio]) media-loading-indicator {
        display: none;
      }
  
      :host([audio]) media-controller {
        background: transparent;
      }
  
      :host([audio]) media-controller::part(vertical-layer) {
        background: transparent;
      }
  
      :host([audio]) media-control-bar {
        width: 100%;
      }
  
      [disabled]:not(media-live-button),
      [aria-disabled='true']:not(media-live-button) {
        opacity: 60%;
        cursor: not-allowed;
      }
  
      /* 0.433s is the transition duration for VTT Regions.
       * Borrowed here, so the captions don't move too fast. */
      media-controller ::slotted([slot='media']) {
        --media-webkit-text-track-transition: transform 0.433s ease-out 0.3s;
      }
      media-controller:is([mediapaused],:not([userinactive])) ::slotted([slot='media']) {
        /* 42px is the height of the control bar and progress bar
         * with an additional 5px as a buffer, to get 47px */
        --media-webkit-text-track-transform: translateY(-47px);
        --media-webkit-text-track-transition: transform 0.15s ease;
      }
  
      :host media-time-range {
        color: var(--_primary-color);
        --media-range-thumb-opacity: 0;
      }
  
      :host(:not([audio])) media-time-range {
        --media-range-padding: 0;
        background: transparent;
        z-index: 10;
        height: 10px;
        bottom: -3px;
        width: 100%;
      }
  
      media-control-bar {
        --media-control-padding: 4px 3px;
      }
  
      [breakpointsm] media-control-bar {
        --media-control-padding: 9px 5px;
      }
  
      [breakpointmd] media-control-bar {
        --media-control-padding: 9px 7px;
      }
  
      media-control-bar :is([role='button'], [role='switch'], button) {
        line-height: 0;
      }
  
      media-control-bar :is(media-text-display, media-time-display):first-child {
        --media-control-padding: 9px 5px 9px 10px;
      }
  
      .spacer {
        flex-grow: 1;
        background-color: var(--media-control-background, rgba(20, 20, 30, 0.7));
      }
  
      /* Add a small space on the right to have the play button and
       * fullscreen button aligned in relation to the progress bar. */
      media-control-bar:not([slot])::after {
        content: '';
        width: 2px;
        height: 100%;
        background-color: var(--media-control-background, rgba(20, 20, 30, 0.7));
      }
  
      media-control-bar[slot='top-chrome'] {
        min-height: 42px;
        pointer-events: none;
      }
  
      :host([title]) media-control-bar[slot='top-chrome']::before {
        content: '';
        position: absolute;
        width: 100%;
        padding-bottom: min(160px, 25%);
        background: linear-gradient(rgb(0 0 0 / 0.4), transparent);
      }
  
      media-control-bar[slot='top-chrome'] > * {
        --media-control-background: transparent;
        --media-control-hover-background: transparent;
        position: relative;
      }
  
      media-controller::part(vertical-layer) {
        transition: background-color 1s;
      }
  
      media-controller:is([mediapaused], :not([userinactive]))::part(vertical-layer) {
        background-color: var(--controls-backdrop-color, var(--controls, transparent));
        transition: background-color 0.25s;
      }
  
      .center-controls {
        --media-button-icon-width: 100%;
        --media-button-icon-height: auto;
        pointer-events: none;
        width: 100%;
        display: flex;
        flex-flow: row;
        align-items: center;
        justify-content: center;
        filter: drop-shadow(0 0 2px rgb(0 0 0 / 0.25)) drop-shadow(0 0 6px rgb(0 0 0 / 0.25));
        paint-order: stroke;
        stroke: rgba(102, 102, 102, 1);
        stroke-width: 0.3px;
        text-shadow: 0 0 2px rgb(0 0 0 / 0.25), 0 0 6px rgb(0 0 0 / 0.25);
      }
  
      .center-controls media-play-button {
        --media-control-background: transparent;
        --media-control-hover-background: transparent;
        padding: 0;
        width: max(43px, min(10%, 55px));
      }
  
      .center-controls media-seek-backward-button,
      .center-controls media-seek-forward-button {
        --media-control-background: transparent;
        --media-control-hover-background: transparent;
        padding: 0;
        margin: 0 2%;
        width: max(33px, min(8%, 40px));
      }
  
      media-control-bar:not([slot]) media-seek-backward-button {
        padding-right: 5px;
      }
  
      media-control-bar:not([slot]) media-seek-forward-button {
        padding-left: 5px;
      }
  
      media-loading-indicator {
        --media-loading-icon-width: 100%;
        --media-button-icon-height: auto;
        display: var(--media-control-display, var(--media-loading-indicator-display, flex));
        pointer-events: none;
        position: absolute;
        width: min(15%, 150px);
        flex-flow: row;
        align-items: center;
        justify-content: center;
      }
  
      /* Intentionally don't target the div for transition but the children
       of the div. Prevents messing with media-chrome's autohide feature. */
      media-loading-indicator + div * {
        transition: opacity 0.15s;
        opacity: 1;
      }
  
      media-loading-indicator[medialoading]:not([mediapaused]) ~ div > * {
        opacity: 0;
        transition-delay: 400ms;
      }
  
      media-volume-range {
        width: min(100%, 100px);
      }
  
      media-time-display {
        white-space: nowrap;
      }
  
      :is(media-time-display, media-text-display, media-playback-rate-button[role='button']) {
        color: inherit;
        line-height: 24px;
      }
  
      :is(.title-display, media-live-button) {
        color: inherit;
        font-size: 16px;
        text-shadow: 0 0 2px rgb(0 0 0 / 0.6);
      }
  
      :host([audio]) .title-display {
        flex-grow: 1;
        font-size: 21px;
      }
    </style>
  
    <template partial="TitleDisplay">
      <template if="title">
        <media-text-display part="top title display" class="title-display">
          {{title}}
        </media-text-display>
      </template>
    </template>
  
    <template partial="PlayButton">
      <media-play-button
        part="{{section ?? 'bottom'}} play button"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      >
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="play">
          <path d="m6.73 20.93 14.05-8.54a.46.46 0 0 0 0-.78L6.73 3.07a.48.48 0 0 0-.73.39v17.07a.48.48 0 0 0 .73.4Z" />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="pause">
          <path
            d="M6 19.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-15a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v15ZM14.5 4a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-15a.5.5 0 0 0-.5-.5h-3Z"
          />
        </svg>
      </media-play-button>
    </template>
  
    <template partial="SeekBackwardButton">
      <media-seek-backward-button
        seekoffset="{{backwardseekoffset}}"
        part="{{section ?? 'bottom'}} seek-backward button"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      >
        <svg aria-hidden="true" viewBox="0 0 22 24" slot="backward">
          <path d="M11 6V3L5.37 7 11 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 11 6Z" />
          <text class="value" transform="translate(2.5 21)" style="font-size: 8px; font-family: 'ArialMT', 'Arial'">
            {{backwardseekoffset}}
          </text>
        </svg>
      </media-seek-backward-button>
    </template>
  
    <template partial="SeekForwardButton">
      <media-seek-forward-button
        seekoffset="{{forwardseekoffset}}"
        part="{{section ?? 'bottom'}} seek-forward button"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      >
        <svg aria-hidden="true" viewBox="0 0 22 24" slot="forward">
          <path d="M11 6V3l5.61 4L11 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 11 6Z" />
          <text class="value" transform="translate(10 21)" style="font-size: 8px; font-family: 'ArialMT', 'Arial'">
            {{forwardseekoffset}}
          </text>
        </svg>
      </media-seek-forward-button>
    </template>
  
    <template partial="MuteButton">
      <media-mute-button part="bottom mute button" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="high">
          <path
            d="m11.14 4.86-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.21a.5.5 0 0 0-.86-.35Zm2.74-1.56v1.52A7.52 7.52 0 0 1 19.47 12a7.52 7.52 0 0 1-5.59 7.18v1.52A9 9 0 0 0 21 12a9 9 0 0 0-7.12-8.7Zm3.56 8.7a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="low">
          <path
            d="m11.14 4.853-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.203a.5.5 0 0 0-.86-.35Zm6.3 7.14a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="medium">
          <path
            d="m11.14 4.853-4 4a.49.49 0 0 1-.35.14H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.5.5 0 0 0 .85-.36V5.203a.5.5 0 0 0-.86-.35Zm6.3 7.14a5.49 5.49 0 0 0-3.56-5.1v1.66a3.93 3.93 0 0 1 0 6.88v1.66a5.49 5.49 0 0 0 3.56-5.1Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="off">
          <path
            d="m3 4.05 4.48 4.47-.33.33a.49.49 0 0 1-.36.15H3.25a.25.25 0 0 0-.25.25v5.5a.25.25 0 0 0 .25.25h3.54a.49.49 0 0 1 .36.15l4 4a.48.48 0 0 0 .36.15.5.5 0 0 0 .5-.5v-5.75l4.67 4.66a7.71 7.71 0 0 1-2.79 1.47v1.52a9.32 9.32 0 0 0 3.87-1.91L20 21l1-1L4.06 3 3 4.05Zm5.36 5.36 2.39 2.39V17L8 14.26a1.74 1.74 0 0 0-1.24-.51H4.25v-3.5h2.54A1.74 1.74 0 0 0 8 9.74l.36-.33ZM19.47 12a7.19 7.19 0 0 1-.89 3.47l1.11 1.1A8.64 8.64 0 0 0 21 12a9 9 0 0 0-7.12-8.7v1.52A7.52 7.52 0 0 1 19.47 12ZM12 8.88V5.21a.5.5 0 0 0-.5-.5.48.48 0 0 0-.36.15L9.56 6.44 12 8.88ZM15.91 12a4.284 4.284 0 0 1-.07.72l1.22 1.22a5.2 5.2 0 0 0 .38-1.94 5.49 5.49 0 0 0-3.56-5.1v1.66A4 4 0 0 1 15.91 12Z"
          />
        </svg>
      </media-mute-button>
    </template>
  
    <template partial="RenditionSelect">
      <media-rendition-selectmenu part="bottom rendition selectmenu" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <media-rendition-button slot="button" part="bottom rendition button">
          <svg aria-hidden="true" slot="icon" viewBox="0 0 18 24">
            <path d="M2.25 14.5a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm6.75 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm6.75 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"/>
          </svg>
        </media-rendition-button>
        <media-rendition-listbox slot="listbox" part="bottom rendition listbox">
          <div slot="header">Quality</div>
        </media-rendition-listbox>
      </media-rendition-selectmenu>
    </template>
  
    <template partial="AudioTrackSelect">
      <media-audio-track-selectmenu part="bottom audio-track selectmenu" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <media-audio-track-button slot="button" part="bottom audio-track button">
          <svg aria-hidden="true" slot="icon" viewBox="0 0 24 24">
            <path d="M12 20.5a8.5 8.5 0 1 0 0-17 8.5 8.5 0 0 0 0 17Zm0 1.5C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10Z"/>
            <path d="M7.25 9.75a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Zm3-3a.75.75 0 0 1 .75.75v9a.75.75 0 0 1-1.5 0v-9a.75.75 0 0 1 .75-.75Zm3 2a.75.75 0 0 1 .75.75v5a.75.75 0 0 1-1.5 0v-5a.75.75 0 0 1 .75-.75Zm3-1a.75.75 0 0 1 .75.75v7a.75.75 0 0 1-1.5 0v-7a.75.75 0 0 1 .75-.75Z"/>
          </svg>
        </media-audio-track-button>
        <media-audio-track-listbox slot="listbox" part="bottom audio-track listbox">
          <div slot="header">Audio</div>
        </media-audio-track-listbox>
      </media-audio-track-selectmenu>
    </template>
  
    <template partial="CaptionsSelect">
      <media-captions-selectmenu part="bottom captions selectmenu" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <media-captions-button slot="button" part="bottom captions button">
          <svg aria-hidden="true" viewBox="0 0 26 24" slot="on">
            <path d="M22.832 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.41 10.1a3.63 3.63 0 0 1-1.51.32 4.76 4.76 0 0 1-1.63-.27 4 4 0 0 1-1.28-.83 3.67 3.67 0 0 1-.84-1.26 4.23 4.23 0 0 1-.3-1.63 4.28 4.28 0 0 1 .3-1.64 3.53 3.53 0 0 1 .84-1.21 3.89 3.89 0 0 1 1.29-.8 4.76 4.76 0 0 1 1.63-.27 4.06 4.06 0 0 1 1.35.24c.225.091.44.205.64.34a2.7 2.7 0 0 1 .55.52l-1.27 1a1.79 1.79 0 0 0-.6-.46 2 2 0 0 0-.83-.16 2 2 0 0 0-1.56.69 2.35 2.35 0 0 0-.46.77 2.78 2.78 0 0 0-.16 1c-.009.34.046.68.16 1 .104.283.26.545.46.77.188.21.415.38.67.5a2 2 0 0 0 .84.18 1.87 1.87 0 0 0 .9-.21 1.78 1.78 0 0 0 .65-.6l1.38 1a2.88 2.88 0 0 1-1.22 1.01Zm7.52 0a3.63 3.63 0 0 1-1.51.32 4.76 4.76 0 0 1-1.63-.27 3.89 3.89 0 0 1-1.28-.83 3.55 3.55 0 0 1-.85-1.26 4.23 4.23 0 0 1-.3-1.63 4.28 4.28 0 0 1 .3-1.64 3.43 3.43 0 0 1 .85-1.25 3.75 3.75 0 0 1 1.28-.8 4.76 4.76 0 0 1 1.63-.27 4 4 0 0 1 1.35.24c.225.091.44.205.64.34.21.144.395.32.55.52l-1.27 1a1.79 1.79 0 0 0-.6-.46 2 2 0 0 0-.83-.16 2 2 0 0 0-1.56.69 2.352 2.352 0 0 0-.46.77 3.01 3.01 0 0 0-.16 1c-.003.34.05.678.16 1 .108.282.263.542.46.77.188.21.416.38.67.5a2 2 0 0 0 .84.18 1.87 1.87 0 0 0 .9-.21 1.78 1.78 0 0 0 .65-.6l1.38 1a2.82 2.82 0 0 1-1.21 1.05Z"/>
          </svg>
          <svg aria-hidden="true" viewBox="0 0 26 24" slot="off">
            <path d="M22.832 5.68a2.58 2.58 0 0 0-2.3-2.5c-1.81-.12-4.67-.18-7.53-.18-2.86 0-5.72.06-7.53.18a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c1.81.12 4.67.18 7.53.18 2.86 0 5.72-.06 7.53-.18a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.137-.21-8.283 0-12.42a1.11 1.11 0 0 1 .91-1.11c1.67-.11 4.43-.18 7.43-.18s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.137.21 8.283 0 12.42ZM10.843 14a1.55 1.55 0 0 1-.76.18 1.57 1.57 0 0 1-.71-.18 1.69 1.69 0 0 1-.57-.42 2.099 2.099 0 0 1-.38-.58 2.47 2.47 0 0 1 0-1.64 2 2 0 0 1 .39-.66 1.73 1.73 0 0 1 .58-.42c.23-.103.479-.158.73-.16.241-.004.48.044.7.14.199.088.373.222.51.39l1.08-.89a2.179 2.179 0 0 0-.47-.44 2.81 2.81 0 0 0-.54-.32 2.91 2.91 0 0 0-.58-.15 2.71 2.71 0 0 0-.56 0 4.08 4.08 0 0 0-1.38.15 3.27 3.27 0 0 0-1.09.67 3.14 3.14 0 0 0-.71 1.06 3.62 3.62 0 0 0-.26 1.39 3.57 3.57 0 0 0 .26 1.38 3 3 0 0 0 .71 1.06c.316.293.687.52 1.09.67.443.16.91.238 1.38.23a3.2 3.2 0 0 0 1.28-.27c.401-.183.747-.47 1-.83l-1.17-.88a1.42 1.42 0 0 1-.53.52Zm6.62 0a1.58 1.58 0 0 1-.76.18 1.54 1.54 0 0 1-.7-.18 1.69 1.69 0 0 1-.57-.42 2.12 2.12 0 0 1-.43-.58 2.29 2.29 0 0 1 .39-2.3 1.84 1.84 0 0 1 1.32-.58c.241-.003.48.045.7.14.199.088.373.222.51.39l1.08-.92a2.43 2.43 0 0 0-.47-.44 3.22 3.22 0 0 0-.53-.29 2.999 2.999 0 0 0-.57-.15 2.87 2.87 0 0 0-.57 0 4.06 4.06 0 0 0-1.36.15 3.17 3.17 0 0 0-1.09.67 3 3 0 0 0-.72 1.06 3.62 3.62 0 0 0-.25 1.39 3.57 3.57 0 0 0 .25 1.38c.16.402.405.764.72 1.06a3.17 3.17 0 0 0 1.09.67c.44.16.904.237 1.37.23.441 0 .877-.092 1.28-.27a2.45 2.45 0 0 0 1-.83l-1.15-.85a1.49 1.49 0 0 1-.54.49Z"/>
          </svg>
        </media-captions-button>
        <media-captions-listbox slot="listbox" part="bottom captions listbox"></media-captions-listbox>
      </media-captions-selectmenu>
    </template>
  
    <template partial="AirplayButton">
      <media-airplay-button part="bottom airplay button" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <svg aria-hidden="true" viewBox="0 0 26 24" slot="airplay">
          <path
            d="M13.19 14.22a.25.25 0 0 0-.38 0l-5.46 6.37a.25.25 0 0 0 .19.41h10.92a.25.25 0 0 0 .19-.41l-5.46-6.37Z"
          />
          <path
            d="M22 3H4a1 1 0 0 0-1 1v13a1 1 0 0 0 1 1h2.94L8 16.75H4.25V4.25h17.5v12.5H18L19.06 18H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z"
          />
        </svg>
      </media-airplay-button>
    </template>
  
    <template partial="CastButton">
      <media-cast-button part="bottom cast button" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <svg aria-hidden="true" viewBox="0 0 26 24" slot="enter">
          <path d="M3 15.5V17c2.206 0 4 1.794 4 4h1.5A5.5 5.5 0 0 0 3 15.5Zm0 3V21h2.5A2.5 2.5 0 0 0 3 18.5Z" />
          <path d="M3 12.5V14c3.86 0 7 3.14 7 7h1.5A8.5 8.5 0 0 0 3 12.5Z" />
          <path
            d="M22 3H4a1 1 0 0 0-1 1v6.984c.424 0 .84.035 1.25.086V4.25h17.5v15.5h-8.82c.051.41.086.826.086 1.25H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 26 24" slot="exit">
          <path d="M3 15.5V17c2.206 0 4 1.794 4 4h1.5A5.5 5.5 0 0 0 3 15.5Zm0 3V21h2.5A2.5 2.5 0 0 0 3 18.5Z" />
          <path d="M3 12.5V14c3.86 0 7 3.14 7 7h1.5A8.5 8.5 0 0 0 3 12.5Z" />
          <path
            d="M22 3H4a1 1 0 0 0-1 1v6.984c.424 0 .84.035 1.25.086V4.25h17.5v15.5h-8.82c.051.41.086.826.086 1.25H22a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Z"
          />
          <path d="M20.5 5.5h-15v5.811c3.52.906 6.283 3.67 7.189 7.19H20.5V5.5Z" />
        </svg>
      </media-cast-button>
    </template>
  
    <template partial="PipButton">
      <media-pip-button part="bottom pip button" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <svg aria-hidden="true" viewBox="0 0 26 24" slot="enter">
          <path
            d="M22 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h6.75v-1.25h-6.5V4.25h17.5v6.5H23V4a1 1 0 0 0-1-1Zm0 10h-8a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1Zm-.5 6.5h-7v-5h7v5Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 26 24" slot="exit">
          <path
            d="M22 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h6.75v-1.25h-6.5V4.25h17.5v6.5H23V4a1 1 0 0 0-1-1Zm0 10h-8a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1Zm-.5 6.5h-7v-5h7v5Z"
          />
        </svg>
      </media-pip-button>
    </template>
  
    <template partial="FullscreenButton">
      <media-fullscreen-button part="bottom fullscreen button" disabled="{{disabled}}" aria-disabled="{{disabled}}">
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="enter">
          <path
            d="M20.25 14.5a.76.76 0 0 0-.75.75v4.25h-4.25a.75.75 0 1 0 0 1.5h5a.76.76 0 0 0 .75-.75v-5a.76.76 0 0 0-.75-.75Zm0-11.5h-5a.76.76 0 0 0-.75.75.76.76 0 0 0 .75.75h4.25v4.25a.75.75 0 1 0 1.5 0v-5a.76.76 0 0 0-.75-.75ZM8.75 19.5H4.5v-4.25a.76.76 0 0 0-.75-.75.76.76 0 0 0-.75.75v5a.76.76 0 0 0 .75.75h5a.75.75 0 1 0 0-1.5Zm0-16.5h-5a.76.76 0 0 0-.75.75v5a.76.76 0 0 0 .75.75.76.76 0 0 0 .75-.75V4.5h4.25a.76.76 0 0 0 .75-.75.76.76 0 0 0-.75-.75Z"
          />
        </svg>
        <svg aria-hidden="true" viewBox="0 0 24 24" slot="exit">
          <path
            d="M20.25 14.5h-5a.76.76 0 0 0-.75.75v5a.75.75 0 1 0 1.5 0V16h4.25a.75.75 0 1 0 0-1.5Zm-5-5h5a.75.75 0 1 0 0-1.5H16V3.75a.75.75 0 1 0-1.5 0v5a.76.76 0 0 0 .75.75Zm-6.5 5h-5a.75.75 0 1 0 0 1.5H8v4.25a.75.75 0 1 0 1.5 0v-5a.76.76 0 0 0-.75-.75Zm0-11.5a.76.76 0 0 0-.75.75V8H3.75a.75.75 0 0 0 0 1.5h5a.76.76 0 0 0 .75-.75v-5A.76.76 0 0 0 8.75 3Z"
          />
        </svg>
      </media-fullscreen-button>
    </template>
  
    <template partial="LiveButton">
      <media-live-button
        part="{{section ?? 'top'}} live button"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      ></media-live-button>
    </template>
  
    <template partial="PlaybackRateButton">
      <media-playback-rate-button
        rates="{{playbackrates}}"
        part="bottom playback-rate button"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      ></media-playback-rate-button>
    </template>
  
    <template partial="VolumeRange">
      <media-volume-range
        part="bottom volume range"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      ></media-volume-range>
    </template>
  
    <template partial="TimeDisplay">
      <media-time-display
        remaining="{{defaultshowremainingtime}}"
        showduration="{{!hideduration}}"
        part="bottom time display"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      ></media-time-display>
    </template>
  
    <template partial="TimeRange">
      <media-time-range
        part="bottom time range"
        disabled="{{disabled}}"
        aria-disabled="{{disabled}}"
      ></media-time-range>
    </template>
  
    <media-controller
      part="controller"
      defaultstreamtype="{{defaultstreamtype ?? 'on-demand'}}"
      breakpoints="sm:300 md:700"
      gesturesdisabled="{{disabled}}"
      hotkeys="{{hotkeys}}"
      nohotkeys="{{nohotkeys}}"
      novolumepref="{{novolumepref}}"
      audio="{{audio}}"
      noautoseektolive="{{noautoseektolive}}"
      defaultsubtitles="{{defaultsubtitles}}"
      exportparts="layer, media-layer, poster-layer, vertical-layer, centered-layer, gesture-layer"
    >
      <slot name="media" slot="media"></slot>
      <slot name="poster" slot="poster"></slot>
      <media-loading-indicator slot="centered-chrome" noautohide></media-loading-indicator>
  
      <template if="audio">
  
        <template if="streamtype == 'on-demand'">
          <template if="title">
            <media-control-bar part="control-bar top">{{>TitleDisplay}}</media-control-bar>
          </template>
          <media-control-bar part="control-bar bottom">
            {{>PlayButton}}
            {{>SeekBackwardButton}}
            {{>SeekForwardButton}}
            {{>TimeDisplay}}
            {{>TimeRange}}
            {{>MuteButton}}
            {{>VolumeRange}}
            {{>PlaybackRateButton}}
            {{>AudioTrackSelect}}
            {{>AirplayButton}}
            {{>CastButton}}
          </media-control-bar>
        </template>
  
        <template if="streamtype == 'live'">
  
          <template if="targetlivewindow > 0">
            <template if="title">
              <media-control-bar part="control-bar top">{{>TitleDisplay}}</media-control-bar>
            </template>
            <media-control-bar part="control-bar bottom">
              {{>PlayButton}}
              {{>LiveButton section="bottom"}}
              {{>SeekBackwardButton}}
              {{>SeekForwardButton}}
              {{>TimeDisplay}}
              {{>TimeRange}}
              {{>MuteButton}}
              {{>VolumeRange}}
              {{>PlaybackRateButton}}
              {{>AudioTrackSelect}}
              {{>AirplayButton}}
              {{>CastButton}}
            </media-control-bar>
          </template>
  
          <template if="!targetlivewindow">
            <template if="title">
              <media-control-bar part="control-bar top">{{>TitleDisplay}}</media-control-bar>
            </template>
            <media-control-bar part="control-bar bottom">
              {{>PlayButton}}
              {{>LiveButton section="bottom"}}
              {{>MuteButton}}
              {{>VolumeRange}}
              <div class="spacer"></div>
              {{>AudioTrackSelect}}
              {{>AirplayButton}}
              {{>CastButton}}
            </media-control-bar>
          </template>
  
        </template>
      </template>
  
      <template if="!audio">
  
        <template if="streamtype == 'on-demand'">
  
          <template if="!breakpointsm">
            {{>TimeRange}}
            <media-control-bar part="control-bar bottom">
              {{>PlayButton}}
              {{>MuteButton}}
              <div class="spacer"></div>
              {{>CaptionsSelect}}
              {{>FullscreenButton}}
            </media-control-bar>
          </template>
  
          <template if="breakpointsm">
            <template if="!breakpointmd">
              <media-control-bar part="control-bar top" slot="top-chrome">
                {{>TitleDisplay}}
              </media-control-bar>
              <div slot="centered-chrome" class="center-controls">
                {{>SeekBackwardButton section="center"}}
                {{>PlayButton section="center"}}
                {{>SeekForwardButton section="center"}}
              </div>
              {{>TimeRange}}
              <media-control-bar part="control-bar bottom">
                {{>PlayButton}}
                {{>TimeDisplay}}
                {{>MuteButton}}
                {{>VolumeRange}}
                <div class="spacer"></div>
                {{>RenditionSelect}}
                {{>PlaybackRateButton}}
                {{>AudioTrackSelect}}
                {{>CaptionsSelect}}
                {{>AirplayButton}}
                {{>CastButton}}
                {{>PipButton}}
                {{>FullscreenButton}}
              </media-control-bar>
            </template>
          </template>
  
          <template if="breakpointmd">
            <media-control-bar part="control-bar top" slot="top-chrome">
              {{>TitleDisplay}}
            </media-control-bar>
            <div slot="centered-chrome" class="center-controls">
              {{>PlayButton section="center"}}
            </div>
            {{>TimeRange}}
            <media-control-bar part="control-bar bottom">
              {{>PlayButton}}
              {{>SeekBackwardButton}}
              {{>SeekForwardButton}}
              {{>TimeDisplay}}
              {{>MuteButton}}
              {{>VolumeRange}}
              <div class="spacer"></div>
              {{>RenditionSelect}}
              {{>PlaybackRateButton}}
              {{>AudioTrackSelect}}
              {{>CaptionsSelect}}
              {{>AirplayButton}}
              {{>CastButton}}
              {{>PipButton}}
              {{>FullscreenButton}}
            </media-control-bar>
          </template>
  
        </template>
  
        <template if="streamtype == 'live'">
  
          <template if="!targetlivewindow">
  
            <template if="!breakpointsm">
              <media-control-bar part="control-bar top" slot="top-chrome">
                {{>LiveButton}}
              </media-control-bar>
              <media-control-bar part="control-bar bottom">
                {{>PlayButton}}
                {{>MuteButton}}
                <div class="spacer"></div>
                {{>CaptionsSelect}}
                {{>FullscreenButton}}
              </media-control-bar>
            </template>
  
            <template if="breakpointsm">
              <template if="!breakpointmd">
                <media-control-bar part="control-bar top" slot="top-chrome">
                  {{>LiveButton}}
                  {{>TitleDisplay}}
                </media-control-bar>
                <div slot="centered-chrome" class="center-controls">
                  {{>PlayButton section="center"}}
                </div>
                <media-control-bar part="control-bar bottom">
                  {{>PlayButton}}
                  {{>MuteButton}}
                  {{>VolumeRange}}
                  <div class="spacer"></div>
                  {{>RenditionSelect}}
                  {{>AudioTrackSelect}}
                  {{>CaptionsSelect}}
                  {{>AirplayButton}}
                  {{>CastButton}}
                  {{>PipButton}}
                  {{>FullscreenButton}}
                </media-control-bar>
              </template>
            </template>
  
            <template if="breakpointmd">
              <media-control-bar part="control-bar top" slot="top-chrome">
                {{>LiveButton}}
                {{>TitleDisplay}}
              </media-control-bar>
              <div slot="centered-chrome" class="center-controls">
                {{>PlayButton section="center"}}
              </div>
              <media-control-bar part="control-bar bottom">
                {{>PlayButton}}
                {{>MuteButton}}
                {{>VolumeRange}}
                <div class="spacer"></div>
                {{>RenditionSelect}}
                {{>AudioTrackSelect}}
                {{>CaptionsSelect}}
                {{>AirplayButton}}
                {{>CastButton}}
                {{>PipButton}}
                {{>FullscreenButton}}
              </media-control-bar>
            </template>
          </template>
  
          <template if="targetlivewindow > 0">
  
            <template if="!breakpointsm">
              <media-control-bar part="control-bar top" slot="top-chrome">
                {{>LiveButton}}
              </media-control-bar>
              {{>TimeRange}}
              <media-control-bar part="control-bar bottom">
                {{>PlayButton}}
                {{>MuteButton}}
                <div class="spacer"></div>
                {{>CaptionsSelect}}
                {{>FullscreenButton}}
              </media-control-bar>
            </template>
  
            <template if="breakpointsm">
              <template if="!breakpointmd">
                <media-control-bar part="control-bar top" slot="top-chrome">
                  {{>LiveButton}}
                  {{>TitleDisplay}}
                </media-control-bar>
                <div slot="centered-chrome" class="center-controls">
                  {{>SeekBackwardButton section="center"}}
                  {{>PlayButton section="center"}}
                  {{>SeekForwardButton section="center"}}
                </div>
                {{>TimeRange}}
                <media-control-bar part="control-bar bottom">
                  {{>PlayButton}}
                  {{>MuteButton}}
                  {{>VolumeRange}}
                  <div class="spacer"></div>
                  {{>RenditionSelect}}
                  {{>AudioTrackSelect}}
                  {{>CaptionsSelect}}
                  {{>AirplayButton}}
                  {{>CastButton}}
                  {{>PipButton}}
                  {{>FullscreenButton}}
                </media-control-bar>
              </template>
            </template>
  
            <template if="breakpointmd">
              <media-control-bar part="control-bar top" slot="top-chrome">
                {{>LiveButton}}
                {{>TitleDisplay}}
              </media-control-bar>
              <div slot="centered-chrome" class="center-controls">
                {{>PlayButton section="center"}}
              </div>
              {{>TimeRange}}
              <media-control-bar part="control-bar bottom">
                {{>PlayButton}}
                {{>SeekBackwardButton}}
                {{>SeekForwardButton}}
                {{>MuteButton}}
                {{>VolumeRange}}
                <div class="spacer"></div>
                {{>RenditionSelect}}
                {{>AudioTrackSelect}}
                {{>CaptionsSelect}}
                {{>AirplayButton}}
                {{>CastButton}}
                {{>PipButton}}
                {{>FullscreenButton}}
              </media-control-bar>
            </template>
  
          </template>
  
        </template>
  
      </template>
  
      <slot></slot>
  
    </media-controller>
  </template>
  `, oO = n9.createElement("template"); "innerHTML" in oO && (oO.innerHTML = oR); var oN, oP, oU = class extends MediaThemeElement { }; oU.template = null == (oP = null == (oN = oO.content) ? void 0 : oN.children) ? void 0 : oP[0], n6.customElements.get("media-theme-classic") || n6.customElements.define("media-theme-classic", oU); var oB = { SRC: "src", POSTER: "poster" }, oW = { STYLE: "style", DEFAULT_HIDDEN_CAPTIONS: "default-hidden-captions", PRIMARY_COLOR: "primary-color", SECONDARY_COLOR: "secondary-color", FORWARD_SEEK_OFFSET: "forward-seek-offset", BACKWARD_SEEK_OFFSET: "backward-seek-offset", PLAYBACK_TOKEN: "playback-token", THUMBNAIL_TOKEN: "thumbnail-token", STORYBOARD_TOKEN: "storyboard-token", STORYBOARD_SRC: "storyboard-src", THUMBNAIL_TIME: "thumbnail-time", AUDIO: "audio", NOHOTKEYS: "nohotkeys", HOTKEYS: "hotkeys", PLAYBACK_RATES: "playbackrates", DEFAULT_SHOW_REMAINING_TIME: "default-show-remaining-time", TITLE: "title", PLACEHOLDER: "placeholder", THEME: "theme", DEFAULT_STREAM_TYPE: "default-stream-type", TARGET_LIVE_WINDOW: "target-live-window", NO_VOLUME_PREF: "no-volume-pref" }, oF = ["audio", "backwardseekoffset", "defaultshowremainingtime", "defaultsubtitles", "noautoseektolive", "disabled", "exportparts", "forwardseekoffset", "hideduration", "hotkeys", "nohotkeys", "playbackrates", "defaultstreamtype", "streamtype", "style", "targetlivewindow", "template", "title", "novolumepref"]; function mux_player_dist_Lt(b) { let A = b.hasAttribute(oW.TITLE) ? { video_title: b.getAttribute(oW.TITLE) } : {}; return b.getAttributeNames().filter(b => b.startsWith("metadata-")).reduce((A, D) => { let N = b.getAttribute(D); return null !== N && (A[D.replace(/^metadata-/, "").replace(/-/g, "_")] = N), A }, A) } var oH, oG, oV, oj, oq, o$, oY, oK, oZ, oQ, oz, oX, oJ, o0, o1, o2, o5, o3, o4, o7, o8, o6 = Object.values(ny), o9 = Object.values(oB), st = Object.values(oW), si = { dialog: void 0, isDialogOpen: !1 }, sr = class extends ob { constructor() { super(), dist_b(this, o$), dist_b(this, oK), dist_b(this, oQ), dist_b(this, oX), dist_b(this, o0), dist_b(this, o2), dist_b(this, o3), dist_b(this, o7), dist_b(this, oH, !1), dist_b(this, oG, {}), dist_b(this, oV, !0), dist_b(this, oj, new ou(this, "hotkeys")), dist_b(this, oq, { ...si, onCloseErrorDialog: () => mux_player_dist_f(this, oQ, oz).call(this, { dialog: void 0, isDialogOpen: !1 }), onInitFocusDialog: b => { mux_player_dist_Ce(this, n9.activeElement) || b.preventDefault() } }), this.attachShadow({ mode: "open" }), mux_player_dist_f(this, oK, oZ).call(this), this.isConnected && mux_player_dist_f(this, o$, oY).call(this) } static get observedAttributes() { var b; return [...null != (b = ob.observedAttributes) ? b : [], ...o9, ...o6, ...st] } get mediaTheme() { var b; return null == (b = this.shadowRoot) ? void 0 : b.querySelector("media-theme") } get mediaController() { var b, A; return null == (A = null == (b = this.mediaTheme) ? void 0 : b.shadowRoot) ? void 0 : A.querySelector("media-controller") } connectedCallback() { var b; let A = null == (b = this.shadowRoot) ? void 0 : b.querySelector("mux-video"); A && (A.metadata = mux_player_dist_Lt(this)) } attributeChangedCallback(b, A, D) { var N; switch (mux_player_dist_f(this, o$, oY).call(this), super.attributeChangedCallback(b, A, D), b) { case oW.HOTKEYS: u(this, oj).value = D; break; case oW.THUMBNAIL_TIME: null != D && this.tokens.thumbnail && mux_player_dist_B(l("Use of thumbnail-time with thumbnail-token is currently unsupported. Ignore thumbnail-time.").format({})); break; case oW.THUMBNAIL_TOKEN: { let { aud: b } = dist_N(D); D && "t" !== b && mux_player_dist_B(l("The provided thumbnail-token should have audience value 't' instead of '{aud}'.").format({ aud: b })); break } case oW.STORYBOARD_TOKEN: { let { aud: b } = dist_N(D); D && "s" !== b && mux_player_dist_B(l("The provided storyboard-token should have audience value 's' instead of '{aud}'.").format({ aud: b })); break } case ny.PLAYBACK_ID: null != D && D.includes("?token") && dist_S(l("The specificed playback ID {playbackId} contains a token which must be provided via the playback-token attribute.").format({ playbackId: D })); break; case ny.STREAM_TYPE: D && ![tG.LIVE, tG.ON_DEMAND, tG.UNKNOWN].includes(D) ? ["ll-live", "live:dvr", "ll-live:dvr"].includes(this.streamType) ? this.targetLiveWindow = D.includes("dvr") ? Number.POSITIVE_INFINITY : 0 : dist_Be({ file: "invalid-stream-type.md", message: l("Invalid stream-type value supplied: `{streamType}`. Please provide stream-type as either: `on-demand` or `live`").format({ streamType: this.streamType }) }) : this.targetLiveWindow = D === tG.LIVE ? 0 : Number.NaN }[ny.PLAYBACK_ID, oB.SRC, oW.PLAYBACK_TOKEN].includes(b) && A !== D && dist_x(this, oq, { ...u(this, oq), ...si }), mux_player_dist_f(this, oX, oJ).call(this, { [null != (N = od[b]) ? N : mux_player_dist_me(b)]: D }) } get preferCmcd() { var b; return null != (b = this.getAttribute(ny.PREFER_CMCD)) ? b : void 0 } set preferCmcd(b) { b !== this.preferCmcd && (b ? tq.includes(b) ? this.setAttribute(ny.PREFER_CMCD, b) : mux_player_dist_B(`Invalid value for preferCmcd. Must be one of ${tq.join()}`) : this.removeAttribute(ny.PREFER_CMCD)) } get hasPlayed() { var b, A; return null != (A = null == (b = this.mediaController) ? void 0 : b.hasAttribute("media-has-played")) && A } get inLiveWindow() { var b; return null == (b = this.mediaController) ? void 0 : b.hasAttribute("media-time-is-live") } get _hls() { var b; return null == (b = this.media) ? void 0 : b._hls } get mux() { var b; return null == (b = this.media) ? void 0 : b.mux } get theme() { var b; return null != (b = this.getAttribute(oW.THEME)) ? b : "classic" } set theme(b) { this.setAttribute(oW.THEME, `${b}`) } get themeProps() { let b = this.mediaTheme; if (!b) return; let A = {}; for (let D of b.getAttributeNames()) { if (oF.includes(D)) continue; let N = b.getAttribute(D); A[mux_player_dist_me(D)] = "" === N || N } return A } set themeProps(b) { var A, D; mux_player_dist_f(this, o$, oY).call(this); let N = { ...this.themeProps, ...b }; for (let V in N) { if (oF.includes(V)) continue; let N = null == b ? void 0 : b[V]; "boolean" == typeof N || null == N ? null == (A = this.mediaTheme) || A.toggleAttribute(mux_player_dist_le(V), !!N) : null == (D = this.mediaTheme) || D.setAttribute(mux_player_dist_le(V), N) } } get playbackId() { var b; return null != (b = this.getAttribute(ny.PLAYBACK_ID)) ? b : void 0 } set playbackId(b) { b ? this.setAttribute(ny.PLAYBACK_ID, b) : this.removeAttribute(ny.PLAYBACK_ID) } get src() { var b, A; return this.playbackId ? null != (b = mux_player_dist_W(this, oB.SRC)) ? b : void 0 : null != (A = this.getAttribute(oB.SRC)) ? A : void 0 } set src(b) { b ? this.setAttribute(oB.SRC, b) : this.removeAttribute(oB.SRC) } get poster() { var b; let A = this.getAttribute(oB.POSTER); return null != A ? A : this.playbackId && !this.audio ? dt(this.playbackId, { domain: this.customDomain, thumbnailTime: null != (b = this.thumbnailTime) ? b : this.startTime, token: this.tokens.thumbnail }) : void 0 } set poster(b) { b || "" === b ? this.setAttribute(oB.POSTER, b) : this.removeAttribute(oB.POSTER) } get storyboardSrc() { var b; return null != (b = this.getAttribute(oW.STORYBOARD_SRC)) ? b : void 0 } set storyboardSrc(b) { b ? this.setAttribute(oW.STORYBOARD_SRC, b) : this.removeAttribute(oW.STORYBOARD_SRC) } get storyboard() { return this.storyboardSrc && !this.tokens.storyboard ? this.storyboardSrc : this.audio || !this.playbackId || !this.streamType || [tG.LIVE, tG.UNKNOWN].includes(this.streamType) ? void 0 : dist_lt(this.playbackId, { domain: this.customDomain, token: this.tokens.storyboard }) } get audio() { return this.hasAttribute(oW.AUDIO) } set audio(b) { if (!b) { this.removeAttribute(oW.AUDIO); return } this.setAttribute(oW.AUDIO, "") } get hotkeys() { return u(this, oj) } get nohotkeys() { return this.hasAttribute(oW.NOHOTKEYS) } set nohotkeys(b) { if (!b) { this.removeAttribute(oW.NOHOTKEYS); return } this.setAttribute(oW.NOHOTKEYS, "") } get thumbnailTime() { return dist_R(this.getAttribute(oW.THUMBNAIL_TIME)) } set thumbnailTime(b) { this.setAttribute(oW.THUMBNAIL_TIME, `${b}`) } get title() { var b; return null != (b = this.getAttribute(oW.TITLE)) ? b : "" } set title(b) { b !== this.title && (b ? this.setAttribute(oW.TITLE, b) : this.removeAttribute("title"), super.title = b) } get placeholder() { var b; return null != (b = mux_player_dist_W(this, oW.PLACEHOLDER)) ? b : "" } set placeholder(b) { this.setAttribute(oW.PLACEHOLDER, `${b}`) } get primaryColor() { var b, A; let D = this.getAttribute(oW.PRIMARY_COLOR); if (null != D || this.mediaTheme && (D = null == (A = null == (b = n6.getComputedStyle(this.mediaTheme)) ? void 0 : b.getPropertyValue("--_primary-color")) ? void 0 : A.trim())) return D } set primaryColor(b) { this.setAttribute(oW.PRIMARY_COLOR, `${b}`) } get secondaryColor() { var b, A; let D = this.getAttribute(oW.SECONDARY_COLOR); if (null != D || this.mediaTheme && (D = null == (A = null == (b = n6.getComputedStyle(this.mediaTheme)) ? void 0 : b.getPropertyValue("--_secondary-color")) ? void 0 : A.trim())) return D } set secondaryColor(b) { this.setAttribute(oW.SECONDARY_COLOR, `${b}`) } get defaultShowRemainingTime() { return this.hasAttribute(oW.DEFAULT_SHOW_REMAINING_TIME) } set defaultShowRemainingTime(b) { b ? this.setAttribute(oW.DEFAULT_SHOW_REMAINING_TIME, "") : this.removeAttribute(oW.DEFAULT_SHOW_REMAINING_TIME) } get playbackRates() { if (this.hasAttribute(oW.PLAYBACK_RATES)) return this.getAttribute(oW.PLAYBACK_RATES).trim().split(/\s*,?\s+/).map(b => Number(b)).filter(b => !Number.isNaN(b)).sort((b, A) => b - A) } set playbackRates(b) { if (!b) { this.removeAttribute(oW.PLAYBACK_RATES); return } this.setAttribute(oW.PLAYBACK_RATES, b.join(" ")) } get forwardSeekOffset() { var b; return null != (b = dist_R(this.getAttribute(oW.FORWARD_SEEK_OFFSET))) ? b : 10 } set forwardSeekOffset(b) { this.setAttribute(oW.FORWARD_SEEK_OFFSET, `${b}`) } get backwardSeekOffset() { var b; return null != (b = dist_R(this.getAttribute(oW.BACKWARD_SEEK_OFFSET))) ? b : 10 } set backwardSeekOffset(b) { this.setAttribute(oW.BACKWARD_SEEK_OFFSET, `${b}`) } get defaultHiddenCaptions() { return this.hasAttribute(oW.DEFAULT_HIDDEN_CAPTIONS) } set defaultHiddenCaptions(b) { b ? this.setAttribute(oW.DEFAULT_HIDDEN_CAPTIONS, "") : this.removeAttribute(oW.DEFAULT_HIDDEN_CAPTIONS) } get playerSoftwareName() { var b; return null != (b = this.getAttribute(ny.PLAYER_SOFTWARE_NAME)) ? b : "mux-player" } get playerSoftwareVersion() { var b; return null != (b = this.getAttribute(ny.PLAYER_SOFTWARE_VERSION)) ? b : ol } get beaconCollectionDomain() { var b; return null != (b = this.getAttribute(ny.BEACON_COLLECTION_DOMAIN)) ? b : void 0 } set beaconCollectionDomain(b) { b !== this.beaconCollectionDomain && (b ? this.setAttribute(ny.BEACON_COLLECTION_DOMAIN, b) : this.removeAttribute(ny.BEACON_COLLECTION_DOMAIN)) } get maxResolution() { var b; return null != (b = this.getAttribute(ny.MAX_RESOLUTION)) ? b : void 0 } set maxResolution(b) { b !== this.maxResolution && (b ? this.setAttribute(ny.MAX_RESOLUTION, b) : this.removeAttribute(ny.MAX_RESOLUTION)) } get customDomain() { var b; return null != (b = this.getAttribute(ny.CUSTOM_DOMAIN)) ? b : void 0 } set customDomain(b) { b !== this.customDomain && (b ? this.setAttribute(ny.CUSTOM_DOMAIN, b) : this.removeAttribute(ny.CUSTOM_DOMAIN)) } get envKey() { var b; return null != (b = mux_player_dist_W(this, ny.ENV_KEY)) ? b : void 0 } set envKey(b) { this.setAttribute(ny.ENV_KEY, `${b}`) } get noVolumePref() { return this.hasAttribute(oW.NO_VOLUME_PREF) } set noVolumePref(b) { b ? this.setAttribute(oW.NO_VOLUME_PREF, "") : this.removeAttribute(oW.NO_VOLUME_PREF) } get debug() { return null != mux_player_dist_W(this, ny.DEBUG) } set debug(b) { b ? this.setAttribute(ny.DEBUG, "") : this.removeAttribute(ny.DEBUG) } get disableCookies() { return null != mux_player_dist_W(this, ny.DISABLE_COOKIES) } set disableCookies(b) { b ? this.setAttribute(ny.DISABLE_COOKIES, "") : this.removeAttribute(ny.DISABLE_COOKIES) } get streamType() { var b, A, D; return null != (D = null != (A = this.getAttribute(ny.STREAM_TYPE)) ? A : null == (b = this.media) ? void 0 : b.streamType) ? D : tG.UNKNOWN } set streamType(b) { this.setAttribute(ny.STREAM_TYPE, `${b}`) } get defaultStreamType() { var b, A, D; return null != (D = null != (A = this.getAttribute(oW.DEFAULT_STREAM_TYPE)) ? A : null == (b = this.mediaController) ? void 0 : b.getAttribute(oW.DEFAULT_STREAM_TYPE)) ? D : tG.ON_DEMAND } set defaultStreamType(b) { b ? this.setAttribute(oW.DEFAULT_STREAM_TYPE, b) : this.removeAttribute(oW.DEFAULT_STREAM_TYPE) } get targetLiveWindow() { var b, A; return this.hasAttribute(oW.TARGET_LIVE_WINDOW) ? +this.getAttribute(oW.TARGET_LIVE_WINDOW) : null != (A = null == (b = this.media) ? void 0 : b.targetLiveWindow) ? A : Number.NaN } set targetLiveWindow(b) { b != this.targetLiveWindow && (null == b ? this.removeAttribute(oW.TARGET_LIVE_WINDOW) : this.setAttribute(oW.TARGET_LIVE_WINDOW, `${+b}`)) } get liveEdgeStart() { var b; return null == (b = this.media) ? void 0 : b.liveEdgeStart } get startTime() { return dist_R(mux_player_dist_W(this, ny.START_TIME)) } set startTime(b) { this.setAttribute(ny.START_TIME, `${b}`) } get preferPlayback() { let b = this.getAttribute(ny.PREFER_PLAYBACK); if (b === tV.MSE || b === tV.NATIVE) return b } set preferPlayback(b) { b !== this.preferPlayback && (b === tV.MSE || b === tV.NATIVE ? this.setAttribute(ny.PREFER_PLAYBACK, b) : this.removeAttribute(ny.PREFER_PLAYBACK)) } get metadata() { var b; return null == (b = this.media) ? void 0 : b.metadata } set metadata(b) { if (mux_player_dist_f(this, o$, oY).call(this), !this.media) { dist_S("underlying media element missing when trying to set metadata. metadata will not be set."); return } this.media.metadata = { ...mux_player_dist_Lt(this), ...b } } async addCuePoints(b) { var A; if (mux_player_dist_f(this, o$, oY).call(this), !this.media) { dist_S("underlying media element missing when trying to addCuePoints. cuePoints will not be added."); return } return null == (A = this.media) ? void 0 : A.addCuePoints(b) } get activeCuePoint() { var b; return null == (b = this.media) ? void 0 : b.activeCuePoint } get cuePoints() { var b, A; return null != (A = null == (b = this.media) ? void 0 : b.cuePoints) ? A : [] } getStartDate() { var b; return null == (b = this.media) ? void 0 : b.getStartDate() } get currentPdt() { var b; return null == (b = this.media) ? void 0 : b.currentPdt } get tokens() { let b = this.getAttribute(oW.PLAYBACK_TOKEN), A = this.getAttribute(oW.THUMBNAIL_TOKEN), D = this.getAttribute(oW.STORYBOARD_TOKEN); return { ...u(this, oG), ...null != b ? { playback: b } : {}, ...null != A ? { thumbnail: A } : {}, ...null != D ? { storyboard: D } : {} } } set tokens(b) { dist_x(this, oG, null != b ? b : {}) } get playbackToken() { var b; return null != (b = this.getAttribute(oW.PLAYBACK_TOKEN)) ? b : void 0 } set playbackToken(b) { this.setAttribute(oW.PLAYBACK_TOKEN, `${b}`) } get thumbnailToken() { var b; return null != (b = this.getAttribute(oW.THUMBNAIL_TOKEN)) ? b : void 0 } set thumbnailToken(b) { this.setAttribute(oW.THUMBNAIL_TOKEN, `${b}`) } get storyboardToken() { var b; return null != (b = this.getAttribute(oW.STORYBOARD_TOKEN)) ? b : void 0 } set storyboardToken(b) { this.setAttribute(oW.STORYBOARD_TOKEN, `${b}`) } addTextTrack(b, A, D, N) { var V; let Y = null == (V = this.media) ? void 0 : V.nativeEl; if (Y) return _(Y, b, A, D, N) } removeTextTrack(b) { var A; let D = null == (A = this.media) ? void 0 : A.nativeEl; if (D) { let A; return void (null == (A = Array.prototype.find.call(D.querySelectorAll("track"), A => A.track === b)) || A.remove()) } } get textTracks() { var b; return null == (b = this.media) ? void 0 : b.textTracks } }; function mux_player_dist_W(b, A) { return b.media ? b.media.getAttribute(A) : b.getAttribute(A) } oH = new WeakMap, oG = new WeakMap, oV = new WeakMap, oj = new WeakMap, oq = new WeakMap, o$ = new WeakSet, oY = function () { var b, A, D, N; if (!u(this, oH)) { dist_x(this, oH, !0), mux_player_dist_f(this, oX, oJ).call(this); try { if (customElements.upgrade(this.mediaTheme), !(this.mediaTheme instanceof n6.HTMLElement)) throw "" } catch { dist_S("<media-theme> failed to upgrade!") } try { if (customElements.upgrade(this.media), !(this.media instanceof nk)) throw "" } catch { dist_S("<mux-video> failed to upgrade!") } try { if (customElements.upgrade(this.mediaController), !(this.mediaController instanceof MediaController)) throw "" } catch { dist_S("<media-controller> failed to upgrade!") } N = this, N.querySelectorAll(":scope > track").forEach(b => { var A; null == (A = N.media) || A.append(b.cloneNode()) }), ov.forEach(b => { var A; null == (A = N.media) || A.addEventListener(b, b => { N.dispatchEvent(new Event(b.type)) }) }), mux_player_dist_f(this, o0, o1).call(this), mux_player_dist_f(this, o2, o5).call(this), mux_player_dist_f(this, o3, o4).call(this), dist_x(this, oV, null == (A = null == (b = this.mediaController) ? void 0 : b.hasAttribute("userinactive")) || A), mux_player_dist_f(this, o7, o8).call(this), null == (D = this.media) || D.addEventListener("streamtypechange", () => { mux_player_dist_f(this, oX, oJ).call(this) }) } }, oK = new WeakSet, oZ = function () { var b, A; try { null == (b = null == window ? void 0 : window.CSS) || b.registerProperty({ name: "--media-primary-color", syntax: "<color>", inherits: !0 }), null == (A = null == window ? void 0 : window.CSS) || A.registerProperty({ name: "--media-secondary-color", syntax: "<color>", inherits: !0 }) } catch { } }, oQ = new WeakSet, oz = function (b) { Object.assign(u(this, oq), b), mux_player_dist_f(this, oX, oJ).call(this) }, oX = new WeakSet, oJ = function (b = {}) { var A, D, N; let V; (function (b, A) { b.renderInto(A) })(mux_player_dist_xt((A = { ...u(this, oq), ...b }, { src: !this.playbackId && this.src, playbackId: this.playbackId, hasSrc: !!this.playbackId || !!this.src, poster: this.poster, storyboard: this.storyboard, storyboardSrc: this.getAttribute(oW.STORYBOARD_SRC), placeholder: this.getAttribute("placeholder"), themeTemplate: function (b) { var A, D; let N = b.theme; if (N) { let V = null == (D = null == (A = b.getRootNode()) ? void 0 : A.getElementById) ? void 0 : D.call(A, N); if (V && V instanceof HTMLTemplateElement) return V; N.startsWith("media-theme-") || (N = `media-theme-${N}`); let Y = n6.customElements.get(N); if (null != Y && Y.template) return Y.template } }(this), thumbnailTime: !this.tokens.thumbnail && this.thumbnailTime, autoplay: this.autoplay, crossOrigin: this.crossOrigin, loop: this.loop, noHotKeys: this.hasAttribute(oW.NOHOTKEYS), hotKeys: this.getAttribute(oW.HOTKEYS), muted: this.muted, paused: this.paused, preload: this.preload, envKey: this.envKey, preferCmcd: this.preferCmcd, debug: this.debug, disableCookies: this.disableCookies, tokens: this.tokens, beaconCollectionDomain: this.beaconCollectionDomain, maxResolution: this.maxResolution, metadata: this.metadata, playerSoftwareName: this.playerSoftwareName, playerSoftwareVersion: this.playerSoftwareVersion, startTime: this.startTime, preferPlayback: this.preferPlayback, audio: this.audio, defaultStreamType: this.defaultStreamType, targetLiveWindow: this.getAttribute(ny.TARGET_LIVE_WINDOW), streamType: dist_Q(this.getAttribute(ny.STREAM_TYPE)), primaryColor: this.primaryColor, secondaryColor: this.secondaryColor, forwardSeekOffset: this.forwardSeekOffset, backwardSeekOffset: this.backwardSeekOffset, defaultHiddenCaptions: this.defaultHiddenCaptions, defaultShowRemainingTime: this.defaultShowRemainingTime, hideDuration: (V = null == (N = this.mediaController) ? void 0 : N.querySelector("media-time-display")) && "none" === getComputedStyle(V).getPropertyValue("--media-duration-display-display").trim(), playbackRates: this.getAttribute(oW.PLAYBACK_RATES), customDomain: null != (D = this.getAttribute(ny.CUSTOM_DOMAIN)) ? D : void 0, title: this.getAttribute(oW.TITLE), novolumepref: this.hasAttribute(oW.NO_VOLUME_PREF), ...A })), this.shadowRoot) }, o0 = new WeakSet, o1 = function () { let e = b => { var A, D; if (!(null != b && b.startsWith("theme-"))) return; let N = b.replace(/^theme-/, ""); if (oF.includes(N)) return; let V = this.getAttribute(b); null != V ? null == (A = this.mediaTheme) || A.setAttribute(N, V) : null == (D = this.mediaTheme) || D.removeAttribute(N) }; new MutationObserver(b => { for (let { attributeName: A } of b) e(A) }).observe(this, { attributes: !0 }), this.getAttributeNames().forEach(e) }, o2 = new WeakSet, o5 = function () { var b; this.addEventListener("error", b => { let { detail: A } = b; if (A instanceof tF || (A = new tF(A.message, A.code, A.fatal)), !(null != A && A.fatal)) { mux_player_dist_B(A), A.data && mux_player_dist_B(`${A.name} data:`, A.data); return } let { dialog: D, devlog: N } = dist_ye(A, !window.navigator.onLine, this.playbackId, this.playbackToken); N.message && dist_Be(N), dist_S(A), A.data && dist_S(`${A.name} data:`, A.data), mux_player_dist_f(this, oQ, oz).call(this, { isDialogOpen: !0, dialog: D }) }), this.media && (this.media.errorTranslator = (b = {}) => { var A, D, N; if (!((null == (A = this.media) ? void 0 : A.error) instanceof tF)) return b; let { devlog: V } = dist_ye(null == (D = this.media) ? void 0 : D.error, !window.navigator.onLine, this.playbackId, this.playbackToken, !1); return { player_error_code: null == (N = this.media) ? void 0 : N.error.code, player_error_message: V.message ? String(V.message) : b.player_error_message, player_error_context: V.context ? String(V.context) : b.player_error_context } }), null == (b = this.media) || b.addEventListener("error", b => { var A, D; let { detail: N } = b; if (!N) { let { message: b, code: V } = null != (D = null == (A = this.media) ? void 0 : A.error) ? D : {}; N = new tF(b, V) } null != N && N.fatal && this.dispatchEvent(new CustomEvent("error", { detail: N })) }) }, o3 = new WeakSet, o4 = function () { var b, A, D, N; let e = () => mux_player_dist_f(this, oX, oJ).call(this); null == (A = null == (b = this.media) ? void 0 : b.textTracks) || A.addEventListener("addtrack", e), null == (N = null == (D = this.media) ? void 0 : D.textTracks) || N.addEventListener("removetrack", e) }, o7 = new WeakSet, o8 = function () {
      var b, A; let D = /.*Version\/.*Safari\/.*/.test(navigator.userAgent); if (!/Firefox/i.test(navigator.userAgent)) return; let N, V = new WeakMap, n = () => this.streamType === tG.LIVE && !this.secondaryColor && this.offsetWidth >= 800, m = (b, A, N = !1) => {
        n() || Array.from(b && b.activeCues || []).forEach(b => {
          if (!(!b.snapToLines || b.line < -5 || b.line >= 0 && b.line < 10)) {
            if (!A || this.paused) {
              let A = b.text.split(`
  `).length, Y = D ? -2 : -3; this.streamType === tG.LIVE && (Y = D ? -1 : -2); let Z = Y - A; (b.line !== Z || N) && (V.has(b) || V.set(b, b.line), b.line = Z - 1, b.line = Z)
            } else setTimeout(() => { b.line = V.get(b) || "auto" }, 500)
          }
        })
      }, h = () => { var b, A; m(N, null != (A = null == (b = this.mediaController) ? void 0 : b.hasAttribute("userinactive")) && A) }, w = () => { var b, A; let D = Array.from((null == (A = null == (b = this.mediaController) ? void 0 : b.media) ? void 0 : A.textTracks) || []).filter(b => ["subtitles", "captions"].includes(b.kind) && "showing" === b.mode)[0]; D !== N && (null == N || N.removeEventListener("cuechange", h)), null == (N = D) || N.addEventListener("cuechange", h), m(N, u(this, oV)) }; if (w(), null == (b = this.textTracks) || b.addEventListener("change", w), null == (A = this.textTracks) || A.addEventListener("addtrack", w), navigator.userAgent.includes("Chrome/")) { let g = () => { m(N, u(this, oV), !0), this.paused || window.requestAnimationFrame(g) }; this.addEventListener("playing", () => { g() }) } this.addEventListener("userinactivechange", () => { var b, A; let D = null == (A = null == (b = this.mediaController) ? void 0 : b.hasAttribute("userinactive")) || A; u(this, oV) !== D && (dist_x(this, oV, D), m(N, u(this, oV))) })
    }, n6.customElements.get("mux-player") || (n6.customElements.define("mux-player", sr), n6.MuxPlayerElement = sr); var sn = { className: "class", classname: "class", htmlFor: "for", crossOrigin: "crossorigin", viewBox: "viewBox", playsInline: "playsinline", autoPlay: "autoplay", playbackRate: "playbackrate" }, dist_ = b => null == b, mux_player_react_dist_q = (b, A) => !dist_(A) && b in A, mux_player_react_dist_J = b => b.replace(/[A-Z]/g, b => `-${b.toLowerCase()}`), mux_player_react_dist_Y = (b, A) => { if (!("boolean" == typeof A && !A)) return mux_player_react_dist_q(b, sn) ? sn[b] : /[A-Z]/.test(b) ? mux_player_react_dist_J(b) : b }, mux_player_react_dist_$ = (b, A) => "boolean" == typeof b ? "" : b, dist_d = (b = {}) => Object.entries(b).reduce((b, [A, D]) => { let N = mux_player_react_dist_Y(A, D); if (!N) return b; let V = mux_player_react_dist_$(D, A); return b[N] = V, b }, {}), dist_m = (...b) => { let A = (0, Y.useRef)(null); return (0, Y.useEffect)(() => { b.forEach(b => { b && ("function" == typeof b ? b(A.current) : b.current = A.current) }) }, [b]), A }, so = Object.prototype.hasOwnProperty, mux_player_react_dist_te = (b, A) => { if (Object.is(b, A)) return !0; if ("object" != typeof b || null === b || "object" != typeof A || null === A) return !1; if (Array.isArray(b)) return !!Array.isArray(A) && b.length === A.length && b.some((b, D) => A[D] === b); let D = Object.keys(b), N = Object.keys(A); if (D.length !== N.length) return !1; for (let N = 0; N < D.length; N++)if (!so.call(A, D[N]) || !Object.is(b[D[N]], A[D[N]])) return !1; return !0 }, dist_p = (b, A, D) => !mux_player_react_dist_te(A, b[D]), mux_player_react_dist_ne = (b, A, D) => { b[D] = A }, dist_l = (b, A, D, N = mux_player_react_dist_ne, V = dist_p) => (0, Y.useEffect)(() => { let Y = null == D ? void 0 : D.current; Y && V(Y, A, b) && N(Y, A, b) }, [null == D ? void 0 : D.current, A]), ss = (() => { try { return "1.15.0" } catch { } return "UNKNOWN" })(), sl = Y.forwardRef(({ children: b, ...A }, D) => Y.createElement("mux-player", dist_d({ ...A, ref: D }), b)), a = (b, A, D) => (0, Y.useEffect)(() => { let N = null == A ? void 0 : A.current; if (!(!N || !D)) return N.addEventListener(b, D), () => { N.removeEventListener(b, D) } }, [null == A ? void 0 : A.current, D]), mux_player_react_dist_ue = (b, A) => { let { onAbort: D, onCanPlay: N, onCanPlayThrough: V, onEmptied: Y, onLoadStart: Z, onLoadedData: ee, onLoadedMetadata: et, onProgress: ea, onDurationChange: er, onVolumeChange: en, onRateChange: eo, onResize: es, onWaiting: el, onPlay: ed, onPlaying: eu, onTimeUpdate: ec, onPause: em, onSeeking: eh, onSeeked: ep, onStalled: ev, onSuspend: e_, onEnded: ef, onError: eb, onCuePointChange: eg, onCuePointsChange: eE, metadata: ey, tokens: eA, paused: ek, playbackId: eT, playbackRates: ew, currentTime: eS, themeProps: eD, ...eI } = A; return dist_l("playbackRates", ew, b), dist_l("metadata", ey, b), dist_l("themeProps", eD, b), dist_l("tokens", eA, b), dist_l("playbackId", eT, b), dist_l("paused", ek, b, (b, A) => { null != A && (A ? b.pause() : b.play()) }, (b, A, D) => (!b.hasAttribute("autoplay") || !!b.hasPlayed) && dist_p(b, A, D)), dist_l("currentTime", eS, b, (b, A) => { null != A && (b.currentTime = A) }), a("abort", b, D), a("canplay", b, N), a("canplaythrough", b, V), a("emptied", b, Y), a("loadstart", b, Z), a("loadeddata", b, ee), a("loadedmetadata", b, et), a("progress", b, ea), a("durationchange", b, er), a("volumechange", b, en), a("ratechange", b, eo), a("resize", b, es), a("waiting", b, el), a("play", b, ed), a("playing", b, eu), a("timeupdate", b, ec), a("pause", b, em), a("seeking", b, eh), a("seeked", b, ep), a("stalled", b, ev), a("suspend", b, e_), a("ended", b, ef), a("error", b, eb), a("cuepointchange", b, eg), a("cuepointschange", b, eE), [eI] }, sd = Y.forwardRef((b, A) => { let D = (0, Y.useRef)(null), N = dist_m(D, A), [V] = mux_player_react_dist_ue(D, b); return Y.createElement(sl, { ref: N, playerSoftwareName: "mux-player-react", playerSoftwareVersion: ss, ...V }) })
  }
}]);
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[883], { 65978: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return Video_Video } }); var n = i(11527), r = i(37334), a = i(50959), hooks_useVideo = e => { let { reference: t } = e, [i, n] = (0, a.useState)(!1); return { isVideoPlaying: i, play: () => { var e; null === (e = t.current) || void 0 === e || e.play(), n(!0) }, pause: () => { var e; null === (e = t.current) || void 0 === e || e.pause(), n(!1) } } }, o = i(8211), l = i(86259), s = i(92923), c = i(86293), d = i.n(c), Video_Video = function (e) { let { video: { youtubeId: t, embeddedVideo: i, alt: c = "", thumbnail: u }, autoplay: m = !1, loop: p = !1, className: _ } = e, x = (0, a.useRef)(null), { ref: f, inView: h } = (0, s.YD)(), { isVideoPlaying: g, play: v, pause: S } = hooks_useVideo({ reference: x }); return (0, a.useEffect)(() => { m && (h ? v() : S()) }, [m, v, S, h]), (0, n.jsx)("div", { ref: f, className: (0, l.Z)(d().mediaContainer, _), children: t ? (0, n.jsx)("iframe", { className: d().media, src: "https://www.youtube-nocookie.com/embed/".concat(t).concat(m ? "autoplay=1&mute=1" : ""), allow: "autoplay", allowFullScreen: !0, title: c }) : (0, n.jsxs)(n.Fragment, { children: [(0, n.jsx)(o.Z, { playbackId: null == i ? void 0 : i.playbackId, ref: x, className: (0, l.Z)(d().media, (!g || m) && d().withoutControls), title: c, muted: m, loop: p, poster: null == u ? void 0 : u.url }), !g && !m && (0, n.jsx)("div", { className: d().buttonContainer, children: (0, n.jsx)(r.Z, { icon: "PLAY", className: d().button, onClick: v, label: "Play video", hideLabel: !0 }) })] }) }) } }, 95297: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return Carousel } }); var n = i(11527); i(14068); var r = i(37334), a = i(86259), o = i(92956), l = i(50959), s = i(67907), c = i(4370), d = i(33389), u = i.n(d); let m = { nl: { previous: "Vorige slide", next: "Volgende slide" }, en: { previous: "Previous slide", next: "Next slide" } }, p = "next", _ = "previous"; function Carousel(e) { let { items: t, SlideItem: i, slidesPerView: d, modifier: x } = e, f = (0, o.useRouter)().locale, h = (0, l.useRef)(), g = (0, l.useRef)(), [v, S] = (0, l.useState)(null), [j, b] = (0, l.useState)(0), handleNavigation = e => { e === _ ? null == v || v.slidePrev() : e === p && (null == v || v.slideNext()) }, handleSlide = e => { let { activeIndex: t } = e; return b(t) }, Z = "number" == typeof d ? d : d.desktop, N = !!x || j > 0, C = !!x || j < t.length - Z; return (0, n.jsxs)("div", { className: (0, a.Z)(u().wrapper, x && u()[x]), children: [(0, n.jsx)(c.tq, { modules: [s.W_], navigation: { prevEl: h.current, nextEl: g.current }, onSwiper: S, className: u().swiper, initialSlide: 0, onResize: handleSlide, onSlideChange: handleSlide, breakpoints: { 320: { spaceBetween: 12, slidesPerView: "number" == typeof d ? d : d.mobile }, 640: { spaceBetween: 24, slidesPerView: "number" == typeof d ? d : d.tablet }, 1280: { spaceBetween: 24, slidesPerView: Z } }, children: t.map((e, t) => (0, n.jsx)(c.o5, { children: (0, n.jsx)(i, { ...e, modifier: x }) }, "".concat(e.id, "-").concat(t))) }), t.length > Z && (0, n.jsxs)(n.Fragment, { children: [N && (0, n.jsx)(r.Z, { label: m[f].previous, variant: "white", icon: "NAV_ARROW_LEFT", hideLabel: !0, rounded: !0, onClick: () => handleNavigation(_), className: (0, a.Z)(u().button, u().previous) }), C && (0, n.jsx)(r.Z, { label: m[f].next, variant: "white", icon: "NAV_ARROW_RIGHT", hideLabel: !0, rounded: !0, onClick: () => handleNavigation(p), className: (0, a.Z)(u().button, u().next) })] })] }) } }, 97816: function (e, t, i) { "use strict"; var n = i(11527), r = i(37334), a = i(16505), o = i(75022); t.Z = function (e) { var t; let i, { cta: l, className: s, variant: c = "primary", fullWidth: d = !1, ctaAnimation: u = !0, modifier: m } = e, { store: { locale: p } } = (0, a.Z)(); return l && l.title && (l.internalLink[0] ? i = (0, o.Z)({ internalLink: l.internalLink[0], locale: p }) : l.externalLink ? i = l.externalLink : (null === (t = l.file) || void 0 === t ? void 0 : t.url) && (i = "".concat(l.file.url, "?cd=inline")), i) ? (0, n.jsx)(r.Z, { href: i, label: l.title, icon: "NAV_ARROW_RIGHT", iconLeft: l.icon, className: s, noAnimation: !u, variant: c, fullWidth: d, modifier: m }) : null } }, 1011: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return Section } }); var n = i(11527), r = i(30486), a = i(86259), o = i(38685), l = i.n(o); function Section(e) { let { backgroundColor: t = r.gi, containerClassName: i, children: o, id: s } = e; return (0, n.jsx)("section", { id: s, className: (0, a.Z)(l().section, l()[t]), "data-section": !0, children: (0, n.jsx)("div", { className: (0, a.Z)("u-container", i), children: o }) }) } }, 63007: function (e, t, i) { "use strict"; var n = i(11527), r = i(5252), a = i(86259), o = i(97816), l = i(55624), s = i.n(l); t.Z = function (e) { let { title: t, subtitle: i, text: l, cta: c, centered: d, className: u, children: m, modifier: p, addSpaceForButtons: _ } = e; return t || i || l || (null == c ? void 0 : c.title) || m ? (0, n.jsxs)("div", { className: (0, a.Z)(s().container, d && s().centered, p && s()[p], _ && s().addSpaceForButtons, u), children: [t && (0, n.jsx)("h2", { className: s().title, children: t }), i && (0, n.jsx)("p", { className: s().subtitle, children: i }), l && (0, n.jsx)(r.Z, { text: l, className: s().text, store: "inStore" === p }), c && ("inStore" !== p || "StoreMapPage" === c.internalLink[0].typename) && (0, n.jsx)(o.Z, { cta: c, modifier: "inStore" === p ? p : void 0 }), m] }) : null } }, 76095: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return SectionWrapper } }); var n = i(11527), r = i(1011); function SectionWrapper(e) { let { children: t, isHeroSection: i, backgroundColor: a } = e; return i ? t : (0, n.jsx)(r.Z, { backgroundColor: null == a ? void 0 : a.color, children: t }) } }, 93373: function (e, t, i) { "use strict"; var n = i(11527), r = i(94367), a = i(1011), o = i(63007), l = i(86259), s = i(92956), c = i(95964), d = i.n(c); let u = { general: "accessibility", guideDog: "wolf", hearingImpaired: "closed-captions-tag", visuallyImpaired: "eye", walkingDifficulties: "accessibility-sign" }, m = { nl: { title: "Toegankelijkheid", general: "Algemeen", guideDog: "Geleidehond toegestaan", hearingImpaired: "Toegankelijk voor slechthorenden", visuallyImpaired: "Toegankelijk voor slechtzienden", walkingDifficulties: "Toegankelijk voor rolstoelen" }, en: { title: "Accessibility", general: "General", guideDog: "Guide dog allowed", hearingImpaired: "Accessible for the hearing impaired", visuallyImpaired: "Accessible for the visually impaired", walkingDifficulties: "Accessible for wheelchairs" } }; t.Z = function (e) { let { title: t, text: i, guideDog: c, hearingImpaired: p, general: _, visuallyImpaired: x, walkingDifficulties: f, backgroundColor: h, modifier: g } = e, v = (0, s.useRouter)().locale, S = { guideDog: c, hearingImpaired: p, general: _, visuallyImpaired: x, walkingDifficulties: f }, j = Object.values(S).filter(e => !!e).length > 0; return j ? (0, n.jsx)(a.Z, { backgroundColor: h.color, children: (0, n.jsx)(o.Z, { title: t || m[v].title, text: i, centered: !0, className: d().content, modifier: "inStore" === g ? "inStore" : void 0, children: (0, n.jsx)("ul", { className: (0, l.Z)(d().wrapper, g && d()[g], "u-list-clean u-grid u-grid--gap-0 u-grid--gap-6@sm u-grid--2@sm"), children: Object.entries(S).map(e => { let [t, i] = e; if (!i) return null; let a = u[t], o = m[v][t]; return (0, n.jsxs)("li", { className: d().item, children: [a && (0, n.jsx)("span", { className: (0, l.Z)(d().iconContainer), "aria-hidden": "true", children: (0, n.jsx)(r.Z, { className: (0, l.Z)(d().svgIcon), icon: a }) }), o] }, t) }) }) }) }) : null } }, 96140: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return ContentCarouselSection } }); var n = i(11527), r = i(16505), a = i(37418), o = i(95297), l = i(63007), s = i(76095), c = i(75022), d = i(77124), u = i.n(d); function ContentCarouselSection(e) { var t, i, d; let { id: m, title: p, subtitle: _, text: x, imageSize: f, cardSize: h, backgroundColor: g, selection: v, modifier: S } = e, { store: { page: j, locale: b } } = (0, r.Z)(), Z = (null == j ? void 0 : null === (d = j.additionalSectionData) || void 0 === d ? void 0 : null === (i = d[m]) || void 0 === i ? void 0 : null === (t = i.ContentItems) || void 0 === t ? void 0 : t.items) || [], N = [...v, ...Z].map(e => ({ ...e, href: (0, c.Z)({ internalLink: e, locale: b, store: "inStore" === S }), showType: !0, imageSize: f || "md" })); return (null == N ? void 0 : N.length) ? (0, n.jsxs)(s.Z, { isHeroSection: "heroSection" === S, backgroundColor: g, children: [(0, n.jsx)(l.Z, { title: p, subtitle: _, text: x, modifier: "inStore" === S ? "inStore" : void 0, addSpaceForButtons: "inStore" === S }), (0, n.jsx)("div", { className: u().wrapper, children: (0, n.jsx)(o.Z, { items: N, SlideItem: a.Z, slidesPerView: "inStore" === S ? 2.5 : ({ sm: { mobile: 1, tablet: 3.25, desktop: 4 }, md: { mobile: 1, tablet: 2.5, desktop: 3 }, lg: { mobile: 1, tablet: 1.5, desktop: 2 } })[h || "sm"], modifier: "inStore" === S ? "inStore" : void 0 }) })] }) : null } }, 8949: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return ExploreFormSection } }); var n = i(11527), r = i(37334), a = i(31292), o = i(2339), l = i(16505), s = i(1011), c = i(63007), d = i(92956), u = i(50959), m = i(28879), p = i.n(m); let splitOptions = e => ({ period: e.filter(e => { let { type: t } = e; return "period" === t }), companion: e.filter(e => { let { type: t } = e; return "companion" === t }), transport: e.filter(e => { let { type: t } = e; return "transport" === t }), weather: e.filter(e => { let { type: t } = e; return "weather" === t }) }), mapOptions = e => e.map(e => { let { slug: t, title: i } = e; return { value: t, label: i } }), _ = { nl: { 1: "In", 2: "met", 3: "Ik kom", 4: "als" }, en: { 1: "In", 2: "with", 3: "I come", 4: "when" } }; function ExploreFormSection(e) { var t, i, m, x; let { id: f, title: h, ctaLabel: g, backgroundColor: v } = e, { query: S, push: j } = (0, d.useRouter)(), { store: { locale: b, page: Z } } = (0, l.Z)(), { period: N, companion: C, transport: w, weather: F } = (0, u.useMemo)(() => { var e, t, i; return splitOptions((null == Z ? void 0 : null === (i = Z.additionalSectionData) || void 0 === i ? void 0 : null === (t = i[f]) || void 0 === t ? void 0 : null === (e = t.ExploreTags) || void 0 === e ? void 0 : e.items) || (null == Z ? void 0 : Z.exploreTags) || []) }, [b, null == Z ? void 0 : Z.exploreTags]), { inputs: I, handleChange: k } = (0, o.Z)({ period: null === (t = N[0]) || void 0 === t ? void 0 : t.slug, companion: null === (i = C[0]) || void 0 === i ? void 0 : i.slug, transport: null === (m = w[0]) || void 0 === m ? void 0 : m.slug, weather: null === (x = F[0]) || void 0 === x ? void 0 : x.slug, ...S }), nlfSelect = (e, t) => (0, n.jsx)("span", { className: p().selectWrapper, children: (0, n.jsx)(a.Z, { fitContent: !0, id: "nlf-".concat(e, "-select"), label: e, name: e, value: I[e], onChange: k, options: mapOptions(t) }) }); return (0, n.jsx)(s.Z, { backgroundColor: v.color, children: (0, n.jsxs)("div", { className: p().container, children: [(0, n.jsx)(c.Z, { title: h }), (0, n.jsxs)("form", { className: p().form, onSubmit: e => { e.preventDefault(), j({ pathname: "explore", query: { ...I, page: 1 } }) }, children: [(0, n.jsxs)("div", { className: p().question, children: [(0, n.jsxs)("span", { children: [_[b][1], " ", nlfSelect("period", N), " "] }), (0, n.jsxs)("span", { children: [_[b][2], " ", nlfSelect("companion", C), "."] }), (0, n.jsxs)("span", { children: ["  ", _[b][3], " ", nlfSelect("transport", w), " "] }), (0, n.jsxs)("span", { children: [_[b][4], " ", nlfSelect("weather", F)] })] }), (0, n.jsx)(r.Z, { label: g, submit: !0, className: p().submit, iconLeft: "MAP", icon: "NAV_ARROW_RIGHT" })] })] }) }) } }, 2059: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return ImageSliderSection } }); var n = i(11527), r = i(95297), a = i(87334), o = i.n(a), l = i(99295), s = i.n(l); function ImageSliderItem(e) { let { url: t, caption: i, placeholder: r } = e; return (0, n.jsx)("div", { className: s().imageWrapper, children: (0, n.jsx)(o(), { src: t, placeholder: "blur", blurDataURL: r, alt: i || "", layout: "fill", objectFit: "cover", objectPosition: "center", itemProp: "image", className: s().image }) }) } var c = i(1011), d = i(73383), u = i.n(d); function ImageSliderSection(e) { let { images: t, backgroundColor: i } = e; return (0, n.jsx)(c.Z, { backgroundColor: i.color, children: (0, n.jsx)("div", { className: u().wrapper, children: (0, n.jsx)(r.Z, { items: t, SlideItem: ImageSliderItem, slidesPerView: { mobile: 1, tablet: 2.25, desktop: 3 } }) }) }) } }, 10883: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return Sections_Sections } }); var n = i(11527), r = i(30486), a = i(93373), o = i(96140), l = i(97816), s = i(63007), c = i(76095), d = i(86259), u = i(33344), m = i.n(u), p = i(16505), _ = i(37418), x = i(95297), f = i(1011), h = i(75022), g = i(40084), v = i.n(g), S = i(37334); i(21468); var j = i(27365), b = i(50959), Z = i(24608), N = i(35750), C = i.n(N); function DatePicker(e) { let { id: t, options: i = {}, label: r, hideLabel: a, name: o } = e, { store: { locale: l } } = (0, p.Z)(), [s, c] = (0, b.useState)(""); return (0, n.jsxs)("div", { className: (0, d.Z)(C().wrapper, !!s && C().hasValue), children: [!a && !!t && (0, n.jsx)("label", { className: C().label, htmlFor: t, children: r }), (0, n.jsx)(Z.Z, { value: s, onChange: e => { var t; c((null === (t = e[0]) || void 0 === t ? void 0 : t.toISOString()) || "") }, id: t, name: o, "aria-label": r, className: C().input, options: { mode: "single", locale: "nl" === l ? j.Dutch : void 0, dateFormat: "d-m-Y", minDate: "today", time_24hr: !0, ...i } })] }) } var w = i(24312), F = i(19489), I = i.n(F); function Fieldset(e) { let { legend: t, className: i, children: r } = e; return (0, n.jsxs)("fieldset", { className: (0, d.Z)(I().fieldset, i), children: [(0, n.jsx)("legend", { className: (0, d.Z)(I().legend, "u-typography-heading-4"), children: t }), r] }) } var k = i(94367), y = i(89900), E = i(78655), W = i.n(E); function FileUpload(e) { let { maxSizeInMb: t, disabled: i, required: r, helpText: a, accept: o, label: l, name: s, id: c } = e, d = (0, y.Z)(), [u, m] = (0, b.useState)(null), [p, _] = (0, b.useState)(null); return (0, n.jsxs)("div", { className: W().container, children: [(0, n.jsx)("input", { className: W().input, onChange: function (e) { var i; let n = (null === (i = e.target.files) || void 0 === i ? void 0 : i.length) ? e.target.files[0] : null; if (t && n && n.size > 1048576 * t) { _(d.fileToLarge); return } m(n), _(null) }, required: r, disabled: i, accept: o, type: "file", name: s, id: c }), (0, n.jsxs)("label", { htmlFor: c, className: W().label, children: [(0, n.jsx)(k.Z, { icon: "UPLOAD" }), l] }), !!p && (0, n.jsxs)("p", { className: W().error, children: [(0, n.jsx)(k.Z, { icon: "WARNING_CIRCLE" }), p] }), !p && (0, n.jsx)("p", { className: W().fileName, children: u ? u.name : d.noFileSelected }), a && (0, n.jsx)("p", { className: W().helpText, children: a })] }) } var q = i(5030), T = i(92956), L = i(89671), A = i.n(L); function EventForm(e) { var t; let { id: i } = e, { store: { locale: a } } = (0, p.Z)(), o = (0, T.useRouter)(), l = (0, y.Z)(), [s, c] = (0, b.useState)(!1), { setErrors: d, getError: u, clearError: m } = function () { let [e, t] = (0, b.useState)([]), getError = t => e.find(e => e.key === t); return { errors: e, setErrors: t, getError, clearError: i => { let n = getError(i); n && t(e.filter(e => e !== n)) } } }(), handleSubmit = async e => { e.preventDefault(), c(!0); let t = new FormData(e.currentTarget), i = await fetch("/api/register-event", { method: "POST", body: t }); i.ok ? o.push("/".concat(r.Z6.EventCreatedPage[a])) : (422 === i.status && d((await i.json()).errors.map(e => ({ key: e.path[0], message: l["".concat(e.message.replace(/(?:^\w|[A-Z]|\b\w)/g, (e, t) => 0 === t ? e.toLowerCase() : e.toUpperCase()).replace(/\s+/g, ""))] || e.message }))), d([{ key: "server", message: l.somethingWentWrong }])), c(!1) }; return (0, n.jsxs)("form", { className: A().form, onSubmit: handleSubmit, children: [(0, n.jsx)("input", { type: "hidden", name: "locale", value: a }), (0, n.jsxs)(Fieldset, { legend: l.eventInformation, children: [(0, n.jsx)(q.Z, { required: !0, label: l.eventName, name: "title", id: "".concat(i, "-name"), error: u("title"), onChange: () => m("title") }), (0, n.jsx)(q.Z, { type: "textarea", required: !0, label: l.description, name: "description", id: "".concat(i, "-description"), error: u("description"), onChange: () => m("description") }), (0, n.jsx)(q.Z, { label: l.price, name: "price", id: "".concat(i, "-price"), type: "textarea" })] }), (0, n.jsxs)(Fieldset, { legend: l.dateAndTime, children: [(0, n.jsx)(DatePicker, { label: l.eventStart, id: "".concat(i, "-start"), name: "startDate", options: { enableTime: !0, dateFormat: "Y-m-d H:i:S", altInput: !0, altFormat: "d-m-Y H:i" } }), (0, n.jsx)(DatePicker, { label: l.eventEnd, id: "".concat(i, "-end"), name: "endDate", options: { enableTime: !0, dateFormat: "Y-m-d H:i:S", altInput: !0, altFormat: "d-m-Y H:i" } })] }), (0, n.jsxs)(Fieldset, { legend: l.eventLocationTitle, children: [(0, n.jsxs)("div", { className: A().streetGroup, children: [(0, n.jsx)(q.Z, { wrapperClassName: A().street, label: l.street, name: "street", id: "".concat(i, "-street") }), (0, n.jsx)(q.Z, { label: l.streetNumber, name: "streetNumber", id: "".concat(i, "-streetNumber"), error: u("streetNumber"), onChange: () => m("streetNumber") }), (0, n.jsx)(q.Z, { label: l.streetNumberSuffix, name: "streetNumberSuffix", id: "".concat(i, "-streetNumberSuffix") })] }), (0, n.jsxs)("div", { className: A().cityGroup, children: [(0, n.jsx)(q.Z, { label: l.zipcode, name: "zipcode", id: "".concat(i, "-zipcode") }), (0, n.jsx)(q.Z, { required: !0, label: l.city, name: "city", id: "".concat(i, "-city"), defaultValue: "Breda", error: u("city"), onChange: () => m("city") })] }), (0, n.jsx)(q.Z, { defaultValue: "NL", label: l.country, name: "country", id: "".concat(i, "-country") }), (0, n.jsx)(q.Z, { required: !0, label: l.locationName, name: "locationName", id: "".concat(i, "-locationName"), error: u("locationName"), onChange: () => m("locationName") })] }), (0, n.jsxs)(Fieldset, { legend: l.contactInformation, children: [(0, n.jsx)(q.Z, { label: l.website, name: "website", id: "".concat(i, "-website") }), (0, n.jsx)(q.Z, { label: l.email, name: "email", type: "email", id: "".concat(i, "-email"), error: u("email"), onChange: () => m("email") }), (0, n.jsx)(q.Z, { label: l.phone, name: "phone", id: "".concat(i, "-phone") })] }), (0, n.jsx)(Fieldset, { legend: l.addImage, children: (0, n.jsx)(FileUpload, { label: "Selecteer een bestand", helpText: "Max. grootte: 20 MB", maxSizeInMb: 20, name: "image", id: "image" }) }), (0, n.jsxs)(Fieldset, { legend: l.yourDetails, children: [(0, n.jsx)(q.Z, { required: !0, label: l.name, name: "contactName", id: "".concat(i, "-contactName"), error: u("contactName"), onChange: () => m("contactName") }), (0, n.jsx)(q.Z, { required: !0, label: l.email, name: "contactEmail", id: "".concat(i, "-contactEmail"), type: "email", error: u("contactEmail"), onChange: () => m("contactEmail") }), (0, n.jsx)(q.Z, { required: !0, label: l.phone, name: "contactPhone", id: "".concat(i, "-contactPhone"), error: u("contactPhone"), onChange: () => m("contactPhone") })] }), (0, n.jsx)(Fieldset, { legend: l.additionalDetails, children: (0, n.jsx)(q.Z, { type: "textarea", label: l.comments, name: "comments", id: "".concat(i, "-comments") }) }), (0, n.jsx)(S.Z, { label: l.submitEvent, submit: !0, loading: s }), (0, n.jsx)(w.Z, { message: null === (t = u("server")) || void 0 === t ? void 0 : t.message })] }) } var V = i(8949), P = i(5252), D = i(46217), R = i(9700), M = i.n(R), FaqList_FaqItem = function (e) { let { item: t, id: i, isOpen: r, handleAccordion: a } = e, o = "".concat(i, "-toggle"), l = "".concat(i, "-panel"), s = r ? "MINUS" : "PLUS", [c, u] = (0, b.useState)("0"), m = (0, b.useRef)(null); return (0, b.useEffect)(() => { var e; u("".concat((null == m ? void 0 : null === (e = m.current) || void 0 === e ? void 0 : e.offsetHeight) || 0, "px")) }, [r]), (0, n.jsxs)("div", { className: M().faqItem, children: [(0, n.jsx)("dt", { className: M().header, children: (0, n.jsxs)("button", { id: o, onClick: a, className: M().accordionButton, "aria-expanded": r ? "true" : "false", "aria-controls": l, type: "button", children: [t.title, (0, n.jsx)("span", { className: M().iconContainer, "aria-hidden": "true", children: (0, n.jsx)(k.Z, { className: M().svgIcon, icon: s }) })] }) }), (0, n.jsx)("div", { id: l, style: { "--faq-height": c }, children: (0, n.jsx)(D.Z, { in: !!r, timeout: 300, unmountOnExit: !0, classNames: { enter: M().fadeEnter, enterActive: M().fadeEnterActive, exit: M().fadeExit, exitActive: M().fadeExitActive }, children: (0, n.jsx)("div", { className: M().textWrapper, children: (0, n.jsx)("dd", { "aria-labelledby": o, className: (0, d.Z)(M().text, !!r && M().showText), ref: m, children: (0, n.jsx)(P.Z, { text: t.text, className: M().richText }) }) }) }) })] }) }, B = i(21151), O = i.n(B), FaqList_FaqList = function (e) { let { faqList: t, firstQuestionOpen: i = !1, altBackground: r } = e, [a, o] = (0, b.useState)(i ? 0 : -1); return (0, n.jsx)("dl", { className: (0, d.Z)(O().wrapper, "u-list-clean u-grid u-grid--gap-0", r && O().altBackground), children: t.map((e, t) => (0, n.jsx)(FaqList_FaqItem, { item: e, id: e.id, isOpen: a === t, handleAccordion: () => o(t === a ? -1 : t) }, e.id)) }) }, G = i(68079), U = i.n(G), H = i(87334), z = i.n(H), Q = i(28094), X = i.n(Q), Figure_Figure = function (e) { let { image: t, alt: i = "", sizes: r, caption: a, className: o, imageClassName: l } = e; return (0, n.jsxs)("figure", { className: (0, d.Z)(X().figure, o), children: [(0, n.jsx)(z(), { src: t.url, placeholder: "blur", blurDataURL: t.placeholder, alt: i, sizes: r, objectFit: "cover", objectPosition: "center", layout: "fill", className: (0, d.Z)(X().image, l) }), a && (0, n.jsx)("figcaption", { className: X().caption, children: a })] }) }, Y = i(69603), J = i.n(Y), K = i(2059), $ = i(27918), ee = i(62846), et = i.n(ee), ei = i(73889), en = i.n(ei), er = i(36164), ea = i(2305), eo = i.n(ea), TextMediaWrapper_TextMediaWrapper = function (e) { let { title: t, subtitle: i, text: r, cta: a, backgroundColor: o, textLeft: l = !0, children: c, modifier: u } = e; return (0, n.jsxs)(f.Z, { backgroundColor: o, containerClassName: (0, d.Z)(eo().wrapper, !l && eo().textRight, u && eo()[u]), children: [(0, n.jsx)(s.Z, { title: t, subtitle: i, text: r, cta: a, className: eo().content, modifier: u }), (0, n.jsx)("div", { className: eo().media, children: c })] }) }, el = i(33193), es = i.n(el), ec = i(63135), ed = i(65978), eu = i(42810), em = i.n(eu), ep = i(51756); let e_ = { ImageSection: function (e) { let { title: t, subtitle: i, text: r, cta: a, image: o, imageAlt: l, backgroundColor: c, fullWidth: u, modifier: m } = e; return (0, n.jsxs)(f.Z, { backgroundColor: c.color, children: [(0, n.jsx)(s.Z, { title: t, subtitle: i, text: r, cta: a, className: J().content, centered: !0, modifier: "inStore" === m ? m : void 0 }), (0, n.jsx)(Figure_Figure, { image: o, alt: l, sizes: u ? "(min-width: 1024px) 1231px, (min-width: 1280px) 1296px" : "(min-width: 1024px) 608px, (min-width: 1280px) 640px", className: (0, d.Z)(J().imageWrapper, u && J().fullWidth), imageClassName: J().image })] }) }, TextImageSection: function (e) { let { title: t, subtitle: i, text: r, cta: a, backgroundColor: o, textLeft: l, image: s, imageAlt: c, modifier: d } = e; return (0, n.jsx)(TextMediaWrapper_TextMediaWrapper, { title: t, subtitle: i, text: r, cta: a, textLeft: l, backgroundColor: o.color, modifier: "inStore" === d ? "inStore" : void 0, children: (0, n.jsx)(Figure_Figure, { image: s, alt: c, sizes: "(min-width: 1024px) 608px, (min-width: 1280px) 640px", className: es().figure, imageClassName: es().image }) }) }, TextSection: ec.Z, TextVideoSection: function (e) { var t; let { title: i, subtitle: r, text: a, cta: o, backgroundColor: l, textLeft: s, video: c, modifier: d } = e; return (0, n.jsx)(TextMediaWrapper_TextMediaWrapper, { title: i, subtitle: r, text: a, cta: o, textLeft: s, backgroundColor: l.color, modifier: "inStore" === d ? "inStore" : void 0, children: ((null == c ? void 0 : null === (t = c.embeddedVideo) || void 0 === t ? void 0 : t.playbackId) || (null == c ? void 0 : c.youtubeId)) && (0, n.jsx)(ed.Z, { video: c, className: em().video }) }) }, VideoSection: ep.Z, CtaButtonsSection: function (e) { let { title: t, text: i, ctaButtons: r, backgroundColor: a, modifier: o } = e, u = r.flatMap(e => e.ctaButtons); return (0, n.jsxs)(c.Z, { isHeroSection: "heroSection" === o, backgroundColor: a, children: [(0, n.jsx)(s.Z, { title: t, text: i, className: m().content }), (0, n.jsx)("ul", { className: (0, d.Z)(m().ctas, "u-list-clean u-grid u-grid--gap-2 u-grid--2@sm u-grid--3@lg u-grid--4@xl"), children: u.map(e => (0, n.jsx)("li", { className: m().item, children: (0, n.jsx)(l.Z, { variant: "white", cta: e, fullWidth: !0 }) }, e.id)) })] }) }, AccessibilitySection: a.Z, ImageSliderSection: K.Z, FaqSection: function (e) { let { title: t, subtitle: i, text: a, cta: o, faqList: l, firstQuestionOpen: c, backgroundColor: d, modifier: u } = e; return (0, n.jsxs)(f.Z, { backgroundColor: d.color, children: [(0, n.jsx)(s.Z, { title: t, subtitle: i, text: a, cta: o, modifier: "inStore" === u ? u : void 0 }), (0, n.jsx)(FaqList_FaqList, { faqList: l, firstQuestionOpen: c, altBackground: d.color === r.gi })] }) }, QuoteSection: function (e) { let { quote: t, name: i, image: r, functionName: a, backgroundColor: o } = e; return (0, n.jsx)(f.Z, { backgroundColor: o.color, children: (0, n.jsxs)("div", { className: en().wrapper, children: [(0, n.jsx)("h2", { className: en().quote, children: t }), (a || i || r) && (0, n.jsxs)("div", { className: en().figureContent, children: [(a || i) && (0, n.jsxs)("div", { className: en().nameWrapper, children: [i && (0, n.jsx)("h3", { className: en().name, children: i }), a && (0, n.jsx)(P.Z, { text: a, className: en().functionName })] }), (null == r ? void 0 : r.url) && (0, n.jsx)(Figure_Figure, { image: r, alt: i, sizes: "(min-width: 64px) 64px, (min-width: 64px) 64px", imageClassName: en().image, className: en().image })] })] }) }) }, EventRegistrationSection: function (e) { let { id: t, title: i, subtitle: r, text: a, backgroundColor: o } = e; return (0, n.jsx)(f.Z, { backgroundColor: o.color, children: (0, n.jsx)(s.Z, { title: i, subtitle: r, text: a, centered: !0, children: (0, n.jsx)(EventForm, { id: t }) }) }) }, ContentCarouselSection: o.Z, ExploreFormSection: V.Z, EventCarouselSection: function (e) { var t, i, r; let { id: a, title: o, subtitle: l, text: c, backgroundColor: d, selection: u, modifier: m } = e, { store: { page: g, locale: S } } = (0, p.Z)(), j = (null == g ? void 0 : null === (r = g.additionalSectionData) || void 0 === r ? void 0 : null === (i = r[a]) || void 0 === i ? void 0 : null === (t = i.EventPages) || void 0 === t ? void 0 : t.items) || [], b = [...u, ...j].map(e => ({ ...e, href: (0, h.Z)({ internalLink: e, locale: S, store: "inStore" === m }), showType: !0 })); return (null == b ? void 0 : b.length) ? (0, n.jsxs)(f.Z, { backgroundColor: d.color, children: [(0, n.jsx)(s.Z, { title: o, subtitle: l, text: c, modifier: "inStore" === m ? "inStore" : void 0, addSpaceForButtons: "inStore" === m }), (0, n.jsx)("div", { className: v().wrapper, children: (0, n.jsx)(x.Z, { items: b, SlideItem: _.Z, slidesPerView: "inStore" === m ? 2.5 : { mobile: 1, tablet: 3.25, desktop: 4 }, modifier: "inStore" === m ? "inStore" : void 0 }) })] }) : null }, NewsletterSection: function (e) { let { title: t, text: i, backgroundColor: r } = e; return (0, n.jsx)(f.Z, { backgroundColor: r.color, children: (0, n.jsxs)("div", { className: et().wrapper, children: [(0, n.jsx)(s.Z, { className: et().content, title: t, text: i }), (0, n.jsx)("div", { className: et().formContent, children: (0, n.jsx)($.Z, {}) })] }) }) }, StoreMapCtaSection: er.Z, IframeSection: function (e) { let { title: t, text: i, iframe: r, backgroundColor: a, modifier: o } = e, [l, c] = (0, b.useState)(""); return (0, b.useEffect)(() => { c(r.replaceAll(//g, '"').replaceAll(//g, '"').replaceAll(//g, "'").replaceAll(//g, "'")) }, [r]), (0, n.jsxs)(f.Z, { backgroundColor: a.color, children: [(0, n.jsx)(s.Z, { title: t, text: i, className: U().content, centered: !0, modifier: "inStore" === o ? o : void 0 }), !!l && (0, n.jsx)("div", { className: U().container, dangerouslySetInnerHTML: { __html: l } })] }) } }; var Sections_Sections = function (e) { let { sections: t, modifier: i } = e; return t.length ? t.map(e => { if ("inStore" === i && r.Nl.includes(e.typename)) return null; let t = e_[null == e ? void 0 : e.typename]; return t ? (0, n.jsx)(t, { ...e, modifier: i }, "".concat(e.id)) : null }) : null } }, 36164: function (e, t, i) { "use strict"; i.d(t, { Z: function () { return StoreMapCtaSection } }); var n = i(11527), r = i(1011), a = i(63007), o = i(87334), l = i.n(o), s = i(78176), c = i.n(s); function StoreMapCtaSection(e) { let { backgroundColor: t, title: i, text: o, cta: s, image: d } = e; return (0, n.jsx)(r.Z, { backgroundColor: t.color, children: (0, n.jsxs)("div", { className: c().wrapper, children: [(0, n.jsx)("div", { className: c().imageWrapper, children: (0, n.jsx)(l(), { src: d.url, placeholder: "blur", blurDataURL: d.placeholder, layout: "fill", alt: "", objectFit: "cover" }) }), (0, n.jsx)(a.Z, { title: i, text: o, cta: s, className: c().content, modifier: "inStore" })] }) }) } }, 63135: function (e, t, i) { "use strict"; var n = i(11527), r = i(1011), a = i(63007), o = i(88568), l = i.n(o); t.Z = function (e) { let { title: t, subtitle: i, text: o, cta: s, backgroundColor: c, modifier: d } = e; return (0, n.jsx)(r.Z, { backgroundColor: c.color, children: (0, n.jsx)(a.Z, { title: t, subtitle: i, text: o, cta: s, centered: !0, className: l().content, modifier: "inStore" === d ? "inStore" : void 0 }) }) } }, 51756: function (e, t, i) { "use strict"; var n = i(11527), r = i(65978), a = i(1011), o = i(63007), l = i(86259), s = i(45020), c = i.n(s); t.Z = function (e) { var t; let { title: i, subtitle: s, text: d, cta: u, backgroundColor: m, video: p, fullWidth: _, modifier: x } = e; return (null == p ? void 0 : null === (t = p.embeddedVideo) || void 0 === t ? void 0 : t.playbackId) || (null == p ? void 0 : p.youtubeId) ? (0, n.jsxs)(a.Z, { backgroundColor: m.color, children: [(0, n.jsx)(o.Z, { title: i, subtitle: s, text: d, cta: u, className: c().content, centered: !0, modifier: "inStore" === x ? "inStore" : void 0 }), (0, n.jsx)(r.Z, { video: p, className: (0, l.Z)(c().video, _ && c().fullWidth) })] }) : null } }, 35750: function (e) { e.exports = { wrapper: "DatePicker_wrapper__ZDgLh", input: "DatePicker_input__hQXSp", label: "DatePicker_label__ibjcy", hasValue: "DatePicker_hasValue__sc_Ni" } }, 19489: function (e) { e.exports = { fieldset: "Fieldset_fieldset__x5JnT", legend: "Fieldset_legend__QZPZK" } }, 28094: function (e) { e.exports = { figure: "Figure_figure__ot9u2" } }, 78655: function (e) { e.exports = { input: "FileUpload_input__MCDFS", label: "FileUpload_label__mgZk6", iconContainer: "FileUpload_iconContainer__d9_G6", icon: "FileUpload_icon__Wijx7", fileName: "FileUpload_fileName__vaX2O", error: "FileUpload_error__VsXNX", helpText: "FileUpload_helpText__wH6Vn", errorIcon: "FileUpload_errorIcon__446Iv" } }, 86293: function (e) { e.exports = { mediaContainer: "Video_mediaContainer__xUBmI", media: "Video_media__PLQRL", withoutControls: "Video_withoutControls__ElbRi", buttonContainer: "Video_buttonContainer__QjAIO", button: "Video_button__DJz2L" } }, 33389: function (e) { e.exports = { wrapper: "Carousel_wrapper__Ux7eK", swiper: "Carousel_swiper__qAa7J", navigation: "Carousel_navigation__nTodO", button: "Carousel_button__1UegG", previous: "Carousel_previous__cJi_m", next: "Carousel_next__2nyce", inStore: "Carousel_inStore__oGTic" } }, 89671: function (e) { e.exports = { streetGroup: "EventForm_streetGroup__8etw8", street: "EventForm_street__FH_Zj", cityGroup: "EventForm_cityGroup__Y_hFG" } }, 9700: function (e) { e.exports = { faqItem: "FaqItem_faqItem__wmXu5", header: "FaqItem_header__i19Kq", text: "FaqItem_text___0pv8", accordionButton: "FaqItem_accordionButton__04vXt", svgIcon: "FaqItem_svgIcon__aar2H", richText: "FaqItem_richText__3UamC", textWrapper: "FaqItem_textWrapper__mMz3i", fadeEnter: "FaqItem_fadeEnter__FW0lC", fadeEnterActive: "FaqItem_fadeEnterActive__rFYv1", fadeExit: "FaqItem_fadeExit__7CR6p", fadeExitActive: "FaqItem_fadeExitActive__6VrlC" } }, 21151: function (e) { e.exports = { wrapper: "FaqList_wrapper__8Svq_", altBackground: "FaqList_altBackground__HuZWh", iconContainer: "FaqList_iconContainer__7jd_g", svgIcon: "FaqList_svgIcon__6O6cJ" } }, 99295: function (e) { e.exports = { imageWrapper: "ImageSliderItem_imageWrapper__3TV9s", image: "ImageSliderItem_image__8BeBx" } }, 38685: function (e) { e.exports = { section: "Section_section__lbtX3", white: "Section_white__2fn2o", gray: "Section_gray__dCl3h" } }, 55624: function (e) { e.exports = { container: "SectionContent_container__9w66L", centered: "SectionContent_centered__aC4Xi", text: "SectionContent_text__FWBgu", subtitle: "SectionContent_subtitle__5Gq5p", inStore: "SectionContent_inStore__aPc7c", title: "SectionContent_title__GS0F_", fullWidth: "SectionContent_fullWidth__OwdF9", addSpaceForButtons: "SectionContent_addSpaceForButtons__qs1sw" } }, 2305: function (e) { e.exports = { wrapper: "TextMediaWrapper_wrapper__9Bnh0", content: "TextMediaWrapper_content__5wdsj", media: "TextMediaWrapper_media__QA0Fa", textRight: "TextMediaWrapper_textRight__trQdm", inStore: "TextMediaWrapper_inStore__lFMcl" } }, 95964: function (e) { e.exports = { wrapper: "AccessibilitySection_wrapper__uEfKN", item: "AccessibilitySection_item__2adCr", iconContainer: "AccessibilitySection_iconContainer__wk_yV", svgIcon: "AccessibilitySection_svgIcon__fEWYT", inStore: "AccessibilitySection_inStore__35ffL" } }, 77124: function (e) { e.exports = { wrapper: "ContentCarouselSection_wrapper__C0XWj" } }, 33344: function (e) { e.exports = { ctas: "CtaButtonsSection_ctas__i44ss" } }, 40084: function (e) { e.exports = { wrapper: "EventCarouselSection_wrapper__kmDS9" } }, 28879: function (e) { e.exports = { container: "ExploreFormSection_container__jJ_aO", question: "ExploreFormSection_question__8hAVO", selectWrapper: "ExploreFormSection_selectWrapper__bi_xh", submit: "ExploreFormSection_submit__0eAjH", form: "ExploreFormSection_form__OhIl1" } }, 68079: function (e) { e.exports = { container: "IframeSection_container__baE_p" } }, 69603: function (e) { e.exports = { imageWrapper: "ImageSection_imageWrapper__4N5SX", fullWidth: "ImageSection_fullWidth__j8VDy" } }, 73383: function (e) { e.exports = { wrapper: "ImageSliderSection_wrapper__XcPBF" } }, 62846: function (e) { e.exports = { wrapper: "NewsletterSection_wrapper__6B0_7", content: "NewsletterSection_content__waWZI", formContent: "NewsletterSection_formContent__fzqj0" } }, 73889: function (e) { e.exports = { wrapper: "QuoteSection_wrapper__Fy04H", quote: "QuoteSection_quote__oundx", figureContent: "QuoteSection_figureContent__eKNJ3", name: "QuoteSection_name__5p1y8", image: "QuoteSection_image__kGRch" } }, 78176: function (e) { e.exports = { wrapper: "StoreMapCtaSection_wrapper__Moy9A", imageWrapper: "StoreMapCtaSection_imageWrapper__1PtrV", content: "StoreMapCtaSection_content__XwuBX" } }, 33193: function (e) { e.exports = { figure: "TextImageSection_figure__loJqc", image: "TextImageSection_image__2_L_W" } }, 88568: function (e) { e.exports = { content: "TextSection_content__QmPGq" } }, 42810: function (e) { e.exports = { video: "TextVideoSection_video__D9xws" } }, 45020: function (e) { e.exports = { video: "VideoSection_video__iLbll", fullWidth: "VideoSection_fullWidth__bhmxV" } } }]);

"use strict"; (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[307], {
  94836: function (e, t, i) {
    let r, s, a; i.d(t, { ZP: function () { return Hls } }); var n, l, o, h, d, u, c, f, g, m, p, E, T, y, v, S, A = { exports: {} }; n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, l = /^(?=([^\/?#]*))\1([^]*)$/, o = /(?:\/|^)\.(?=\/)/g, h = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, d = { buildAbsoluteURL: function (e, t, i) { if (i = i || {}, e = e.trim(), !(t = t.trim())) { if (!i.alwaysNormalize) return e; var r = d.parseURL(e); if (!r) throw Error("Error trying to parse base URL."); return r.path = d.normalizePath(r.path), d.buildURLFromParts(r) } var s = d.parseURL(t); if (!s) throw Error("Error trying to parse relative URL."); if (s.scheme) return i.alwaysNormalize ? (s.path = d.normalizePath(s.path), d.buildURLFromParts(s)) : t; var a = d.parseURL(e); if (!a) throw Error("Error trying to parse base URL."); if (!a.netLoc && a.path && "/" !== a.path[0]) { var n = l.exec(a.path); a.netLoc = n[1], a.path = n[2] } a.netLoc && !a.path && (a.path = "/"); var o = { scheme: a.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; if (!s.netLoc && (o.netLoc = a.netLoc, "/" !== s.path[0])) { if (s.path) { var h = a.path, u = h.substring(0, h.lastIndexOf("/") + 1) + s.path; o.path = d.normalizePath(u) } else o.path = a.path, s.params || (o.params = a.params, s.query || (o.query = a.query)) } return null === o.path && (o.path = i.alwaysNormalize ? d.normalizePath(s.path) : s.path), d.buildURLFromParts(o) }, parseURL: function (e) { var t = n.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(o, ""); e.length !== (e = e.replace(h, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, A.exports = d; var L = A.exports; function ownKeys(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), i.push.apply(i, r) } return i } function _objectSpread2(e) { for (var t = 1; t < arguments.length; t++) { var i = null != arguments[t] ? arguments[t] : {}; t % 2 ? ownKeys(Object(i), !0).forEach(function (t) { !function (e, t, i) { var r; (t = "symbol" == typeof (r = function (e, t) { if ("object" != typeof e || !e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var r = i.call(e, t || "default"); if ("object" != typeof r) return r; throw TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(t, "string")) ? r : String(r)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i }(e, t, i[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ownKeys(Object(i)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t)) }) } return e } function _extends() { return (_extends = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }).apply(this, arguments) } let R = Number.isFinite || function (e) { return "number" == typeof e && isFinite(e) }, I = Number.isSafeInteger || function (e) { return "number" == typeof e && Math.abs(e) <= D }, D = Number.MAX_SAFE_INTEGER || 9007199254740991, b = ((u = {}).MEDIA_ATTACHING = "hlsMediaAttaching", u.MEDIA_ATTACHED = "hlsMediaAttached", u.MEDIA_DETACHING = "hlsMediaDetaching", u.MEDIA_DETACHED = "hlsMediaDetached", u.BUFFER_RESET = "hlsBufferReset", u.BUFFER_CODECS = "hlsBufferCodecs", u.BUFFER_CREATED = "hlsBufferCreated", u.BUFFER_APPENDING = "hlsBufferAppending", u.BUFFER_APPENDED = "hlsBufferAppended", u.BUFFER_EOS = "hlsBufferEos", u.BUFFER_FLUSHING = "hlsBufferFlushing", u.BUFFER_FLUSHED = "hlsBufferFlushed", u.MANIFEST_LOADING = "hlsManifestLoading", u.MANIFEST_LOADED = "hlsManifestLoaded", u.MANIFEST_PARSED = "hlsManifestParsed", u.LEVEL_SWITCHING = "hlsLevelSwitching", u.LEVEL_SWITCHED = "hlsLevelSwitched", u.LEVEL_LOADING = "hlsLevelLoading", u.LEVEL_LOADED = "hlsLevelLoaded", u.LEVEL_UPDATED = "hlsLevelUpdated", u.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", u.LEVELS_UPDATED = "hlsLevelsUpdated", u.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", u.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", u.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", u.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", u.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", u.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", u.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", u.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", u.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", u.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", u.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", u.CUES_PARSED = "hlsCuesParsed", u.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", u.INIT_PTS_FOUND = "hlsInitPtsFound", u.FRAG_LOADING = "hlsFragLoading", u.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", u.FRAG_LOADED = "hlsFragLoaded", u.FRAG_DECRYPTED = "hlsFragDecrypted", u.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", u.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", u.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", u.FRAG_PARSED = "hlsFragParsed", u.FRAG_BUFFERED = "hlsFragBuffered", u.FRAG_CHANGED = "hlsFragChanged", u.FPS_DROP = "hlsFpsDrop", u.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", u.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", u.ERROR = "hlsError", u.DESTROYING = "hlsDestroying", u.KEY_LOADING = "hlsKeyLoading", u.KEY_LOADED = "hlsKeyLoaded", u.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", u.BACK_BUFFER_REACHED = "hlsBackBufferReached", u.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", u), C = ((c = {}).NETWORK_ERROR = "networkError", c.MEDIA_ERROR = "mediaError", c.KEY_SYSTEM_ERROR = "keySystemError", c.MUX_ERROR = "muxError", c.OTHER_ERROR = "otherError", c), k = ((f = {}).KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", f.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", f.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", f.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", f.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", f.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", f.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", f.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", f.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", f.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", f.MANIFEST_LOAD_ERROR = "manifestLoadError", f.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", f.MANIFEST_PARSING_ERROR = "manifestParsingError", f.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", f.LEVEL_EMPTY_ERROR = "levelEmptyError", f.LEVEL_LOAD_ERROR = "levelLoadError", f.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", f.LEVEL_PARSING_ERROR = "levelParsingError", f.LEVEL_SWITCH_ERROR = "levelSwitchError", f.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", f.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", f.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", f.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", f.FRAG_LOAD_ERROR = "fragLoadError", f.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", f.FRAG_DECRYPT_ERROR = "fragDecryptError", f.FRAG_PARSING_ERROR = "fragParsingError", f.FRAG_GAP = "fragGap", f.REMUX_ALLOC_ERROR = "remuxAllocError", f.KEY_LOAD_ERROR = "keyLoadError", f.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", f.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", f.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", f.BUFFER_APPEND_ERROR = "bufferAppendError", f.BUFFER_APPENDING_ERROR = "bufferAppendingError", f.BUFFER_STALLED_ERROR = "bufferStalledError", f.BUFFER_FULL_ERROR = "bufferFullError", f.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", f.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", f.INTERNAL_EXCEPTION = "internalException", f.INTERNAL_ABORTED = "aborted", f.UNKNOWN = "unknown", f), noop = function () { }, P = { trace: noop, debug: noop, log: noop, warn: noop, info: noop, error: noop }, _ = P, M = _, x = /^(\d+)x(\d+)$/, w = /(.+?)=(".*?"|.*?)(?:,|$)/g; let AttrList = class AttrList { constructor(e) { "string" == typeof e && (e = AttrList.parseAttrList(e)), _extends(this, e) } get clientAttrs() { return Object.keys(this).filter(e => "X-" === e.substring(0, 2)) } decimalInteger(e) { let t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } hexadecimalInteger(e) { if (!this[e]) return null; { let t = (this[e] || "0x").slice(2); t = (1 & t.length ? "0" : "") + t; let i = new Uint8Array(t.length / 2); for (let e = 0; e < t.length / 2; e++)i[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16); return i } } hexadecimalIntegerAsNumber(e) { let t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } decimalFloatingPoint(e) { return parseFloat(this[e]) } optionalFloat(e, t) { let i = this[e]; return i ? parseFloat(i) : t } enumeratedString(e) { return this[e] } bool(e) { return "YES" === this[e] } decimalResolution(e) { let t = x.exec(this[e]); if (null !== t) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) } } static parseAttrList(e) { let t; let i = {}; for (w.lastIndex = 0; null !== (t = w.exec(e));) { let e = t[2]; 0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1)); let r = t[1].trim(); i[r] = e } return i } }; let DateRange = class DateRange { constructor(e, t) { if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) { let i = t.attr; for (let t in i) if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== i[t]) { M.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = t; break } e = _extends(new AttrList({}), i, e) } if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) { let e = new Date(this.attr["END-DATE"]); R(e.getTime()) && (this._endDate = e) } } get id() { return this.attr.ID } get class() { return this.attr.CLASS } get startDate() { return this._startDate } get endDate() { if (this._endDate) return this._endDate; let e = this.duration; return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null } get duration() { if ("DURATION" in this.attr) { let e = this.attr.decimalFloatingPoint("DURATION"); if (R(e)) return e } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3; return null } get plannedDuration() { return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null } get endOnNext() { return this.attr.bool("END-ON-NEXT") } get isValid() { return !!this.id && !this._badValueForSameId && R(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class) } }; let LoadStats = class LoadStats { constructor() { this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 } } }; var F = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" }; let BaseSegment = class BaseSegment { constructor(e) { this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = { [F.AUDIO]: null, [F.VIDEO]: null, [F.AUDIOVIDEO]: null }, this.baseurl = e } setByteRange(e, t) { let i; let r = e.split("@", 2); i = 1 === r.length ? (null == t ? void 0 : t.byteRangeEndOffset) || 0 : parseInt(r[1]), this._byteRange = [i, parseInt(r[0]) + i] } get byteRange() { return this._byteRange ? this._byteRange : [] } get byteRangeStartOffset() { return this.byteRange[0] } get byteRangeEndOffset() { return this.byteRange[1] } get url() { return !this._url && this.baseurl && this.relurl && (this._url = L.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url || "" } set url(e) { this._url = e } }; let Fragment = class Fragment extends BaseSegment { constructor(e, t) { super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new LoadStats, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e } get decryptdata() { let { levelkeys: e } = this; if (!e && !this._decryptdata) return null; if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) { let e = this.levelkeys.identity; if (e) this._decryptdata = e.getDecryptData(this.sn); else { let e = Object.keys(this.levelkeys); if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn) } } return this._decryptdata } get end() { return this.start + this.duration } get endProgramDateTime() { if (null === this.programDateTime || !R(this.programDateTime)) return null; let e = R(this.duration) ? this.duration : 0; return this.programDateTime + 1e3 * e } get encrypted() { var e; if (null != (e = this._decryptdata) && e.encrypted) return !0; if (this.levelkeys) { let e = Object.keys(this.levelkeys), t = e.length; if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted) return !0 } return !1 } setKeyFormat(e) { if (this.levelkeys) { let t = this.levelkeys[e]; t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn)) } } abortRequests() { var e, t; null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort() } setElementaryStreamInfo(e, t, i, r, s, a = !1) { let { elementaryStreams: n } = this, l = n[e]; if (!l) { n[e] = { startPTS: t, endPTS: i, startDTS: r, endDTS: s, partial: a }; return } l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, i), l.startDTS = Math.min(l.startDTS, r), l.endDTS = Math.max(l.endDTS, s) } clearElementaryStreamInfo() { let { elementaryStreams: e } = this; e[F.AUDIO] = null, e[F.VIDEO] = null, e[F.AUDIOVIDEO] = null } }; let Part = class Part extends BaseSegment { constructor(e, t, i, r, s) { super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new LoadStats, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = r; let a = e.enumeratedString("BYTERANGE"); a && this.setByteRange(a, s), s && (this.fragOffset = s.fragOffset + s.duration) } get start() { return this.fragment.start + this.fragOffset } get end() { return this.start + this.duration } get loaded() { let { elementaryStreams: e } = this; return !!(e.audio || e.video || e.audiovideo) } }; let LevelDetails = class LevelDetails { constructor(e) { this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e } reloaded(e) { if (!e) { this.advanced = !0, this.updated = !0; return } let t = this.lastPartSn - e.lastPartSn, i = this.lastPartIndex - e.lastPartIndex; this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay } get hasProgramDateTime() { return !!this.fragments.length && R(this.fragments[this.fragments.length - 1].programDateTime) } get levelTargetDuration() { return this.averagetargetduration || this.targetduration || 10 } get drift() { let e = this.driftEndTime - this.driftStartTime; if (e > 0) { let t = this.driftEnd - this.driftStart; return 1e3 * t / e } return 1 } get edge() { return this.partEnd || this.fragmentEnd } get partEnd() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd } get fragmentEnd() { var e; return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0 } get age() { return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0 } get lastPartIndex() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1 } get lastPartSn() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN } }; function base64Decode(e) { return Uint8Array.from(atob(e), e => e.charCodeAt(0)) } function strToUtf8array(e) { return Uint8Array.from(unescape(encodeURIComponent(e)), e => e.charCodeAt(0)) } let O = "undefined" != typeof self ? self : void 0; var N = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.fps", PLAYREADY: "com.microsoft.playready", WIDEVINE: "com.widevine.alpha" }, U = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.streamingkeydelivery", PLAYREADY: "com.microsoft.playready", WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" }; function keySystemFormatToKeySystemDomain(e) { switch (e) { case U.FAIRPLAY: return N.FAIRPLAY; case U.PLAYREADY: return N.PLAYREADY; case U.WIDEVINE: return N.WIDEVINE; case U.CLEARKEY: return N.CLEARKEY } } var B = { WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed" }; function keySystemDomainToKeySystemFormat(e) { switch (e) { case N.FAIRPLAY: return U.FAIRPLAY; case N.PLAYREADY: return U.PLAYREADY; case N.WIDEVINE: return U.WIDEVINE; case N.CLEARKEY: return U.CLEARKEY } } function getKeySystemsForConfig(e) { let { drmSystems: t, widevineLicenseUrl: i } = e, r = t ? [N.FAIRPLAY, N.WIDEVINE, N.PLAYREADY, N.CLEARKEY].filter(e => !!t[e]) : []; return !r[N.WIDEVINE] && i && r.push(N.WIDEVINE), r } let $ = null != O && null != (g = O.navigator) && g.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null; function sliceUint8(e, t, i) { return Uint8Array.prototype.slice ? e.slice(t, i) : new Uint8Array(Array.prototype.slice.call(e, t, i)) } let isHeader$2 = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, isFooter = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, getID3Data = (e, t) => { let i = t, r = 0; for (; isHeader$2(e, t);) { r += 10; let i = readSize(e, t + 6); r += i, isFooter(e, t + 10) && (r += 10), t += r } if (r > 0) return e.subarray(i, i + r) }, readSize = (e, t) => (127 & e[t]) << 21 | (127 & e[t + 1]) << 14 | (127 & e[t + 2]) << 7 | 127 & e[t + 3], canParse$2 = (e, t) => isHeader$2(e, t) && readSize(e, t + 6) + 10 <= e.length - t, getTimeStamp = e => { let t = getID3Frames(e); for (let e = 0; e < t.length; e++) { let i = t[e]; if (isTimeStampFrame(i)) return readTimeStamp(i) } }, isTimeStampFrame = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info, getFrameData = e => { let t = String.fromCharCode(e[0], e[1], e[2], e[3]), i = readSize(e, 4); return { type: t, size: i, data: e.subarray(10, 10 + i) } }, getID3Frames = e => { let t = 0, i = []; for (; isHeader$2(e, t);) { let r = readSize(e, t + 6); t += 10; let s = t + r; for (; t + 8 < s;) { let r = getFrameData(e.subarray(t)), s = decodeFrame(r); s && i.push(s), t += r.size + 10 } isFooter(e, t) && (t += 10) } return i }, decodeFrame = e => "PRIV" === e.type ? decodePrivFrame(e) : "W" === e.type[0] ? decodeURLFrame(e) : decodeTextFrame(e), decodePrivFrame = e => { if (e.size < 2) return; let t = utf8ArrayToStr(e.data, !0), i = new Uint8Array(e.data.subarray(t.length + 1)); return { key: e.type, info: t, data: i.buffer } }, decodeTextFrame = e => { if (e.size < 2) return; if ("TXXX" === e.type) { let t = 1, i = utf8ArrayToStr(e.data.subarray(t), !0); t += i.length + 1; let r = utf8ArrayToStr(e.data.subarray(t)); return { key: e.type, info: i, data: r } } let t = utf8ArrayToStr(e.data.subarray(1)); return { key: e.type, data: t } }, decodeURLFrame = e => { if ("WXXX" === e.type) { if (e.size < 2) return; let t = 1, i = utf8ArrayToStr(e.data.subarray(t), !0); t += i.length + 1; let r = utf8ArrayToStr(e.data.subarray(t)); return { key: e.type, info: i, data: r } } let t = utf8ArrayToStr(e.data); return { key: e.type, data: t } }, readTimeStamp = e => { if (8 === e.data.byteLength) { let t = new Uint8Array(e.data), i = 1 & t[3], r = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7]; return r /= 45, i && (r += 47721858.84), Math.round(r) } }, utf8ArrayToStr = (e, t = !1) => { let i, s; let a = function () { if (!navigator.userAgent.includes("PlayStation 4")) return r || void 0 === self.TextDecoder || (r = new self.TextDecoder("utf-8")), r }(); if (a) { let i = a.decode(e); if (t) { let e = i.indexOf("\x00"); return -1 !== e ? i.substring(0, e) : i } return i.replace(/\0/g, "") } let n = e.length, l = "", o = 0; for (; o < n && (0 !== (i = e[o++]) || !t);)if (0 !== i && 3 !== i) switch (i >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: l += String.fromCharCode(i); break; case 12: case 13: l += String.fromCharCode((31 & i) << 6 | 63 & e[o++]); break; case 14: l += String.fromCharCode((15 & i) << 12 | (63 & e[o++]) << 6 | (63 & e[o++]) << 0) }return l }, G = { hexDump: function (e) { let t = ""; for (let i = 0; i < e.length; i++) { let r = e[i].toString(16); r.length < 2 && (r = "0" + r), t += r } return t } }, K = [].push, H = { video: 1, audio: 2, id3: 3, text: 4 }; function bin2str(e) { return String.fromCharCode.apply(null, e) } function readUint16(e, t) { let i = e[t] << 8 | e[t + 1]; return i < 0 ? 65536 + i : i } function readUint32(e, t) { let i = readSint32(e, t); return i < 0 ? 4294967296 + i : i } function readUint64(e, t) { let i = readUint32(e, t); return i *= 4294967296, i += readUint32(e, t + 4) } function readSint32(e, t) { return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3] } function writeUint32(e, t, i) { e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i } function findBox(e, t) { let i = []; if (!t.length) return i; let r = e.byteLength; for (let s = 0; s < r;) { let a = readUint32(e, s), n = bin2str(e.subarray(s + 4, s + 8)), l = a > 1 ? s + a : r; if (n === t[0]) { if (1 === t.length) i.push(e.subarray(s + 8, l)); else { let r = findBox(e.subarray(s + 8, l), t.slice(1)); r.length && K.apply(i, r) } } s = l } return i } function parseInitSegment(e) { let t = [], i = findBox(e, ["moov", "trak"]); for (let e = 0; e < i.length; e++) { let r = i[e], s = findBox(r, ["tkhd"])[0]; if (s) { let e = s[0], i = readUint32(s, 0 === e ? 12 : 20), a = findBox(r, ["mdia", "mdhd"])[0]; if (a) { e = a[0]; let s = readUint32(a, 0 === e ? 12 : 20), n = findBox(r, ["mdia", "hdlr"])[0]; if (n) { let e = bin2str(n.subarray(8, 12)), a = { soun: F.AUDIO, vide: F.VIDEO }[e]; if (a) { let e = findBox(r, ["mdia", "minf", "stbl", "stsd"])[0], n = function (e) { let t = e.subarray(8), i = t.subarray(86), r = bin2str(t.subarray(4, 8)), s = r, a = "enca" === r || "encv" === r; if (a) { let e = findBox(t, [r])[0], i = e.subarray("enca" === r ? 28 : 78), a = findBox(i, ["sinf"]); a.forEach(e => { let t = findBox(e, ["schm"])[0]; if (t) { let i = bin2str(t.subarray(4, 8)); if ("cbcs" === i || "cenc" === i) { let t = findBox(e, ["frma"])[0]; t && (s = bin2str(t)) } } }) } switch (s) { case "avc1": case "avc2": case "avc3": case "avc4": { let e = findBox(i, ["avcC"])[0]; s += "." + toHex(e[1]) + toHex(e[2]) + toHex(e[3]); break } case "mp4a": { let e = findBox(t, [r])[0], i = findBox(e.subarray(28), ["esds"])[0]; if (i && i.length > 12) { let e = 4; if (3 !== i[e++]) break; e = skipBERInteger(i, e) + 2; let t = i[e++]; if (128 & t && (e += 2), 64 & t && (e += i[e++]), 4 !== i[e++]) break; e = skipBERInteger(i, e); let r = i[e++]; if (64 === r) s += "." + toHex(r); else break; if (e += 12, 5 !== i[e++]) break; e = skipBERInteger(i, e); let a = i[e++], n = (248 & a) >> 3; 31 === n && (n += 1 + ((7 & a) << 3) + ((224 & i[e]) >> 5)), s += "." + n } break } case "hvc1": case "hev1": { let e = findBox(i, ["hvcC"])[0], t = e[1], r = ["", "A", "B", "C"][t >> 6], a = readUint32(e, 2), n = e[12], l = e.subarray(6, 12); s += "." + r + (31 & t) + "." + a.toString(16).toUpperCase() + "." + ((32 & t) >> 5 ? "H" : "L") + n; let o = ""; for (let e = l.length; e--;) { let t = l[e]; if (t || o) { let e = t.toString(16).toUpperCase(); o = "." + e + o } } s += o; break } case "dvh1": case "dvhe": { let e = findBox(i, ["dvcC"])[0], t = e[2] >> 1 & 127, r = e[2] << 5 & 32 | e[3] >> 3 & 31; s += "." + addLeadingZero(t) + "." + addLeadingZero(r); break } case "vp09": { let e = findBox(i, ["vpcC"])[0], t = e[4], r = e[5], a = e[6] >> 4 & 15; s += "." + addLeadingZero(t) + "." + addLeadingZero(r) + "." + addLeadingZero(a); break } case "av01": { let e = findBox(i, ["av1C"])[0], t = e[1] >>> 5, r = 31 & e[1], a = e[2] >>> 7 ? "H" : "M", n = (64 & e[2]) >> 6, l = (32 & e[2]) >> 5, o = 2 === t && n ? l ? 12 : 10 : n ? 10 : 8, h = (16 & e[2]) >> 4, d = (8 & e[2]) >> 3, u = (4 & e[2]) >> 2, c = 3 & e[2]; s += "." + t + "." + addLeadingZero(r) + a + "." + addLeadingZero(o) + "." + h + "." + d + u + c + "." + addLeadingZero(1) + "." + addLeadingZero(1) + "." + addLeadingZero(1) + ".0" } }return { codec: s, encrypted: a } }(e); t[i] = { timescale: s, type: a }, t[a] = _objectSpread2({ timescale: s, id: i }, n) } } } } } let r = findBox(e, ["moov", "mvex", "trex"]); return r.forEach(e => { let i = readUint32(e, 4), r = t[i]; r && (r.default = { duration: readUint32(e, 12), flags: readUint32(e, 20) }) }), t } function skipBERInteger(e, t) { let i = t + 5; for (; 128 & e[t++] && t < i;); return t } function toHex(e) { return ("0" + e.toString(16).toUpperCase()).slice(-2) } function addLeadingZero(e) { return (e < 10 ? "0" : "") + e } function parseSinf(e) { let t = findBox(e, ["schm"])[0]; if (t) { let i = bin2str(t.subarray(4, 8)); if ("cbcs" === i || "cenc" === i) return findBox(e, ["schi", "tenc"])[0] } return M.error("[eme] missing 'schm' box"), null } function appendUint8Array(e, t) { let i = new Uint8Array(e.length + t.length); return i.set(e), i.set(t, e.length), i } function parseSamples(e, t) { let i = [], r = t.samples, s = t.timescale, a = t.id, n = !1, l = findBox(r, ["moof"]); return l.map(l => { let o = l.byteOffset - 8, h = findBox(l, ["traf"]); h.map(l => { let h = findBox(l, ["tfdt"]).map(e => { let t = e[0], i = readUint32(e, 4); return 1 === t && (i *= 4294967296, i += readUint32(e, 8)), i / s })[0]; return void 0 !== h && (e = h), findBox(l, ["tfhd"]).map(h => { let d = readUint32(h, 4), u = 16777215 & readUint32(h, 0), c = 0, f = 0, g = 8; d === a && ((1 & u) != 0 && (g += 8), (2 & u) != 0 && (g += 4), (8 & u) != 0 && (c = readUint32(h, g), g += 4), (16 & u) != 0 && (f = readUint32(h, g), g += 4), (32 & u) != 0 && (g += 4), "video" === t.type && (n = function (e) { if (!e) return !1; let t = e.indexOf("."), i = t < 0 ? e : e.substring(0, t); return "hvc1" === i || "hev1" === i || "dvh1" === i || "dvhe" === i }(t.codec)), findBox(l, ["trun"]).map(a => { let l = a[0], h = 16777215 & readUint32(a, 0), d = 0, u = (256 & h) != 0, g = 0, m = (512 & h) != 0, p = 0, E = (1024 & h) != 0, T = (2048 & h) != 0, y = 0, v = readUint32(a, 4), S = 8; (1 & h) != 0 && (d = readUint32(a, S), S += 4), (4 & h) != 0 && (S += 4); let A = d + o; for (let o = 0; o < v; o++) { if (u ? (g = readUint32(a, S), S += 4) : g = c, m ? (p = readUint32(a, S), S += 4) : p = f, E && (S += 4), T && (y = 0 === l ? readUint32(a, S) : readSint32(a, S), S += 4), t.type === F.VIDEO) { let t = 0; for (; t < p;) { let a = readUint32(r, A); if (A += 4, function (e, t) { if (!e) return 6 == (31 & t); { let e = t >> 1 & 63; return 39 === e || 40 === e } }(n, r[A])) { let t = r.subarray(A, A + a); parseSEIMessageFromNALu(t, n ? 2 : 1, e + y / s, i) } A += a, t += a + 4 } } e += g / s } })) }) }) }), i } function parseSEIMessageFromNALu(e, t, i, r) { let s; let a = discardEPB(e); s = 0 + t; let n = 0, l = 0, o = 0; for (; s < a.length;) { n = 0; do { if (s >= a.length) break; n += o = a[s++] } while (255 === o); l = 0; do { if (s >= a.length) break; l += o = a[s++] } while (255 === o); let e = a.length - s, t = s; if (l < e) s += l; else if (l > e) { M.error(`Malformed SEI payload. ${l} is too small, only ${e} bytes left to parse.`); break } if (4 === n) { let e = a[t++]; if (181 === e) { let e = readUint16(a, t); if (t += 2, 49 === e) { let e = readUint32(a, t); if (t += 4, 1195456820 === e) { let e = a[t++]; if (3 === e) { let s = a[t++], l = 31 & s, o = 64 & s, h = o ? 2 + 3 * l : 0, d = new Uint8Array(h); if (o) { d[0] = s; for (let e = 1; e < h; e++)d[e] = a[t++] } r.push({ type: e, payloadType: n, pts: i, bytes: d }) } } } } } else if (5 === n && l > 16) { let e = []; for (let i = 0; i < 16; i++) { let r = a[t++].toString(16); e.push(1 == r.length ? "0" + r : r), (3 === i || 5 === i || 7 === i || 9 === i) && e.push("-") } let s = l - 16, o = new Uint8Array(s); for (let e = 0; e < s; e++)o[e] = a[t++]; r.push({ payloadType: n, pts: i, uuid: e.join(""), userData: utf8ArrayToStr(o), userDataBytes: o }) } } } function discardEPB(e) { let t = e.byteLength, i = [], r = 1; for (; r < t - 2;)0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++; if (0 === i.length) return e; let s = t - i.length, a = new Uint8Array(s), n = 0; for (r = 0; r < s; n++, r++)n === i[0] && (n++, i.shift()), a[r] = e[n]; return a } let V = {}; let LevelKey = class LevelKey { static clearKeyUriToKeyIdMap() { V = {} } constructor(e, t, i, r = [1], s = null) { this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = r, this.iv = s, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e } isSupported() { if (this.method) { if ("AES-128" === this.method || "NONE" === this.method) return !0; if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method; switch (this.keyFormat) { case U.FAIRPLAY: case U.WIDEVINE: case U.PLAYREADY: case U.CLEARKEY: return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) } } return !1 } getDecryptData(e) { if (!this.encrypted || !this.uri) return null; if ("AES-128" === this.method && this.uri && !this.iv) { "number" != typeof e && ("AES-128" !== this.method || this.iv || M.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0); let t = function (e) { let t = new Uint8Array(16); for (let i = 12; i < 16; i++)t[i] = e >> 8 * (15 - i) & 255; return t }(e), i = new LevelKey(this.method, this.uri, "identity", this.keyFormatVersions, t); return i } let t = function (e) { let t = e.split(":"), i = null; if ("data" === t[0] && 2 === t.length) { let e = t[1].split(";"), r = e[e.length - 1].split(","); if (2 === r.length) { let t = "base64" === r[0], s = r[1]; t ? (e.splice(-1, 1), i = base64Decode(s)) : i = function (e) { let t = strToUtf8array(e).subarray(0, 16), i = new Uint8Array(16); return i.set(t, 16 - t.length), i }(s) } } return i }(this.uri); if (t) switch (this.keyFormat) { case U.WIDEVINE: this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6)); break; case U.PLAYREADY: { let e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]); this.pssh = function (e, t, i) { let r, s, a; if (16 !== e.byteLength) throw RangeError("Invalid system id"); if (t) { r = 1, s = new Uint8Array(16 * t.length); for (let e = 0; e < t.length; e++) { let i = t[e]; if (16 !== i.byteLength) throw RangeError("Invalid key"); s.set(i, 16 * e) } } else r = 0, s = new Uint8Array; r > 0 ? (a = new Uint8Array(4), t.length > 0 && new DataView(a.buffer).setUint32(0, t.length, !1)) : a = new Uint8Array; let n = new Uint8Array(4); return i && i.byteLength > 0 && new DataView(n.buffer).setUint32(0, i.byteLength, !1), function (e, ...t) { let i = t.length, r = 8, s = i; for (; s--;)r += t[s].byteLength; let a = new Uint8Array(r); for (a[0] = r >> 24 & 255, a[1] = r >> 16 & 255, a[2] = r >> 8 & 255, a[3] = 255 & r, a.set(e, 4), s = 0, r = 8; s < i; s++)a.set(t[s], r), r += t[s].byteLength; return a }([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), e, a, s, n, i || new Uint8Array) }(e, null, t); let i = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2), r = String.fromCharCode.apply(null, Array.from(i)), s = r.substring(r.indexOf("<"), r.length), a = new DOMParser, n = a.parseFromString(s, "text/xml"), l = n.getElementsByTagName("KID")[0]; if (l) { let e = l.childNodes[0] ? l.childNodes[0].nodeValue : l.getAttribute("VALUE"); if (e) { let t = base64Decode(e).subarray(0, 16); !function (e) { let swap = function (e, t, i) { let r = e[t]; e[t] = e[i], e[i] = r }; swap(e, 0, 3), swap(e, 1, 2), swap(e, 4, 5), swap(e, 6, 7) }(t), this.keyId = t } } break } default: { let e = t.subarray(0, 16); if (16 !== e.length) { let t = new Uint8Array(16); t.set(e, 16 - e.length), e = t } this.keyId = e } }if (!this.keyId || 16 !== this.keyId.byteLength) { let e = V[this.uri]; if (!e) { let t = Object.keys(V).length % Number.MAX_SAFE_INTEGER; e = new Uint8Array(16); let i = new DataView(e.buffer, 12, 4); i.setUint32(0, t), V[this.uri] = e } this.keyId = e } return this } }; let W = /\{\$([a-zA-Z0-9-_]+)\}/g; function substituteVariablesInAttributes(e, t, i) { if (null !== e.variableList || e.hasVariableRefs) for (let r = i.length; r--;) { let s = i[r], a = t[s]; a && (t[s] = substituteVariables(e, a)) } } function substituteVariables(e, t) { if (null !== e.variableList || e.hasVariableRefs) { let i = e.variableList; return t.replace(W, t => { let r = t.substring(2, t.length - 1), s = null == i ? void 0 : i[r]; return void 0 === s ? (e.playlistParsingError || (e.playlistParsingError = Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)), t) : s }) } return t } function addVariableDefinition(e, t, i) { let r, s, a = e.variableList; if (a || (e.variableList = a = {}), "QUERYPARAM" in t) { r = t.QUERYPARAM; try { let e = new self.URL(i).searchParams; if (e.has(r)) s = e.get(r); else throw Error(`"${r}" does not match any query parameter in URI: "${i}"`) } catch (t) { e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE QUERYPARAM: ${t.message}`)) } } else r = t.NAME, s = t.VALUE; r in a ? e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : a[r] = s || "" } function getMediaSource(e = !0) { if ("undefined" == typeof self) return; let t = (e || !self.MediaSource) && self.ManagedMediaSource; return t || self.MediaSource || self.WebKitMediaSource } let Y = { audio: { a3ds: 1, "ac-3": .95, "ac-4": 1, alac: .9, alaw: 1, dra1: 1, "dts+": 1, "dts-": 1, dtsc: 1, dtse: 1, dtsh: 1, "ec-3": .9, enca: 1, fLaC: .9, flac: .9, FLAC: .9, g719: 1, g726: 1, m4ae: 1, mha1: 1, mha2: 1, mhm1: 1, mhm2: 1, mlpa: 1, mp4a: 1, "raw ": 1, Opus: 1, opus: 1, samr: 1, sawb: 1, sawp: 1, sevc: 1, sqcp: 1, ssmv: 1, twos: 1, ulaw: 1 }, video: { avc1: 1, avc2: 1, avc3: 1, avc4: 1, avcp: 1, av01: .8, drac: 1, dva1: 1, dvav: 1, dvh1: .7, dvhe: .7, encv: 1, hev1: .75, hvc1: .75, mjp2: 1, mp4v: 1, mvc1: 1, mvc2: 1, mvc3: 1, mvc4: 1, resv: 1, rv60: 1, s263: 1, svc1: 1, svc2: 1, "vc-1": 1, vp08: 1, vp09: .9 }, text: { stpp: 1, wvtt: 1 } }; function areCodecsMediaSourceSupported(e, t, i = !0) { return !e.split(",").some(e => !isCodecMediaSourceSupported(e, t, i)) } function isCodecMediaSourceSupported(e, t, i = !0) { var r; let s = getMediaSource(i); return null != (r = null == s ? void 0 : s.isTypeSupported(mimeTypeForCodec(e, t))) && r } function mimeTypeForCodec(e, t) { return `${t}/mp4;codecs="${e}"` } function videoCodecPreferenceValue(e) { if (e) { let t = e.substring(0, 4); return Y.video[t] } return 2 } function codecsSetSelectionPreferenceValue(e) { return e.split(",").reduce((e, t) => { let i = Y.video[t]; return i ? (2 * i + e) / (e ? 3 : 2) : (Y.audio[t] + e) / (e ? 2 : 1) }, 0) } let j = {}, q = /flac|opus/i; function getCodecCompatibleName(e, t = !0) { return e.replace(q, e => (function (e, t = !0) { if (j[e]) return j[e]; let i = { flac: ["flac", "fLaC", "FLAC"], opus: ["opus", "Opus"] }[e]; for (let r = 0; r < i.length; r++)if (isCodecMediaSourceSupported(i[r], "audio", t)) return j[e] = i[r], i[r]; return e })(e.toLowerCase(), t)) } function pickMostCompleteCodecName(e, t) { return e && "mp4a" !== e ? e : t } let z = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, X = /#EXT-X-MEDIA:(.*)/g, Q = /^#EXT(?:INF|-X-TARGETDURATION):/m, Z = RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"), J = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")); let M3U8Parser = class M3U8Parser { static findGroup(e, t) { for (let i = 0; i < e.length; i++) { let r = e[i]; if (r.id === t) return r } } static resolve(e, t) { return L.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) } static isMediaPlaylist(e) { return Q.test(e) } static parseMasterPlaylist(e, t) { var i; let r; let s = W.test(e), a = { contentSteering: null, levels: [], playlistParsingError: null, sessionData: null, sessionKeys: null, startTimeOffset: null, variableList: null, hasVariableRefs: s }, n = []; for (z.lastIndex = 0; null != (r = z.exec(e));)if (r[1]) { let e = new AttrList(r[1]); substituteVariablesInAttributes(a, e, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]); let s = substituteVariables(a, r[2]), l = { attrs: e, bitrate: e.decimalInteger("BANDWIDTH") || e.decimalInteger("AVERAGE-BANDWIDTH"), name: e.NAME, url: M3U8Parser.resolve(s, t) }, o = e.decimalResolution("RESOLUTION"); o && (l.width = o.width, l.height = o.height), function (e, t) { let i = (e || "").split(/[ ,]+/).filter(e => e);["video", "audio", "text"].forEach(e => { let r = i.filter(t => (function (e, t) { let i = Y[t]; return !!i && !!i[e.slice(0, 4)] })(t, e)); r.length && (t[`${e}Codec`] = r.join(","), i = i.filter(e => -1 === r.indexOf(e))) }), t.unknownCodecs = i }(e.CODECS, l), null != (i = l.unknownCodecs) && i.length || n.push(l), a.levels.push(l) } else if (r[3]) { let e = r[3], i = r[4]; switch (e) { case "SESSION-DATA": { let e = new AttrList(i); substituteVariablesInAttributes(a, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]); let t = e["DATA-ID"]; t && (null === a.sessionData && (a.sessionData = {}), a.sessionData[t] = e); break } case "SESSION-KEY": { let e = parseKey(i, t, a); e.encrypted && e.isSupported() ? (null === a.sessionKeys && (a.sessionKeys = []), a.sessionKeys.push(e)) : M.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${i}"`); break } case "DEFINE": { let e = new AttrList(i); substituteVariablesInAttributes(a, e, ["NAME", "VALUE", "QUERYPARAM"]), addVariableDefinition(a, e, t) } break; case "CONTENT-STEERING": { let e = new AttrList(i); substituteVariablesInAttributes(a, e, ["SERVER-URI", "PATHWAY-ID"]), a.contentSteering = { uri: M3U8Parser.resolve(e["SERVER-URI"], t), pathwayId: e["PATHWAY-ID"] || "." }; break } case "START": a.startTimeOffset = parseStartTimeOffset(i) } } let l = n.length > 0 && n.length < a.levels.length; return a.levels = l ? n : a.levels, 0 === a.levels.length && (a.playlistParsingError = Error("no levels found in manifest")), a } static parseMasterPlaylistMedia(e, t, i) { let r; let s = {}, a = i.levels, n = { AUDIO: a.map(e => ({ id: e.attrs.AUDIO, audioCodec: e.audioCodec })), SUBTITLES: a.map(e => ({ id: e.attrs.SUBTITLES, textCodec: e.textCodec })), "CLOSED-CAPTIONS": [] }, l = 0; for (X.lastIndex = 0; null !== (r = X.exec(e));) { let e = new AttrList(r[1]), a = e.TYPE; if (a) { let r = n[a], o = s[a] || []; s[a] = o, substituteVariablesInAttributes(i, e, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]); let h = e.LANGUAGE, d = e["ASSOC-LANGUAGE"], u = e.CHANNELS, c = e.CHARACTERISTICS, f = e["INSTREAM-ID"], g = { attrs: e, bitrate: 0, id: l++, groupId: e["GROUP-ID"] || "", name: e.NAME || h || "", type: a, default: e.bool("DEFAULT"), autoselect: e.bool("AUTOSELECT"), forced: e.bool("FORCED"), lang: h, url: e.URI ? M3U8Parser.resolve(e.URI, t) : "" }; if (d && (g.assocLang = d), u && (g.channels = u), c && (g.characteristics = c), f && (g.instreamId = f), null != r && r.length) { let e = M3U8Parser.findGroup(r, g.groupId) || r[0]; assignCodec(g, e, "audioCodec"), assignCodec(g, e, "textCodec") } o.push(g) } } return s } static parseLevelPlaylist(e, t, i, r, s, a) { let n, l, o; let h = new LevelDetails(t), d = h.fragments, u = null, c = 0, f = 0, g = 0, m = 0, p = null, E = new Fragment(r, t), T = -1, y = !1, v = null; for (Z.lastIndex = 0, h.m3u8 = e, h.hasVariableRefs = W.test(e); null !== (n = Z.exec(e));) { y && (y = !1, (E = new Fragment(r, t)).start = g, E.sn = c, E.cc = m, E.level = i, u && (E.initSegment = u, E.rawProgramDateTime = u.rawProgramDateTime, u.rawProgramDateTime = null, v && (E.setByteRange(v), v = null))); let e = n[1]; if (e) { E.duration = parseFloat(e); let t = (" " + n[2]).slice(1); E.title = t || null, E.tagList.push(t ? ["INF", e, t] : ["INF", e]) } else if (n[3]) { if (R(E.duration)) { E.start = g, o && setFragLevelKeys(E, o, h), E.sn = c, E.level = i, E.cc = m, d.push(E); let e = (" " + n[3]).slice(1); E.relurl = substituteVariables(h, e), assignProgramDateTime(E, p), p = E, g += E.duration, c++, f = 0, y = !0 } } else if (n[4]) { let e = (" " + n[4]).slice(1); p ? E.setByteRange(e, p) : E.setByteRange(e) } else if (n[5]) E.rawProgramDateTime = (" " + n[5]).slice(1), E.tagList.push(["PROGRAM-DATE-TIME", E.rawProgramDateTime]), -1 === T && (T = d.length); else { if (!(n = n[0].match(J))) { M.warn("No matches on slow regex match for level playlist!"); continue } for (l = 1; l < n.length && void 0 === n[l]; l++); let e = (" " + n[l]).slice(1), s = (" " + n[l + 1]).slice(1), g = n[l + 2] ? (" " + n[l + 2]).slice(1) : ""; switch (e) { case "PLAYLIST-TYPE": h.type = s.toUpperCase(); break; case "MEDIA-SEQUENCE": c = h.startSN = parseInt(s); break; case "SKIP": { let e = new AttrList(s); substituteVariablesInAttributes(h, e, ["RECENTLY-REMOVED-DATERANGES"]); let t = e.decimalInteger("SKIPPED-SEGMENTS"); if (R(t)) { h.skippedSegments = t; for (let e = t; e--;)d.unshift(null); c += t } let i = e.enumeratedString("RECENTLY-REMOVED-DATERANGES"); i && (h.recentlyRemovedDateranges = i.split("	")); break } case "TARGETDURATION": h.targetduration = Math.max(parseInt(s), 1); break; case "VERSION": h.version = parseInt(s); break; case "INDEPENDENT-SEGMENTS": case "EXTM3U": break; case "ENDLIST": h.live = !1; break; case "#": (s || g) && E.tagList.push(g ? [s, g] : [s]); break; case "DISCONTINUITY": m++, E.tagList.push(["DIS"]); break; case "GAP": E.gap = !0, E.tagList.push([e]); break; case "BITRATE": E.tagList.push([e, s]); break; case "DATERANGE": { let e = new AttrList(s); substituteVariablesInAttributes(h, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), substituteVariablesInAttributes(h, e, e.clientAttrs); let t = new DateRange(e, h.dateRanges[e.ID]); t.isValid || h.skippedSegments ? h.dateRanges[t.id] = t : M.warn(`Ignoring invalid DATERANGE tag: "${s}"`), E.tagList.push(["EXT-X-DATERANGE", s]); break } case "DEFINE": { let e = new AttrList(s); substituteVariablesInAttributes(h, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in e ? function (e, t, i) { let r = t.IMPORT; if (i && r in i) { let t = e.variableList; t || (e.variableList = t = {}), t[r] = i[r] } else e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`)) }(h, e, a) : addVariableDefinition(h, e, t) } break; case "DISCONTINUITY-SEQUENCE": m = parseInt(s); break; case "KEY": { let e = parseKey(s, t, h); if (e.isSupported()) { if ("NONE" === e.method) { o = void 0; break } o || (o = {}), o[e.keyFormat] && (o = _extends({}, o)), o[e.keyFormat] = e } else M.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${s}"`); break } case "START": h.startTimeOffset = parseStartTimeOffset(s); break; case "MAP": { let e = new AttrList(s); if (substituteVariablesInAttributes(h, e, ["BYTERANGE", "URI"]), E.duration) { let s = new Fragment(r, t); setInitSegment(s, e, i, o), u = s, E.initSegment = u, u.rawProgramDateTime && !E.rawProgramDateTime && (E.rawProgramDateTime = u.rawProgramDateTime) } else { let t = E.byteRangeEndOffset; if (t) { let e = E.byteRangeStartOffset; v = `${t - e}@${e}` } else v = null; setInitSegment(E, e, i, o), u = E, y = !0 } break } case "SERVER-CONTROL": { let e = new AttrList(s); h.canBlockReload = e.bool("CAN-BLOCK-RELOAD"), h.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0), h.canSkipDateRanges = h.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"), h.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0), h.holdBack = e.optionalFloat("HOLD-BACK", 0); break } case "PART-INF": { let e = new AttrList(s); h.partTarget = e.decimalFloatingPoint("PART-TARGET"); break } case "PART": { let e = h.partList; e || (e = h.partList = []); let i = f > 0 ? e[e.length - 1] : void 0, r = f++, a = new AttrList(s); substituteVariablesInAttributes(h, a, ["BYTERANGE", "URI"]); let n = new Part(a, E, t, r, i); e.push(n), E.duration += n.duration; break } case "PRELOAD-HINT": { let e = new AttrList(s); substituteVariablesInAttributes(h, e, ["URI"]), h.preloadHint = e; break } case "RENDITION-REPORT": { let e = new AttrList(s); substituteVariablesInAttributes(h, e, ["URI"]), h.renditionReports = h.renditionReports || [], h.renditionReports.push(e); break } default: M.warn(`line parsed but not handled: ${n}`) } } } p && !p.relurl ? (d.pop(), g -= p.duration, h.partList && (h.fragmentHint = p)) : h.partList && (assignProgramDateTime(E, p), E.cc = m, h.fragmentHint = E, o && setFragLevelKeys(E, o, h)); let S = d.length, A = d[0], L = d[S - 1]; if ((g += h.skippedSegments * h.targetduration) > 0 && S && L) { h.averagetargetduration = g / S; let e = L.sn; h.endSN = "initSegment" !== e ? e : 0, h.live || (L.endList = !0), A && (h.startCC = A.cc) } else h.endSN = 0, h.startCC = 0; return h.fragmentHint && (g += h.fragmentHint.duration), h.totalduration = g, h.endCC = m, T > 0 && function (e, t) { let i = e[t]; for (let r = t; r--;) { let t = e[r]; if (!t) return; t.programDateTime = i.programDateTime - 1e3 * t.duration, i = t } }(d, T), h } }; function parseKey(e, t, i) { var r, s; let a = new AttrList(e); substituteVariablesInAttributes(i, a, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]); let n = null != (r = a.METHOD) ? r : "", l = a.URI, o = a.hexadecimalInteger("IV"), h = a.KEYFORMATVERSIONS, d = null != (s = a.KEYFORMAT) ? s : "identity"; l && a.IV && !o && M.error(`Invalid IV: ${a.IV}`); let u = l ? M3U8Parser.resolve(l, t) : "", c = (h || "1").split("/").map(Number).filter(Number.isFinite); return new LevelKey(n, u, d, c, o) } function parseStartTimeOffset(e) { let t = new AttrList(e), i = t.decimalFloatingPoint("TIME-OFFSET"); return R(i) ? i : null } function assignCodec(e, t, i) { let r = t[i]; r && (e[i] = r) } function assignProgramDateTime(e, t) { e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), R(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null) } function setInitSegment(e, t, i, r) { e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = i, e.sn = "initSegment", r && (e.levelkeys = r), e.initSegment = null } function setFragLevelKeys(e, t, i) { e.levelkeys = t; let { encryptedFragments: r } = i; (!r.length || r[r.length - 1].levelkeys !== t) && Object.keys(t).some(e => t[e].isCommonEncryption) && r.push(e) } var ee = { MANIFEST: "manifest", LEVEL: "level", AUDIO_TRACK: "audioTrack", SUBTITLE_TRACK: "subtitleTrack" }, et = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" }; function mapContextToLevelType(e) { let { type: t } = e; switch (t) { case ee.AUDIO_TRACK: return et.AUDIO; case ee.SUBTITLE_TRACK: return et.SUBTITLE; default: return et.MAIN } } function getResponseUrl(e, t) { let i = e.url; return (void 0 === i || 0 === i.indexOf("data:")) && (i = t.url), i } let PlaylistLoader = class PlaylistLoader { constructor(e) { this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners() } startLoad(e) { } stopLoad() { this.destroyInternalLoaders() } registerListeners() { let { hls: e } = this; e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.LEVEL_LOADING, this.onLevelLoading, this), e.on(b.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(b.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } unregisterListeners() { let { hls: e } = this; e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.LEVEL_LOADING, this.onLevelLoading, this), e.off(b.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(b.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } createInternalLoader(e) { let t = this.hls.config, i = t.pLoader, r = t.loader, s = new (i || r)(t); return this.loaders[e.type] = s, s } getInternalLoader(e) { return this.loaders[e.type] } resetInternalLoader(e) { this.loaders[e] && delete this.loaders[e] } destroyInternalLoaders() { for (let e in this.loaders) { let t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } } destroy() { this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders() } onManifestLoading(e, t) { let { url: i } = t; this.variableList = null, this.load({ id: null, level: 0, responseType: "text", type: ee.MANIFEST, url: i, deliveryDirectives: null }) } onLevelLoading(e, t) { let { id: i, level: r, pathwayId: s, url: a, deliveryDirectives: n } = t; this.load({ id: i, level: r, pathwayId: s, responseType: "text", type: ee.LEVEL, url: a, deliveryDirectives: n }) } onAudioTrackLoading(e, t) { let { id: i, groupId: r, url: s, deliveryDirectives: a } = t; this.load({ id: i, groupId: r, level: null, responseType: "text", type: ee.AUDIO_TRACK, url: s, deliveryDirectives: a }) } onSubtitleTrackLoading(e, t) { let { id: i, groupId: r, url: s, deliveryDirectives: a } = t; this.load({ id: i, groupId: r, level: null, responseType: "text", type: ee.SUBTITLE_TRACK, url: s, deliveryDirectives: a }) } load(e) { var t; let i; let r = this.hls.config, s = this.getInternalLoader(e); if (s) { let t = s.context; if (t && t.url === e.url && t.level === e.level) { M.trace("[playlist-loader]: playlist request ongoing"); return } M.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), s.abort() } if (i = e.type === ee.MANIFEST ? r.manifestLoadPolicy.default : _extends({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null }), s = this.createInternalLoader(e), R(null == (t = e.deliveryDirectives) ? void 0 : t.part)) { let t; if (e.type === ee.LEVEL && null !== e.level ? t = this.hls.levels[e.level].details : e.type === ee.AUDIO_TRACK && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === ee.SUBTITLE_TRACK && null !== e.id && (t = this.hls.subtitleTracks[e.id].details), t) { let e = t.partTarget, r = t.targetduration; if (e && r) { let t = 1e3 * Math.max(3 * e, .8 * r); i = _extends({}, i, { maxTimeToFirstByteMs: Math.min(t, i.maxTimeToFirstByteMs), maxLoadTimeMs: Math.min(t, i.maxTimeToFirstByteMs) }) } } } let a = i.errorRetry || i.timeoutRetry || {}, n = { loadPolicy: i, timeout: i.maxLoadTimeMs, maxRetry: a.maxNumRetry || 0, retryDelay: a.retryDelayMs || 0, maxRetryDelay: a.maxRetryDelayMs || 0 }; s.load(e, n, { onSuccess: (e, t, i, r) => { let s = this.getInternalLoader(i); this.resetInternalLoader(i.type); let a = e.data; if (0 !== a.indexOf("#EXTM3U")) { this.handleManifestParsingError(e, i, Error("no EXTM3U delimiter"), r || null, t); return } t.parsing.start = performance.now(), M3U8Parser.isMediaPlaylist(a) ? this.handleTrackOrLevelPlaylist(e, t, i, r || null, s) : this.handleMasterPlaylist(e, t, i, r) }, onError: (e, t, i, r) => { this.handleNetworkError(t, i, !1, e, r) }, onTimeout: (e, t, i) => { this.handleNetworkError(t, i, !0, void 0, e) } }) } handleMasterPlaylist(e, t, i, r) { let s = this.hls, a = e.data, n = getResponseUrl(e, i), l = M3U8Parser.parseMasterPlaylist(a, n); if (l.playlistParsingError) { this.handleManifestParsingError(e, i, l.playlistParsingError, r, t); return } let { contentSteering: o, levels: h, sessionData: d, sessionKeys: u, startTimeOffset: c, variableList: f } = l; this.variableList = f; let { AUDIO: g = [], SUBTITLES: m, "CLOSED-CAPTIONS": p } = M3U8Parser.parseMasterPlaylistMedia(a, n, l); if (g.length) { let e = g.some(e => !e.url); e || !h[0].audioCodec || h[0].attrs.AUDIO || (M.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({ type: "main", name: "main", groupId: "main", default: !1, autoselect: !1, forced: !1, id: -1, attrs: new AttrList({}), bitrate: 0, url: "" })) } s.trigger(b.MANIFEST_LOADED, { levels: h, audioTracks: g, subtitles: m, captions: p, contentSteering: o, url: n, stats: t, networkDetails: r, sessionData: d, sessionKeys: u, startTimeOffset: c, variableList: f }) } handleTrackOrLevelPlaylist(e, t, i, r, s) { let a = this.hls, { id: n, level: l, type: o } = i, h = getResponseUrl(e, i), d = R(l) ? l : R(n) ? n : 0, u = mapContextToLevelType(i), c = M3U8Parser.parseLevelPlaylist(e.data, h, d, u, 0, this.variableList); if (o === ee.MANIFEST) { let e = { attrs: new AttrList({}), bitrate: 0, details: c, name: "", url: h }; a.trigger(b.MANIFEST_LOADED, { levels: [e], audioTracks: [], url: h, stats: t, networkDetails: r, sessionData: null, sessionKeys: null, contentSteering: null, startTimeOffset: null, variableList: null }) } t.parsing.end = performance.now(), i.levelDetails = c, this.handlePlaylistLoaded(c, e, t, i, r, s) } handleManifestParsingError(e, t, i, r, s) { this.hls.trigger(b.ERROR, { type: C.NETWORK_ERROR, details: k.MANIFEST_PARSING_ERROR, fatal: t.type === ee.MANIFEST, url: e.url, err: i, error: i, reason: i.message, response: e, context: t, networkDetails: r, stats: s }) } handleNetworkError(e, t, i = !1, r, s) { let a = `A network ${i ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")} occurred while loading ${e.type}`; e.type === ee.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === ee.AUDIO_TRACK || e.type === ee.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`); let n = Error(a); M.warn(`[playlist-loader]: ${a}`); let l = k.UNKNOWN, o = !1, h = this.getInternalLoader(e); switch (e.type) { case ee.MANIFEST: l = i ? k.MANIFEST_LOAD_TIMEOUT : k.MANIFEST_LOAD_ERROR, o = !0; break; case ee.LEVEL: l = i ? k.LEVEL_LOAD_TIMEOUT : k.LEVEL_LOAD_ERROR, o = !1; break; case ee.AUDIO_TRACK: l = i ? k.AUDIO_TRACK_LOAD_TIMEOUT : k.AUDIO_TRACK_LOAD_ERROR, o = !1; break; case ee.SUBTITLE_TRACK: l = i ? k.SUBTITLE_TRACK_LOAD_TIMEOUT : k.SUBTITLE_LOAD_ERROR, o = !1 }h && this.resetInternalLoader(e.type); let d = { type: C.NETWORK_ERROR, details: l, fatal: o, url: e.url, loader: h, context: e, error: n, networkDetails: t, stats: s }; if (r) { let i = (null == t ? void 0 : t.url) || e.url; d.response = _objectSpread2({ url: i, data: void 0 }, r) } this.hls.trigger(b.ERROR, d) } handlePlaylistLoaded(e, t, i, r, s, a) { let n = this.hls, { type: l, level: o, id: h, groupId: d, deliveryDirectives: u } = r, c = getResponseUrl(t, r), f = mapContextToLevelType(r), g = "number" == typeof r.level && f === et.MAIN ? o : void 0; if (!e.fragments.length) { let e = Error("No Segments found in Playlist"); n.trigger(b.ERROR, { type: C.NETWORK_ERROR, details: k.LEVEL_EMPTY_ERROR, fatal: !1, url: c, error: e, reason: e.message, response: t, context: r, level: g, parent: f, networkDetails: s, stats: i }); return } e.targetduration || (e.playlistParsingError = Error("Missing Target Duration")); let m = e.playlistParsingError; if (m) { n.trigger(b.ERROR, { type: C.NETWORK_ERROR, details: k.LEVEL_PARSING_ERROR, fatal: !1, url: c, error: m, reason: m.message, response: t, context: r, level: g, parent: f, networkDetails: s, stats: i }); return } switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), l) { case ee.MANIFEST: case ee.LEVEL: n.trigger(b.LEVEL_LOADED, { details: e, level: g || 0, id: h || 0, stats: i, networkDetails: s, deliveryDirectives: u }); break; case ee.AUDIO_TRACK: n.trigger(b.AUDIO_TRACK_LOADED, { details: e, id: h || 0, groupId: d || "", stats: i, networkDetails: s, deliveryDirectives: u }); break; case ee.SUBTITLE_TRACK: n.trigger(b.SUBTITLE_TRACK_LOADED, { details: e, id: h || 0, groupId: d || "", stats: i, networkDetails: s, deliveryDirectives: u }) } } }; function sendAddTrackEvent(e, t) { let i; try { i = new Event("addtrack") } catch (e) { (i = document.createEvent("Event")).initEvent("addtrack", !1, !1) } i.track = e, t.dispatchEvent(i) } function addCueToTrack(e, t) { let i = e.mode; if ("disabled" === i && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try { if (e.addCue(t), !e.cues.getCueById(t.id)) throw Error(`addCue is failed for: ${t}`) } catch (i) { M.debug(`[texttrack-utils]: ${i}`); try { let i = new self.TextTrackCue(t.startTime, t.endTime, t.text); i.id = t.id, e.addCue(i) } catch (e) { M.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${e}`) } } "disabled" === i && (e.mode = i) } function clearCurrentCues(e) { let t = e.mode; if ("disabled" === t && (e.mode = "hidden"), e.cues) for (let t = e.cues.length; t--;)e.removeCue(e.cues[t]); "disabled" === t && (e.mode = t) } function removeCuesInRange(e, t, i, r) { let s = e.mode; if ("disabled" === s && (e.mode = "hidden"), e.cues && e.cues.length > 0) { let s = function (e, t, i) { let r = [], s = function (e, t) { if (t < e[0].startTime) return 0; let i = e.length - 1; if (t > e[i].endTime) return -1; let r = 0, s = i; for (; r <= s;) { let a = Math.floor((s + r) / 2); if (t < e[a].startTime) s = a - 1; else { if (!(t > e[a].startTime) || !(r < i)) return a; r = a + 1 } } return e[r].startTime - t < t - e[s].startTime ? r : s }(e, t); if (s > -1) for (let a = s, n = e.length; a < n; a++) { let s = e[a]; if (s.startTime >= t && s.endTime <= i) r.push(s); else if (s.startTime > i) break } return r }(e.cues, t, i); for (let t = 0; t < s.length; t++)(!r || r(s[t])) && e.removeCue(s[t]) } "disabled" === s && (e.mode = s) } function filterSubtitleTracks(e) { let t = []; for (let i = 0; i < e.length; i++) { let r = e[i]; ("subtitles" === r.kind || "captions" === r.kind) && r.label && t.push(e[i]) } return t } var ei = { audioId3: "org.id3", dateRange: "com.apple.quicktime.HLS", emsg: "https://aomedia.org/emsg/ID3" }; function getCueClass() { if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue } function createCueWithDataFields(e, t, i, r, s) { let a = new e(t, i, ""); try { a.value = r, s && (a.type = s) } catch (n) { a = new e(t, i, JSON.stringify(s ? _objectSpread2({ type: s }, r) : r)) } return a } let er = (() => { let e = getCueClass(); try { e && new e(0, Number.POSITIVE_INFINITY, "") } catch (e) { return Number.MAX_VALUE } return Number.POSITIVE_INFINITY })(); function dateRangeDateToTimelineSeconds(e, t) { return e.getTime() / 1e3 - t } let ID3TrackController = class ID3TrackController { constructor(e) { this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners() } destroy() { this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null } _registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(b.LEVEL_UPDATED, this.onLevelUpdated, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(b.LEVEL_UPDATED, this.onLevelUpdated, this) } onMediaAttached(e, t) { this.media = t.media } onMediaDetaching() { this.id3Track && (clearCurrentCues(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}) } onManifestLoading() { this.dateRangeCuesAppended = {} } createTrack(e) { let t = this.getID3Track(e.textTracks); return t.mode = "hidden", t } getID3Track(e) { if (this.media) { for (let t = 0; t < e.length; t++) { let i = e[t]; if ("metadata" === i.kind && "id3" === i.label) return sendAddTrackEvent(i, this.media), i } return this.media.addTextTrack("metadata", "id3") } } onFragParsingMetadata(e, t) { if (!this.media) return; let { hls: { config: { enableEmsgMetadataCues: i, enableID3MetadataCues: r } } } = this; if (!i && !r) return; let { samples: s } = t; this.id3Track || (this.id3Track = this.createTrack(this.media)); let a = getCueClass(); if (a) for (let e = 0; e < s.length; e++) { let t = s[e].type; if (t === ei.emsg && !i || !r) continue; let n = getID3Frames(s[e].data); if (n) { let i = s[e].pts, r = i + s[e].duration; r > er && (r = er); let l = r - i; l <= 0 && (r = i + .25); for (let e = 0; e < n.length; e++) { let s = n[e]; if (!isTimeStampFrame(s)) { this.updateId3CueEnds(i, t); let e = createCueWithDataFields(a, i, r, s, t); e && this.id3Track.addCue(e) } } } } } updateId3CueEnds(e, t) { var i; let r = null == (i = this.id3Track) ? void 0 : i.cues; if (r) for (let i = r.length; i--;) { let s = r[i]; s.type === t && s.startTime < e && s.endTime === er && (s.endTime = e) } } onBufferFlushing(e, { startOffset: t, endOffset: i, type: r }) { let { id3Track: s, hls: a } = this; if (!a) return; let { config: { enableEmsgMetadataCues: n, enableID3MetadataCues: l } } = a; s && (n || l) && removeCuesInRange(s, t, i, "audio" === r ? e => e.type === ei.audioId3 && l : "video" === r ? e => e.type === ei.emsg && n : e => e.type === ei.audioId3 && l || e.type === ei.emsg && n) } onLevelUpdated(e, { details: t }) { if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return; let { dateRangeCuesAppended: i, id3Track: r } = this, { dateRanges: s } = t, a = Object.keys(s); if (r) { let e = Object.keys(i).filter(e => !a.includes(e)); for (let t = e.length; t--;) { let s = e[t]; Object.keys(i[s].cues).forEach(e => { r.removeCue(i[s].cues[e]) }), delete i[s] } } let n = t.fragments[t.fragments.length - 1]; if (0 === a.length || !R(null == n ? void 0 : n.programDateTime)) return; this.id3Track || (this.id3Track = this.createTrack(this.media)); let l = n.programDateTime / 1e3 - n.start, o = getCueClass(); for (let e = 0; e < a.length; e++) { let t = a[e], r = s[t], n = dateRangeDateToTimelineSeconds(r.startDate, l), d = i[t], u = (null == d ? void 0 : d.cues) || {}, c = (null == d ? void 0 : d.durationKnown) || !1, f = er, g = r.endDate; if (g) f = dateRangeDateToTimelineSeconds(g, l), c = !0; else if (r.endOnNext && !c) { let e = a.reduce((e, t) => { if (t !== r.id) { let i = s[t]; if (i.class === r.class && i.startDate > r.startDate && (!e || r.startDate < e.startDate)) return i } return e }, null); e && (f = dateRangeDateToTimelineSeconds(e.startDate, l), c = !0) } let m = Object.keys(r.attr); for (let e = 0; e < m.length; e++) { var h; let i = m[e]; if (!("ID" !== i && "CLASS" !== i && "START-DATE" !== i && "DURATION" !== i && "END-DATE" !== i && "END-ON-NEXT" !== i)) continue; let s = u[i]; if (s) c && !d.durationKnown && (s.endTime = f); else if (o) { let e = r.attr[i]; ("SCTE35-OUT" === i || "SCTE35-IN" === i) && (h = e, e = Uint8Array.from(h.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer); let s = createCueWithDataFields(o, n, f, { key: i, data: e }, ei.dateRange); s && (s.id = t, this.id3Track.addCue(s), u[i] = s) } } i[t] = { cues: u, dateRange: r, durationKnown: c } } } }; let LatencyController = class LatencyController { constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners() } get latency() { return this._latency || 0 } get maxLatency() { let { config: e, levelDetails: t } = this; return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0 } get targetLatency() { let { levelDetails: e } = this; if (null === e) return null; let { holdBack: t, partHoldBack: i, targetduration: r } = e, { liveSyncDuration: s, liveSyncDurationCount: a, lowLatencyMode: n } = this.config, l = this.hls.userConfig, o = n && i || t; return (l.liveSyncDuration || l.liveSyncDurationCount || 0 === o) && (o = void 0 !== s ? s : a * r), o + Math.min(1 * this.stallCount, r) } get liveSyncPosition() { let e = this.estimateLiveEdge(), t = this.targetLatency, i = this.levelDetails; if (null === e || null === t || null === i) return null; let r = i.edge, s = e - t - this.edgeStalled, a = r - i.totalduration, n = r - (this.config.lowLatencyMode && i.partTarget || i.targetduration); return Math.min(Math.max(a, s), n) } get drift() { let { levelDetails: e } = this; return null === e ? 1 : e.drift } get edgeStalled() { let { levelDetails: e } = this; if (null === e) return 0; let t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration); return Math.max(e.age - t, 0) } get forwardBufferLength() { let { media: e, levelDetails: t } = this; if (!e || !t) return 0; let i = e.buffered.length; return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime } destroy() { this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null } registerListeners() { this.hls.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(b.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(b.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(b.ERROR, this.onError, this) } unregisterListeners() { this.hls.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(b.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(b.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(b.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler) } onMediaDetaching() { this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null) } onManifestLoading() { this.levelDetails = null, this._latency = null, this.stallCount = 0 } onLevelUpdated(e, { details: t }) { this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler) } onError(e, t) { var i; t.details === k.BUFFER_STALLED_ERROR && (this.stallCount++, null != (i = this.levelDetails) && i.live && M.warn("[playback-rate-controller]: Stall detected, adjusting target latency")) } timeupdate() { let { media: e, levelDetails: t } = this; if (!e || !t) return; this.currentTime = e.currentTime; let i = this.computeLatency(); if (null === i) return; this._latency = i; let { lowLatencyMode: r, maxLiveSyncPlaybackRate: s } = this.config; if (!r || 1 === s || !t.live) return; let a = this.targetLatency; if (null === a) return; let n = i - a, l = Math.min(this.maxLatency, a + t.targetduration); if (n < l && n > .05 && this.forwardBufferLength > 1) { let t = Math.min(2, Math.max(1, s)), i = Math.round(2 / (1 + Math.exp(-.75 * n - this.edgeStalled)) * 20) / 20; e.playbackRate = Math.min(t, Math.max(1, i)) } else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1) } estimateLiveEdge() { let { levelDetails: e } = this; return null === e ? null : e.edge + e.age } computeLatency() { let e = this.estimateLiveEdge(); return null === e ? null : e - this.currentTime } }; let es = ["NONE", "TYPE-0", "TYPE-1", null], ea = ["SDR", "PQ", "HLG"]; var en = { No: "", Yes: "YES", v2: "v2" }; let HlsUrlParameters = class HlsUrlParameters { constructor(e, t, i) { this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i } addDirectives(e) { let t = new self.URL(e); return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href } }; let Level = class Level { constructor(e) { this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter(e => !!e).map(e => e.substring(0, 4)).join(","), this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES) } get maxBitrate() { return Math.max(this.realBitrate, this.bitrate) } get averageBitrate() { return this._avgBitrate || this.realBitrate || this.bitrate } get attrs() { return this._attrs[0] } get codecs() { return this.attrs.CODECS || "" } get pathwayId() { return this.attrs["PATHWAY-ID"] || "." } get videoRange() { return this.attrs["VIDEO-RANGE"] || "SDR" } get score() { return this.attrs.optionalFloat("SCORE", 0) } get uri() { return this.url[0] || "" } hasAudioGroup(e) { return hasGroup(this._audioGroups, e) } hasSubtitleGroup(e) { return hasGroup(this._subtitleGroups, e) } get audioGroups() { return this._audioGroups } get subtitleGroups() { return this._subtitleGroups } addGroupId(e, t) { if (t) { if ("audio" === e) { let e = this._audioGroups; e || (e = this._audioGroups = []), -1 === e.indexOf(t) && e.push(t) } else if ("text" === e) { let e = this._subtitleGroups; e || (e = this._subtitleGroups = []), -1 === e.indexOf(t) && e.push(t) } } } get urlId() { return 0 } set urlId(e) { } get audioGroupIds() { return this.audioGroups ? [this.audioGroupId] : void 0 } get textGroupIds() { return this.subtitleGroups ? [this.textGroupId] : void 0 } get audioGroupId() { var e; return null == (e = this.audioGroups) ? void 0 : e[0] } get textGroupId() { var e; return null == (e = this.subtitleGroups) ? void 0 : e[0] } addFallback() { } }; function hasGroup(e, t) { return !!t && !!e && -1 !== e.indexOf(t) } function updateFromToPTS(e, t) { let i = t.startPTS; if (R(i)) { let r, s = 0; t.sn > e.sn ? (s = i - e.start, r = e) : (s = e.start - i, r = t), r.duration !== s && (r.duration = s) } else if (t.sn > e.sn) { let i = e.cc === t.cc; i && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration } else t.start = Math.max(e.start - t.duration, 0) } function updateFragPTSDTS(e, t, i, r, s, a) { let n; let l = r - i; l <= 0 && (M.warn("Fragment should have a positive duration", t), r = i + t.duration, a = s + t.duration); let o = i, h = r, d = t.startPTS, u = t.endPTS; if (R(d)) { let e = Math.abs(d - i); R(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e, o = Math.max(i, d), i = Math.min(i, d), s = Math.min(s, t.startDTS), h = Math.min(r, u), r = Math.max(r, u), a = Math.max(a, t.endDTS) } let c = i - t.start; 0 !== t.start && (t.start = i), t.duration = r - t.start, t.startPTS = i, t.maxStartPTS = o, t.startDTS = s, t.endPTS = r, t.minEndPTS = h, t.endDTS = a; let f = t.sn; if (!e || f < e.startSN || f > e.endSN) return 0; let g = f - e.startSN, m = e.fragments; for (m[g] = t, n = g; n > 0; n--)updateFromToPTS(m[n], m[n - 1]); for (n = g; n < m.length - 1; n++)updateFromToPTS(m[n], m[n + 1]); return e.fragmentHint && updateFromToPTS(m[m.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, c } function adjustSliding(e, t) { let i = t.startSN + t.skippedSegments - e.startSN, r = e.fragments; i < 0 || i >= r.length || addSliding(t, r[i].start) } function addSliding(e, t) { if (t) { let i = e.fragments; for (let r = e.skippedSegments; r < i.length; r++)i[r].start += t; e.fragmentHint && (e.fragmentHint.start += t) } } function getPartWith(e, t, i) { var r; return null != e && e.details ? findPart(null == (r = e.details) ? void 0 : r.partList, t, i) : null } function findPart(e, t, i) { if (e) for (let r = e.length; r--;) { let s = e[r]; if (s.index === i && s.fragment.sn === t) return s } return null } function reassignFragmentLevelIndexes(e) { e.forEach((e, t) => { let { details: i } = e; null != i && i.fragments && i.fragments.forEach(e => { e.level = t }) }) } function isTimeoutError(e) { switch (e.details) { case k.FRAG_LOAD_TIMEOUT: case k.KEY_LOAD_TIMEOUT: case k.LEVEL_LOAD_TIMEOUT: case k.MANIFEST_LOAD_TIMEOUT: return !0 }return !1 } function getRetryConfig(e, t) { let i = isTimeoutError(t); return e.default[`${i ? "timeout" : "error"}Retry`] } function getRetryDelay(e, t) { let i = "linear" === e.backoff ? 1 : Math.pow(2, t); return Math.min(i * e.retryDelayMs, e.maxRetryDelayMs) } function getLoaderConfigWithoutReties(e) { return _objectSpread2(_objectSpread2({}, e), { errorRetry: null, timeoutRetry: null }) } function shouldRetry(e, t, i, r) { if (!e) return !1; let s = null == r ? void 0 : r.code, a = t < e.maxNumRetry && (0 === s && !1 === navigator.onLine || !!s && (s < 400 || s > 499) || !!i); return e.shouldRetry ? e.shouldRetry(e, t, i, r, a) : a } let el = { search: function (e, t) { let i = 0, r = e.length - 1, s = null, a = null; for (; i <= r;) { a = e[s = (i + r) / 2 | 0]; let n = t(a); if (n > 0) i = s + 1; else { if (!(n < 0)) return a; r = s - 1 } } return null } }; function findFragmentByPTS(e, t, i = 0, r = 0) { let s = null; if (e) { s = t[e.sn - t[0].sn + 1] || null; let r = e.endDTS - i; r > 0 && r < 15e-7 && (i += 15e-7) } else 0 === i && 0 === t[0].start && (s = t[0]); if (s && (!e || e.level === s.level) && 0 === fragmentWithinToleranceTest(i, r, s)) return s; let a = el.search(t, fragmentWithinToleranceTest.bind(null, i, r)); return a && (a !== e || !s) ? a : s } function fragmentWithinToleranceTest(e = 0, t = 0, i) { if (i.start <= e && i.start + i.duration > e) return 0; let r = Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0)); return i.start + i.duration - r <= e ? 1 : i.start - r > e && i.start ? -1 : 0 } var eo = { DoNothing: 0, SendAlternateToPenaltyBox: 2, RemoveAlternatePermanently: 3, RetryRequest: 5 }, eh = { None: 0, MoveAllAlternatesMatchingHost: 1, MoveAllAlternatesMatchingHDCP: 2 }; let BasePlaylistController = class BasePlaylistController { constructor(e, t) { this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = M.log.bind(M, `${t}:`), this.warn = M.warn.bind(M, `${t}:`), this.hls = e } destroy() { this.clearTimer(), this.hls = this.log = this.warn = null } clearTimer() { -1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1) } startLoad() { this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist() } stopLoad() { this.canLoad = !1, this.clearTimer() } switchParams(e, t) { let i = null == t ? void 0 : t.renditionReports; if (i) { let r = -1; for (let s = 0; s < i.length; s++) { let a; let n = i[s]; try { a = new self.URL(n.URI, t.url).href } catch (e) { M.warn(`Could not construct new URL for Rendition Report: ${e}`), a = n.URI || "" } if (a === e) { r = s; break } a === e.substring(0, a.length) && (r = s) } if (-1 !== r) { let e = i[r], s = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn), a = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex); if (this.hls.config.lowLatencyMode) { let e = Math.min(t.age - t.partTarget, t.targetduration); a >= 0 && e > t.partTarget && (a += 1) } return new HlsUrlParameters(s, a >= 0 ? a : void 0, en.No) } } } loadPlaylist(e) { -1 === this.requestScheduled && (this.requestScheduled = self.performance.now()) } shouldLoadPlaylist(e) { return this.canLoad && !!e && !!e.url && (!e.details || e.details.live) } shouldReloadPlaylist(e) { return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e) } playlistLoaded(e, t, i) { let { details: r, stats: s } = t, a = self.performance.now(), n = s.loading.first ? Math.max(0, a - s.loading.first) : 0; if (r.advancedDateTime = Date.now() - n, r.live || null != i && i.live) { let n, l, o; if (r.reloaded(i), i && this.log(`live playlist ${e} ${r.advanced ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex : r.updated ? "UPDATED" : "MISSED"}`), i && r.fragments.length > 0 && function (e, t) { let i, r = null, s = e.fragments; for (let e = s.length - 1; e >= 0; e--) { let t = s[e].initSegment; if (t) { r = t; break } } e.fragmentHint && delete e.fragmentHint.endPTS; let a = 0; if (function (e, t, i) { let r = t.skippedSegments, s = Math.max(e.startSN, t.startSN) - t.startSN, a = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, n = t.startSN - e.startSN, l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments; for (let e = s; e <= a; e++) { let s = o[n + e], a = l[e]; r && !a && e < r && (a = t.fragments[e] = s), s && a && i(s, a) } }(e, t, (e, s) => { e.relurl && (a = e.cc - s.cc), R(e.startPTS) && R(e.endPTS) && (s.start = s.startPTS = e.startPTS, s.startDTS = e.startDTS, s.maxStartPTS = e.maxStartPTS, s.endPTS = e.endPTS, s.endDTS = e.endDTS, s.minEndPTS = e.minEndPTS, s.duration = e.endPTS - e.startPTS, s.duration && (i = s), t.PTSKnown = t.alignedSliding = !0), s.elementaryStreams = e.elementaryStreams, s.loader = e.loader, s.stats = e.stats, e.initSegment && (s.initSegment = e.initSegment, r = e.initSegment) }), r) { let e = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments; e.forEach(e => { var t; e && (!e.initSegment || e.initSegment.relurl === (null == (t = r) ? void 0 : t.relurl)) && (e.initSegment = r) }) } if (t.skippedSegments) { if (t.deltaUpdateFailed = t.fragments.some(e => !e), t.deltaUpdateFailed) { M.warn("[level-helper] Previous playlist missing segments skipped in delta playlist"); for (let e = t.skippedSegments; e--;)t.fragments.shift(); t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc } else t.canSkipDateRanges && (t.dateRanges = function (e, t, i) { let r = _extends({}, e); return i && i.forEach(e => { delete r[e] }), Object.keys(t).forEach(e => { let i = new DateRange(t[e].attr, r[e]); i.isValid ? r[e] = i : M.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`) }), r }(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges)) } let n = t.fragments; if (a) { M.warn("discontinuity sliding from playlist, take drift into account"); for (let e = 0; e < n.length; e++)n[e].cc += a } t.skippedSegments && (t.startCC = t.fragments[0].cc), function (e, t, i) { if (e && t) { let r = 0; for (let s = 0, a = e.length; s <= a; s++) { let a = e[s], n = t[s + r]; a && n && a.index === n.index && a.fragment.sn === n.fragment.sn ? i(a, n) : r-- } } }(e.partList, t.partList, (e, t) => { t.elementaryStreams = e.elementaryStreams, t.stats = e.stats }), i ? updateFragPTSDTS(t, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : adjustSliding(e, t), n.length && (t.totalduration = t.edge - n[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart; let l = t.advancedDateTime; if (t.advanced && l) { let e = t.edge; t.driftStart || (t.driftStartTime = l, t.driftStart = e), t.driftEndTime = l, t.driftEnd = e } else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime }(i, r), !this.canLoad || !r.live) return; if (r.canBlockReload && r.endSN && r.advanced) { let e = this.hls.config.lowLatencyMode, s = r.lastPartSn, a = r.endSN, h = r.lastPartIndex, d = s === a; -1 !== h ? (l = d ? a + 1 : s, o = d ? e ? 0 : h : h + 1) : l = a + 1; let u = r.age, c = u + r.ageHeader, f = Math.min(c - r.partTarget, 1.5 * r.targetduration); if (f > 0) { if (i && f > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${f} with playlist age: ${r.age}`), f = 0; else { let e = Math.floor(f / r.targetduration); if (l += e, void 0 !== o) { let e = Math.round(f % r.targetduration / r.partTarget); o += e } this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${u.toFixed(2)}s goal: ${f} skip sn ${e} to part ${o}`) } r.tuneInGoal = f } if (n = this.getDeliveryDirectives(r, t.deliveryDirectives, l, o), e || !d) { this.loadPlaylist(n); return } } else (r.canBlockReload || r.canSkipUntil) && (n = this.getDeliveryDirectives(r, t.deliveryDirectives, l, o)); let h = this.hls.mainForwardBufferInfo, d = h ? h.end - h.len : 0, u = (r.edge - d) * 1e3, c = function (e, t = 1 / 0) { let i = 1e3 * e.targetduration; if (e.updated) { let r = e.fragments; if (r.length && 4 * i > t) { let e = 1e3 * r[r.length - 1].duration; e < i && (i = e) } } else i /= 2; return Math.round(i) }(r, u); r.updated && a > this.requestScheduled + c && (this.requestScheduled = s.loading.start), void 0 !== l && r.canBlockReload ? this.requestScheduled = s.loading.first + c - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + c < a ? this.requestScheduled = a : this.requestScheduled - a <= 0 && (this.requestScheduled += c); let f = this.requestScheduled - a; f = Math.max(0, f), this.log(`reload live playlist ${e} in ${Math.round(f)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(n), f) } else this.clearTimer() } getDeliveryDirectives(e, t, i, r) { let s = function (e, t) { let { canSkipUntil: i, canSkipDateRanges: r, endSN: s } = e; return i && (void 0 !== t ? t - s : 0) < i ? r ? en.v2 : en.Yes : en.No }(e, i); return null != t && t.skip && e.deltaUpdateFailed && (i = t.msn, r = t.part, s = en.No), new HlsUrlParameters(i, r, s) } checkRetry(e) { let t = e.details, i = isTimeoutError(e), r = e.errorAction, { action: s, retryCount: a = 0, retryConfig: n } = r || {}, l = !!r && !!n && (s === eo.RetryRequest || !r.resolved && s === eo.SendAlternateToPenaltyBox); if (l) { var o; if (this.requestScheduled = -1, a >= n.maxNumRetry) return !1; if (i && null != (o = e.context) && o.deliveryDirectives) this.warn(`Retrying playlist loading ${a + 1}/${n.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else { let e = getRetryDelay(n, a); this.timer = self.setTimeout(() => this.loadPlaylist(), e), this.warn(`Retrying playlist loading ${a + 1}/${n.maxNumRetry} after "${t}" in ${e}ms`) } e.levelRetry = !0, r.resolved = !0 } return l } }; let EWMA = class EWMA { constructor(e, t = 0, i = 0) { this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i } sample(e, t) { let i = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e } getTotalWeight() { return this.totalWeight_ } getEstimate() { if (this.alpha_) { let e = 1 - Math.pow(this.alpha_, this.totalWeight_); if (e) return this.estimate_ / e } return this.estimate_ } }; let EwmaBandWidthEstimator = class EwmaBandWidthEstimator { constructor(e, t, i, r = 100) { this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new EWMA(e), this.fast_ = new EWMA(t), this.defaultTTFB_ = r, this.ttfb_ = new EWMA(e) } update(e, t) { let { slow_: i, fast_: r, ttfb_: s } = this; i.halfLife !== e && (this.slow_ = new EWMA(e, i.getEstimate(), i.getTotalWeight())), r.halfLife !== t && (this.fast_ = new EWMA(t, r.getEstimate(), r.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new EWMA(e, s.getEstimate(), s.getTotalWeight())) } sample(e, t) { e = Math.max(e, this.minDelayMs_); let i = e / 1e3, r = 8 * t / i; this.fast_.sample(i, r), this.slow_.sample(i, r) } sampleTTFB(e) { let t = Math.sqrt(2) * Math.exp(-Math.pow(e / 1e3, 2) / 2); this.ttfb_.sample(t, Math.max(e, 5)) } canEstimate() { return this.fast_.getTotalWeight() >= this.minWeight_ } getEstimate() { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ } getEstimateTTFB() { return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_ } destroy() { } }; let ed = { supported: !0, configurations: [], decodingInfoResults: [{ supported: !0, powerEfficient: !0, smooth: !0 }] }, eu = {}; function logStartCodecCandidateIgnored(e, t) { M.log(`[abr] start candidates with "${e}" ignored because ${t}`) } function findMatchingOption(e, t, i) { if ("attrs" in e) { let i = t.indexOf(e); if (-1 !== i) return i } for (let r = 0; r < t.length; r++) { let s = t[r]; if (matchesOption(e, s, i)) return r } return -1 } function matchesOption(e, t, i) { let { groupId: r, name: s, lang: a, assocLang: n, characteristics: l, default: o } = e, h = e.forced; return (void 0 === r || t.groupId === r) && (void 0 === s || t.name === s) && (void 0 === a || t.lang === a) && (void 0 === a || t.assocLang === n) && (void 0 === o || t.default === o) && (void 0 === h || t.forced === h) && (void 0 === l || function (e, t = "") { let i = e.split(","), r = t.split(","); return i.length === r.length && !i.some(e => -1 === r.indexOf(e)) }(l, t.characteristics)) && (void 0 === i || i(e, t)) } function audioMatchPredicate(e, t) { let { audioCodec: i, channels: r } = e; return (void 0 === i || (t.audioCodec || "").substring(0, 4) === i.substring(0, 4)) && (void 0 === r || r === (t.channels || "2")) } function searchDownAndUpList(e, t, i) { for (let r = t; r; r--)if (i(e[r])) return r; for (let r = t + 1; r < e.length; r++)if (i(e[r])) return r; return -1 } let TaskLoop = class TaskLoop { constructor() { this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this) } destroy() { this.onHandlerDestroying(), this.onHandlerDestroyed() } onHandlerDestroying() { this.clearNextTick(), this.clearInterval() } onHandlerDestroyed() { } hasInterval() { return !!this._tickInterval } hasNextTick() { return !!this._tickTimer } setInterval(e) { return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0) } clearInterval() { return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) } clearNextTick() { return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) } tick() { this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0) } tickImmediate() { this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0) } doTick() { } }; var ec = { NOT_LOADED: "NOT_LOADED", APPENDING: "APPENDING", PARTIAL: "PARTIAL", OK: "OK" }; let FragmentTracker = class FragmentTracker { constructor(e) { this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(b.BUFFER_APPENDED, this.onBufferAppended, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this), e.on(b.FRAG_LOADED, this.onFragLoaded, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.BUFFER_APPENDED, this.onBufferAppended, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this), e.off(b.FRAG_LOADED, this.onFragLoaded, this) } destroy() { this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null } getAppendedFrag(e, t) { let i = this.activePartLists[t]; if (i) for (let t = i.length; t--;) { let r = i[t]; if (!r) break; let s = r.end; if (r.start <= e && null !== s && e <= s) return r } return this.getBufferedFrag(e, t) } getBufferedFrag(e, t) { let { fragments: i } = this, r = Object.keys(i); for (let s = r.length; s--;) { let a = i[r[s]]; if ((null == a ? void 0 : a.body.type) === t && a.buffered) { let t = a.body; if (t.start <= e && e <= t.end) return t } } return null } detectEvictedFragments(e, t, i, r) { this.timeRanges && (this.timeRanges[e] = t); let s = (null == r ? void 0 : r.fragment.sn) || -1; Object.keys(this.fragments).forEach(r => { let a = this.fragments[r]; if (!a || s >= a.body.sn) return; if (!a.buffered && !a.loaded) { a.body.type === i && this.removeFragment(a.body); return } let n = a.range[e]; n && n.time.some(e => { let i = !this.isTimeBuffered(e.startPTS, e.endPTS, t); return i && this.removeFragment(a.body), i }) }) } detectPartialFragments(e) { let t = this.timeRanges, { frag: i, part: r } = e; if (!t || "initSegment" === i.sn) return; let s = getFragmentKey(i), a = this.fragments[s]; if (!a || a.buffered && i.gap) return; let n = !i.relurl; if (Object.keys(t).forEach(e => { let s = i.elementaryStreams[e]; if (!s) return; let l = t[e], o = n || !0 === s.partial; a.range[e] = this.getBufferedTimes(i, r, o, l) }), a.loaded = null, Object.keys(a.range).length) { a.buffered = !0; let e = a.body.endList = i.endList || a.body.endList; e && (this.endListFragments[a.body.type] = a), isPartial(a) || this.removeParts(i.sn - 1, i.type) } else this.removeFragment(a.body) } removeParts(e, t) { let i = this.activePartLists[t]; i && (this.activePartLists[t] = i.filter(t => t.fragment.sn >= e)) } fragBuffered(e, t) { let i = getFragmentKey(e), r = this.fragments[i]; !r && t && (r = this.fragments[i] = { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }, e.gap && (this.hasGaps = !0)), r && (r.loaded = null, r.buffered = !0) } getBufferedTimes(e, t, i, r) { let s = { time: [], partial: i }, a = e.start, n = e.end, l = e.minEndPTS || n, o = e.maxStartPTS || a; for (let e = 0; e < r.length; e++) { let t = r.start(e) - this.bufferPadding, i = r.end(e) + this.bufferPadding; if (o >= t && l <= i) { s.time.push({ startPTS: Math.max(a, r.start(e)), endPTS: Math.min(n, r.end(e)) }); break } if (a < i && n > t) { let t = Math.max(a, r.start(e)), i = Math.min(n, r.end(e)); i > t && (s.partial = !0, s.time.push({ startPTS: t, endPTS: i })) } else if (n <= t) break } return s } getPartialFragment(e) { let t, i, r, s = null, a = 0, { bufferPadding: n, fragments: l } = this; return Object.keys(l).forEach(o => { let h = l[o]; h && isPartial(h) && (i = h.body.start - n, r = h.body.end + n, e >= i && e <= r && a <= (t = Math.min(e - i, r - e)) && (s = h.body, a = t)) }), s } isEndListAppended(e) { let t = this.endListFragments[e]; return void 0 !== t && (t.buffered || isPartial(t)) } getState(e) { let t = getFragmentKey(e), i = this.fragments[t]; return i ? i.buffered ? isPartial(i) ? ec.PARTIAL : ec.OK : ec.APPENDING : ec.NOT_LOADED } isTimeBuffered(e, t, i) { let r, s; for (let a = 0; a < i.length; a++) { if (r = i.start(a) - this.bufferPadding, s = i.end(a) + this.bufferPadding, e >= r && t <= s) return !0; if (t <= r) break } return !1 } onFragLoaded(e, t) { let { frag: i, part: r } = t; if ("initSegment" === i.sn || i.bitrateTest) return; let s = getFragmentKey(i); this.fragments[s] = { body: i, appendedPTS: null, loaded: r ? null : t, buffered: !1, range: Object.create(null) } } onBufferAppended(e, t) { let { frag: i, part: r, timeRanges: s } = t; if ("initSegment" === i.sn) return; let a = i.type; if (r) { let e = this.activePartLists[a]; e || (this.activePartLists[a] = e = []), e.push(r) } this.timeRanges = s, Object.keys(s).forEach(e => { let t = s[e]; this.detectEvictedFragments(e, t, a, r) }) } onFragBuffered(e, t) { this.detectPartialFragments(t) } hasFragment(e) { let t = getFragmentKey(e); return !!this.fragments[t] } hasParts(e) { var t; return !!(null != (t = this.activePartLists[e]) && t.length) } removeFragmentsInRange(e, t, i, r, s) { (!r || this.hasGaps) && Object.keys(this.fragments).forEach(a => { let n = this.fragments[a]; if (!n) return; let l = n.body; l.type === i && (!r || l.gap) && l.start < t && l.end > e && (n.buffered || s) && this.removeFragment(l) }) } removeFragment(e) { let t = getFragmentKey(e); e.stats.loaded = 0, e.clearElementaryStreamInfo(); let i = this.activePartLists[e.type]; if (i) { let t = e.sn; this.activePartLists[e.type] = i.filter(e => e.fragment.sn !== t) } delete this.fragments[t], e.endList && delete this.endListFragments[e.type] } removeAllFragments() { this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1 } }; function isPartial(e) { var t, i, r; return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (i = e.range.audio) ? void 0 : i.partial) || (null == (r = e.range.audiovideo) ? void 0 : r.partial)) } function getFragmentKey(e) { return `${e.type}_${e.level}_${e.sn}` } let ef = { length: 0, start: () => 0, end: () => 0 }; let BufferHelper = class BufferHelper { static isBuffered(e, t) { try { if (e) { let i = BufferHelper.getBuffered(e); for (let e = 0; e < i.length; e++)if (t >= i.start(e) && t <= i.end(e)) return !0 } } catch (e) { } return !1 } static bufferInfo(e, t, i) { try { if (e) { let r; let s = BufferHelper.getBuffered(e), a = []; for (r = 0; r < s.length; r++)a.push({ start: s.start(r), end: s.end(r) }); return this.bufferedInfo(a, t, i) } } catch (e) { } return { len: 0, start: t, end: t, nextStart: void 0 } } static bufferedInfo(e, t, i) { let r; t = Math.max(0, t), e.sort(function (e, t) { let i = e.start - t.start; return i || t.end - e.end }); let s = []; if (i) for (let t = 0; t < e.length; t++) { let r = s.length; if (r) { let a = s[r - 1].end; e[t].start - a < i ? e[t].end > a && (s[r - 1].end = e[t].end) : s.push(e[t]) } else s.push(e[t]) } else s = e; let a = 0, n = t, l = t; for (let e = 0; e < s.length; e++) { let o = s[e].start, h = s[e].end; if (t + i >= o && t < h) n = o, a = (l = h) - t; else if (t + i < o) { r = o; break } } return { len: a, start: n || 0, end: l || 0, nextStart: r } } static getBuffered(e) { try { return e.buffered } catch (e) { return M.log("failed to get media.buffered", e), ef } } }; let ChunkMetadata = class ChunkMetadata { constructor(e, t, i, r = 0, s = -1, a = !1) { this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = getNewPerformanceTiming(), this.buffering = { audio: getNewPerformanceTiming(), video: getNewPerformanceTiming(), audiovideo: getNewPerformanceTiming() }, this.level = e, this.sn = t, this.id = i, this.size = r, this.part = s, this.partial = a } }; function getNewPerformanceTiming() { return { start: 0, executeStart: 0, executeEnd: 0, end: 0 } } function findFirstFragWithCC(e, t) { for (let r = 0, s = e.length; r < s; r++) { var i; if ((null == (i = e[r]) ? void 0 : i.cc) === t) return e[r] } return null } function adjustFragmentStart(e, t) { if (e) { let i = e.start + t; e.start = e.startPTS = i, e.endPTS = i + e.duration } } function adjustSlidingStart(e, t) { let i = t.fragments; for (let t = 0, r = i.length; t < r; t++)adjustFragmentStart(i[t], e); t.fragmentHint && adjustFragmentStart(t.fragmentHint, e), t.alignedSliding = !0 } function alignMediaPlaylistByPDT(e, t) { let i, r; if (!e.hasProgramDateTime || !t.hasProgramDateTime) return; let s = e.fragments, a = t.fragments; if (!s.length || !a.length) return; let n = Math.min(t.endCC, e.endCC); t.startCC < n && e.startCC < n && (i = findFirstFragWithCC(a, n), r = findFirstFragWithCC(s, n)), i && r || (r = findFirstFragWithCC(s, (i = a[Math.floor(a.length / 2)]).cc) || s[Math.floor(s.length / 2)]); let l = i.programDateTime, o = r.programDateTime; if (!l || !o) return; let h = (o - l) / 1e3 - (r.start - i.start); adjustSlidingStart(h, e) } let FragmentLoader = class FragmentLoader { constructor(e) { this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e } destroy() { this.loader && (this.loader.destroy(), this.loader = null) } abort() { this.loader && this.loader.abort() } load(e, t) { let i = e.url; if (!i) return Promise.reject(new LoadError({ type: C.NETWORK_ERROR, details: k.FRAG_LOAD_ERROR, fatal: !1, frag: e, error: Error(`Fragment does not have a ${i ? "part list" : "url"}`), networkDetails: null })); this.abort(); let r = this.config, s = r.fLoader, a = r.loader; return new Promise((n, l) => { if (this.loader && this.loader.destroy(), e.gap) { if (e.tagList.some(e => "GAP" === e[0])) { l(createGapLoadError(e)); return } e.gap = !1 } let o = this.loader = e.loader = s ? new s(r) : new a(r), h = createLoaderContext(e), d = getLoaderConfigWithoutReties(r.fragLoadPolicy.default), u = { loadPolicy: d, timeout: d.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: "initSegment" === e.sn ? 1 / 0 : 131072 }; e.stats = o.stats, o.load(h, u, { onSuccess: (t, i, r, s) => { this.resetLoader(e, o); let a = t.data; r.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(a.slice(0, 16)), a = a.slice(16)), n({ frag: e, part: null, payload: a, networkDetails: s }) }, onError: (t, r, s, a) => { this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.FRAG_LOAD_ERROR, fatal: !1, frag: e, response: _objectSpread2({ url: i, data: void 0 }, t), error: Error(`HTTP Error ${t.code} ${t.text}`), networkDetails: s, stats: a })) }, onAbort: (t, i, r) => { this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.INTERNAL_ABORTED, fatal: !1, frag: e, error: Error("Aborted"), networkDetails: r, stats: t })) }, onTimeout: (t, i, r) => { this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, error: Error(`Timeout after ${u.timeout}ms`), networkDetails: r, stats: t })) }, onProgress: (i, r, s, a) => { t && t({ frag: e, part: null, payload: s, networkDetails: a }) } }) }) } loadPart(e, t, i) { this.abort(); let r = this.config, s = r.fLoader, a = r.loader; return new Promise((n, l) => { if (this.loader && this.loader.destroy(), e.gap || t.gap) { l(createGapLoadError(e, t)); return } let o = this.loader = e.loader = s ? new s(r) : new a(r), h = createLoaderContext(e, t), d = getLoaderConfigWithoutReties(r.fragLoadPolicy.default), u = { loadPolicy: d, timeout: d.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: 131072 }; t.stats = o.stats, o.load(h, u, { onSuccess: (r, s, a, l) => { this.resetLoader(e, o), this.updateStatsFromPart(e, t); let h = { frag: e, part: t, payload: r.data, networkDetails: l }; i(h), n(h) }, onError: (i, r, s, a) => { this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.FRAG_LOAD_ERROR, fatal: !1, frag: e, part: t, response: _objectSpread2({ url: h.url, data: void 0 }, i), error: Error(`HTTP Error ${i.code} ${i.text}`), networkDetails: s, stats: a })) }, onAbort: (i, r, s) => { e.stats.aborted = t.stats.aborted, this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.INTERNAL_ABORTED, fatal: !1, frag: e, part: t, error: Error("Aborted"), networkDetails: s, stats: i })) }, onTimeout: (i, r, s) => { this.resetLoader(e, o), l(new LoadError({ type: C.NETWORK_ERROR, details: k.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, part: t, error: Error(`Timeout after ${u.timeout}ms`), networkDetails: s, stats: i })) } }) }) } updateStatsFromPart(e, t) { let i = e.stats, r = t.stats, s = r.total; if (i.loaded += r.loaded, s) { let r = Math.round(e.duration / t.duration), a = Math.min(Math.round(i.loaded / s), r), n = (r - a) * Math.round(i.loaded / a); i.total = i.loaded + n } else i.total = Math.max(i.loaded, i.total); let a = i.loading, n = r.loading; a.start ? a.first += n.first - n.start : (a.start = n.start, a.first = n.first), a.end = n.end } resetLoader(e, t) { e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy() } }; function createLoaderContext(e, t = null) { let i = t || e, r = { frag: e, part: t, responseType: "arraybuffer", url: i.url, headers: {}, rangeStart: 0, rangeEnd: 0 }, s = i.byteRangeStartOffset, a = i.byteRangeEndOffset; if (R(s) && R(a)) { var n; let t = s, i = a; if ("initSegment" === e.sn && (null == (n = e.decryptdata) ? void 0 : n.method) === "AES-128") { let e = a - s; e % 16 && (i = a + (16 - e % 16)), 0 !== s && (r.resetIV = !0, t = s - 16) } r.rangeStart = t, r.rangeEnd = i } return r } function createGapLoadError(e, t) { let i = Error(`GAP ${e.gap ? "tag" : "attribute"} found`), r = { type: C.MEDIA_ERROR, details: k.FRAG_GAP, fatal: !1, frag: e, error: i, networkDetails: null }; return t && (r.part = t), (t || e).stats.aborted = !0, new LoadError(r) } let LoadError = class LoadError extends Error { constructor(e) { super(e.error.message), this.data = void 0, this.data = e } }; let AESCrypto = class AESCrypto { constructor(e, t) { this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t } decrypt(e, t) { return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e) } }; let FastAESKey = class FastAESKey { constructor(e, t) { this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t } expandKey() { return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]) } }; let AESDecryptor = class AESDecryptor { constructor() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable() } uint8ArrayToUint32Array_(e) { let t = new DataView(e), i = new Uint32Array(4); for (let e = 0; e < 4; e++)i[e] = t.getUint32(4 * e); return i } initTable() { let e = this.sBox, t = this.invSBox, i = this.subMix, r = i[0], s = i[1], a = i[2], n = i[3], l = this.invSubMix, o = l[0], h = l[1], d = l[2], u = l[3], c = new Uint32Array(256), f = 0, g = 0, m = 0; for (m = 0; m < 256; m++)m < 128 ? c[m] = m << 1 : c[m] = m << 1 ^ 283; for (m = 0; m < 256; m++) { let i = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4; i = i >>> 8 ^ 255 & i ^ 99, e[f] = i, t[i] = f; let l = c[f], m = c[l], p = c[m], E = 257 * c[i] ^ 16843008 * i; r[f] = E << 24 | E >>> 8, s[f] = E << 16 | E >>> 16, a[f] = E << 8 | E >>> 24, n[f] = E, E = 16843009 * p ^ 65537 * m ^ 257 * l ^ 16843008 * f, o[i] = E << 24 | E >>> 8, h[i] = E << 16 | E >>> 16, d[i] = E << 8 | E >>> 24, u[i] = E, f ? (f = l ^ c[c[c[p ^ l]]], g ^= c[c[g]]) : f = g = 1 } } expandKey(e) { let t, i, r, s; let a = this.uint8ArrayToUint32Array_(e), n = !0, l = 0; for (; l < a.length && n;)n = a[l] === this.key[l], l++; if (n) return; this.key = a; let o = this.keySize = a.length; if (4 !== o && 6 !== o && 8 !== o) throw Error("Invalid aes key size=" + o); let h = this.ksRows = (o + 6 + 1) * 4, d = this.keySchedule = new Uint32Array(h), u = this.invKeySchedule = new Uint32Array(h), c = this.sBox, f = this.rcon, g = this.invSubMix, m = g[0], p = g[1], E = g[2], T = g[3]; for (t = 0; t < h; t++) { if (t < o) { r = d[t] = a[t]; continue } s = r, t % o == 0 ? s = (c[(s = s << 8 | s >>> 24) >>> 24] << 24 | c[s >>> 16 & 255] << 16 | c[s >>> 8 & 255] << 8 | c[255 & s]) ^ f[t / o | 0] << 24 : o > 6 && t % o == 4 && (s = c[s >>> 24] << 24 | c[s >>> 16 & 255] << 16 | c[s >>> 8 & 255] << 8 | c[255 & s]), d[t] = r = (d[t - o] ^ s) >>> 0 } for (i = 0; i < h; i++)t = h - i, s = 3 & i ? d[t] : d[t - 4], i < 4 || t <= 4 ? u[i] = s : u[i] = m[c[s >>> 24]] ^ p[c[s >>> 16 & 255]] ^ E[c[s >>> 8 & 255]] ^ T[c[255 & s]], u[i] = u[i] >>> 0 } networkToHostOrderSwap(e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 } decrypt(e, t, i) { let r, s, a, n, l, o, h, d, u, c, f, g, m, p; let E = this.keySize + 6, T = this.invKeySchedule, y = this.invSBox, v = this.invSubMix, S = v[0], A = v[1], L = v[2], R = v[3], I = this.uint8ArrayToUint32Array_(i), D = I[0], b = I[1], C = I[2], k = I[3], P = new Int32Array(e), _ = new Int32Array(P.length), M = this.networkToHostOrderSwap; for (; t < P.length;) { for (p = 1, u = M(P[t]), c = M(P[t + 1]), f = M(P[t + 2]), g = M(P[t + 3]), l = u ^ T[0], o = g ^ T[1], h = f ^ T[2], d = c ^ T[3], m = 4; p < E; p++)r = S[l >>> 24] ^ A[o >> 16 & 255] ^ L[h >> 8 & 255] ^ R[255 & d] ^ T[m], s = S[o >>> 24] ^ A[h >> 16 & 255] ^ L[d >> 8 & 255] ^ R[255 & l] ^ T[m + 1], a = S[h >>> 24] ^ A[d >> 16 & 255] ^ L[l >> 8 & 255] ^ R[255 & o] ^ T[m + 2], n = S[d >>> 24] ^ A[l >> 16 & 255] ^ L[o >> 8 & 255] ^ R[255 & h] ^ T[m + 3], l = r, o = s, h = a, d = n, m += 4; r = y[l >>> 24] << 24 ^ y[o >> 16 & 255] << 16 ^ y[h >> 8 & 255] << 8 ^ y[255 & d] ^ T[m], s = y[o >>> 24] << 24 ^ y[h >> 16 & 255] << 16 ^ y[d >> 8 & 255] << 8 ^ y[255 & l] ^ T[m + 1], a = y[h >>> 24] << 24 ^ y[d >> 16 & 255] << 16 ^ y[l >> 8 & 255] << 8 ^ y[255 & o] ^ T[m + 2], n = y[d >>> 24] << 24 ^ y[l >> 16 & 255] << 16 ^ y[o >> 8 & 255] << 8 ^ y[255 & h] ^ T[m + 3], _[t] = M(r ^ D), _[t + 1] = M(n ^ b), _[t + 2] = M(a ^ C), _[t + 3] = M(s ^ k), D = u, b = c, C = f, k = g, t += 4 } return _.buffer } }; let Decrypter = class Decrypter { constructor(e, { removePKCS7Padding: t = !0 } = {}) { if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try { let e = self.crypto; e && (this.subtle = e.subtle || e.webkitSubtle) } catch (e) { } null === this.subtle && (this.useSoftware = !0) } destroy() { this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null } isSync() { return this.useSoftware } flush() { let { currentResult: e, remainderData: t } = this; if (!e || t) return this.reset(), null; let i = new Uint8Array(e); return (this.reset(), this.removePKCS7Padding) ? function (e) { let t = e.byteLength, i = t && new DataView(e.buffer).getUint8(t - 1); return i ? sliceUint8(e, 0, t - i) : e }(i) : i } reset() { this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null) } decrypt(e, t, i) { return this.useSoftware ? new Promise((r, s) => { this.softwareDecrypt(new Uint8Array(e), t, i); let a = this.flush(); a ? r(a.buffer) : s(Error("[softwareDecrypt] Failed to decrypt data")) }) : this.webCryptoDecrypt(new Uint8Array(e), t, i) } softwareDecrypt(e, t, i) { let { currentIV: r, currentResult: s, remainderData: a } = this; this.logOnce("JS AES decrypt"), a && (e = appendUint8Array(a, e), this.remainderData = null); let n = this.getValidChunk(e); if (!n.length) return null; r && (i = r); let l = this.softwareDecrypter; return (l || (l = this.softwareDecrypter = new AESDecryptor), l.expandKey(t), this.currentResult = l.decrypt(n.buffer, 0, i), this.currentIV = sliceUint8(n, -16).buffer, s) ? s : null } webCryptoDecrypt(e, t, i) { let r = this.subtle; return this.key === t && this.fastAesKey || (this.key = t, this.fastAesKey = new FastAESKey(r, t)), this.fastAesKey.expandKey().then(t => { if (!r) return Promise.reject(Error("web crypto not initialized")); this.logOnce("WebCrypto AES decrypt"); let s = new AESCrypto(r, new Uint8Array(i)); return s.decrypt(e.buffer, t) }).catch(r => (M.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(e, t, i))) } onWebCryptoError(e, t, i) { this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i); let r = this.flush(); if (r) return r.buffer; throw Error("WebCrypto and softwareDecrypt: failed to decrypt data") } getValidChunk(e) { let t = e, i = e.length - e.length % 16; return i !== e.length && (t = sliceUint8(e, 0, i), this.remainderData = sliceUint8(e, i)), t } logOnce(e) { this.logEnabled && (M.log(`[decrypter]: ${e}`), this.logEnabled = !1) } }; let eg = { toString: function (e) { let t = "", i = e.length; for (let r = 0; r < i; r++)t += `[${e.start(r).toFixed(3)}-${e.end(r).toFixed(3)}]`; return t } }, em = { STOPPED: "STOPPED", IDLE: "IDLE", KEY_LOADING: "KEY_LOADING", FRAG_LOADING: "FRAG_LOADING", FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY", WAITING_TRACK: "WAITING_TRACK", PARSING: "PARSING", PARSED: "PARSED", ENDED: "ENDED", ERROR: "ERROR", WAITING_INIT_PTS: "WAITING_INIT_PTS", WAITING_LEVEL: "WAITING_LEVEL" }; let BaseStreamController = class BaseStreamController extends TaskLoop { constructor(e, t, i, r, s) { super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = em.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = s, this.logPrefix = r, this.log = M.log.bind(M, `${r}:`), this.warn = M.warn.bind(M, `${r}:`), this.hls = e, this.fragmentLoader = new FragmentLoader(e.config), this.keyLoader = i, this.fragmentTracker = t, this.config = e.config, this.decrypter = new Decrypter(e.config), e.on(b.MANIFEST_LOADED, this.onManifestLoaded, this) } doTick() { this.onTickEnd() } onTickEnd() { } startLoad(e) { } stopLoad() { this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType); let e = this.fragCurrent; null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = em.STOPPED } _streamEnded(e, t) { if (t.live || e.nextStart || !e.end || !this.media) return !1; let i = t.partList; if (null != i && i.length) { let e = i[i.length - 1], t = BufferHelper.isBuffered(this.media, e.start + e.duration / 2); return t } let r = t.fragments[t.fragments.length - 1].type; return this.fragmentTracker.isEndListAppended(r) } getLevelDetails() { if (this.levels && null !== this.levelLastLoaded) { var e; return null == (e = this.levelLastLoaded) ? void 0 : e.details } } onMediaAttached(e, t) { let i = this.media = this.mediaBuffer = t.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), i.addEventListener("seeking", this.onvseeking), i.addEventListener("ended", this.onvended); let r = this.config; this.levels && r.autoStartLoad && this.state === em.STOPPED && this.startLoad(r.startPosition) } onMediaDetaching() { let e = this.media; null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() } onMediaSeeking() { let { config: e, fragCurrent: t, media: i, mediaBuffer: r, state: s } = this, a = i ? i.currentTime : 0, n = BufferHelper.bufferInfo(r || i, a, e.maxBufferHole); if (this.log(`media seeking to ${R(a) ? a.toFixed(3) : a}, state: ${s}`), this.state === em.ENDED) this.resetLoadingState(); else if (t) { let i = e.maxFragLookUpTolerance, r = t.start - i, s = t.start + t.duration + i; if (!n.len || s < n.start || r > n.end) { let e = a > s; (a < r || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null) } } i && (this.fragmentTracker.removeFragmentsInRange(a, 1 / 0, this.playlistType, !0), this.lastCurrentTime = a), this.loadedmetadata || n.len || (this.nextLoadPosition = this.startPosition = a), this.tickImmediate() } onMediaEnded() { this.startPosition = this.lastCurrentTime = 0 } onManifestLoaded(e, t) { this.startTimeOffset = t.startTimeOffset, this.initPTS = [] } onHandlerDestroying() { this.hls.off(b.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), super.onHandlerDestroying(), this.hls = null } onHandlerDestroyed() { this.state = em.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed() } loadFragment(e, t, i) { this._loadFragForPlayback(e, t, i) } _loadFragForPlayback(e, t, i) { this._doFragLoad(e, t, i, t => { if (this.fragContextChanged(e)) { this.warn(`Fragment ${e.sn}${t.part ? " p: " + t.part.index : ""} of level ${e.level} was dropped during download.`), this.fragmentTracker.removeFragment(e); return } e.stats.chunkCount++, this._handleFragmentLoadProgress(t) }).then(t => { if (!t) return; let i = this.state; if (this.fragContextChanged(e)) { i !== em.FRAG_LOADING && (this.fragCurrent || i !== em.PARSING) || (this.fragmentTracker.removeFragment(e), this.state = em.IDLE); return } "payload" in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(b.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t) }).catch(t => { this.state !== em.STOPPED && this.state !== em.ERROR && (this.warn(t), this.resetFragmentLoading(e)) }) } clearTrackerIfNeeded(e) { var t; let { fragmentTracker: i } = this, r = i.getState(e); if (r === ec.APPENDING) { let t = e.type, r = this.getFwdBufferInfo(this.mediaBuffer, t), s = Math.max(e.duration, r ? r.len : this.config.maxBufferLength); this.reduceMaxBufferLength(s) && i.removeFragment(e) } else (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) === 0 ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), i.getState(e) === ec.PARTIAL && i.removeFragment(e)) } checkLiveUpdate(e) { if (e.updated && !e.live) { let t = e.fragments[e.fragments.length - 1]; this.fragmentTracker.detectPartialFragments({ frag: t, part: null, stats: t.stats, id: t.type }) } e.fragments[0] || (e.deltaUpdateFailed = !0) } flushMainBuffer(e, t, i = null) { e - t && this.hls.trigger(b.BUFFER_FLUSHING, { startOffset: e, endOffset: t, type: i }) } _loadInitSegment(e, t) { this._doFragLoad(e, t).then(t => { if (!t || this.fragContextChanged(e) || !this.levels) throw Error("init load aborted"); return t }).then(t => { let { hls: i } = this, { payload: r } = t, s = e.decryptdata; if (r && r.byteLength > 0 && null != s && s.key && s.iv && "AES-128" === s.method) { let a = self.performance.now(); return this.decrypter.decrypt(new Uint8Array(r), s.key.buffer, s.iv.buffer).catch(t => { throw i.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_DECRYPT_ERROR, fatal: !1, error: t, reason: t.message, frag: e }), t }).then(r => { let s = self.performance.now(); return i.trigger(b.FRAG_DECRYPTED, { frag: e, payload: r, stats: { tstart: a, tdecrypt: s } }), t.payload = r, this.completeInitSegmentLoad(t) }) } return this.completeInitSegmentLoad(t) }).catch(t => { this.state !== em.STOPPED && this.state !== em.ERROR && (this.warn(t), this.resetFragmentLoading(e)) }) } completeInitSegmentLoad(e) { let { levels: t } = this; if (!t) throw Error("init load aborted, missing levels"); let i = e.frag.stats; this.state = em.IDLE, e.frag.data = new Uint8Array(e.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick() } fragContextChanged(e) { let { fragCurrent: t } = this; return !e || !t || e.sn !== t.sn || e.level !== t.level } fragBufferedComplete(e, t) { var i, r, s, a, n; let l = this.mediaBuffer ? this.mediaBuffer : this.media; if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === et.MAIN ? "level" : "track"} ${e.level} (frag:[${(null != (i = e.startPTS) ? i : NaN).toFixed(3)}-${(null != (r = e.endPTS) ? r : NaN).toFixed(3)}] > buffer:${l ? eg.toString(BufferHelper.getBuffered(l)) : "(detached)"})`), "initSegment" !== e.sn) { if (e.type !== et.SUBTITLE) { let t = e.elementaryStreams; if (!Object.keys(t).some(e => !!t[e])) { this.state = em.IDLE; return } } let t = null == (n = this.levels) ? void 0 : n[e.level]; null != t && t.fragmentError && (this.log(`Resetting level fragment error count of ${t.fragmentError} on frag buffered`), t.fragmentError = 0) } this.state = em.IDLE, l && (!this.loadedmetadata && e.type == et.MAIN && l.buffered.length && (null == (s = this.fragCurrent) ? void 0 : s.sn) === (null == (a = this.fragPrevious) ? void 0 : a.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick()) } seekToStartPos() { } _handleFragmentLoadComplete(e) { let { transmuxer: t } = this; if (!t) return; let { frag: i, part: r, partsLoaded: s } = e, a = !s || 0 === s.length || s.some(e => !e), n = new ChunkMetadata(i.level, i.sn, i.stats.chunkCount + 1, 0, r ? r.index : -1, !a); t.flush(n) } _handleFragmentLoadProgress(e) { } _doFragLoad(e, t, i = null, r) { var s; let a; let n = null == t ? void 0 : t.details; if (!this.levels || !n) throw Error(`frag load aborted, missing level${n ? "" : " detail"}s`); let l = null; if (e.encrypted && !(null != (s = e.decryptdata) && s.key) ? (this.log(`Loading key for ${e.sn} of [${n.startSN}-${n.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ${e.level}`), this.state = em.KEY_LOADING, this.fragCurrent = e, l = this.keyLoader.load(e).then(e => { if (!this.fragContextChanged(e.frag)) return this.hls.trigger(b.KEY_LOADED, e), this.state === em.KEY_LOADING && (this.state = em.IDLE), e }), this.hls.trigger(b.KEY_LOADING, { frag: e }), null === this.fragCurrent && (l = Promise.reject(Error("frag load aborted, context changed in KEY_LOADING")))) : !e.encrypted && n.encryptedFragments.length && this.keyLoader.loadClear(e, n.encryptedFragments), i = Math.max(e.start, i || 0), this.config.lowLatencyMode && "initSegment" !== e.sn) { let s = n.partList; if (s && r) { i > e.end && n.fragmentHint && (e = n.fragmentHint); let a = this.getNextPart(s, e, i); if (a > -1) { let o; let h = s[a]; return (this.log(`Loading part sn: ${e.sn} p: ${h.index} cc: ${e.cc} of playlist [${n.startSN}-${n.endSN}] parts [0-${a}-${s.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = h.start + h.duration, this.state = em.FRAG_LOADING, o = l ? l.then(i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(e, h, t, r)).catch(e => this.handleFragLoadError(e)) : this.doFragPartsLoad(e, h, t, r).catch(e => this.handleFragLoadError(e)), this.hls.trigger(b.FRAG_LOADING, { frag: e, part: h, targetBufferTime: i }), null === this.fragCurrent) ? Promise.reject(Error("frag load aborted, context changed in FRAG_LOADING parts")) : o } if (!e.url || this.loadedEndOfParts(s, i)) return Promise.resolve(null) } } this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${n ? "of [" + n.startSN + "-" + n.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), R(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = em.FRAG_LOADING; let o = this.config.progressive; return (a = o && l ? l.then(t => !t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, r)).catch(e => this.handleFragLoadError(e)) : Promise.all([this.fragmentLoader.load(e, o ? r : void 0), l]).then(([e]) => (!o && e && r && r(e), e)).catch(e => this.handleFragLoadError(e)), this.hls.trigger(b.FRAG_LOADING, { frag: e, targetBufferTime: i }), null === this.fragCurrent) ? Promise.reject(Error("frag load aborted, context changed in FRAG_LOADING")) : a } doFragPartsLoad(e, t, i, r) { return new Promise((s, a) => { var n; let l = [], o = null == (n = i.details) ? void 0 : n.partList, loadPart = t => { this.fragmentLoader.loadPart(e, t, r).then(r => { l[t.index] = r; let a = r.part; this.hls.trigger(b.FRAG_LOADED, r); let n = getPartWith(i, e.sn, t.index + 1) || findPart(o, e.sn, t.index + 1); if (!n) return s({ frag: e, part: a, partsLoaded: l }); loadPart(n) }).catch(a) }; loadPart(t) }) } handleFragLoadError(e) { if ("data" in e) { let t = e.data; e.data && t.details === k.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(b.ERROR, t) } else this.hls.trigger(b.ERROR, { type: C.OTHER_ERROR, details: k.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 }); return null } _handleTransmuxerFlush(e) { let t = this.getCurrentContext(e); if (!t || this.state !== em.PARSING) { this.fragCurrent || this.state === em.STOPPED || this.state === em.ERROR || (this.state = em.IDLE); return } let { frag: i, part: r, level: s } = t, a = self.performance.now(); i.stats.parsing.end = a, r && (r.stats.parsing.end = a), this.updateLevelTiming(i, r, s, e.partial) } getCurrentContext(e) { let { levels: t, fragCurrent: i } = this, { level: r, sn: s, part: a } = e; if (!(null != t && t[r])) return this.warn(`Levels object was unset while buffering fragment ${s} of level ${r}. The current chunk will not be buffered.`), null; let n = t[r], l = a > -1 ? getPartWith(n, s, a) : null, o = l ? l.fragment : function (e, t, i) { if (!(null != e && e.details)) return null; let r = e.details, s = r.fragments[t - r.startSN]; return s || (s = r.fragmentHint) && s.sn === t ? s : t < r.startSN && i && i.sn === t ? i : null }(n, s, i); return o ? (i && i !== o && (o.stats = i.stats), { frag: o, part: l, level: n }) : null } bufferFragmentData(e, t, i, r, s) { var a; if (!e || this.state !== em.PARSING) return; let { data1: n, data2: l } = e, o = n; if (n && l && (o = appendUint8Array(n, l)), !(null != (a = o) && a.length)) return; let h = { type: e.type, frag: t, part: i, chunkMeta: r, parent: t.type, data: o }; if (this.hls.trigger(b.BUFFER_APPENDING, h), e.dropped && e.independent && !i) { if (s) return; this.flushBufferGap(t) } } flushBufferGap(e) { let t = this.media; if (!t) return; if (!BufferHelper.isBuffered(t, t.currentTime)) { this.flushMainBuffer(0, e.start); return } let i = t.currentTime, r = BufferHelper.bufferInfo(t, i, 0), s = e.duration, a = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * s), n = Math.max(Math.min(e.start - a, r.end - a), i + a); e.start - n > a && this.flushMainBuffer(n, e.start) } getFwdBufferInfo(e, t) { let i = this.getLoadPosition(); return R(i) ? this.getFwdBufferInfoAtPos(e, i, t) : null } getFwdBufferInfoAtPos(e, t, i) { let { config: { maxBufferHole: r } } = this, s = BufferHelper.bufferInfo(e, t, r); if (0 === s.len && void 0 !== s.nextStart) { let a = this.fragmentTracker.getBufferedFrag(t, i); if (a && s.nextStart < a.end) return BufferHelper.bufferInfo(e, t, Math.max(s.nextStart, r)) } return s } getMaxBufferLength(e) { let { config: t } = this; return Math.min(e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength, t.maxMaxBufferLength) } reduceMaxBufferLength(e) { let t = this.config, i = e || t.maxBufferLength; return t.maxMaxBufferLength >= i && (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0) } getAppendedFrag(e, t = et.MAIN) { let i = this.fragmentTracker.getAppendedFrag(e, et.MAIN); return i && "fragment" in i ? i.fragment : i } getNextFragment(e, t) { let i; let r = t.fragments, s = r.length; if (!s) return null; let { config: a } = this, n = r[0].start; if (t.live) { let l = a.initialLiveManifestSize; if (s < l) return this.warn(`Not enough fragments to start playback (have: ${s}, need: ${l})`), null; (t.PTSKnown || this.startFragRequested || -1 !== this.startPosition) && !(e < n) || (i = this.getInitialLiveFragment(t, r), this.startPosition = this.nextLoadPosition = i ? this.hls.liveSyncPosition || i.start : e) } else e <= n && (i = r[0]); if (!i) { let r = a.lowLatencyMode ? t.partEnd : t.fragmentEnd; i = this.getFragmentAtPosition(e, r, t) } return this.mapToInitFragWhenRequired(i) } isLoopLoading(e, t) { let i = this.fragmentTracker.getState(e); return (i === ec.OK || i === ec.PARTIAL && !!e.gap) && this.nextLoadPosition > t } getNextFragmentLoopLoading(e, t, i, r, s) { let a = e.gap, n = this.getNextFragment(this.nextLoadPosition, t); if (null === n) return n; if (e = n, a && e && !e.gap && i.nextStart) { let t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, r); if (null !== t && i.len + t.len >= s) return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${e.sn}`), null } return e } mapToInitFragWhenRequired(e) { return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment } getNextPart(e, t, i) { let r = -1, s = !1, a = !0; for (let n = 0, l = e.length; n < l; n++) { let l = e[n]; if (a = a && !l.independent, r > -1 && i < l.start) break; let o = l.loaded; o ? r = -1 : (s || l.independent || a) && l.fragment === t && (r = n), s = o } return r } loadedEndOfParts(e, t) { let i = e[e.length - 1]; return i && t > i.start && i.loaded } getInitialLiveFragment(e, t) { let i = this.fragPrevious, r = null; if (i) { if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), r = function (e, t, i) { if (null === t || !Array.isArray(e) || !e.length || !R(t)) return null; let r = e[0].programDateTime; if (t < (r || 0)) return null; let s = e[e.length - 1].endProgramDateTime; if (t >= (s || 0)) return null; i = i || 0; for (let r = 0; r < e.length; ++r) { let s = e[r]; if (function (e, t, i) { let r = 1e3 * Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0)), s = i.endProgramDateTime || 0; return s - r > e }(t, i, s)) return s } return null }(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) { let a = i.sn + 1; if (a >= e.startSN && a <= e.endSN) { let s = t[a - e.startSN]; i.cc === s.cc && (r = s, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`)) } if (!r) { var s; s = i.cc, (r = el.search(t, e => e.cc < s ? 1 : e.cc > s ? -1 : 0)) && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`) } } } else { let t = this.hls.liveSyncPosition; null !== t && (r = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e)) } return r } getFragmentAtPosition(e, t, i) { let r; let { config: s } = this, { fragPrevious: a } = this, { fragments: n, endSN: l } = i, { fragmentHint: o } = i, h = s.maxFragLookUpTolerance, d = i.partList, u = !!(s.lowLatencyMode && null != d && d.length && o); if (u && o && !this.bitrateTest && (n = n.concat(o), l = o.sn), e < t) { let i = e > t - h ? 0 : h; r = findFragmentByPTS(a, n, e, i) } else r = n[n.length - 1]; if (r) { let e = r.sn - i.startSN, t = this.fragmentTracker.getState(r); if ((t === ec.OK || t === ec.PARTIAL && r.gap) && (a = r), a && r.sn === a.sn && (!u || d[0].fragment.sn > r.sn)) { let t = a && r.level === a.level; if (t) { let t = n[e + 1]; r = r.sn < l && this.fragmentTracker.getState(t) !== ec.OK ? t : null } } } return r } synchronizeToLiveEdge(e) { let { config: t, media: i } = this; if (!i) return; let r = this.hls.liveSyncPosition, s = i.currentTime, a = e.fragments[0].start, n = e.edge, l = s >= a - t.maxFragLookUpTolerance && s <= n; if (null !== r && i.duration > r && (s < r || !l)) { let a = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration; (!l && i.readyState < 4 || s < n - a) && (this.loadedmetadata || (this.nextLoadPosition = r), i.readyState && (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${n}, reset currentTime to : ${r.toFixed(3)}`), i.currentTime = r)) } } alignPlaylists(e, t, i) { let r = e.fragments.length; if (!r) return this.warn("No fragments in live playlist"), 0; let s = e.fragments[0].start, a = !t, n = e.alignedSliding && R(s); if (a || !n && !s) { let { fragPrevious: s } = this; i && (function (e, t, i) { if (i && (t.endCC > t.startCC || e && e.cc < t.startCC)) { let e = function (e, t) { let i = e.fragments, r = t.fragments; if (!r.length || !i.length) { M.log("No fragments to align"); return } let s = findFirstFragWithCC(i, r[0].cc); if (!s || s && !s.startPTS) { M.log("No frag in previous level to align on"); return } return s }(i, t); e && R(e.start) && (M.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`), adjustSlidingStart(e.start, t)) } }(s, e, i), !e.alignedSliding && i && alignMediaPlaylistByPDT(e, i), e.alignedSliding || !i || e.skippedSegments || adjustSliding(i, e)); let a = e.fragments[0].start; return this.log(`Live playlist sliding: ${a.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${s ? s.sn : "na"} fragments: ${r}`), a } return s } waitForCdnTuneIn(e) { return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget) } setStartPosition(e, t) { let i = this.startPosition; if (i < t && (i = -1), -1 === i || -1 === this.lastCurrentTime) { let r = null !== this.startTimeOffset, s = r ? this.startTimeOffset : e.startTimeOffset; null !== s && R(s) ? (i = t + s, s < 0 && (i += e.totalduration), i = Math.min(Math.max(t, i), t + e.totalduration), this.log(`Start time offset ${s} found in ${r ? "multivariant" : "media"} playlist, adjust startPosition to ${i}`), this.startPosition = i) : e.live ? i = this.hls.liveSyncPosition || t : this.startPosition = i = 0, this.lastCurrentTime = i } this.nextLoadPosition = i } getLoadPosition() { let { media: e } = this, t = 0; return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t } handleFragLoadAborted(e, t) { this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e)) } resetFragmentLoading(e) { this.fragCurrent && (this.fragContextChanged(e) || this.state === em.FRAG_LOADING_WAITING_RETRY) || (this.state = em.IDLE) } onFragmentOrKeyLoadError(e, t) { if (t.chunkMeta && !t.frag) { let e = this.getCurrentContext(t.chunkMeta); e && (t.frag = e.frag) } let i = t.frag; if (!i || i.type !== e || !this.levels) return; if (this.fragContextChanged(i)) { var r; this.warn(`Frag load error must match current frag to retry ${i.url} > ${null == (r = this.fragCurrent) ? void 0 : r.url}`); return } let s = t.details === k.FRAG_GAP; s && this.fragmentTracker.fragBuffered(i, !0); let a = t.errorAction, { action: n, retryCount: l = 0, retryConfig: o } = a || {}; if (a && n === eo.RetryRequest && o) { this.resetStartWhenNotLoaded(this.levelLastLoaded); let r = getRetryDelay(o, l); this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${t.details}, retrying loading ${l + 1}/${o.maxNumRetry} in ${r}ms`), a.resolved = !0, this.retryDate = self.performance.now() + r, this.state = em.FRAG_LOADING_WAITING_RETRY } else if (o && a) { if (this.resetFragmentErrors(e), l < o.maxNumRetry) s || n === eo.RemoveAlternatePermanently || (a.resolved = !0); else { M.warn(`${t.details} reached or exceeded max retry (${l})`); return } } else (null == a ? void 0 : a.action) === eo.SendAlternateToPenaltyBox ? this.state = em.WAITING_LEVEL : this.state = em.ERROR; this.tickImmediate() } reduceLengthAndFlushBuffer(e) { if (this.state === em.PARSING || this.state === em.PARSED) { let t = e.parent, i = this.getFwdBufferInfo(this.mediaBuffer, t), r = i && i.len > .5; r && this.reduceMaxBufferLength(i.len); let s = !r; return s && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), s } return !1 } resetFragmentErrors(e) { e === et.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== em.STOPPED && (this.state = em.IDLE) } afterBufferFlushed(e, t, i) { if (!e) return; let r = BufferHelper.getBuffered(e); this.fragmentTracker.detectEvictedFragments(t, r, i), this.state === em.ENDED && this.resetLoadingState() } resetLoadingState() { this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = em.IDLE } resetStartWhenNotLoaded(e) { if (!this.loadedmetadata) { this.startFragRequested = !1; let t = e ? e.details : null; null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition } } resetWhenMissingContext(e) { this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState() } removeUnbufferedFrags(e = 0) { this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0) } updateLevelTiming(e, t, i, r) { var s; let a = i.details; if (!a) { this.warn("level.details undefined"); return } let n = Object.keys(e.elementaryStreams).reduce((t, s) => { let n = e.elementaryStreams[s]; if (n) { let l = n.endPTS - n.startPTS; if (l <= 0) return this.warn(`Could not parse fragment ${e.sn} ${s} duration reliably (${l})`), t || !1; let o = r ? 0 : updateFragPTSDTS(a, e, n.startPTS, n.endPTS, n.startDTS, n.endDTS); return this.hls.trigger(b.LEVEL_PTS_UPDATED, { details: a, level: i, drift: o, type: s, frag: e, start: n.startPTS, end: n.endPTS }), !0 } return t }, !1); if (!n && (null == (s = this.transmuxer) ? void 0 : s.error) === null) { let t = Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`); if (0 === i.fragmentError && (i.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(t.message), this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, fatal: !1, error: t, frag: e, reason: `Found no media in msn ${e.sn} of level "${i.url}"` }), !this.hls) return; this.resetTransmuxer() } this.state = em.PARSED, this.hls.trigger(b.FRAG_PARSED, { frag: e, part: t }) } resetTransmuxer() { this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null) } recoverWorkerError(e) { "demuxerWorker" === e.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()) } set state(e) { let t = this._state; t !== e && (this._state = e, this.log(`${t}->${e}`)) } get state() { return this._state } }; let ChunkCache = class ChunkCache { constructor() { this.chunks = [], this.dataLength = 0 } push(e) { this.chunks.push(e), this.dataLength += e.length } flush() { let e; let { chunks: t, dataLength: i } = this; return t.length ? (e = 1 === t.length ? t[0] : function (e, t) { let i = new Uint8Array(t), r = 0; for (let t = 0; t < e.length; t++) { let s = e[t]; i.set(s, r), r += s.length } return i }(t, i), this.reset(), e) : new Uint8Array(0) } reset() { this.chunks.length = 0, this.dataLength = 0 } }; function dummyTrack(e = "", t = 9e4) { return { type: e, id: -1, pid: -1, inputTimeScale: t, sequenceNumber: -1, samples: [], dropped: 0 } } let BaseAudioDemuxer = class BaseAudioDemuxer { constructor() { this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null } resetInitSegment(e, t, i, r) { this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 } } resetTimeStamp(e) { this.initPTS = e, this.resetContiguity() } resetContiguity() { this.basePTS = null, this.lastPTS = null, this.frameIndex = 0 } canParse(e, t) { return !1 } appendFrame(e, t, i) { } demux(e, t) { let i; this.cachedData && (e = appendUint8Array(this.cachedData, e), this.cachedData = null); let r = getID3Data(e, 0), s = r ? r.length : 0, a = this._audioTrack, n = this._id3Track, l = r ? getTimeStamp(r) : void 0, o = e.length; for ((null === this.basePTS || 0 === this.frameIndex && R(l)) && (this.basePTS = initPTSFn(l, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && n.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: ei.audioId3, duration: Number.POSITIVE_INFINITY }); s < o;) { if (this.canParse(e, s)) { let t = this.appendFrame(a, e, s); t ? (this.frameIndex++, this.lastPTS = t.sample.pts, s += t.length, i = s) : s = o } else canParse$2(e, s) ? (r = getID3Data(e, s), n.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: ei.audioId3, duration: Number.POSITIVE_INFINITY }), s += r.length, i = s) : s++; if (s === o && i !== o) { let t = sliceUint8(e, i); this.cachedData ? this.cachedData = appendUint8Array(this.cachedData, t) : this.cachedData = t } } return { audioTrack: a, videoTrack: dummyTrack(), id3Track: n, textTrack: dummyTrack() } } demuxSampleAes(e, t, i) { return Promise.reject(Error(`[${this}] This demuxer does not support Sample-AES decryption`)) } flush(e) { let t = this.cachedData; return t && (this.cachedData = null, this.demux(t, 0)), { audioTrack: this._audioTrack, videoTrack: dummyTrack(), id3Track: this._id3Track, textTrack: dummyTrack() } } destroy() { } }; let initPTSFn = (e, t, i) => { if (R(e)) return 90 * e; let r = i ? 9e4 * i.baseTime / i.timescale : 0; return 9e4 * t + r }; function isHeaderPattern$1(e, t) { return 255 === e[t] && (246 & e[t + 1]) == 240 } function getHeaderLength(e, t) { return 1 & e[t + 1] ? 7 : 9 } function getFullFrameLength(e, t) { return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5 } function isHeader$1(e, t) { return t + 1 < e.length && isHeaderPattern$1(e, t) } function initTrackConfig(e, t, i, r, s) { if (!e.samplerate) { let a = function (e, t, i, r) { let s, a, n, l; let o = navigator.userAgent.toLowerCase(), h = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; s = ((192 & t[i + 2]) >>> 6) + 1; let d = (60 & t[i + 2]) >>> 2; if (d > h.length - 1) { let t = Error(`invalid ADTS sampling index:${d}`); e.emit(b.ERROR, b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, fatal: !0, error: t, reason: t.message }); return } return n = (1 & t[i + 2]) << 2 | (192 & t[i + 3]) >>> 6, M.log(`manifest codec:${r}, ADTS type:${s}, samplingIndex:${d}`), /firefox/i.test(o) ? d >= 6 ? (s = 5, l = [, , , ,], a = d - 3) : (s = 2, l = [, ,], a = d) : -1 !== o.indexOf("android") ? (s = 2, l = [, ,], a = d) : (s = 5, l = [, , , ,], r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && d >= 6 ? a = d - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (d >= 6 && 1 === n || /vivaldi/i.test(o)) || !r && 1 === n) && (s = 2, l = [, ,]), a = d)), l[0] = s << 3, l[0] |= (14 & d) >> 1, l[1] |= (1 & d) << 7, l[1] |= n << 3, 5 === s && (l[1] |= (14 & a) >> 1, l[2] = (1 & a) << 7, l[2] |= 8, l[3] = 0), { config: l, samplerate: h[d], channelCount: n, codec: "mp4a.40." + s, manifestCodec: r } }(t, i, r, s); a && (e.config = a.config, e.samplerate = a.samplerate, e.channelCount = a.channelCount, e.codec = a.codec, e.manifestCodec = a.manifestCodec, M.log(`parsed codec:${e.codec}, rate:${a.samplerate}, channels:${a.channelCount}`)) } } function appendFrame$2(e, t, i, r, s) { let a; let n = 9216e4 / e.samplerate, l = r + s * n, o = function (e, t) { let i = getHeaderLength(e, t); if (t + i <= e.length) { let r = getFullFrameLength(e, t) - i; if (r > 0) return { headerLength: i, frameLength: r } } }(t, i); if (o) { let { frameLength: r, headerLength: s } = o, n = s + r, h = Math.max(0, i + n - t.length); h ? (a = new Uint8Array(n - s)).set(t.subarray(i + s, t.length), 0) : a = t.subarray(i + s, i + n); let d = { unit: a, pts: l }; return h || e.samples.push(d), { sample: d, length: n, missing: h } } let h = t.length - i; (a = new Uint8Array(h)).set(t.subarray(i, t.length), 0); let d = { unit: a, pts: l }; return { sample: d, length: h, missing: -1 } } let ep = null, eE = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], eT = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], ey = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], ev = [0, 1, 1, 4]; function appendFrame$1(e, t, i, r, s) { if (i + 24 > t.length) return; let a = parseHeader(t, i); if (a && i + a.frameLength <= t.length) { let n = 9e4 * a.samplesPerFrame / a.sampleRate, l = r + s * n, o = { unit: t.subarray(i, i + a.frameLength), pts: l, dts: l }; return e.config = [], e.channelCount = a.channelCount, e.samplerate = a.sampleRate, e.samples.push(o), { sample: o, length: a.frameLength, missing: 0 } } } function parseHeader(e, t) { let i = e[t + 1] >> 3 & 3, r = e[t + 1] >> 1 & 3, s = e[t + 2] >> 4 & 15, a = e[t + 2] >> 2 & 3; if (1 !== i && 0 !== s && 15 !== s && 3 !== a) { let n = e[t + 2] >> 1 & 1, l = e[t + 3] >> 6, o = 1e3 * eE[14 * (3 === i ? 3 - r : 3 === r ? 3 : 4) + s - 1], h = eT[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + a], d = ey[i][r], u = ev[r], c = Math.floor(d * o / h + n) * u; if (null === ep) { let e = navigator.userAgent || "", t = e.match(/Chrome\/(\d+)/i); ep = t ? parseInt(t[1]) : 0 } let f = !!ep && ep <= 87; return f && 2 === r && o >= 224e3 && 0 === l && (e[t + 3] = 128 | e[t + 3]), { sampleRate: h, channelCount: 3 === l ? 1 : 2, frameLength: c, samplesPerFrame: 8 * d * u } } } function isHeaderPattern(e, t) { return 255 === e[t] && (224 & e[t + 1]) == 224 && (6 & e[t + 1]) != 0 } function isHeader(e, t) { return t + 1 < e.length && isHeaderPattern(e, t) } function probe(e, t) { if (t + 1 < e.length && isHeaderPattern(e, t)) { let i = parseHeader(e, t), r = 4; null != i && i.frameLength && (r = i.frameLength); let s = t + r; return s === e.length || isHeader(e, s) } return !1 } let eS = /\/emsg[-/]ID3/i, getAudioBSID = (e, t) => { let i = 0, r = 5; t += 5; let s = new Uint32Array(1), a = new Uint32Array(1), n = new Uint8Array(1); for (; r > 0;) { n[0] = e[t]; let l = Math.min(r, 8), o = 8 - l; a[0] = 4278190080 >>> 24 + o << o, s[0] = (n[0] & a[0]) >> o, i = i ? i << l | s[0] : s[0], t += 1, r -= l } return i }; function appendFrame(e, t, i, r, s) { if (i + 8 > t.length || 11 !== t[i] || 119 !== t[i + 1]) return -1; let a = t[i + 4] >> 6; if (a >= 3) return -1; let n = [48e3, 44100, 32e3][a], l = 63 & t[i + 4], o = 2 * [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][3 * l + a]; if (i + o > t.length) return -1; let h = t[i + 6] >> 5, d = 0; 2 === h ? d += 2 : (1 & h && 1 !== h && (d += 2), 4 & h && (d += 2)); let u = (t[i + 6] << 8 | t[i + 7]) >> 12 - d & 1, c = [2, 1, 2, 3, 3, 4, 4, 5][h] + u, f = t[i + 5] >> 3, g = 7 & t[i + 5], m = new Uint8Array([a << 6 | f << 1 | g >> 2, (3 & g) << 6 | h << 3 | u << 2 | l >> 4, l << 4 & 224]), p = t.subarray(i, i + o); return e.config = m, e.channelCount = c, e.samplerate = n, e.samples.push({ unit: p, pts: r + s * (1536 / n * 9e4) }), o } let BaseVideoParser = class BaseVideoParser { constructor() { this.VideoSample = null } createVideoSample(e, t, i, r) { return { key: e, frame: !1, pts: t, dts: i, units: [], debug: r, length: 0 } } getLastNalUnit(e) { var t; let i; let r = this.VideoSample; if (r && 0 !== r.units.length || (r = e[e.length - 1]), null != (t = r) && t.units) { let e = r.units; i = e[e.length - 1] } return i } pushAccessUnit(e, t) { if (e.units.length && e.frame) { if (void 0 === e.pts) { let i = t.samples, r = i.length; if (r) { let t = i[r - 1]; e.pts = t.pts, e.dts = t.dts } else { t.dropped++; return } } t.samples.push(e) } e.debug.length && M.log(e.pts + "/" + e.dts + ":" + e.debug) } }; let ExpGolomb = class ExpGolomb { constructor(e) { this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 } loadWord() { let e = this.data, t = this.bytesAvailable, i = e.byteLength - t, r = new Uint8Array(4), s = Math.min(4, t); if (0 === s) throw Error("no bytes available"); r.set(e.subarray(i, i + s)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * s, this.bytesAvailable -= s } skipBits(e) { let t; e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e || (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e } readBits(e) { let t = Math.min(this.bitsAvailable, e), i = this.word >>> 32 - t; if (e > 32 && M.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else if (this.bytesAvailable > 0) this.loadWord(); else throw Error("no bits available"); return (t = e - t) > 0 && this.bitsAvailable ? i << t | this.readBits(t) : i } skipLZ() { let e; for (e = 0; e < this.bitsAvailable; ++e)if ((this.word & 2147483648 >>> e) != 0) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() } skipUEG() { this.skipBits(1 + this.skipLZ()) } skipEG() { this.skipBits(1 + this.skipLZ()) } readUEG() { let e = this.skipLZ(); return this.readBits(e + 1) - 1 } readEG() { let e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) } readBoolean() { return 1 === this.readBits(1) } readUByte() { return this.readBits(8) } readUShort() { return this.readBits(16) } readUInt() { return this.readBits(32) } skipScalingList(e) { let t = 8, i = 8; for (let r = 0; r < e; r++)0 !== i && (i = (t + this.readEG() + 256) % 256), t = 0 === i ? t : i } readSPS() { let e, t, i, r = 0, s = 0, a = 0, n = 0, l = this.readUByte.bind(this), o = this.readBits.bind(this), h = this.readUEG.bind(this), d = this.readBoolean.bind(this), u = this.skipBits.bind(this), c = this.skipEG.bind(this), f = this.skipUEG.bind(this), g = this.skipScalingList.bind(this); l(); let m = l(); if (o(5), u(3), l(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) { let e = h(); if (3 === e && u(1), f(), f(), u(1), d()) for (i = 0, t = 3 !== e ? 8 : 12; i < t; i++)d() && g(i < 6 ? 16 : 64) } f(); let p = h(); if (0 === p) h(); else if (1 === p) for (u(1), c(), c(), e = h(), i = 0; i < e; i++)c(); f(), u(1); let E = h(), T = h(), y = o(1); 0 === y && u(1), u(1), d() && (r = h(), s = h(), a = h(), n = h()); let v = [1, 1]; if (d() && d()) { let e = l(); switch (e) { case 1: v = [1, 1]; break; case 2: v = [12, 11]; break; case 3: v = [10, 11]; break; case 4: v = [16, 11]; break; case 5: v = [40, 33]; break; case 6: v = [24, 11]; break; case 7: v = [20, 11]; break; case 8: v = [32, 11]; break; case 9: v = [80, 33]; break; case 10: v = [18, 11]; break; case 11: v = [15, 11]; break; case 12: v = [64, 33]; break; case 13: v = [160, 99]; break; case 14: v = [4, 3]; break; case 15: v = [3, 2]; break; case 16: v = [2, 1]; break; case 255: v = [l() << 8 | l(), l() << 8 | l()] } } return { width: Math.ceil((E + 1) * 16 - 2 * r - 2 * s), height: (2 - y) * (T + 1) * 16 - (y ? 2 : 4) * (a + n), pixelRatio: v } } readSliceType() { return this.readUByte(), this.readUEG(), this.readUEG() } }; let AvcVideoParser = class AvcVideoParser extends BaseVideoParser { parseAVCPES(e, t, i, r, s) { let a; let n = this.parseAVCNALu(e, i.data), l = this.VideoSample, o = !1; i.data = null, l && n.length && !e.audFound && (this.pushAccessUnit(l, e), l = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "")), n.forEach(r => { var n, h, d, u; switch (r.type) { case 1: { let t = !1; a = !0; let s = r.data; if (o && s.length > 4) { let e = new ExpGolomb(s).readSliceType(); (2 === e || 4 === e || 7 === e || 9 === e) && (t = !0) } t && null != (h = l) && h.frame && !l.key && (this.pushAccessUnit(l, e), l = this.VideoSample = null), l || (l = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), l.frame = !0, l.key = t; break } case 5: a = !0, null != (n = l) && n.frame && !l.key && (this.pushAccessUnit(l, e), l = this.VideoSample = null), l || (l = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), l.key = !0, l.frame = !0; break; case 6: a = !0, parseSEIMessageFromNALu(r.data, 1, i.pts, t.samples); break; case 7: { a = !0, o = !0; let t = r.data, i = new ExpGolomb(t), n = i.readSPS(); if (!e.sps || e.width !== n.width || e.height !== n.height || (null == (d = e.pixelRatio) ? void 0 : d[0]) !== n.pixelRatio[0] || (null == (u = e.pixelRatio) ? void 0 : u[1]) !== n.pixelRatio[1]) { e.width = n.width, e.height = n.height, e.pixelRatio = n.pixelRatio, e.sps = [t], e.duration = s; let i = t.subarray(1, 4), r = "avc1."; for (let e = 0; e < 3; e++) { let t = i[e].toString(16); t.length < 2 && (t = "0" + t), r += t } e.codec = r } break } case 8: a = !0, e.pps = [r.data]; break; case 9: a = !0, e.audFound = !0, l && this.pushAccessUnit(l, e), l = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, ""); break; case 12: a = !0; break; default: a = !1, l && (l.debug += "unknown NAL " + r.type + " ") }if (l && a) { let e = l.units; e.push(r) } }), r && l && (this.pushAccessUnit(l, e), this.VideoSample = null) } parseAVCNALu(e, t) { let i, r, s; let a = t.byteLength, n = e.naluState || 0, l = n, o = [], h = 0, d = -1, u = 0; for (-1 === n && (d = 0, u = 31 & t[0], n = 0, h = 1); h < a;) { if (i = t[h++], !n) { n = i ? 0 : 1; continue } if (1 === n) { n = i ? 0 : 2; continue } if (i) { if (1 === i) { if (r = h - n - 1, d >= 0) { let e = { data: t.subarray(d, r), type: u }; o.push(e) } else { let i = this.getLastNalUnit(e.samples); i && (l && h <= 4 - l && i.state && (i.data = i.data.subarray(0, i.data.byteLength - l)), r > 0 && (i.data = appendUint8Array(i.data, t.subarray(0, r)), i.state = 0)) } h < a ? (s = 31 & t[h], d = h, u = s, n = 0) : n = -1 } else n = 0 } else n = 3 } if (d >= 0 && n >= 0) { let e = { data: t.subarray(d, a), type: u, state: n }; o.push(e) } if (0 === o.length) { let i = this.getLastNalUnit(e.samples); i && (i.data = appendUint8Array(i.data, t)) } return e.naluState = n, o } }; let SampleAesDecrypter = class SampleAesDecrypter { constructor(e, t, i) { this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new Decrypter(t, { removePKCS7Padding: !1 }) } decryptBuffer(e) { return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer) } decryptAacSample(e, t, i) { let r = e[t].unit; if (r.length <= 16) return; let s = r.subarray(16, r.length - r.length % 16), a = s.buffer.slice(s.byteOffset, s.byteOffset + s.length); this.decryptBuffer(a).then(s => { let a = new Uint8Array(s); r.set(a, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i) }) } decryptAacSamples(e, t, i) { for (; ; t++) { if (t >= e.length) { i(); return } if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, i), !this.decrypter.isSync())) return } } getAvcEncryptedData(e) { let t = 16 * Math.floor((e.length - 48) / 160) + 16, i = new Int8Array(t), r = 0; for (let t = 32; t < e.length - 16; t += 160, r += 16)i.set(e.subarray(t, t + 16), r); return i } getAvcDecryptedUnit(e, t) { let i = new Uint8Array(t), r = 0; for (let t = 32; t < e.length - 16; t += 160, r += 16)e.set(i.subarray(r, r + 16), t); return e } decryptAvcSample(e, t, i, r, s) { let a = discardEPB(s.data), n = this.getAvcEncryptedData(a); this.decryptBuffer(n.buffer).then(n => { s.data = this.getAvcDecryptedUnit(a, n), this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, r) }) } decryptAvcSamples(e, t, i, r) { if (e instanceof Uint8Array) throw Error("Cannot decrypt samples of type Uint8Array"); for (; ; t++, i = 0) { if (t >= e.length) { r(); return } let s = e[t].units; for (; !(i >= s.length); i++) { let a = s[i]; if (!(a.data.length <= 48) && (1 === a.type || 5 === a.type) && (this.decryptAvcSample(e, t, i, r, a), !this.decrypter.isSync())) return } } } }; let TSDemuxer = class TSDemuxer { constructor(e, t, i) { this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.videoParser = new AvcVideoParser } static probe(e) { let t = TSDemuxer.syncOffset(e); return t > 0 && M.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), -1 !== t } static syncOffset(e) { let t = e.length, i = Math.min(940, t - 188) + 1, r = 0; for (; r < i;) { let s = !1, a = -1, n = 0; for (let l = r; l < t; l += 188)if (71 === e[l] && (t - l == 188 || 71 === e[l + 188])) { if (n++, -1 === a && 0 !== (a = l) && (i = Math.min(a + 18612, e.length - 188) + 1), s || (s = 0 === parsePID(e, l)), s && n > 1 && (0 === a && n > 2 || l + 188 > i)) return a } else if (n) return -1; else break; r++ } return -1 } static createTrack(e, t) { return { container: "video" === e || "audio" === e ? "video/mp2t" : void 0, type: e, id: H[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: "audio" === e ? t : void 0 } } resetInitSegment(e, t, i, r) { this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = TSDemuxer.createTrack("video"), this._audioTrack = TSDemuxer.createTrack("audio", r), this._id3Track = TSDemuxer.createTrack("id3"), this._txtTrack = TSDemuxer.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = i, this._duration = r } resetTimeStamp() { } resetContiguity() { let { _audioTrack: e, _videoTrack: t, _id3Track: i } = this; e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null } demux(e, t, i = !1, r = !1) { let s; i || (this.sampleAes = null); let a = this._videoTrack, n = this._audioTrack, l = this._id3Track, o = this._txtTrack, h = a.pid, d = a.pesData, u = n.pid, c = l.pid, f = n.pesData, g = l.pesData, m = null, p = this.pmtParsed, E = this._pmtId, T = e.length; if (this.remainderData && (T = (e = appendUint8Array(this.remainderData, e)).length, this.remainderData = null), T < 188 && !r) return this.remainderData = e, { audioTrack: n, videoTrack: a, id3Track: l, textTrack: o }; let y = Math.max(0, TSDemuxer.syncOffset(e)); (T -= (T - y) % 188) < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer, T, e.buffer.byteLength - T)); let v = 0; for (let t = y; t < T; t += 188)if (71 === e[t]) { let r; let T = !!(64 & e[t + 1]), v = parsePID(e, t), L = (48 & e[t + 3]) >> 4; if (L > 1) { if ((r = t + 5 + e[t + 4]) === t + 188) continue } else r = t + 4; switch (v) { case h: T && (d && (s = parsePES(d)) && this.videoParser.parseAVCPES(a, o, s, !1, this._duration), d = { data: [], size: 0 }), d && (d.data.push(e.subarray(r, t + 188)), d.size += t + 188 - r); break; case u: if (T) { if (f && (s = parsePES(f))) switch (n.segmentCodec) { case "aac": this.parseAACPES(n, s); break; case "mp3": this.parseMPEGPES(n, s); break; case "ac3": this.parseAC3PES(n, s) }f = { data: [], size: 0 } } f && (f.data.push(e.subarray(r, t + 188)), f.size += t + 188 - r); break; case c: T && (g && (s = parsePES(g)) && this.parseID3PES(l, s), g = { data: [], size: 0 }), g && (g.data.push(e.subarray(r, t + 188)), g.size += t + 188 - r); break; case 0: var S, A; T && (r += e[r] + 1), E = this._pmtId = (31 & (S = e)[(A = r) + 10]) << 8 | S[A + 11]; break; case E: { T && (r += e[r] + 1); let s = function (e, t, i, r) { let s = { audioPid: -1, videoPid: -1, id3Pid: -1, segmentVideoCodec: "avc", segmentAudioCodec: "aac" }, a = (15 & e[t + 1]) << 8 | e[t + 2], n = t + 3 + a - 4, l = (15 & e[t + 10]) << 8 | e[t + 11]; for (t += 12 + l; t < n;) { let a = parsePID(e, t), n = (15 & e[t + 3]) << 8 | e[t + 4]; switch (e[t]) { case 207: if (!r) { logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC"); break } case 15: -1 === s.audioPid && (s.audioPid = a); break; case 21: -1 === s.id3Pid && (s.id3Pid = a); break; case 219: if (!r) { logEncryptedSamplesFoundInUnencryptedStream("H.264"); break } case 27: -1 === s.videoPid && (s.videoPid = a, s.segmentVideoCodec = "avc"); break; case 3: case 4: i.mpeg || i.mp3 ? -1 === s.audioPid && (s.audioPid = a, s.segmentAudioCodec = "mp3") : M.log("MPEG audio found, not supported in this browser"); break; case 193: if (!r) { logEncryptedSamplesFoundInUnencryptedStream("AC-3"); break } case 129: i.ac3 ? -1 === s.audioPid && (s.audioPid = a, s.segmentAudioCodec = "ac3") : M.log("AC-3 audio found, not supported in this browser"); break; case 6: if (-1 === s.audioPid && n > 0) { let r = t + 5, l = n; for (; l > 2;) { let t = e[r]; 106 === t && (!0 !== i.ac3 ? M.log("AC-3 audio found, not supported in this browser for now") : (s.audioPid = a, s.segmentAudioCodec = "ac3")); let n = e[r + 1] + 2; r += n, l -= n } } break; case 194: case 135: M.warn("Unsupported EC-3 in M2TS found"); break; case 36: M.warn("Unsupported HEVC in M2TS found") }t += n + 5 } return s }(e, r, this.typeSupported, i); (h = s.videoPid) > 0 && (a.pid = h, a.segmentCodec = s.segmentVideoCodec), (u = s.audioPid) > 0 && (n.pid = u, n.segmentCodec = s.segmentAudioCodec), (c = s.id3Pid) > 0 && (l.pid = c), null === m || p || (M.warn(`MPEG-TS PMT found at ${t} after unknown PID '${m}'. Backtracking to sync byte @${y} to parse all TS packets.`), m = null, t = y - 188), p = this.pmtParsed = !0; break } case 17: case 8191: break; default: m = v } } else v++; if (v > 0) { let e = Error(`Found ${v} TS packet/s that do not start with 0x47`); this.observer.emit(b.ERROR, b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, fatal: !1, error: e, reason: e.message }) } a.pesData = d, n.pesData = f, l.pesData = g; let L = { audioTrack: n, videoTrack: a, id3Track: l, textTrack: o }; return r && this.extractRemainingSamples(L), L } flush() { let e; let { remainderData: t } = this; return (this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : { videoTrack: this._videoTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(e), this.sampleAes) ? this.decrypt(e, this.sampleAes) : e } extractRemainingSamples(e) { let t; let { audioTrack: i, videoTrack: r, id3Track: s, textTrack: a } = e, n = r.pesData, l = i.pesData, o = s.pesData; if (n && (t = parsePES(n)) ? (this.videoParser.parseAVCPES(r, a, t, !0, this._duration), r.pesData = null) : r.pesData = n, l && (t = parsePES(l))) { switch (i.segmentCodec) { case "aac": this.parseAACPES(i, t); break; case "mp3": this.parseMPEGPES(i, t); break; case "ac3": this.parseAC3PES(i, t) }i.pesData = null } else null != l && l.size && M.log("last AAC PES packet truncated,might overlap between fragments"), i.pesData = l; o && (t = parsePES(o)) ? (this.parseID3PES(s, t), s.pesData = null) : s.pesData = o } demuxSampleAes(e, t, i) { let r = this.demux(e, i, !0, !this.config.progressive), s = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, t); return this.decrypt(r, s) } decrypt(e, t) { return new Promise(i => { let { audioTrack: r, videoTrack: s } = e; r.samples && "aac" === r.segmentCodec ? t.decryptAacSamples(r.samples, 0, () => { s.samples ? t.decryptAvcSamples(s.samples, 0, 0, () => { i(e) }) : i(e) }) : s.samples && t.decryptAvcSamples(s.samples, 0, 0, () => { i(e) }) }) } destroy() { this._duration = 0 } parseAACPES(e, t) { let i, r, s, a, n = 0, l = this.aacOverFlow, o = t.data; if (l) { this.aacOverFlow = null; let t = l.missing, i = l.sample.unit.byteLength; if (-1 === t) o = appendUint8Array(l.sample.unit, o); else { let r = i - t; l.sample.unit.set(o.subarray(0, t), r), e.samples.push(l.sample), n = l.missing } } for (i = n, r = o.length; i < r - 1 && !isHeader$1(o, i); i++); if (i !== n) { let e; let t = i < r - 1; e = t ? `AAC PES did not start with ADTS header,offset:${i}` : "No ADTS header found in AAC PES"; let s = Error(e); if (M.warn(`parsing error: ${e}`), this.observer.emit(b.ERROR, b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, fatal: !1, levelRetry: t, error: s, reason: e }), !t) return } if (initTrackConfig(e, this.observer, o, i, this.audioCodec), void 0 !== t.pts) s = t.pts; else if (l) { let t = 9216e4 / e.samplerate; s = l.sample.pts + t } else { M.warn("[tsdemuxer]: AAC PES unknown PTS"); return } let h = 0; for (; i < r;) { if (a = appendFrame$2(e, o, i, s, h), i += a.length, a.missing) { this.aacOverFlow = a; break } for (h++; i < r - 1 && !isHeader$1(o, i); i++); } } parseMPEGPES(e, t) { let i = t.data, r = i.length, s = 0, a = 0, n = t.pts; if (void 0 === n) { M.warn("[tsdemuxer]: MPEG PES unknown PTS"); return } for (; a < r;)if (isHeader(i, a)) { let t = appendFrame$1(e, i, a, n, s); if (t) a += t.length, s++; else break } else a++ } parseAC3PES(e, t) { { let i; let r = t.data, s = t.pts; if (void 0 === s) { M.warn("[tsdemuxer]: AC3 PES unknown PTS"); return } let a = r.length, n = 0, l = 0; for (; l < a && (i = appendFrame(e, r, l, s, n++)) > 0;)l += i } } parseID3PES(e, t) { if (void 0 === t.pts) { M.warn("[tsdemuxer]: ID3 PES unknown PTS"); return } let i = _extends({}, t, { type: this._videoTrack ? ei.emsg : ei.audioId3, duration: Number.POSITIVE_INFINITY }); e.samples.push(i) } }; function parsePID(e, t) { return ((31 & e[t + 1]) << 8) + e[t + 2] } function logEncryptedSamplesFoundInUnencryptedStream(e) { M.log(`${e} with AES-128-CBC encryption found in unencrypted stream`) } function parsePES(e) { let t, i, r, s, a, n = 0, l = e.data; if (!e || 0 === e.size) return null; for (; l[0].length < 19 && l.length > 1;)l[0] = appendUint8Array(l[0], l[1]), l.splice(1, 1); t = l[0]; let o = (t[0] << 16) + (t[1] << 8) + t[2]; if (1 === o) { if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null; let o = t[7]; 192 & o && (s = (14 & t[9]) * 536870912 + (255 & t[10]) * 4194304 + (254 & t[11]) * 16384 + (255 & t[12]) * 128 + (254 & t[13]) / 2, 64 & o ? s - (a = (14 & t[14]) * 536870912 + (255 & t[15]) * 4194304 + (254 & t[16]) * 16384 + (255 & t[17]) * 128 + (254 & t[18]) / 2) > 54e5 && (M.warn(`${Math.round((s - a) / 9e4)}s delta between PTS and DTS, align them`), s = a) : a = s); let h = (r = t[8]) + 9; if (e.size <= h) return null; e.size -= h; let d = new Uint8Array(e.size); for (let e = 0, i = l.length; e < i; e++) { let i = (t = l[e]).byteLength; if (h) { if (h > i) { h -= i; continue } t = t.subarray(h), i -= h, h = 0 } d.set(t, n), n += i } return i && (i -= r + 3), { data: d, pts: s, dts: a, len: i } } return null } let AAC = class AAC { static getSilentFrame(e, t) { if ("mp4a.40.2" === e) { if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); else if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); else if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) } else { if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (2 === t || 3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) } } }; let MP4 = class MP4 { static init() { let e; for (e in MP4.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], dac3: [], "ac-3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }, MP4.types) MP4.types.hasOwnProperty(e) && (MP4.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); let t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); MP4.HDLR_TYPES = { video: t, audio: i }; let r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); MP4.STTS = MP4.STSC = MP4.STCO = s, MP4.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), MP4.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), MP4.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), MP4.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); let a = new Uint8Array([105, 115, 111, 109]), n = new Uint8Array([97, 118, 99, 49]), l = new Uint8Array([0, 0, 0, 1]); MP4.FTYP = MP4.box(MP4.types.ftyp, a, l, a, n), MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, r)) } static box(e, ...t) { let i = 8, r = t.length, s = r; for (; r--;)i += t[r].byteLength; let a = new Uint8Array(i); for (a[0] = i >> 24 & 255, a[1] = i >> 16 & 255, a[2] = i >> 8 & 255, a[3] = 255 & i, a.set(e, 4), r = 0, i = 8; r < s; r++)a.set(t[r], i), i += t[r].byteLength; return a } static hdlr(e) { return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[e]) } static mdat(e) { return MP4.box(MP4.types.mdat, e) } static mdhd(e, t) { t *= e; let i = Math.floor(t / 4294967296), r = Math.floor(t % 4294967296); return MP4.box(MP4.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0])) } static mdia(e) { return MP4.box(MP4.types.mdia, MP4.mdhd(e.timescale, e.duration), MP4.hdlr(e.type), MP4.minf(e)) } static mfhd(e) { return MP4.box(MP4.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e])) } static minf(e) { return "audio" === e.type ? MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(e)) : MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(e)) } static moof(e, t, i) { return MP4.box(MP4.types.moof, MP4.mfhd(e), MP4.traf(i, t)) } static moov(e) { let t = e.length, i = []; for (; t--;)i[t] = MP4.trak(e[t]); return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(MP4.mvex(e))) } static mvex(e) { let t = e.length, i = []; for (; t--;)i[t] = MP4.trex(e[t]); return MP4.box.apply(null, [MP4.types.mvex, ...i]) } static mvhd(e, t) { t *= e; let i = Math.floor(t / 4294967296), r = Math.floor(t % 4294967296), s = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return MP4.box(MP4.types.mvhd, s) } static sdtp(e) { let t, i; let r = e.samples || [], s = new Uint8Array(4 + r.length); for (t = 0; t < r.length; t++)i = r[t].flags, s[t + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy; return MP4.box(MP4.types.sdtp, s) } static stbl(e) { return MP4.box(MP4.types.stbl, MP4.stsd(e), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO)) } static avc1(e) { let t, i, r, s = [], a = []; for (t = 0; t < e.sps.length; t++)r = (i = e.sps[t]).byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(i)); for (t = 0; t < e.pps.length; t++)r = (i = e.pps[t]).byteLength, a.push(r >>> 8 & 255), a.push(255 & r), a = a.concat(Array.prototype.slice.call(i)); let n = MP4.box(MP4.types.avcC, new Uint8Array([1, s[3], s[4], s[5], 255, 224 | e.sps.length].concat(s).concat([e.pps.length]).concat(a))), l = e.width, o = e.height, h = e.pixelRatio[0], d = e.pixelRatio[1]; return MP4.box(MP4.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, o >> 8 & 255, 255 & o, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), n, MP4.box(MP4.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), MP4.box(MP4.types.pasp, new Uint8Array([h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d]))) } static esds(e) { let t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])) } static audioStsd(e) { let t = e.samplerate; return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]) } static mp4a(e) { return MP4.box(MP4.types.mp4a, MP4.audioStsd(e), MP4.box(MP4.types.esds, MP4.esds(e))) } static mp3(e) { return MP4.box(MP4.types[".mp3"], MP4.audioStsd(e)) } static ac3(e) { return MP4.box(MP4.types["ac-3"], MP4.audioStsd(e), MP4.box(MP4.types.dac3, e.config)) } static stsd(e) { return "audio" !== e.type ? MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(e)) : "mp3" === e.segmentCodec && "mp3" === e.codec ? MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(e)) : "ac3" === e.segmentCodec ? MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(e)) : MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(e)) } static tkhd(e) { let t = e.id, i = e.duration * e.timescale, r = e.width, s = e.height, a = Math.floor(i / 4294967296), n = Math.floor(i % 4294967296); return MP4.box(MP4.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, s >> 8 & 255, 255 & s, 0, 0])) } static traf(e, t) { let i = MP4.sdtp(e), r = e.id, s = Math.floor(t / 4294967296), a = Math.floor(t % 4294967296); return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), MP4.box(MP4.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), MP4.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i) } static trak(e) { return e.duration = e.duration || 4294967295, MP4.box(MP4.types.trak, MP4.tkhd(e), MP4.mdia(e)) } static trex(e) { let t = e.id; return MP4.box(MP4.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) } static trun(e, t) { let i, r, s, a, n, l; let o = e.samples || [], h = o.length, d = 12 + 16 * h, u = new Uint8Array(d); for (t += 8 + d, u.set(["video" === e.type ? 1 : 0, 0, 15, 1, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), i = 0; i < h; i++)s = (r = o[i]).duration, a = r.size, n = r.flags, l = r.cts, u.set([s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, n.isLeading << 2 | n.dependsOn, n.isDependedOn << 6 | n.hasRedundancy << 4 | n.paddingValue << 1 | n.isNonSync, 61440 & n.degradPrio, 15 & n.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i); return MP4.box(MP4.types.trun, u) } static initSegment(e) { MP4.types || MP4.init(); let t = MP4.moov(e), i = appendUint8Array(MP4.FTYP, t); return i } }; function toTimescaleFromBase(e, t, i = 1, r = !1) { let s = e * t * i; return r ? Math.round(s) : s } function toMsFromMpegTsClock(e, t = !1) { return toTimescaleFromBase(e, 1e3, 11111111111111112e-21, t) } MP4.types = void 0, MP4.HDLR_TYPES = void 0, MP4.STTS = void 0, MP4.STSC = void 0, MP4.STCO = void 0, MP4.STSZ = void 0, MP4.VMHD = void 0, MP4.SMHD = void 0, MP4.STSD = void 0, MP4.FTYP = void 0, MP4.DINF = void 0; let eA = null, eL = null; let MP4Remuxer = class MP4Remuxer { constructor(e, t, i, r = "") { if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, null === eA) { let e = navigator.userAgent || "", t = e.match(/Chrome\/(\d+)/i); eA = t ? parseInt(t[1]) : 0 } if (null === eL) { let e = navigator.userAgent.match(/Safari\/(\d+)/i); eL = e ? parseInt(e[1]) : 0 } } destroy() { this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null } resetTimeStamp(e) { M.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e } resetNextTimestamp() { M.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1 } resetInitSegment() { M.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0 } getVideoStartPts(e) { let t = !1, i = e.reduce((e, i) => { let r = i.pts - e; return r < -4294967296 ? (t = !0, normalizePts(e, i.pts)) : r > 0 ? e : i.pts }, e[0].pts); return t && M.debug("PTS rollover detected"), i } remux(e, t, i, r, s, a, n, l) { let o, h, d, u, c, f; let g = s, m = s, p = e.pid > -1, E = t.pid > -1, T = t.samples.length, y = e.samples.length > 0, v = n && T > 0 || T > 1, S = (!p || y) && (!E || v) || this.ISGenerated || n; if (S) { let i; if (this.ISGenerated) { var A, L, R, I; let e = this.videoTrackConfig; e && (t.width !== e.width || t.height !== e.height || (null == (A = t.pixelRatio) ? void 0 : A[0]) !== (null == (L = e.pixelRatio) ? void 0 : L[0]) || (null == (R = t.pixelRatio) ? void 0 : R[1]) !== (null == (I = e.pixelRatio) ? void 0 : I[1])) && this.resetInitSegment() } else d = this.generateIS(e, t, s, a); let r = this.isVideoContiguous, n = -1; if (v && (n = function (e) { for (let t = 0; t < e.length; t++)if (e[t].key) return t; return -1 }(t.samples), !r && this.config.forceKeyFrameOnDiscontinuity)) { if (f = !0, n > 0) { M.warn(`[mp4-remuxer]: Dropped ${n} out of ${T} video samples due to a missing keyframe`); let e = this.getVideoStartPts(t.samples); t.samples = t.samples.slice(n), t.dropped += n, m += (t.samples[0].pts - e) / t.inputTimeScale, i = m } else -1 === n && (M.warn(`[mp4-remuxer]: No keyframe found out of ${T} video samples`), f = !1) } if (this.ISGenerated) { if (y && v) { let i = this.getVideoStartPts(t.samples), r = normalizePts(e.samples[0].pts, i) - i, s = r / t.inputTimeScale; g += Math.max(0, s), m += Math.max(0, -s) } if (y) { if (e.samplerate || (M.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), d = this.generateIS(e, t, s, a)), h = this.remuxAudio(e, g, this.isAudioContiguous, a, E || v || l === et.AUDIO ? m : void 0), v) { let i = h ? h.endPTS - h.startPTS : 0; t.inputTimeScale || (M.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), d = this.generateIS(e, t, s, a)), o = this.remuxVideo(t, m, r, i) } } else v && (o = this.remuxVideo(t, m, r, 0)); o && (o.firstKeyFrame = n, o.independent = -1 !== n, o.firstKeyFramePTS = i) } } return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (c = flushTextTrackMetadataCueSamples(i, s, this._initPTS, this._initDTS)), r.samples.length && (u = flushTextTrackUserdataCueSamples(r, s, this._initPTS))), { audio: h, video: o, initSegment: d, independent: f, text: u, id3: c } } generateIS(e, t, i, r) { let s, a, n; let l = e.samples, o = t.samples, h = this.typeSupported, d = {}, u = this._initPTS, c = !u || r, f = "audio/mp4"; if (c && (s = a = 1 / 0), e.config && l.length) { switch (e.timescale = e.samplerate, e.segmentCodec) { case "mp3": h.mpeg ? (f = "audio/mpeg", e.codec = "") : h.mp3 && (e.codec = "mp3"); break; case "ac3": e.codec = "ac-3" }d.audio = { id: "audio", container: f, codec: e.codec, initSegment: "mp3" === e.segmentCodec && h.mpeg ? new Uint8Array(0) : MP4.initSegment([e]), metadata: { channelCount: e.channelCount } }, c && (n = e.inputTimeScale, u && n === u.timescale ? c = !1 : s = a = l[0].pts - Math.round(n * i)) } if (t.sps && t.pps && o.length) { if (t.timescale = t.inputTimeScale, d.video = { id: "main", container: "video/mp4", codec: t.codec, initSegment: MP4.initSegment([t]), metadata: { width: t.width, height: t.height } }, c) { if (n = t.inputTimeScale, u && n === u.timescale) c = !1; else { let e = this.getVideoStartPts(o), t = Math.round(n * i); a = Math.min(a, normalizePts(o[0].dts, e) - t), s = Math.min(s, e - t) } } this.videoTrackConfig = { width: t.width, height: t.height, pixelRatio: t.pixelRatio } } if (Object.keys(d).length) return this.ISGenerated = !0, c ? (this._initPTS = { baseTime: s, timescale: n }, this._initDTS = { baseTime: a, timescale: n }) : s = n = void 0, { tracks: d, initPTS: s, timescale: n } } remuxVideo(e, t, i, r) { let s, a, n; let l = e.inputTimeScale, o = e.samples, h = [], d = o.length, u = this._initPTS, c = this.nextAvcDts, f = 8, g = this.videoSampleDuration, m = Number.POSITIVE_INFINITY, p = Number.NEGATIVE_INFINITY, E = !1; if (!i || null === c) { let e = t * l, r = o[0].pts - normalizePts(o[0].dts, o[0].pts); eA && null !== c && 15e3 > Math.abs(e - r - c) ? i = !0 : c = e - r } let T = u.baseTime * l / u.timescale; for (let e = 0; e < d; e++) { let t = o[e]; t.pts = normalizePts(t.pts - T, c), t.dts = normalizePts(t.dts - T, c), t.dts < o[e > 0 ? e - 1 : e].dts && (E = !0) } E && o.sort(function (e, t) { let i = e.dts - t.dts, r = e.pts - t.pts; return i || r }), s = o[0].dts, a = o[o.length - 1].dts; let y = a - s, v = y ? Math.round(y / (d - 1)) : g || e.inputTimeScale / 30; if (i) { let e = s - c, i = e > v, r = e < -1; if ((i || r) && (i ? M.warn(`AVC: ${toMsFromMpegTsClock(e, !0)} ms (${e}dts) hole between fragments detected at ${t.toFixed(3)}`) : M.warn(`AVC: ${toMsFromMpegTsClock(-e, !0)} ms (${e}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !r || c >= o[0].pts || eA)) { s = c; let t = o[0].pts - e; if (i) o[0].dts = s, o[0].pts = t; else for (let i = 0; i < o.length && !(o[i].dts > t); i++)o[i].dts -= e, o[i].pts -= e; M.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(t, !0)}/${toMsFromMpegTsClock(s, !0)}, delta: ${toMsFromMpegTsClock(e, !0)} ms`) } } let S = 0, A = 0, L = s = Math.max(0, s); for (let e = 0; e < d; e++) { let t = o[e], i = t.units, r = i.length, s = 0; for (let e = 0; e < r; e++)s += i[e].data.length; A += s, S += r, t.length = s, t.dts < L ? (t.dts = L, L += v / 4 | 0 || 1) : L = t.dts, m = Math.min(t.pts, m), p = Math.max(t.pts, p) } a = o[d - 1].dts; let R = A + 4 * S + 8; try { n = new Uint8Array(R) } catch (e) { this.observer.emit(b.ERROR, b.ERROR, { type: C.MUX_ERROR, details: k.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: R, reason: `fail allocating video mdat ${R}` }); return } let I = new DataView(n.buffer); I.setUint32(0, R), n.set(MP4.types.mdat, 4); let D = !1, P = Number.POSITIVE_INFINITY, _ = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY, w = Number.NEGATIVE_INFINITY; for (let e = 0; e < d; e++) { let t; let i = o[e], s = i.units, a = 0; for (let e = 0, t = s.length; e < t; e++) { let t = s[e], i = t.data, r = t.data.byteLength; I.setUint32(f, r), f += 4, n.set(i, f), f += r, a += 4 + r } if (e < d - 1) g = o[e + 1].dts - i.dts, t = o[e + 1].pts - i.pts; else { let s = this.config, a = e > 0 ? i.dts - o[e - 1].dts : v; if (t = e > 0 ? i.pts - o[e - 1].pts : v, s.stretchShortVideoTrack && null !== this.nextAudioPts) { let e = Math.floor(s.maxBufferHole * l), t = (r ? m + r * l : this.nextAudioPts) - i.pts; t > e ? ((g = t - a) < 0 ? g = a : D = !0, M.log(`[mp4-remuxer]: It is approximately ${t / 90} ms to the next segment; using duration ${g / 90} ms for the last video frame.`)) : g = a } else g = a } let u = Math.round(i.pts - i.dts); P = Math.min(P, g), x = Math.max(x, g), _ = Math.min(_, t), w = Math.max(w, t), h.push(new Mp4Sample(i.key, g, a, u)) } if (h.length) { if (eA) { if (eA < 70) { let e = h[0].flags; e.dependsOn = 2, e.isNonSync = 0 } } else if (eL && w - _ < x - P && v / x < .025 && 0 === h[0].cts) { M.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."); let e = s; for (let t = 0, i = h.length; t < i; t++) { let r = e + h[t].duration, s = e + h[t].cts; if (t < i - 1) { let e = r + h[t + 1].cts; h[t].duration = e - s } else h[t].duration = t ? h[t - 1].duration : v; h[t].cts = 0, e = r } } } g = D || !g ? v : g, this.nextAvcDts = c = a + g, this.videoSampleDuration = g, this.isVideoContiguous = !0; let F = MP4.moof(e.sequenceNumber++, s, _extends({}, e, { samples: h })), O = { data1: F, data2: n, startPTS: m / l, endPTS: (p + g) / l, startDTS: s / l, endDTS: c / l, type: "video", hasAudio: !1, hasVideo: !0, nb: h.length, dropped: e.dropped }; return e.samples = [], e.dropped = 0, O } getSamplesPerFrame(e) { switch (e.segmentCodec) { case "mp3": return 1152; case "ac3": return 1536; default: return 1024 } } remuxAudio(e, t, i, r, s) { let a; let n = e.inputTimeScale, l = e.samplerate ? e.samplerate : n, o = n / l, h = this.getSamplesPerFrame(e), d = h * o, u = this._initPTS, c = "mp3" === e.segmentCodec && this.typeSupported.mpeg, f = [], g = void 0 !== s, m = e.samples, p = c ? 0 : 8, E = this.nextAudioPts || -1, T = t * n, y = u.baseTime * n / u.timescale; if (this.isAudioContiguous = i = i || m.length && E > 0 && (r && 9e3 > Math.abs(T - E) || Math.abs(normalizePts(m[0].pts - y, T) - E) < 20 * d), m.forEach(function (e) { e.pts = normalizePts(e.pts - y, T) }), !i || E < 0) { if (!(m = m.filter(e => e.pts >= 0)).length) return; E = 0 === s ? 0 : r && !g ? Math.max(0, T) : m[0].pts } if ("aac" === e.segmentCodec) { let t = this.config.maxAudioFramesDrift; for (let i = 0, r = E; i < m.length; i++) { let s = m[i], a = s.pts, l = a - r, o = Math.abs(1e3 * l / n); if (l <= -t * d && g) 0 === i && (M.warn(`Audio frame @ ${(a / n).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * l / n)} ms.`), this.nextAudioPts = E = r = a); else if (l >= t * d && o < 1e4 && g) { let t = Math.round(l / d); (r = a - t * d) < 0 && (t--, r += d), 0 === i && (this.nextAudioPts = E = r), M.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(r / n).toFixed(3)}s due to ${Math.round(1e3 * l / n)} ms gap.`); for (let a = 0; a < t; a++) { let t = Math.max(r, 0), a = AAC.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); a || (M.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), a = s.unit.subarray()), m.splice(i, 0, { unit: a, pts: t }), r += d, i++ } } s.pts = r, r += d } } let v = null, S = null, A = 0, L = m.length; for (; L--;)A += m[L].unit.byteLength; for (let t = 0, r = m.length; t < r; t++) { let r = m[t], s = r.unit, n = r.pts; if (null !== S) { let e = f[t - 1]; e.duration = Math.round((n - S) / o) } else { if (i && "aac" === e.segmentCodec && (n = E), v = n, !(A > 0)) return; A += p; try { a = new Uint8Array(A) } catch (e) { this.observer.emit(b.ERROR, b.ERROR, { type: C.MUX_ERROR, details: k.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: A, reason: `fail allocating audio mdat ${A}` }); return } if (!c) { let e = new DataView(a.buffer); e.setUint32(0, A), a.set(MP4.types.mdat, 4) } } a.set(s, p); let l = s.byteLength; p += l, f.push(new Mp4Sample(!0, h, l, 0)), S = n } let R = f.length; if (!R) return; let I = f[f.length - 1]; this.nextAudioPts = E = S + o * I.duration; let D = c ? new Uint8Array(0) : MP4.moof(e.sequenceNumber++, v / o, _extends({}, e, { samples: f })); e.samples = []; let P = v / n, _ = E / n, x = { data1: D, data2: a, startPTS: P, endPTS: _, startDTS: P, endDTS: _, type: "audio", hasAudio: !0, hasVideo: !1, nb: R }; return this.isAudioContiguous = !0, x } remuxEmptyAudio(e, t, i, r) { let s = e.inputTimeScale, a = e.samplerate ? e.samplerate : s, n = this.nextAudioPts, l = this._initDTS, o = 9e4 * l.baseTime / l.timescale, h = (null !== n ? n : r.startDTS * s) + o, d = r.endDTS * s + o, u = s / a * 1024, c = Math.ceil((d - h) / u), f = AAC.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (M.warn("[mp4-remuxer]: remux empty Audio"), !f) { M.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec"); return } let g = []; for (let e = 0; e < c; e++) { let t = h + e * u; g.push({ unit: f, pts: t, dts: t }) } return e.samples = g, this.remuxAudio(e, t, i, !1) } }; function normalizePts(e, t) { let i; if (null === t) return e; for (i = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;)e += i; return e } function flushTextTrackMetadataCueSamples(e, t, i, r) { let s = e.samples.length; if (!s) return; let a = e.inputTimeScale; for (let n = 0; n < s; n++) { let s = e.samples[n]; s.pts = normalizePts(s.pts - i.baseTime * a / i.timescale, t * a) / a, s.dts = normalizePts(s.dts - r.baseTime * a / r.timescale, t * a) / a } let n = e.samples; return e.samples = [], { samples: n } } function flushTextTrackUserdataCueSamples(e, t, i) { let r = e.samples.length; if (!r) return; let s = e.inputTimeScale; for (let a = 0; a < r; a++) { let r = e.samples[a]; r.pts = normalizePts(r.pts - i.baseTime * s / i.timescale, t * s) / s } e.samples.sort((e, t) => e.pts - t.pts); let a = e.samples; return e.samples = [], { samples: a } } let Mp4Sample = class Mp4Sample { constructor(e, t, i, r) { this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = i, this.cts = r, this.flags = { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: e ? 2 : 1, isNonSync: e ? 0 : 1 } } }; function getParsedTrackCodec(e, t) { let i = null == e ? void 0 : e.codec; if (i && i.length > 4) return i; if (t === F.AUDIO) { if ("ec-3" === i || "ac-3" === i || "alac" === i) return i; if ("fLaC" === i || "Opus" === i) return getCodecCompatibleName(i, !1); let e = "mp4a.40.5"; return M.info(`Parsed audio codec "${i}" or audio object type not handled. Using "${e}"`), e } return (M.warn(`Unhandled video codec "${i}"`), "hvc1" === i || "hev1" === i) ? "hvc1.1.6.L120.90" : "av01" === i ? "av01.0.04M.08" : "avc1.42e01e" } try { s = self.performance.now.bind(self.performance) } catch (e) { M.debug("Unable to use Performance API on this environment"), s = null == O ? void 0 : O.Date.now } let eR = [{ demux: class { constructor(e, t) { this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t } resetTimeStamp() { } resetInitSegment(e, t, i, r) { let s = this.videoTrack = dummyTrack("video", 1), a = this.audioTrack = dummyTrack("audio", 1), n = this.txtTrack = dummyTrack("text", 1); if (this.id3Track = dummyTrack("id3", 1), this.timeOffset = 0, !(null != e && e.byteLength)) return; let l = parseInitSegment(e); if (l.video) { let { id: e, timescale: t, codec: i } = l.video; s.id = e, s.timescale = n.timescale = t, s.codec = i } if (l.audio) { let { id: e, timescale: t, codec: i } = l.audio; a.id = e, a.timescale = t, a.codec = i } n.id = 4, s.sampleDuration = 0, s.duration = a.duration = r } resetContiguity() { this.remainderData = null } static probe(e) { return function (e) { let t = e.byteLength; for (let i = 0; i < t;) { let r = readUint32(e, i); if (r > 8 && 109 === e[i + 4] && 111 === e[i + 5] && 111 === e[i + 6] && 102 === e[i + 7]) return !0; i = r > 1 ? i + r : t } return !1 }(e) } demux(e, t) { this.timeOffset = t; let i = e, r = this.videoTrack, s = this.txtTrack; if (this.config.progressive) { this.remainderData && (i = appendUint8Array(this.remainderData, e)); let t = function (e) { let t = { valid: null, remainder: null }, i = findBox(e, ["moof"]); if (i.length < 2) return t.remainder = e, t; let r = i[i.length - 1]; return t.valid = sliceUint8(e, 0, r.byteOffset - 8), t.remainder = sliceUint8(e, r.byteOffset - 8), t }(i); this.remainderData = t.remainder, r.samples = t.valid || new Uint8Array } else r.samples = i; let a = this.extractID3Track(r, t); return s.samples = parseSamples(t, r), { videoTrack: r, audioTrack: this.audioTrack, id3Track: a, textTrack: this.txtTrack } } flush() { let e = this.timeOffset, t = this.videoTrack, i = this.txtTrack; t.samples = this.remainderData || new Uint8Array, this.remainderData = null; let r = this.extractID3Track(t, this.timeOffset); return i.samples = parseSamples(e, t), { videoTrack: t, audioTrack: dummyTrack(), id3Track: r, textTrack: dummyTrack() } } extractID3Track(e, t) { let i = this.id3Track; if (e.samples.length) { let r = findBox(e.samples, ["emsg"]); r && r.forEach(e => { let r = function (e) { let t = e[0], i = "", r = "", s = 0, a = 0, n = 0, l = 0, o = 0, h = 0; if (0 === t) { for (; "\x00" !== bin2str(e.subarray(h, h + 1));)i += bin2str(e.subarray(h, h + 1)), h += 1; for (i += bin2str(e.subarray(h, h + 1)), h += 1; "\x00" !== bin2str(e.subarray(h, h + 1));)r += bin2str(e.subarray(h, h + 1)), h += 1; r += bin2str(e.subarray(h, h + 1)), h += 1, s = readUint32(e, 12), a = readUint32(e, 16), l = readUint32(e, 20), o = readUint32(e, 24), h = 28 } else if (1 === t) { h += 4, s = readUint32(e, h), h += 4; let t = readUint32(e, h); h += 4; let a = readUint32(e, h); for (h += 4, I(n = 4294967296 * t + a) || (n = Number.MAX_SAFE_INTEGER, M.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), l = readUint32(e, h), h += 4, o = readUint32(e, h), h += 4; "\x00" !== bin2str(e.subarray(h, h + 1));)i += bin2str(e.subarray(h, h + 1)), h += 1; for (i += bin2str(e.subarray(h, h + 1)), h += 1; "\x00" !== bin2str(e.subarray(h, h + 1));)r += bin2str(e.subarray(h, h + 1)), h += 1; r += bin2str(e.subarray(h, h + 1)), h += 1 } let d = e.subarray(h, e.byteLength); return { schemeIdUri: i, value: r, timeScale: s, presentationTime: n, presentationTimeDelta: a, eventDuration: l, id: o, payload: d } }(e); if (eS.test(r.schemeIdUri)) { let e = R(r.presentationTime) ? r.presentationTime / r.timeScale : t + r.presentationTimeDelta / r.timeScale, s = 4294967295 === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale; s <= .001 && (s = Number.POSITIVE_INFINITY); let a = r.payload; i.samples.push({ data: a, len: a.byteLength, dts: e, pts: e, type: ei.emsg, duration: s }) } }) } return i } demuxSampleAes(e, t, i) { return Promise.reject(Error("The MP4 demuxer does not support SAMPLE-AES decryption")) } destroy() { } }, remux: class { constructor() { this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null } destroy() { } resetTimeStamp(e) { this.initPTS = e, this.lastEndTime = null } resetNextTimestamp() { this.lastEndTime = null } resetInitSegment(e, t, i, r) { this.audioCodec = t, this.videoCodec = i, this.generateInitSegment(function (e, t) { if (!e || !t) return e; let i = t.keyId; if (i && t.isCommonEncryption) { let t = findBox(e, ["moov", "trak"]); t.forEach(e => { let t = findBox(e, ["mdia", "minf", "stbl", "stsd"])[0], r = t.subarray(8), s = findBox(r, ["enca"]), a = s.length > 0; a || (s = findBox(r, ["encv"])), s.forEach(e => { let t = a ? e.subarray(28) : e.subarray(78), r = findBox(t, ["sinf"]); r.forEach(e => { let t = parseSinf(e); if (t) { let e = t.subarray(8, 24); e.some(e => 0 !== e) || (M.log(`[eme] Patching keyId in 'enc${a ? "a" : "v"}>sinf>>tenc' box: ${G.hexDump(e)} -> ${G.hexDump(i)}`), t.set(i, 8)) } }) }) }) } return e }(e, r)), this.emitInitSegment = !0 } generateInitSegment(e) { let { audioCodec: t, videoCodec: i } = this; if (!(null != e && e.byteLength)) { this.initTracks = void 0, this.initData = void 0; return } let r = this.initData = parseInitSegment(e); r.audio && (t = getParsedTrackCodec(r.audio, F.AUDIO)), r.video && (i = getParsedTrackCodec(r.video, F.VIDEO)); let s = {}; r.audio && r.video ? s.audiovideo = { container: "video/mp4", codec: t + "," + i, initSegment: e, id: "main" } : r.audio ? s.audio = { container: "audio/mp4", codec: t, initSegment: e, id: "audio" } : r.video ? s.video = { container: "video/mp4", codec: i, initSegment: e, id: "main" } : M.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = s } remux(e, t, i, r, s, a) { var n, l, o; let { initPTS: h, lastEndTime: d } = this, u = { audio: void 0, video: void 0, text: r, id3: i, initSegment: void 0 }; R(d) || (d = this.lastEndTime = s || 0); let c = t.samples; if (!(null != c && c.length)) return u; let f = { initPTS: void 0, timescale: 1 }, g = this.initData; if (null != (n = g) && n.length || (this.generateInitSegment(c), g = this.initData), !(null != (l = g) && l.length)) return M.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), u; this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1); let m = function (e, t) { let i = 0, r = 0, s = 0, a = findBox(e, ["moof", "traf"]); for (let e = 0; e < a.length; e++) { let n = a[e], l = findBox(n, ["tfhd"])[0], o = readUint32(l, 4), h = t[o]; if (!h) continue; let d = h.default, u = readUint32(l, 0) | (null == d ? void 0 : d.flags), c = null == d ? void 0 : d.duration; 8 & u && (c = 2 & u ? readUint32(l, 12) : readUint32(l, 8)); let f = h.timescale || 9e4, g = findBox(n, ["trun"]); for (let e = 0; e < g.length; e++) { if (!(i = function (e) { let t = readUint32(e, 0), i = 8; 1 & t && (i += 4), 4 & t && (i += 4); let r = 0, s = readUint32(e, 4); for (let a = 0; a < s; a++) { if (256 & t) { let t = readUint32(e, i); r += t, i += 4 } 512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4) } return r }(g[e])) && c) { let t = readUint32(g[e], 4); i = c * t } h.type === F.VIDEO ? r += i / f : h.type === F.AUDIO && (s += i / f) } } if (0 === r && 0 === s) { let t = 1 / 0, i = 0, r = 0, s = findBox(e, ["sidx"]); for (let e = 0; e < s.length; e++) { let a = function (e) { let t = [], i = e[0], r = 8, s = readUint32(e, r); r += 4; let a = 0, n = 0; 0 === i ? (a = readUint32(e, r), n = readUint32(e, r + 4), r += 8) : (a = readUint64(e, r), n = readUint64(e, r + 8), r += 16), r += 2; let l = e.length + n, o = readUint16(e, r); r += 2; for (let i = 0; i < o; i++) { let i = r, a = readUint32(e, i); i += 4; let n = 2147483647 & a, o = (2147483648 & a) >>> 31; if (1 === o) return M.warn("SIDX has hierarchical references (not supported)"), null; let h = readUint32(e, i); i += 4, t.push({ referenceSize: n, subsegmentDuration: h, info: { duration: h / s, start: l, end: l + n - 1 } }), l += n, i += 4, r = i } return { earliestPresentationTime: a, timescale: s, version: i, referencesCount: o, references: t } }(s[e]); if (null != a && a.references) { t = Math.min(t, a.earliestPresentationTime / a.timescale); let e = a.references.reduce((e, t) => e + t.info.duration || 0, 0); r = (i = Math.max(i, e + a.earliestPresentationTime / a.timescale)) - t } } if (r && R(r)) return r } return r || s }(c, g), p = (o = g, findBox(c, ["moof", "traf"]).reduce((e, t) => { let i = findBox(t, ["tfdt"])[0], r = i[0], s = findBox(t, ["tfhd"]).reduce((e, t) => { let s = readUint32(t, 4), a = o[s]; if (a) { let t = readUint32(i, 4); if (1 === r) { if (4294967295 === t) return M.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), e; t *= 4294967296, t += readUint32(i, 8) } let s = a.timescale || 9e4, n = t / s; if (R(n) && (null === e || n < e)) return n } return e }, null); return null !== s && R(s) && (null === e || s < e) ? s : e }, null)), E = null === p ? s : p; ((function (e, t, i, r) { if (null === e) return !0; let s = Math.max(r, 1), a = t - e.baseTime / e.timescale; return Math.abs(a - i) > s })(h, E, s, m) || f.timescale !== h.timescale && a) && (f.initPTS = E - s, h && 1 === h.timescale && M.warn(`Adjusting initPTS by ${f.initPTS - h.baseTime}`), this.initPTS = h = { baseTime: f.initPTS, timescale: 1 }); let T = e ? E - h.baseTime / h.timescale : d, y = T + m; !function (e, t, i) { findBox(t, ["moof", "traf"]).forEach(t => { findBox(t, ["tfhd"]).forEach(r => { let s = readUint32(r, 4), a = e[s]; if (!a) return; let n = a.timescale || 9e4; findBox(t, ["tfdt"]).forEach(e => { let t = e[0], r = i * n; if (r) { let i = readUint32(e, 4); if (0 === t) i -= r, writeUint32(e, 4, i = Math.max(i, 0)); else { i *= 4294967296, i += readUint32(e, 8), i -= r, i = Math.max(i, 0); let t = Math.floor(i / 4294967296), s = Math.floor(i % 4294967296); writeUint32(e, 4, t), writeUint32(e, 8, s) } } }) }) }) }(g, c, h.baseTime / h.timescale), m > 0 ? this.lastEndTime = y : (M.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp()); let v = !!g.audio, S = !!g.video, A = ""; v && (A += "audio"), S && (A += "video"); let L = { data1: c, startPTS: T, startDTS: T, endPTS: y, endDTS: y, type: A, hasAudio: v, hasVideo: S, nb: 1, dropped: 0 }; return u.audio = "audio" === L.type ? L : void 0, u.video = "audio" !== L.type ? L : void 0, u.initSegment = f, u.id3 = flushTextTrackMetadataCueSamples(i, s, h, h), r.samples.length && (u.text = flushTextTrackUserdataCueSamples(r, s, h)), u } } }, { demux: TSDemuxer, remux: MP4Remuxer }, { demux: class extends BaseAudioDemuxer { constructor(e, t) { super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t } resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } static probe(e) { if (!e) return !1; let t = getID3Data(e, 0), i = (null == t ? void 0 : t.length) || 0; if (probe(e, i)) return !1; for (let t = e.length; i < t; i++)if (function (e, t) { if (isHeader$1(e, t)) { let i = getHeaderLength(e, t); if (t + i >= e.length) return !1; let r = getFullFrameLength(e, t); if (r <= i) return !1; let s = t + r; return s === e.length || isHeader$1(e, s) } return !1 }(e, i)) return M.log("ADTS sync word found !"), !0; return !1 } canParse(e, t) { return t + 5 < e.length && isHeaderPattern$1(e, t) && getFullFrameLength(e, t) <= e.length - t } appendFrame(e, t, i) { initTrackConfig(e, this.observer, t, i, e.manifestCodec); let r = appendFrame$2(e, t, i, this.basePTS, this.frameIndex); if (r && 0 === r.missing) return r } }, remux: MP4Remuxer }, { demux: class extends BaseAudioDemuxer { resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } static probe(e) { if (!e) return !1; let t = getID3Data(e, 0), i = (null == t ? void 0 : t.length) || 0; if (t && 11 === e[i] && 119 === e[i + 1] && void 0 !== getTimeStamp(t) && 16 >= getAudioBSID(e, i)) return !1; for (let t = e.length; i < t; i++)if (probe(e, i)) return M.log("MPEG Audio sync word found !"), !0; return !1 } canParse(e, t) { return isHeaderPattern(e, t) && 4 <= e.length - t } appendFrame(e, t, i) { if (null !== this.basePTS) return appendFrame$1(e, t, i, this.basePTS, this.frameIndex) } }, remux: MP4Remuxer }]; eR.splice(2, 0, { demux: class extends BaseAudioDemuxer { constructor(e) { super(), this.observer = void 0, this.observer = e } resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/ac-3", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "ac3", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } canParse(e, t) { return t + 64 < e.length } appendFrame(e, t, i) { let r = appendFrame(e, t, i, this.basePTS, this.frameIndex); if (-1 !== r) { let t = e.samples[e.samples.length - 1]; return { sample: t, length: r, missing: 0 } } } static probe(e) { if (!e) return !1; let t = getID3Data(e, 0); if (!t) return !1; let i = t.length; return !!(11 === e[i] && 119 === e[i + 1] && void 0 !== getTimeStamp(t) && 16 > getAudioBSID(e, i)) } }, remux: MP4Remuxer }); let Transmuxer = class Transmuxer { constructor(e, t, i, r, s) { this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.vendor = r, this.id = s } configure(e) { this.transmuxConfig = e, this.decrypter && this.decrypter.reset() } push(e, t, i, r) { let a; let n = i.transmuxing; n.executeStart = s(); let l = new Uint8Array(e), { currentTransmuxState: o, transmuxConfig: h } = this; r && (this.currentTransmuxState = r); let { contiguous: d, discontinuity: u, trackSwitch: c, accurateTimeOffset: f, timeOffset: g, initSegmentChange: m } = r || o, { audioCodec: p, videoCodec: E, defaultInitPts: T, duration: y, initSegmentData: v } = h, S = (a = null, l.byteLength > 0 && (null == t ? void 0 : t.key) != null && null !== t.iv && null != t.method && (a = t), a); if (S && "AES-128" === S.method) { let e = this.getDecrypter(); if (!e.isSync()) return this.decryptionPromise = e.webCryptoDecrypt(l, S.key.buffer, S.iv.buffer).then(e => { let t = this.push(e, null, i); return this.decryptionPromise = null, t }), this.decryptionPromise; { let t = e.softwareDecrypt(l, S.key.buffer, S.iv.buffer), r = i.part > -1; if (r && (t = e.flush()), !t) return n.executeEnd = s(), emptyResult(i); l = new Uint8Array(t) } } let A = this.needsProbing(u, c); if (A) { let e = this.configureTransmuxer(l); if (e) return M.warn(`[transmuxer] ${e.message}`), this.observer.emit(b.ERROR, b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, fatal: !1, error: e, reason: e.message }), n.executeEnd = s(), emptyResult(i) } (u || c || m || A) && this.resetInitSegment(v, p, E, y, t), (u || m || A) && this.resetInitialTimestamp(T), d || this.resetContiguity(); let L = this.transmux(l, S, g, f, i), R = this.currentTransmuxState; return R.contiguous = !0, R.discontinuity = !1, R.trackSwitch = !1, n.executeEnd = s(), L } flush(e) { let t = e.transmuxing; t.executeStart = s(); let { decrypter: i, currentTransmuxState: r, decryptionPromise: a } = this; if (a) return a.then(() => this.flush(e)); let n = [], { timeOffset: l } = r; if (i) { let t = i.flush(); t && n.push(this.push(t, null, e)) } let { demuxer: o, remuxer: h } = this; if (!o || !h) return t.executeEnd = s(), [emptyResult(e)]; let d = o.flush(l); return isPromise(d) ? d.then(t => (this.flushRemux(n, t, e), n)) : (this.flushRemux(n, d, e), n) } flushRemux(e, t, i) { let { audioTrack: r, videoTrack: a, id3Track: n, textTrack: l } = t, { accurateTimeOffset: o, timeOffset: h } = this.currentTransmuxState; M.log(`[transmuxer.ts]: Flushed fragment ${i.sn}${i.part > -1 ? " p: " + i.part : ""} of level ${i.level}`); let d = this.remuxer.remux(r, a, n, l, h, o, !0, this.id); e.push({ remuxResult: d, chunkMeta: i }), i.transmuxing.executeEnd = s() } resetInitialTimestamp(e) { let { demuxer: t, remuxer: i } = this; t && i && (t.resetTimeStamp(e), i.resetTimeStamp(e)) } resetContiguity() { let { demuxer: e, remuxer: t } = this; e && t && (e.resetContiguity(), t.resetNextTimestamp()) } resetInitSegment(e, t, i, r, s) { let { demuxer: a, remuxer: n } = this; a && n && (a.resetInitSegment(e, t, i, r), n.resetInitSegment(e, t, i, s)) } destroy() { this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0) } transmux(e, t, i, r, s) { return t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, i, r, s) : this.transmuxUnencrypted(e, i, r, s) } transmuxUnencrypted(e, t, i, r) { let { audioTrack: s, videoTrack: a, id3Track: n, textTrack: l } = this.demuxer.demux(e, t, !1, !this.config.progressive), o = this.remuxer.remux(s, a, n, l, t, i, !1, this.id); return { remuxResult: o, chunkMeta: r } } transmuxSampleAes(e, t, i, r, s) { return this.demuxer.demuxSampleAes(e, t, i).then(e => { let t = this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, i, r, !1, this.id); return { remuxResult: t, chunkMeta: s } }) } configureTransmuxer(e) { let t; let { config: i, observer: r, typeSupported: s, vendor: a } = this; for (let i = 0, r = eR.length; i < r; i++) { var n; if (null != (n = eR[i].demux) && n.probe(e)) { t = eR[i]; break } } if (!t) return Error("Failed to find demuxer by probing fragment data"); let l = this.demuxer, o = this.remuxer, h = t.remux, d = t.demux; o && o instanceof h || (this.remuxer = new h(r, i, s, a)), l && l instanceof d || (this.demuxer = new d(r, i, s), this.probe = d.probe) } needsProbing(e, t) { return !this.demuxer || !this.remuxer || e || t } getDecrypter() { let e = this.decrypter; return e || (e = this.decrypter = new Decrypter(this.config)), e } }; let emptyResult = e => ({ remuxResult: {}, chunkMeta: e }); function isPromise(e) { return "then" in e && e.then instanceof Function } let TransmuxConfig = class TransmuxConfig { constructor(e, t, i, r, s) { this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = r, this.defaultInitPts = s || null } }; let TransmuxState = class TransmuxState { constructor(e, t, i, r, s, a) { this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = r, this.timeOffset = s, this.initSegmentChange = a } }; var eI = { exports: {} }; !function (e) { var t = Object.prototype.hasOwnProperty, i = "~"; function Events() { } function EE(e, t, i) { this.fn = e, this.context = t, this.once = i || !1 } function addListener(e, t, r, s, a) { if ("function" != typeof r) throw TypeError("The listener must be a function"); var n = new EE(r, s || e, a), l = i ? i + t : t; return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], n] : e._events[l].push(n) : (e._events[l] = n, e._eventsCount++), e } function clearEvent(e, t) { 0 == --e._eventsCount ? e._events = new Events : delete e._events[t] } function EventEmitter() { this._events = new Events, this._eventsCount = 0 } Object.create && (Events.prototype = Object.create(null), new Events().__proto__ || (i = !1)), EventEmitter.prototype.eventNames = function () { var e, r, s = []; if (0 === this._eventsCount) return s; for (r in e = this._events) t.call(e, r) && s.push(i ? r.slice(1) : r); return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(e)) : s }, EventEmitter.prototype.listeners = function (e) { var t = i ? i + e : e, r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var s = 0, a = r.length, n = Array(a); s < a; s++)n[s] = r[s].fn; return n }, EventEmitter.prototype.listenerCount = function (e) { var t = i ? i + e : e, r = this._events[t]; return r ? r.fn ? 1 : r.length : 0 }, EventEmitter.prototype.emit = function (e, t, r, s, a, n) { var l = i ? i + e : e; if (!this._events[l]) return !1; var o, h, d = this._events[l], u = arguments.length; if (d.fn) { switch (d.once && this.removeListener(e, d.fn, void 0, !0), u) { case 1: return d.fn.call(d.context), !0; case 2: return d.fn.call(d.context, t), !0; case 3: return d.fn.call(d.context, t, r), !0; case 4: return d.fn.call(d.context, t, r, s), !0; case 5: return d.fn.call(d.context, t, r, s, a), !0; case 6: return d.fn.call(d.context, t, r, s, a, n), !0 }for (h = 1, o = Array(u - 1); h < u; h++)o[h - 1] = arguments[h]; d.fn.apply(d.context, o) } else { var c, f = d.length; for (h = 0; h < f; h++)switch (d[h].once && this.removeListener(e, d[h].fn, void 0, !0), u) { case 1: d[h].fn.call(d[h].context); break; case 2: d[h].fn.call(d[h].context, t); break; case 3: d[h].fn.call(d[h].context, t, r); break; case 4: d[h].fn.call(d[h].context, t, r, s); break; default: if (!o) for (c = 1, o = Array(u - 1); c < u; c++)o[c - 1] = arguments[c]; d[h].fn.apply(d[h].context, o) } } return !0 }, EventEmitter.prototype.on = function (e, t, i) { return addListener(this, e, t, i, !1) }, EventEmitter.prototype.once = function (e, t, i) { return addListener(this, e, t, i, !0) }, EventEmitter.prototype.removeListener = function (e, t, r, s) { var a = i ? i + e : e; if (!this._events[a]) return this; if (!t) return clearEvent(this, a), this; var n = this._events[a]; if (n.fn) n.fn !== t || s && !n.once || r && n.context !== r || clearEvent(this, a); else { for (var l = 0, o = [], h = n.length; l < h; l++)(n[l].fn !== t || s && !n[l].once || r && n[l].context !== r) && o.push(n[l]); o.length ? this._events[a] = 1 === o.length ? o[0] : o : clearEvent(this, a) } return this }, EventEmitter.prototype.removeAllListeners = function (e) { var t; return e ? (t = i ? i + e : e, this._events[t] && clearEvent(this, t)) : (this._events = new Events, this._eventsCount = 0), this }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = i, EventEmitter.EventEmitter = EventEmitter, e.exports = EventEmitter }(eI); var eD = (m = eI.exports) && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m; let TransmuxerInterface = class TransmuxerInterface {
      constructor(e, t, i, r) { this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0; let s = e.config; this.hls = e, this.id = t, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = i, this.onFlush = r; let forwardMessage = (e, t) => { (t = t || {}).frag = this.frag, t.id = this.id, e === b.ERROR && (this.error = t.error), this.hls.trigger(e, t) }; this.observer = new eD, this.observer.on(b.FRAG_DECRYPTED, forwardMessage), this.observer.on(b.ERROR, forwardMessage); let a = getMediaSource(s.preferManagedMediaSource) || { isTypeSupported: () => !1 }, n = { mpeg: a.isTypeSupported("audio/mpeg"), mp3: a.isTypeSupported('audio/mp4; codecs="mp3"'), ac3: a.isTypeSupported('audio/mp4; codecs="ac-3"') }, l = navigator.vendor; if (this.useWorker && "undefined" != typeof Worker) { let e = s.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__; if (e) { try { s.workerPath ? (M.log(`loading Web Worker ${s.workerPath} for "${t}"`), this.workerContext = function (e) { let t = new self.URL(e, self.location.href).href, i = new self.Worker(t); return { worker: i, scriptURL: t } }(s.workerPath)) : (M.log(`injecting Web Worker for "${t}"`), this.workerContext = function () { let e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], { type: "text/javascript" }), t = self.URL.createObjectURL(e), i = new self.Worker(t); return { worker: i, objectURL: t } }()), this.onwmsg = e => this.onWorkerMessage(e); let { worker: e } = this.workerContext; e.addEventListener("message", this.onwmsg), e.onerror = e => { let i = Error(`${e.message}  (${e.filename}:${e.lineno})`); s.enableWorker = !1, M.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(b.ERROR, { type: C.OTHER_ERROR, details: k.INTERNAL_EXCEPTION, fatal: !1, event: "demuxerWorker", error: i }) }, e.postMessage({ cmd: "init", typeSupported: n, vendor: l, id: t, config: JSON.stringify(s) }) } catch (e) { M.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new Transmuxer(this.observer, n, s, l, t) } return } } this.transmuxer = new Transmuxer(this.observer, n, s, l, t) } resetWorker() { if (this.workerContext) { let { worker: e, objectURL: t } = this.workerContext; t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null } } destroy() { if (this.workerContext) this.resetWorker(), this.onwmsg = void 0; else { let e = this.transmuxer; e && (e.destroy(), this.transmuxer = null) } let e = this.observer; e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null } push(e, t, i, r, s, a, n, l, o, h) {
        var d, u; o.transmuxing.start = self.performance.now(); let { transmuxer: c } = this, f = a ? a.start : s.start, g = s.decryptdata, m = this.frag, p = !(m && s.cc === m.cc), E = !(m && o.level === m.level), T = m ? o.sn - m.sn : -1, y = this.part ? o.part - this.part.index : -1, v = 0 === T && o.id > 1 && o.id === (null == m ? void 0 : m.stats.chunkCount), S = !E && (1 === T || 0 === T && (1 === y || v && y <= 0)), A = self.performance.now(); (E || T || 0 === s.stats.parsing.start) && (s.stats.parsing.start = A), a && (y || !S) && (a.stats.parsing.start = A); let L = !(m && (null == (d = s.initSegment) ? void 0 : d.url) === (null == (u = m.initSegment) ? void 0 : u.url)), R = new TransmuxState(p, S, l, E, f, L); if (!S || p || L) {
          M.log(`[transmuxer-interface, ${s.type}]: Starting new transmux session for sn: ${o.sn} p: ${o.part} level: ${o.level} id: ${o.id}
          discontinuity: ${p}
          trackSwitch: ${E}
          contiguous: ${S}
          accurateTimeOffset: ${l}
          timeOffset: ${f}
          initSegmentChange: ${L}`); let e = new TransmuxConfig(i, r, t, n, h); this.configureTransmuxer(e)
        } if (this.frag = s, this.part = a, this.workerContext) this.workerContext.worker.postMessage({ cmd: "demux", data: e, decryptdata: g, chunkMeta: o, state: R }, e instanceof ArrayBuffer ? [e] : []); else if (c) { let t = c.push(e, g, o, R); isPromise(t) ? (c.async = !0, t.then(e => { this.handleTransmuxComplete(e) }).catch(e => { this.transmuxerError(e, o, "transmuxer-interface push error") })) : (c.async = !1, this.handleTransmuxComplete(t)) }
      } flush(e) { e.transmuxing.start = self.performance.now(); let { transmuxer: t } = this; if (this.workerContext) this.workerContext.worker.postMessage({ cmd: "flush", chunkMeta: e }); else if (t) { let i = t.flush(e), r = isPromise(i); r || t.async ? (isPromise(i) || (i = Promise.resolve(i)), i.then(t => { this.handleFlushResult(t, e) }).catch(t => { this.transmuxerError(t, e, "transmuxer-interface flush error") })) : this.handleFlushResult(i, e) } } transmuxerError(e, t, i) { this.hls && (this.error = e, this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_PARSING_ERROR, chunkMeta: t, fatal: !1, error: e, err: e, reason: i })) } handleFlushResult(e, t) { e.forEach(e => { this.handleTransmuxComplete(e) }), this.onFlush(t) } onWorkerMessage(e) { let t = e.data, i = this.hls; switch (t.event) { case "init": { var r; let e = null == (r = this.workerContext) ? void 0 : r.objectURL; e && self.URL.revokeObjectURL(e); break } case "transmuxComplete": this.handleTransmuxComplete(t.data); break; case "flush": this.onFlush(t.data); break; case "workerLog": M[t.data.logType] && M[t.data.logType](t.data.message); break; default: t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, i.trigger(t.event, t.data) } } configureTransmuxer(e) { let { transmuxer: t } = this; this.workerContext ? this.workerContext.worker.postMessage({ cmd: "configure", config: e }) : t && t.configure(e) } handleTransmuxComplete(e) { e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e) }
    }; function subtitleOptionsIdentical(e, t) { if (e.length !== t.length) return !1; for (let i = 0; i < e.length; i++)if (!mediaAttributesIdentical(e[i].attrs, t[i].attrs)) return !1; return !0 } function mediaAttributesIdentical(e, t, i) { let r = e["STABLE-RENDITION-ID"]; return r && !i ? r === t["STABLE-RENDITION-ID"] : !(i || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(i => e[i] !== t[i]) } function subtitleTrackMatchesTextTrack(e, t) { return t.label.toLowerCase() === e.name.toLowerCase() && (!t.language || t.language.toLowerCase() === (e.lang || "").toLowerCase()) } let BufferableInstance = class BufferableInstance { constructor(e) { this.buffered = void 0; let getRange = (t, i, r) => { if ((i >>>= 0) > r - 1) throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${r})`); return e[i][t] }; this.buffered = { get length() { return e.length }, end: t => getRange("end", t, e.length), start: t => getRange("start", t, e.length) } } }; let BufferOperationQueue = class BufferOperationQueue { constructor(e) { this.buffers = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.buffers = e } append(e, t, i) { let r = this.queues[t]; r.push(e), 1 !== r.length || i || this.executeNext(t) } insertAbort(e, t) { let i = this.queues[t]; i.unshift(e), this.executeNext(t) } appendBlocker(e) { let t; let i = new Promise(e => { t = e }), r = { execute: t, onStart: () => { }, onComplete: () => { }, onError: () => { } }; return this.append(r, e), i } executeNext(e) { let t = this.queues[e]; if (t.length) { let i = t[0]; try { i.execute() } catch (r) { M.warn(`[buffer-operation-queue]: Exception executing "${e}" SourceBuffer operation: ${r}`), i.onError(r); let t = this.buffers[e]; null != t && t.updating || this.shiftAndExecuteNext(e) } } } shiftAndExecuteNext(e) { this.queues[e].shift(), this.executeNext(e) } current(e) { return this.queues[e][0] } }; let eb = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/; function removeSourceChildren(e) { let t = e.querySelectorAll("source");[].slice.call(t).forEach(t => { e.removeChild(t) }) } let eC = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, getCharForByte = function (e) { let t = e; return eC.hasOwnProperty(e) && (t = eC[e]), String.fromCharCode(t) }, ek = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, eP = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, e_ = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, eM = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, ex = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"]; let CaptionsLogger = class CaptionsLogger { constructor() { this.time = null, this.verboseLevel = 0 } log(e, t) { if (this.verboseLevel >= e) { let i = "function" == typeof t ? t() : t; M.log(`${this.time} [${e}] ${i}`) } } }; let numArrayToHexArray = function (e) { let t = []; for (let i = 0; i < e.length; i++)t.push(e[i].toString(16)); return t }; let PenState = class PenState { constructor() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } reset() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } setStyles(e) { let t = ["foreground", "underline", "italics", "background", "flash"]; for (let i = 0; i < t.length; i++) { let r = t[i]; e.hasOwnProperty(r) && (this[r] = e[r]) } } isDefault() { return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash } equals(e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash } copy(e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash } toString() { return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash } }; let StyledUnicodeChar = class StyledUnicodeChar { constructor() { this.uchar = " ", this.penState = new PenState } reset() { this.uchar = " ", this.penState.reset() } setChar(e, t) { this.uchar = e, this.penState.copy(t) } setPenState(e) { this.penState.copy(e) } equals(e) { return this.uchar === e.uchar && this.penState.equals(e.penState) } copy(e) { this.uchar = e.uchar, this.penState.copy(e.penState) } isEmpty() { return " " === this.uchar && this.penState.isDefault() } }; let Row = class Row { constructor(e) { this.chars = [], this.pos = 0, this.currPenState = new PenState, this.cueStartTime = null, this.logger = void 0; for (let e = 0; e < 100; e++)this.chars.push(new StyledUnicodeChar); this.logger = e } equals(e) { for (let t = 0; t < 100; t++)if (!this.chars[t].equals(e.chars[t])) return !1; return !0 } copy(e) { for (let t = 0; t < 100; t++)this.chars[t].copy(e.chars[t]) } isEmpty() { let e = !0; for (let t = 0; t < 100; t++)if (!this.chars[t].isEmpty()) { e = !1; break } return e } setCursor(e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > 100 && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = 100) } moveCursor(e) { let t = this.pos + e; if (e > 1) for (let e = this.pos + 1; e < t + 1; e++)this.chars[e].setPenState(this.currPenState); this.setCursor(t) } backSpace() { this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState) } insertChar(e) { e >= 144 && this.backSpace(); let t = getCharForByte(e); if (this.pos >= 100) { this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!"); return } this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1) } clearFromPos(e) { let t; for (t = e; t < 100; t++)this.chars[t].reset() } clear() { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() } clearToEndOfRow() { this.clearFromPos(this.pos) } getTextString() { let e = [], t = !0; for (let i = 0; i < 100; i++) { let r = this.chars[i].uchar; " " !== r && (t = !1), e.push(r) } return t ? "" : e.join("") } setPenStyles(e) { this.currPenState.setStyles(e); let t = this.chars[this.pos]; t.setPenState(this.currPenState) } }; let CaptionScreen = class CaptionScreen { constructor(e) { this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0; for (let t = 0; t < 15; t++)this.rows.push(new Row(e)); this.logger = e } reset() { for (let e = 0; e < 15; e++)this.rows[e].clear(); this.currRow = 14 } equals(e) { let t = !0; for (let i = 0; i < 15; i++)if (!this.rows[i].equals(e.rows[i])) { t = !1; break } return t } copy(e) { for (let t = 0; t < 15; t++)this.rows[t].copy(e.rows[t]) } isEmpty() { let e = !0; for (let t = 0; t < 15; t++)if (!this.rows[t].isEmpty()) { e = !1; break } return e } backSpace() { let e = this.rows[this.currRow]; e.backSpace() } clearToEndOfRow() { let e = this.rows[this.currRow]; e.clearToEndOfRow() } insertChar(e) { let t = this.rows[this.currRow]; t.insertChar(e) } setPen(e) { let t = this.rows[this.currRow]; t.setPenStyles(e) } moveCursor(e) { let t = this.rows[this.currRow]; t.moveCursor(e) } setCursor(e) { this.logger.log(2, "setCursor: " + e); let t = this.rows[this.currRow]; t.setCursor(e) } setPAC(e) { this.logger.log(2, () => "pacData = " + JSON.stringify(e)); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let e = 0; e < 15; e++)this.rows[e].clear(); let e = this.currRow + 1 - this.nrRollUpRows, i = this.lastOutputScreen; if (i) { let r = i.rows[e].cueStartTime, s = this.logger.time; if (null !== r && null !== s && r < s) for (let r = 0; r < this.nrRollUpRows; r++)this.rows[t - this.nrRollUpRows + r + 1].copy(i.rows[e + r]) } } this.currRow = t; let i = this.rows[this.currRow]; if (null !== e.indent) { let t = e.indent, r = Math.max(t - 1, 0); i.setCursor(e.indent), e.color = i.chars[r].penState.foreground } let r = { foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1 }; this.setPen(r) } setBkgData(e) { this.logger.log(2, () => "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32) } setRollUpRows(e) { this.nrRollUpRows = e } rollUp() { if (null === this.nrRollUpRows) { this.logger.log(3, "roll_up but nrRollUpRows not set yet"); return } this.logger.log(1, () => this.getDisplayText()); let e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0]; t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up") } getDisplayText(e) { e = e || !1; let t = [], i = "", r = -1; for (let i = 0; i < 15; i++) { let s = this.rows[i].getTextString(); s && (r = i + 1, e ? t.push("Row " + r + ": '" + s + "'") : t.push(s.trim())) } return t.length > 0 && (i = e ? "[" + t.join(" | ") + "]" : t.join("\n")), i } getTextAndFormat() { return this.rows } }; let Cea608Channel = class Cea608Channel { constructor(e, t, i) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new CaptionScreen(i), this.nonDisplayedMemory = new CaptionScreen(i), this.lastOutputScreen = new CaptionScreen(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i } reset() { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null } getHandler() { return this.outputFilter } setHandler(e) { this.outputFilter = e } setPAC(e) { this.writeScreen.setPAC(e) } setBkgData(e) { this.writeScreen.setBkgData(e) } setMode(e) { e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) } insertChars(e) { for (let t = 0; t < e.length; t++)this.writeScreen.insertChar(e[t]); let t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP"; this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), ("MODE_PAINT-ON" === this.mode || "MODE_ROLL-UP" === this.mode) && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) } ccRCL() { this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON") } ccBS() { this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()) } ccAOF() { } ccAON() { } ccDER() { this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() } ccRU(e) { this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e) } ccFON() { this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 }) } ccRDC() { this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON") } ccTR() { this.logger.log(2, "TR"), this.setMode("MODE_TEXT") } ccRTD() { this.logger.log(2, "RTD"), this.setMode("MODE_TEXT") } ccEDM() { this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0) } ccCR() { this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0) } ccENM() { this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset() } ccEOC() { if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) { let e = this.displayedMemory; this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText()) } this.outputDataUpdate(!0) } ccTO(e) { this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e) } ccMIDROW(e) { let t = { flash: !1 }; if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white"; else { let i = Math.floor(e / 2) - 16; t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][i] } this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t) } outputDataUpdate(e = !1) { let t = this.logger.time; null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory)) } cueSplitAtTime(e) { this.outputFilter && !this.displayedMemory.isEmpty() && (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e) } }; let Cea608Parser = class Cea608Parser { constructor(e, t, i) { this.channels = void 0, this.currentChannel = 0, this.cmdHistory = createCmdHistory(), this.logger = void 0; let r = this.logger = new CaptionsLogger; this.channels = [null, new Cea608Channel(e, t, r), new Cea608Channel(e + 1, i, r)] } getHandler(e) { return this.channels[e].getHandler() } setHandler(e, t) { this.channels[e].setHandler(t) } addData(e, t) { let i, r, s; let a = !1; this.logger.time = e; for (let e = 0; e < t.length; e += 2)if (r = 127 & t[e], s = 127 & t[e + 1], 0 !== r || 0 !== s) { if (this.logger.log(3, "[" + numArrayToHexArray([t[e], t[e + 1]]) + "] -> (" + numArrayToHexArray([r, s]) + ")"), (i = this.parseCmd(r, s)) || (i = this.parseMidrow(r, s)), i || (i = this.parsePAC(r, s)), i || (i = this.parseBackgroundAttributes(r, s)), !i && (a = this.parseChars(r, s))) { let e = this.currentChannel; if (e && e > 0) { let t = this.channels[e]; t.insertChars(a) } else this.logger.log(2, "No channel found yet. TEXT-MODE?") } i || a || this.logger.log(2, "Couldn't parse cleaned data " + numArrayToHexArray([r, s]) + " orig: " + numArrayToHexArray([t[e], t[e + 1]])) } } parseCmd(e, t) { let { cmdHistory: i } = this, r = (20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47, s = (23 === e || 31 === e) && t >= 33 && t <= 35; if (!(r || s)) return !1; if (hasCmdRepeated(e, t, i)) return setLastCmd(null, null, i), this.logger.log(3, "Repeated command (" + numArrayToHexArray([e, t]) + ") is dropped"), !0; let a = 20 === e || 21 === e || 23 === e ? 1 : 2, n = this.channels[a]; return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? n.ccRCL() : 33 === t ? n.ccBS() : 34 === t ? n.ccAOF() : 35 === t ? n.ccAON() : 36 === t ? n.ccDER() : 37 === t ? n.ccRU(2) : 38 === t ? n.ccRU(3) : 39 === t ? n.ccRU(4) : 40 === t ? n.ccFON() : 41 === t ? n.ccRDC() : 42 === t ? n.ccTR() : 43 === t ? n.ccRTD() : 44 === t ? n.ccEDM() : 45 === t ? n.ccCR() : 46 === t ? n.ccENM() : 47 === t && n.ccEOC() : n.ccTO(t - 32), setLastCmd(e, t, i), this.currentChannel = a, !0 } parseMidrow(e, t) { let i = 0; if ((17 === e || 25 === e) && t >= 32 && t <= 47) { if ((i = 17 === e ? 1 : 2) !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1; let r = this.channels[i]; return !!r && (r.ccMIDROW(t), this.logger.log(3, "MIDROW (" + numArrayToHexArray([e, t]) + ")"), !0) } return !1 } parsePAC(e, t) { let i; let r = this.cmdHistory, s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, a = (16 === e || 24 === e) && t >= 64 && t <= 95; if (!(s || a)) return !1; if (hasCmdRepeated(e, t, r)) return setLastCmd(null, null, r), !0; let n = e <= 23 ? 1 : 2; i = t >= 64 && t <= 95 ? 1 === n ? ek[e] : e_[e] : 1 === n ? eP[e] : eM[e]; let l = this.channels[n]; return !!l && (l.setPAC(this.interpretPAC(i, t)), setLastCmd(e, t, r), this.currentChannel = n, !0) } interpretPAC(e, t) { let i; let r = { color: null, italics: !1, indent: null, underline: !1, row: e }; return i = t > 95 ? t - 96 : t - 64, r.underline = (1 & i) == 1, i <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((i - 16) / 2), r } parseChars(e, t) { let i; let r = null, s = null; if (e >= 25 ? (i = 2, s = e - 8) : (i = 1, s = e), s >= 17 && s <= 19) { let e; e = 17 === s ? t + 80 : 18 === s ? t + 112 : t + 144, this.logger.log(2, "Special char '" + getCharForByte(e) + "' in channel " + i), r = [e] } else e >= 32 && e <= 127 && (r = 0 === t ? [e] : [e, t]); if (r) { let i = numArrayToHexArray(r); this.logger.log(3, "Char codes =  " + i.join(",")), setLastCmd(e, t, this.cmdHistory) } return r } parseBackgroundAttributes(e, t) { let i; let r = (16 === e || 24 === e) && t >= 32 && t <= 47, s = (23 === e || 31 === e) && t >= 45 && t <= 47; if (!(r || s)) return !1; let a = {}; 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), a.background = ex[i], t % 2 == 1 && (a.background = a.background + "_semi")) : 45 === t ? a.background = "transparent" : (a.foreground = "black", 47 === t && (a.underline = !0)); let n = e <= 23 ? 1 : 2, l = this.channels[n]; return l.setBkgData(a), setLastCmd(e, t, this.cmdHistory), !0 } reset() { for (let e = 0; e < Object.keys(this.channels).length; e++) { let t = this.channels[e]; t && t.reset() } this.cmdHistory = createCmdHistory() } cueSplitAtTime(e) { for (let t = 0; t < this.channels.length; t++) { let i = this.channels[t]; i && i.cueSplitAtTime(e) } } }; function setLastCmd(e, t, i) { i.a = e, i.b = t } function hasCmdRepeated(e, t, i) { return i.a === e && i.b === t } function createCmdHistory() { return { a: null, b: null } } let OutputFilter = class OutputFilter { constructor(e, t) { this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t } dispatchCue() { null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null) } newCue(e, t, i) { (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName) } reset() { this.cueRanges = [], this.startTime = null } }; var ew = function () { if (null != O && O.VTTCue) return self.VTTCue; let e = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"]; function isAllowedValue(e, t) { if ("string" != typeof t || !Array.isArray(e)) return !1; let i = t.toLowerCase(); return !!~e.indexOf(i) && i } function extend(e, ...t) { let i = 1; for (; i < arguments.length; i++) { let t = arguments[i]; for (let i in t) e[i] = t[i] } return e } function VTTCue(i, r, s) { let a = { enumerable: !0 }; this.hasBeenReset = !1; let n = "", l = !1, o = i, h = r, d = s, u = null, c = "", f = !0, g = "auto", m = "start", p = 50, E = "middle", T = 50, y = "middle"; Object.defineProperty(this, "id", extend({}, a, { get: function () { return n }, set: function (e) { n = "" + e } })), Object.defineProperty(this, "pauseOnExit", extend({}, a, { get: function () { return l }, set: function (e) { l = !!e } })), Object.defineProperty(this, "startTime", extend({}, a, { get: function () { return o }, set: function (e) { if ("number" != typeof e) throw TypeError("Start time must be set to a number."); o = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "endTime", extend({}, a, { get: function () { return h }, set: function (e) { if ("number" != typeof e) throw TypeError("End time must be set to a number."); h = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "text", extend({}, a, { get: function () { return d }, set: function (e) { d = "" + e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "region", extend({}, a, { get: function () { return u }, set: function (e) { u = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "vertical", extend({}, a, { get: function () { return c }, set: function (t) { let i = isAllowedValue(e, t); if (!1 === i) throw SyntaxError("An invalid or illegal string was specified."); c = i, this.hasBeenReset = !0 } })), Object.defineProperty(this, "snapToLines", extend({}, a, { get: function () { return f }, set: function (e) { f = !!e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "line", extend({}, a, { get: function () { return g }, set: function (e) { if ("number" != typeof e && "auto" !== e) throw SyntaxError("An invalid number or illegal string was specified."); g = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "lineAlign", extend({}, a, { get: function () { return m }, set: function (e) { let i = isAllowedValue(t, e); if (!i) throw SyntaxError("An invalid or illegal string was specified."); m = i, this.hasBeenReset = !0 } })), Object.defineProperty(this, "position", extend({}, a, { get: function () { return p }, set: function (e) { if (e < 0 || e > 100) throw Error("Position must be between 0 and 100."); p = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "positionAlign", extend({}, a, { get: function () { return E }, set: function (e) { let i = isAllowedValue(t, e); if (!i) throw SyntaxError("An invalid or illegal string was specified."); E = i, this.hasBeenReset = !0 } })), Object.defineProperty(this, "size", extend({}, a, { get: function () { return T }, set: function (e) { if (e < 0 || e > 100) throw Error("Size must be between 0 and 100."); T = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "align", extend({}, a, { get: function () { return y }, set: function (e) { let i = isAllowedValue(t, e); if (!i) throw SyntaxError("An invalid or illegal string was specified."); y = i, this.hasBeenReset = !0 } })), this.displayState = void 0 } return VTTCue.prototype.getCueAsHTML = function () { let e = self.WebVTT; return e.convertCueToDOMTree(self, this.text) }, VTTCue }(); let StringDecoder = class StringDecoder { decode(e, t) { if (!e) return ""; if ("string" != typeof e) throw Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } }; function parseTimeStamp(e) { function computeSeconds(e, t, i, r) { return (0 | e) * 3600 + (0 | t) * 60 + (0 | i) + parseFloat(r || 0) } let t = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/); return t ? parseFloat(t[2]) > 59 ? computeSeconds(t[2], t[3], 0, t[4]) : computeSeconds(t[1], t[2], t[3], t[4]) : null } let Settings = class Settings { constructor() { this.values = Object.create(null) } set(e, t) { this.get(e) || "" === t || (this.values[e] = t) } get(e, t, i) { return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t } has(e) { return e in this.values } alt(e, t, i) { for (let r = 0; r < i.length; ++r)if (t === i[r]) { this.set(e, t); break } } integer(e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) } percent(e, t) { if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) { let i = parseFloat(t); if (i >= 0 && i <= 100) return this.set(e, i), !0 } return !1 } }; function parseOptions(e, t, i, r) { let s = r ? e.split(r) : [e]; for (let e in s) { if ("string" != typeof s[e]) continue; let r = s[e].split(i); if (2 !== r.length) continue; let a = r[0], n = r[1]; t(a, n) } } let eF = new ew(0, 0, ""), eO = "middle" === eF.align ? "middle" : "center"; function fixLineBreaks(e) { return e.replace(/<br(?: \/)?>/gi, "\n") } let VTTParser = class VTTParser { constructor() { this.state = "INITIAL", this.buffer = "", this.decoder = new StringDecoder, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0 } parse(e) { let t = this; function collectNextLine() { let e = t.buffer, i = 0; for (e = fixLineBreaks(e); i < e.length && "\r" !== e[i] && "\n" !== e[i];)++i; let r = e.slice(0, i); return "\r" === e[i] && ++i, "\n" === e[i] && ++i, t.buffer = e.slice(i), r } e && (t.buffer += t.decoder.decode(e, { stream: !0 })); try { let e = ""; if ("INITIAL" === t.state) { if (!/\r\n|\n/.test(t.buffer)) return this; e = collectNextLine(); let i = e.match(/^()?WEBVTT([ \t].*)?$/); if (!(null != i && i[0])) throw Error("Malformed WebVTT signature."); t.state = "HEADER" } let r = !1; for (; t.buffer && /\r\n|\n/.test(t.buffer);)switch (r ? r = !1 : e = collectNextLine(), t.state) { case "HEADER": if (/:/.test(e)) { var i; i = e, parseOptions(i, function (e, t) { }, /:/) } else e || (t.state = "ID"); continue; case "NOTE": e || (t.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(e)) { t.state = "NOTE"; break } if (!e) continue; if (t.cue = new ew(0, 0, ""), t.state = "CUE", -1 === e.indexOf("-->")) { t.cue.id = e; continue } case "CUE": if (!t.cue) { t.state = "BADCUE"; continue } try { !function (e, t, i) { let r = e; function consumeTimeStamp() { let t = parseTimeStamp(e); if (null === t) throw Error("Malformed timestamp: " + r); return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t } function skipWhitespace() { e = e.replace(/^\s+/, "") } if (skipWhitespace(), t.startTime = consumeTimeStamp(), skipWhitespace(), "-->" !== e.slice(0, 3)) throw Error("Malformed time stamp (time stamps must be separated by '-->'): " + r); e = e.slice(3), skipWhitespace(), t.endTime = consumeTimeStamp(), skipWhitespace(), function (e, t) { let r = new Settings; parseOptions(e, function (e, t) { let s; switch (e) { case "region": for (let s = i.length - 1; s >= 0; s--)if (i[s].id === t) { r.set(e, i[s].region); break } break; case "vertical": r.alt(e, t, ["rl", "lr"]); break; case "line": s = t.split(","), r.integer(e, s[0]), r.percent(e, s[0]) && r.set("snapToLines", !1), r.alt(e, s[0], ["auto"]), 2 === s.length && r.alt("lineAlign", s[1], ["start", eO, "end"]); break; case "position": s = t.split(","), r.percent(e, s[0]), 2 === s.length && r.alt("positionAlign", s[1], ["start", eO, "end", "line-left", "line-right", "auto"]); break; case "size": r.percent(e, t); break; case "align": r.alt(e, t, ["start", eO, "end", "left", "right"]) } }, /:/, /\s/), t.region = r.get("region", null), t.vertical = r.get("vertical", ""); let s = r.get("line", "auto"); "auto" === s && -1 === eF.line && (s = -1), t.line = s, t.lineAlign = r.get("lineAlign", "start"), t.snapToLines = r.get("snapToLines", !0), t.size = r.get("size", 100), t.align = r.get("align", eO); let a = r.get("position", "auto"); "auto" === a && 50 === eF.position && (a = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = a }(e, t) }(e, t.cue, t.regionList) } catch (e) { t.cue = null, t.state = "BADCUE"; continue } t.state = "CUETEXT"; continue; case "CUETEXT": { let i = -1 !== e.indexOf("-->"); if (!e || i && (r = !0)) { t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID"; continue } if (null === t.cue) continue; t.cue.text && (t.cue.text += "\n"), t.cue.text += e } continue; case "BADCUE": e || (t.state = "ID") } } catch (e) { "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE" } return this } flush() { try { if ((this.cue || "HEADER" === this.state) && (this.buffer += "\n\n", this.parse()), "INITIAL" === this.state || "BADWEBVTT" === this.state) throw Error("Malformed WebVTT signature.") } catch (e) { this.onparsingerror && this.onparsingerror(e) } return this.onflush && this.onflush(), this } }; let eN = /\r\n|\n\r|\n|\r/g, startsWith = function (e, t, i = 0) { return e.slice(i, i + t.length) === t }, cueString2millis = function (e) { let t = parseInt(e.slice(-3)), i = parseInt(e.slice(-6, -4)), r = parseInt(e.slice(-9, -7)), s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0; if (!R(t) || !R(i) || !R(r) || !R(s)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`); return t + (1e3 * i + 6e4 * r + 36e5 * s) }, hash = function (e) { let t = 5381, i = e.length; for (; i;)t = 33 * t ^ e.charCodeAt(--i); return (t >>> 0).toString() }; function generateCueId(e, t, i) { return hash(e.toString()) + hash(t.toString()) + hash(i) } let calculateOffset = function (e, t, i) { let r = e[t], s = e[r.prevCC]; if (!s || !s.new && r.new) { e.ccOffset = e.presentationOffset = r.start, r.new = !1; return } for (; null != (a = s) && a.new;) { var a; e.ccOffset += r.start - s.start, r.new = !1, s = e[(r = s).prevCC] } e.presentationOffset = i }, eU = "stpp.ttml.im1t", eB = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, e$ = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, eG = { left: "start", center: "center", right: "end", start: "start", end: "end" }; function parseIMSC1(e, t, i, r) { let s = findBox(new Uint8Array(e), ["mdat"]); if (0 === s.length) { r(Error("Could not parse IMSC1 mdat")); return } let a = s.map(e => utf8ArrayToStr(e)), n = function (e, t, i = 1, r = !1) { return toTimescaleFromBase(e, 1, 1 / i, r) }(t.baseTime, 0, t.timescale); try { a.forEach(e => i(function (e, t) { let i = new DOMParser, r = i.parseFromString(e, "text/xml"), s = r.getElementsByTagName("tt")[0]; if (!s) throw Error("Invalid ttml"); let a = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }, n = Object.keys(a).reduce((e, t) => (e[t] = s.getAttribute(`ttp:${t}`) || a[t], e), {}), l = "preserve" !== s.getAttribute("xml:space"), o = collectionToDictionary(getElementCollection(s, "styling", "style")), h = collectionToDictionary(getElementCollection(s, "layout", "region")), d = getElementCollection(s, "body", "[begin]"); return [].map.call(d, e => { let i = function getTextContent(e, t) { return [].slice.call(e.childNodes).reduce((e, i, r) => { var s; return "br" === i.nodeName && r ? e + "\n" : null != (s = i.childNodes) && s.length ? getTextContent(i, t) : t ? e + i.textContent.trim().replace(/\s+/g, " ") : e + i.textContent }, "") }(e, l); if (!i || !e.hasAttribute("begin")) return null; let r = parseTtmlTime(e.getAttribute("begin"), n), s = parseTtmlTime(e.getAttribute("dur"), n), a = parseTtmlTime(e.getAttribute("end"), n); if (null === r) throw timestampParsingError(e); if (null === a) { if (null === s) throw timestampParsingError(e); a = r + s } let d = new ew(r - t, a - t, i); d.id = generateCueId(d.startTime, d.endTime, d.text); let u = h[e.getAttribute("region")], c = o[e.getAttribute("style")], f = function (e, t, i) { let r = "http://www.w3.org/ns/ttml#styling", s = null, a = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null; return a && i.hasOwnProperty(a) && (s = i[a]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce((i, a) => { let n = getAttributeNS(t, r, a) || getAttributeNS(e, r, a) || getAttributeNS(s, r, a); return n && (i[a] = n), i }, {}) }(u, c, o), { textAlign: g } = f; if (g) { let e = eG[g]; e && (d.lineAlign = e), d.align = g } return _extends(d, f), d }).filter(e => null !== e) }(e, n))) } catch (e) { r(e) } } function getElementCollection(e, t, i) { let r = e.getElementsByTagName(t)[0]; return r ? [].slice.call(r.querySelectorAll(i)) : [] } function collectionToDictionary(e) { return e.reduce((e, t) => { let i = t.getAttribute("xml:id"); return i && (e[i] = t), e }, {}) } function getAttributeNS(e, t, i) { return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null } function timestampParsingError(e) { return Error(`Could not parse ttml timestamp ${e}`) } function parseTtmlTime(e, t) { if (!e) return null; let i = parseTimeStamp(e); return null === i && (eB.test(e) ? i = function (e, t) { let i = eB.exec(e), r = (0 | i[4]) + (0 | i[5]) / t.subFrameRate; return (0 | i[1]) * 3600 + (0 | i[2]) * 60 + (0 | i[3]) + r / t.frameRate }(e, t) : e$.test(e) && (i = function (e, t) { let i = e$.exec(e), r = Number(i[1]), s = i[2]; switch (s) { case "h": return 3600 * r; case "m": return 60 * r; case "ms": return 1e3 * r; case "f": return r / t.frameRate; case "t": return r / t.tickRate }return r }(e, t))), i } function captionsOrSubtitlesFromCharacteristics(e) { return e.characteristics && /transcribes-spoken-dialog/gi.test(e.characteristics) && /describes-music-and-sound/gi.test(e.characteristics) ? "captions" : "subtitles" } function canReuseVttTextTrack(e, t) { return !!e && e.kind === captionsOrSubtitlesFromCharacteristics(t) && subtitleTrackMatchesTextTrack(t, e) } function newVTTCCs() { return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } } } let CapLevelController = class CapLevelController { constructor(e) { this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners() } setStreamController(e) { this.streamController = e } destroy() { this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null } registerListeners() { let { hls: e } = this; e.on(b.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(b.BUFFER_CODECS, this.onBufferCodecs, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this) } unregisterListener() { let { hls: e } = this; e.off(b.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(b.BUFFER_CODECS, this.onBufferCodecs, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this) } onFpsDropLevelCapping(e, t) { let i = this.hls.levels[t.droppedLevel]; this.isLevelAllowed(i) && this.restrictedLevels.push({ bitrate: i.bitrate, height: i.height, width: i.width }) } onMediaAttaching(e, t) { this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize() } onManifestParsed(e, t) { let i = this.hls; this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping() } onLevelsUpdated(e, t) { this.timer && R(this.autoLevelCapping) && this.detectPlayerSize() } onBufferCodecs(e, t) { let i = this.hls; i.config.capLevelToPlayerSize && t.video && this.startCapping() } onMediaDetaching() { this.stopCapping() } detectPlayerSize() { if (this.media) { if (this.mediaHeight <= 0 || this.mediaWidth <= 0) { this.clientRect = null; return } let e = this.hls.levels; if (e.length) { let t = this.hls, i = this.getMaxLevel(e.length - 1); i !== this.autoLevelCapping && M.log(`Setting autoLevelCapping to ${i}: ${e[i].height}p@${e[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = i, t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping } } } getMaxLevel(e) { let t = this.hls.levels; if (!t.length) return -1; let i = t.filter((t, i) => this.isLevelAllowed(t) && i <= e); return this.clientRect = null, CapLevelController.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight) } startCapping() { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) } stopCapping() { this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0) } getDimensions() { if (this.clientRect) return this.clientRect; let e = this.media, t = { width: 0, height: 0 }; if (e) { let i = e.getBoundingClientRect(); t.width = i.width, t.height = i.height, t.width || t.height || (t.width = i.right - i.left || e.width || 0, t.height = i.bottom - i.top || e.height || 0) } return this.clientRect = t, t } get mediaWidth() { return this.getDimensions().width * this.contentScaleFactor } get mediaHeight() { return this.getDimensions().height * this.contentScaleFactor } get contentScaleFactor() { let e = 1; if (!this.hls.config.ignoreDevicePixelRatio) try { e = self.devicePixelRatio } catch (e) { } return e } isLevelAllowed(e) { let t = this.restrictedLevels; return !t.some(t => e.bitrate === t.bitrate && e.width === t.width && e.height === t.height) } static getMaxLevelByMediaSize(e, t, i) { if (!(null != e && e.length)) return -1; let atGreatestBandwidth = (e, t) => !t || e.width !== t.width || e.height !== t.height, r = e.length - 1, s = Math.max(t, i); for (let t = 0; t < e.length; t += 1) { let i = e[t]; if ((i.width >= s || i.height >= s) && atGreatestBandwidth(i, e[t + 1])) { r = t; break } } return r } }; let eK = "[eme]"; let EMEController = class EMEController {
      constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = M.debug.bind(M, eK), this.log = M.log.bind(M, eK), this.warn = M.warn.bind(M, eK), this.error = M.error.bind(M, eK), this.hls = e, this.config = e.config, this.registerListeners() } destroy() { this.unregisterListeners(), this.onMediaDetached(); let e = this.config; e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null } registerListeners() { this.hls.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(b.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(b.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(b.MANIFEST_LOADED, this.onManifestLoaded, this) } unregisterListeners() { this.hls.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(b.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(b.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(b.MANIFEST_LOADED, this.onManifestLoaded, this) } getLicenseServerUrl(e) { let { drmSystems: t, widevineLicenseUrl: i } = this.config, r = t[e]; if (r) return r.licenseUrl; if (e === N.WIDEVINE && i) return i; throw Error(`no license server URL configured for key-system "${e}"`) } getServerCertificateUrl(e) { let { drmSystems: t } = this.config, i = t[e]; if (i) return i.serverCertificateUrl; this.log(`No Server Certificate in config.drmSystems["${e}"]`) } attemptKeySystemAccess(e) { let t = this.hls.levels, uniqueCodec = (e, t, i) => !!e && i.indexOf(e) === t, i = t.map(e => e.audioCodec).filter(uniqueCodec), r = t.map(e => e.videoCodec).filter(uniqueCodec); return i.length + r.length === 0 && r.push("avc1.42e01e"), new Promise((t, s) => { let attempt = e => { let a = e.shift(); this.getMediaKeysPromise(a, i, r).then(e => t({ keySystem: a, mediaKeys: e })).catch(t => { e.length ? attempt(e) : t instanceof EMEKeyError ? s(t) : s(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_NO_ACCESS, error: t, fatal: !0 }, t.message)) }) }; attempt(e) }) } requestMediaKeySystemAccess(e, t) { let { requestMediaKeySystemAccessFunc: i } = this.config; if ("function" != typeof i) { let e = `Configured requestMediaKeySystemAccess is not a function ${i}`; return null === $ && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(Error(e)) } return i(e, t) } getMediaKeysPromise(e, t, i) { let r = function (e, t, i, r) { let s; switch (e) { case N.FAIRPLAY: s = ["cenc", "sinf"]; break; case N.WIDEVINE: case N.PLAYREADY: s = ["cenc"]; break; case N.CLEARKEY: s = ["cenc", "keyids"]; break; default: throw Error(`Unknown key-system: ${e}`) }return function (e, t, i, r) { let s = { initDataTypes: e, persistentState: r.persistentState || "optional", distinctiveIdentifier: r.distinctiveIdentifier || "optional", sessionTypes: r.sessionTypes || [r.sessionType || "temporary"], audioCapabilities: t.map(e => ({ contentType: `audio/mp4; codecs="${e}"`, robustness: r.audioRobustness || "", encryptionScheme: r.audioEncryptionScheme || null })), videoCapabilities: i.map(e => ({ contentType: `video/mp4; codecs="${e}"`, robustness: r.videoRobustness || "", encryptionScheme: r.videoEncryptionScheme || null })) }; return [s] }(s, t, i, r) }(e, t, i, this.config.drmSystemOptions), s = this.keySystemAccessPromises[e], a = null == s ? void 0 : s.keySystemAccess; if (!a) { this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(r)}`), a = this.requestMediaKeySystemAccess(e, r); let t = this.keySystemAccessPromises[e] = { keySystemAccess: a }; return a.catch(t => { this.log(`Failed to obtain access to key-system "${e}": ${t}`) }), a.then(i => { this.log(`Access for key-system "${i.keySystem}" obtained`); let r = this.fetchServerCertificate(e); return this.log(`Create media-keys for "${e}"`), t.mediaKeys = i.createMediaKeys().then(t => (this.log(`Media-keys created for "${e}"`), r.then(i => i ? this.setMediaKeysServerCertificate(t, e, i) : t))), t.mediaKeys.catch(t => { this.error(`Failed to create media-keys for "${e}"}: ${t}`) }), t.mediaKeys }) } return a.then(() => s.mediaKeys) } createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: i }) { this.log(`Creating key-system session "${t}" keyId: ${G.hexDump(e.keyId || [])}`); let r = i.createSession(), s = { decryptdata: e, keySystem: t, mediaKeys: i, mediaKeysSession: r, keyStatus: "status-pending" }; return this.mediaKeySessions.push(s), s } renewKeySession(e) { let t = e.decryptdata; if (t.pssh) { let i = this.createMediaKeySessionContext(e), r = this.getKeyIdString(t); this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(i, "cenc", t.pssh, "expired") } else this.warn("Could not renew expired session. Missing pssh initData."); this.removeSession(e) } getKeyIdString(e) { if (!e) throw Error("Could not read keyId of undefined decryptdata"); if (null === e.keyId) throw Error("keyId is null"); return G.hexDump(e.keyId) } updateKeySession(e, t) {
        var i; let r = e.mediaKeysSession; return this.log(`Updating key-session "${r.sessionId}" for keyID ${G.hexDump((null == (i = e.decryptdata) ? void 0 : i.keyId) || [])}
        } (data length: ${t ? t.byteLength : t})`), r.update(t)
      } selectKeySystemFormat(e) { let t = Object.keys(e.levelkeys || {}); return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise } getKeyFormatPromise(e) { return new Promise((t, i) => { let r = getKeySystemsForConfig(this.config), s = e.map(keySystemFormatToKeySystemDomain).filter(e => !!e && -1 !== r.indexOf(e)); return this.getKeySystemSelectionPromise(s).then(({ keySystem: e }) => { let r = keySystemDomainToKeySystemFormat(e); r ? t(r) : i(Error(`Unable to find format for key-system "${e}"`)) }).catch(i) }) } loadKey(e) { let t = e.keyInfo.decryptdata, i = this.getKeyIdString(t), r = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`; this.log(`Starting session for key ${r}`); let s = this.keyIdToKeySessionPromise[i]; return s || (s = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(t).then(({ keySystem: i, mediaKeys: s }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`), this.attemptSetMediaKeys(i, s).then(() => { this.throwIfDestroyed(); let e = this.createMediaKeySessionContext({ keySystem: i, mediaKeys: s, decryptdata: t }); return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key") })))).catch(e => this.handleError(e)), s } throwIfDestroyed(e = "Invalid state") { if (!this.hls) throw Error("invalid state") } handleError(e) { this.hls && (this.error(e.message), e instanceof EMEKeyError ? this.hls.trigger(b.ERROR, e.data) : this.hls.trigger(b.ERROR, { type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_NO_KEYS, error: e, fatal: !0 })) } getKeySystemForKeyPromise(e) { let t = this.getKeyIdString(e), i = this.keyIdToKeySessionPromise[t]; if (!i) { let t = keySystemFormatToKeySystemDomain(e.keyFormat), i = t ? [t] : getKeySystemsForConfig(this.config); return this.attemptKeySystemAccess(i) } return i } getKeySystemSelectionPromise(e) { if (e.length || (e = getKeySystemsForConfig(this.config)), 0 === e.length) throw new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 }, `Missing key-system license configuration options ${JSON.stringify({ drmSystems: this.config.drmSystems })}`); return this.attemptKeySystemAccess(e) } _onMediaEncrypted(e) { let t, i; let { initDataType: r, initData: s } = e; if (this.debug(`"${e.type}" event: init data type: "${r}"`), null === s) return; if ("sinf" === r && this.config.drmSystems[N.FAIRPLAY]) { let e = bin2str(new Uint8Array(s)); try { let r = base64Decode(JSON.parse(e).sinf), s = parseSinf(new Uint8Array(r)); if (!s) return; t = s.subarray(8, 24), i = N.FAIRPLAY } catch (e) { this.warn('Failed to parse sinf "encrypted" event message initData'); return } } else { let e = function (e) { if (!(e instanceof ArrayBuffer) || e.byteLength < 32) return null; let t = { version: 0, systemId: "", kids: null, data: null }, i = new DataView(e), r = i.getUint32(0); if (e.byteLength !== r && r > 44) return null; let s = i.getUint32(4); if (1886614376 !== s || (t.version = i.getUint32(8) >>> 24, t.version > 1)) return null; t.systemId = G.hexDump(new Uint8Array(e, 12, 16)); let a = i.getUint32(28); if (0 === t.version) { if (r - 32 < a) return null; t.data = new Uint8Array(e, 32, a) } else if (1 === t.version) { t.kids = []; for (let i = 0; i < a; i++)t.kids.push(new Uint8Array(e, 32 + 16 * i, 16)) } return t }(s); if (null === e) return; 0 === e.version && e.systemId === B.WIDEVINE && e.data && (t = e.data.subarray(8, 24)), i = function (e) { if (e === B.WIDEVINE) return N.WIDEVINE }(e.systemId) } if (!i || !t) return; let a = G.hexDump(t), { keyIdToKeySessionPromise: n, mediaKeySessions: l } = this, o = n[a]; for (let e = 0; e < l.length; e++) { let i = l[e], h = i.decryptdata; if (h.pssh || !h.keyId) continue; let d = G.hexDump(h.keyId); if (a === d || -1 !== h.uri.replace(/-/g, "").indexOf(a)) { o = n[d], delete n[d], h.pssh = new Uint8Array(s), h.keyId = t, o = n[a] = o.then(() => this.generateRequestWithPreferredKeySession(i, r, s, "encrypted-event-key-match")); break } } o || (o = n[a] = this.getKeySystemSelectionPromise([i]).then(({ keySystem: e, mediaKeys: i }) => { var n; this.throwIfDestroyed(); let l = new LevelKey("ISO-23001-7", a, null != (n = keySystemDomainToKeySystemFormat(e)) ? n : ""); return l.pssh = new Uint8Array(s), l.keyId = t, this.attemptSetMediaKeys(e, i).then(() => { this.throwIfDestroyed(); let t = this.createMediaKeySessionContext({ decryptdata: l, keySystem: e, mediaKeys: i }); return this.generateRequestWithPreferredKeySession(t, r, s, "encrypted-event-no-match") }) })), o.catch(e => this.handleError(e)) } _onWaitingForKey(e) { this.log(`"${e.type}" event`) } attemptSetMediaKeys(e, t) { let i = this.setMediaKeysQueue.slice(); this.log(`Setting media-keys for "${e}"`); let r = Promise.all(i).then(() => { if (!this.media) throw Error("Attempted to set mediaKeys without media element attached"); return this.media.setMediaKeys(t) }); return this.setMediaKeysQueue.push(r), r.then(() => { this.log(`Media-keys set for "${e}"`), i.push(r), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(e => -1 === i.indexOf(e)) }) } generateRequestWithPreferredKeySession(e, t, i, r) { var s, a, n; let l = null == (s = this.config.drmSystems) ? void 0 : null == (a = s[e.keySystem]) ? void 0 : a.generateRequest; if (l) try { let r = l.call(this.hls, t, i, e); if (!r) throw Error("Invalid response from configured generateRequest filter"); t = r.initDataType, i = e.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null } catch (e) { if (this.warn(e.message), null != (n = this.hls) && n.config.debug) throw e } if (null === i) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(e); let o = this.getKeyIdString(e.decryptdata); this.log(`Generating key-session request for "${r}": ${o} (init data type: ${t} length: ${i ? i.byteLength : null})`); let h = new eD, d = e._onmessage = t => { let i = e.mediaKeysSession; if (!i) { h.emit("error", Error("invalid state")); return } let { messageType: r, message: s } = t; this.log(`"${r}" message event for session "${i.sessionId}" message size: ${s.byteLength}`), "license-request" === r || "license-renewal" === r ? this.renewLicense(e, s).catch(e => { this.handleError(e), h.emit("error", e) }) : "license-release" === r ? e.keySystem === N.FAIRPLAY && (this.updateKeySession(e, strToUtf8array("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${r}"`) }, u = e._onkeystatuseschange = t => { let i = e.mediaKeysSession; if (!i) { h.emit("error", Error("invalid state")); return } this.onKeyStatusChange(e); let r = e.keyStatus; h.emit("keyStatus", r), "expired" === r && (this.warn(`${e.keySystem} expired for key ${o}`), this.renewKeySession(e)) }; e.mediaKeysSession.addEventListener("message", d), e.mediaKeysSession.addEventListener("keystatuseschange", u); let c = new Promise((e, t) => { h.on("error", t), h.on("keyStatus", i => { i.startsWith("usable") ? e() : "output-restricted" === i ? t(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED, fatal: !1 }, "HDCP level output restricted")) : "internal-error" === i ? t(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_STATUS_INTERNAL_ERROR, fatal: !0 }, `key status changed to "${i}"`)) : "expired" === i ? t(Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`) }) }); return e.mediaKeysSession.generateRequest(t, i).then(() => { var t; this.log(`Request generated for key-session "${null == (t = e.mediaKeysSession) ? void 0 : t.sessionId}" keyId: ${o}`) }).catch(e => { throw new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_NO_SESSION, error: e, fatal: !1 }, `Error generating key-session request: ${e}`) }).then(() => c).catch(t => { throw h.removeAllListeners(), this.removeSession(e), t }).then(() => (h.removeAllListeners(), e)) } onKeyStatusChange(e) { e.mediaKeysSession.keyStatuses.forEach((t, i) => { this.log(`key status change "${t}" for keyStatuses keyId: ${G.hexDump("buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i))} session keyId: ${G.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t }) } fetchServerCertificate(e) { let t = this.config, i = t.loader, r = new i(t), s = this.getServerCertificateUrl(e); return s ? (this.log(`Fetching server certificate for "${e}"`), new Promise((i, a) => { let n = { responseType: "arraybuffer", url: s }, l = t.certLoadPolicy.default, o = { loadPolicy: l, timeout: l.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; r.load(n, o, { onSuccess: (e, t, r, s) => { i(e.data) }, onError: (t, i, r, l) => { a(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: r, response: _objectSpread2({ url: n.url, data: void 0 }, t) }, `"${e}" certificate request failed (${s}). Status: ${t.code} (${t.text})`)) }, onTimeout: (t, i, r) => { a(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: r, response: { url: n.url, data: void 0 } }, `"${e}" certificate request timed out (${s})`)) }, onAbort: (e, t, i) => { a(Error("aborted")) } }) })) : Promise.resolve() } setMediaKeysServerCertificate(e, t, i) { return new Promise((r, s) => { e.setServerCertificate(i).then(s => { this.log(`setServerCertificate ${s ? "success" : "not supported by CDM"} (${null == i ? void 0 : i.byteLength}) on "${t}"`), r(e) }).catch(e => { s(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED, error: e, fatal: !0 }, e.message)) }) }) } renewLicense(e, t) { return this.requestLicense(e, new Uint8Array(t)).then(t => this.updateKeySession(e, new Uint8Array(t)).catch(e => { throw new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_SESSION_UPDATE_FAILED, error: e, fatal: !0 }, e.message) })) } unpackPlayReadyKeyMessage(e, t) { let i = String.fromCharCode.apply(null, new Uint16Array(t.buffer)); if (!i.includes("PlayReadyKeyMessage")) return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t; let r = new DOMParser().parseFromString(i, "application/xml"), s = r.querySelectorAll("HttpHeader"); if (s.length > 0) { let t; for (let i = 0, r = s.length; i < r; i++) { var a, n; t = s[i]; let r = null == (a = t.querySelector("name")) ? void 0 : a.textContent, l = null == (n = t.querySelector("value")) ? void 0 : n.textContent; r && l && e.setRequestHeader(r, l) } } let l = r.querySelector("Challenge"), o = null == l ? void 0 : l.textContent; if (!o) throw Error("Cannot find <Challenge> in key message"); return strToUtf8array(atob(o)) } setupLicenseXHR(e, t, i, r) { let s = this.config.licenseXhrSetup; return s ? Promise.resolve().then(() => { if (!i.decryptdata) throw Error("Key removed"); return s.call(this.hls, e, t, i, r) }).catch(a => { if (!i.decryptdata) throw a; return e.open("POST", t, !0), s.call(this.hls, e, t, i, r) }).then(i => { e.readyState || e.open("POST", t, !0); let s = i || r; return { xhr: e, licenseChallenge: s } }) : (e.open("POST", t, !0), Promise.resolve({ xhr: e, licenseChallenge: r })) } requestLicense(e, t) { let i = this.config.keyLoadPolicy.default; return new Promise((r, s) => { let a = this.getLicenseServerUrl(e.keySystem); this.log(`Sending license request to URL: ${a}`); let n = new XMLHttpRequest; n.responseType = "arraybuffer", n.onreadystatechange = () => { if (!this.hls || !e.mediaKeysSession) return s(Error("invalid state")); if (4 === n.readyState) { if (200 === n.status) { this._requestLicenseFailureCount = 0; let t = n.response; this.log(`License received ${t instanceof ArrayBuffer ? t.byteLength : t}`); let i = this.config.licenseResponseCallback; if (i) try { t = i.call(this.hls, n, a, e) } catch (e) { this.error(e) } r(t) } else { let l = i.errorRetry, o = l ? l.maxNumRetry : 0; if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > o || n.status >= 400 && n.status < 500) s(new EMEKeyError({ type: C.KEY_SYSTEM_ERROR, details: k.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0, networkDetails: n, response: { url: a, data: void 0, code: n.status, text: n.statusText } }, `License Request XHR failed (${a}). Status: ${n.status} (${n.statusText})`)); else { let i = o - this._requestLicenseFailureCount + 1; this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(e, t).then(r, s) } } } }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = n, this.setupLicenseXHR(n, a, e, t).then(({ xhr: t, licenseChallenge: i }) => { e.keySystem == N.PLAYREADY && (i = this.unpackPlayReadyKeyMessage(t, i)), t.send(i) }) }) } onMediaAttached(e, t) { if (!this.config.emeEnabled) return; let i = t.media; this.media = i, i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey) } onMediaDetached() { let e = this.media, t = this.mediaKeySessions; e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, LevelKey.clearKeyUriToKeyIdMap(); let i = t.length; EMEController.CDMCleanupPromise = Promise.all(t.map(e => this.removeSession(e)).concat(null == e ? void 0 : e.setMediaKeys(null).catch(e => { this.log(`Could not clear media keys: ${e}`) }))).then(() => { i && (this.log("finished closing key sessions and clearing media keys"), t.length = 0) }).catch(e => { this.log(`Could not close sessions and clear media keys: ${e}`) }) } onManifestLoading() { this.keyFormatPromise = null } onManifestLoaded(e, { sessionKeys: t }) { if (t && this.config.emeEnabled && !this.keyFormatPromise) { let e = t.reduce((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e), []); this.log(`Selecting key-system from session-keys ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e) } } removeSession(e) { let { mediaKeysSession: t, licenseXhr: i } = e; if (t) { this.log(`Remove licenses and keys and close session ${t.sessionId}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0; let r = this.mediaKeySessions.indexOf(e); return r > -1 && this.mediaKeySessions.splice(r, 1), t.remove().catch(e => { this.log(`Could not remove session: ${e}`) }).then(() => t.close()).catch(e => { this.log(`Could not close session: ${e}`) }) } }
    }; EMEController.CDMCleanupPromise = void 0; let EMEKeyError = class EMEKeyError extends Error { constructor(e, t) { super(t), this.data = void 0, e.error || (e.error = Error(t)), this.data = e, e.err = e.error } }; (p = y || (y = {})).MANIFEST = "m", p.AUDIO = "a", p.VIDEO = "v", p.MUXED = "av", p.INIT = "i", p.CAPTION = "c", p.TIMED_TEXT = "tt", p.KEY = "k", p.OTHER = "o", (E = v || (v = {})).DASH = "d", E.HLS = "h", E.SMOOTH = "s", E.OTHER = "o", (T = S || (S = {})).OBJECT = "CMCD-Object", T.REQUEST = "CMCD-Request", T.SESSION = "CMCD-Session", T.STATUS = "CMCD-Status"; let eH = { [S.OBJECT]: ["br", "d", "ot", "tb"], [S.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"], [S.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"], [S.STATUS]: ["bs", "rtp"] }; let SfItem = class SfItem { constructor(e, t) { this.value = void 0, this.params = void 0, Array.isArray(e) && (e = e.map(e => e instanceof SfItem ? e : new SfItem(e))), this.value = e, this.params = t } }; let SfToken = class SfToken { constructor(e) { this.description = void 0, this.description = e } }; let eV = "Bare Item", eW = /[\x00-\x1f\x7f]+/; function serializeError(e, t, i) { return Error(`failed to serialize "${Array.isArray(e) ? JSON.stringify(e) : e instanceof Map ? "Map{}" : e instanceof Set ? "Set{}" : "object" == typeof e ? JSON.stringify(e) : String(e)}" as ${t}`, { cause: i }) } function serializeInteger(e) { if (e < -999999999999999 || 999999999999999 < e) throw serializeError(e, "Integer"); return e.toString() } function serializeToken(e) { let t = e.description || e.toString().slice(7, -1); if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(t)) throw serializeError(t, "Token"); return t } function serializeBareItem(e) { switch (typeof e) { case "number": if (!R(e)) throw serializeError(e, eV); if (Number.isInteger(e)) return serializeInteger(e); return function (e) { let t = function roundToEven(e, t) { if (e < 0) return -roundToEven(-e, t); let i = Math.pow(10, t), r = Math.abs(e * i % 1 - .5) < Number.EPSILON; if (!r) return Math.round(e * i) / i; { let t = Math.floor(e * i); return (t % 2 == 0 ? t : t + 1) / i } }(e, 3); if (Math.floor(Math.abs(t)).toString().length > 12) throw serializeError(e, "Decimal"); let i = t.toString(); return i.includes(".") ? i : `${i}.0` }(e); case "string": return function (e) { if (eW.test(e)) throw serializeError(e, "String"); return `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` }(e); case "symbol": return serializeToken(e); case "boolean": return function (e) { if ("boolean" != typeof e) throw serializeError(e, "Boolean"); return e ? "?1" : "?0" }(e); case "object": if (e instanceof Date) return `@${serializeInteger(e.getTime() / 1e3)}`; if (e instanceof Uint8Array) return function (e) { if (!1 === ArrayBuffer.isView(e)) throw serializeError(e, "Byte Sequence"); return `:${btoa(String.fromCharCode(...e))}:` }(e); if (e instanceof SfToken) return serializeToken(e); default: throw serializeError(e, eV) } } function serializeKey(e) { if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(e)) throw serializeError(e, "Key"); return e } function serializeParams(e) { return null == e ? "" : Object.entries(e).map(([e, t]) => !0 === t ? `;${serializeKey(e)}` : `;${serializeKey(e)}=${serializeBareItem(t)}`).join("") } function serializeItem(e) { return e instanceof SfItem ? `${serializeBareItem(e.value)}${serializeParams(e.params)}` : serializeBareItem(e) } let isTokenField = e => "ot" === e || "sf" === e || "st" === e, isValid = e => "number" == typeof e ? R(e) : null != e && "" !== e && !1 !== e, toRounded = e => Math.round(e), toHundred = e => 100 * toRounded(e / 100), eY = { br: toRounded, d: toRounded, bl: toHundred, dl: toHundred, mtp: toHundred, nor: (e, t) => (null != t && t.baseUrl && (e = function (e, t) { let i = new URL(e), r = new URL(t); if (i.origin !== r.origin) return e; let s = i.pathname.split("/").slice(1), a = r.pathname.split("/").slice(1, -1); for (; s[0] === a[0];)s.shift(), a.shift(); for (; a.length;)a.shift(), s.unshift(".."); return s.join("/") }(e, t.baseUrl)), encodeURIComponent(e)), rtp: toHundred, tb: toRounded }; function encodeCmcd(e, t = {}) { return e ? function (e, t = { whitespace: !0 }) { if ("object" != typeof e) throw serializeError(e, "Dict"); let i = e instanceof Map ? e.entries() : Object.entries(e), r = null != t && t.whitespace ? " " : ""; return Array.from(i).map(([e, t]) => { t instanceof SfItem == !1 && (t = new SfItem(t)); let i = serializeKey(e); if (!0 === t.value) i += serializeParams(t.params); else if (i += "=", Array.isArray(t.value)) { var r; i += (r = t, `(${r.value.map(serializeItem).join(" ")})${serializeParams(r.params)}`) } else i += serializeItem(t); return i }).join(`,${r}`) }(function (e, t) { let i = {}; if (null == e || "object" != typeof e) return i; let r = Object.keys(e).sort(), s = _extends({}, eY, null == t ? void 0 : t.formatters), a = null == t ? void 0 : t.filter; return r.forEach(r => { if (null != a && a(r)) return; let n = e[r], l = s[r]; l && (n = l(n, t)), ("v" !== r || 1 !== n) && ("pr" != r || 1 !== n) && isValid(n) && (isTokenField(r) && "string" == typeof n && (n = new SfToken(n)), i[r] = n) }), i }(e, t), _extends({ whitespace: !1 }, t)) : "" } let ej = /CMCD=[^&#]+/; function cloneRenditionGroups(e, t, i, r) { e && Object.keys(t).forEach(s => { let a = e.filter(e => e.groupId === s).map(e => { let a = _extends({}, e); return a.details = void 0, a.attrs = new AttrList(a.attrs), a.url = a.attrs.URI = performUriReplacement(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), a.groupId = a.attrs["GROUP-ID"] = t[s], a.attrs["PATHWAY-ID"] = r, a }); e.push(...a) }) } function performUriReplacement(e, t, i, r) { let s; let { HOST: a, PARAMS: n, [i]: l } = r; t && (s = null == l ? void 0 : l[t]) && (e = s); let o = new self.URL(e); return a && !s && (o.host = a), n && Object.keys(n).sort().forEach(e => { e && o.searchParams.set(e, n[e]) }), o.href } let eq = /^age:\s*[\d.]+\s*$/im; let XhrLoader = class XhrLoader { constructor(e) { this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new LoadStats, this.retryDelay = 0 } destroy() { this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null, this.stats = null } abortInternal() { let e = this.loader; self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort())) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader) } load(e, t, i) { if (this.stats.loading.start) throw Error("Loader can only be used once."); this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.loadInternal() } loadInternal() { let { config: e, context: t } = this; if (!e || !t) return; let i = this.loader = new self.XMLHttpRequest, r = this.stats; r.loading.first = 0, r.loaded = 0, r.aborted = !1; let s = this.xhrSetup; s ? Promise.resolve().then(() => { if (!this.stats.aborted) return s(i, t.url) }).catch(e => (i.open("GET", t.url, !0), s(i, t.url))).then(() => { this.stats.aborted || this.openAndSendXhr(i, t, e) }).catch(e => { this.callbacks.onError({ code: i.status, text: e.message }, t, i, r) }) : this.openAndSendXhr(i, t, e) } openAndSendXhr(e, t, i) { e.readyState || e.open("GET", t.url, !0); let r = t.headers, { maxTimeToFirstByteMs: s, maxLoadTimeMs: a } = i.loadPolicy; if (r) for (let t in r) e.setRequestHeader(t, r[t]); t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), i.timeout = s && R(s) ? s : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), e.send() } readystatechange() { let { context: e, loader: t, stats: i } = this; if (!e || !t) return; let r = t.readyState, s = this.config; if (!i.aborted && r >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === r)) { self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null; let r = t.status, a = "text" !== t.responseType; if (r >= 200 && r < 300 && (a && t.response || null !== t.responseText)) { i.loading.end = Math.max(self.performance.now(), i.loading.first); let s = a ? t.response : t.responseText, n = "arraybuffer" === t.responseType ? s.byteLength : s.length; if (i.loaded = i.total = n, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first), !this.callbacks) return; let l = this.callbacks.onProgress; if (l && l(i, e, s, t), !this.callbacks) return; let o = { url: t.responseURL, data: s, code: r }; this.callbacks.onSuccess(o, i, e, t) } else { let a = s.loadPolicy.errorRetry, n = i.retry, l = { url: e.url, data: void 0, code: r }; shouldRetry(a, n, !1, l) ? this.retry(a) : (M.error(`${r} while loading ${e.url}`), this.callbacks.onError({ code: r, text: t.statusText }, e, t, i)) } } } loadtimeout() { var e, t; let i = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry, r = this.stats.retry; if (shouldRetry(i, r, !0)) this.retry(i); else { M.warn(`timeout while loading ${null == (t = this.context) ? void 0 : t.url}`); let e = this.callbacks; e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader)) } } retry(e) { let { context: t, stats: i } = this; this.retryDelay = getRetryDelay(e, i.retry), i.retry++, M.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${null == t ? void 0 : t.url}, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay) } loadprogress(e) { let t = this.stats; t.loaded = e.loaded, e.lengthComputable && (t.total = e.total) } getCacheAge() { let e = null; if (this.loader && eq.test(this.loader.getAllResponseHeaders())) { let t = this.loader.getResponseHeader("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.loader && RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null } }; let ez = /(\d+)-(\d+)\/(\d+)/; let FetchLoader = class FetchLoader { constructor(e) { this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || getRequest, this.controller = new self.AbortController, this.stats = new LoadStats } destroy() { this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null } abortInternal() { this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort()) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response) } load(e, t, i) { let r = this.stats; if (r.loading.start) throw Error("Loader can only be used once."); r.loading.start = self.performance.now(); let s = function (e, t) { let i = { method: "GET", mode: "cors", credentials: "same-origin", signal: t, headers: new self.Headers(_extends({}, e.headers)) }; return e.rangeEnd && i.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), i }(e, this.controller.signal), a = i.onProgress, n = "arraybuffer" === e.responseType, l = n ? "byteLength" : "length", { maxTimeToFirstByteMs: o, maxLoadTimeMs: h } = t.loadPolicy; this.context = e, this.config = t, this.callbacks = i, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), t.timeout = o && R(o) ? o : h, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), i.onTimeout(r, e, this.response) }, t.timeout), self.fetch(this.request).then(s => { this.response = this.loader = s; let l = Math.max(self.performance.now(), r.loading.start); if (self.clearTimeout(this.requestTimeout), t.timeout = h, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), i.onTimeout(r, e, this.response) }, h - (l - r.loading.start)), !s.ok) { let { status: e, statusText: t } = s; throw new FetchError(t || "fetch, bad network response", e, s) } return (r.loading.first = l, r.total = function (e) { let t = e.get("Content-Range"); if (t) { let e = function (e) { let t = ez.exec(e); if (t) return parseInt(t[2]) - parseInt(t[1]) + 1 }(t); if (R(e)) return e } let i = e.get("Content-Length"); if (i) return parseInt(i) }(s.headers) || r.total, a && R(t.highWaterMark)) ? this.loadProgressively(s, r, e, t.highWaterMark, a) : n ? s.arrayBuffer() : "json" === e.responseType ? s.json() : s.text() }).then(s => { let n = this.response; if (!n) throw Error("loader destroyed"); self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first); let o = s[l]; o && (r.loaded = r.total = o); let h = { url: n.url, data: s, code: n.status }; a && !R(t.highWaterMark) && a(r, e, s, n), i.onSuccess(h, r, e, n) }).catch(t => { if (self.clearTimeout(this.requestTimeout), r.aborted) return; let s = t && t.code || 0, a = t ? t.message : null; i.onError({ code: s, text: a }, e, t ? t.details : null, r) }) } getCacheAge() { let e = null; if (this.response) { let t = this.response.headers.get("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.response ? this.response.headers.get(e) : null } loadProgressively(e, t, i, r = 0, s) { let a = new ChunkCache, n = e.body.getReader(), pump = () => n.read().then(n => { if (n.done) return a.dataLength && s(t, i, a.flush(), e), Promise.resolve(new ArrayBuffer(0)); let l = n.value, o = l.length; return t.loaded += o, o < r || a.dataLength ? (a.push(l), a.dataLength >= r && s(t, i, a.flush(), e)) : s(t, i, l, e), pump() }).catch(() => Promise.reject()); return pump() } }; function getRequest(e, t) { return new self.Request(e.url, t) } let FetchError = class FetchError extends Error { constructor(e, t, i) { super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = i } }; let eX = /\s/, eQ = _objectSpread2(_objectSpread2({
      autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, ignoreDevicePixelRatio: !1, preferManagedMediaSource: !0, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, frontBufferFlushThreshold: 1 / 0, maxBufferSize: 6e7, maxBufferHole: .1, highBufferWatchdogPeriod: 2, nudgeOffset: .1, nudgeMaxRetry: 3, maxFragLookUpTolerance: .25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: !1, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: !0, workerPath: null, enableSoftwareAES: !0, startLevel: void 0, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: .2, appendErrorMaxRetry: 3, loader: XhrLoader, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: class {
        constructor(e) {
          this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = () => {
            let e; let { fragCurrent: t, partCurrent: i, hls: r } = this, { autoLevelEnabled: s, media: a } = r; if (!t || !a) return; let n = performance.now(), l = i ? i.stats : t.stats, o = i ? i.duration : t.duration, h = n - l.loading.start, d = r.minAutoLevel; if (l.aborted || l.loaded && l.loaded === l.total || t.level <= d) { this.clearTimer(), this._nextAutoLevel = -1; return } if (!s || a.paused || !a.playbackRate || !a.readyState) return; let u = r.mainForwardBufferInfo; if (null === u) return; let c = this.bwEstimator.getEstimateTTFB(), f = Math.abs(a.playbackRate); if (h <= Math.max(c, 1e3 * (o / (2 * f)))) return; let g = u.len / f, m = l.loading.first ? l.loading.first - l.loading.start : -1, p = l.loaded && m > -1, E = this.getBwEstimate(), T = r.levels, y = T[t.level], v = l.total || Math.max(l.loaded, Math.round(o * y.averageBitrate / 8)), S = p ? h - m : h; S < 1 && p && (S = Math.min(h, 8 * l.loaded / E)); let A = p ? 1e3 * l.loaded / S : 0, L = A ? (v - l.loaded) / A : 8 * v / E + c / 1e3; if (L <= g) return; let I = A ? 8 * A : E, D = Number.POSITIVE_INFINITY; for (e = t.level - 1; e > d; e--) { let t = T[e].maxBitrate; if ((D = this.getTimeToLoadFrag(c / 1e3, I, o * t, !T[e].details)) < g) break } if (D >= L || D > 10 * o) return; r.nextLoadLevel = r.nextAutoLevel = e, p ? this.bwEstimator.sample(h - Math.min(c, m), l.loaded) : this.bwEstimator.sampleTTFB(h); let C = T[e].maxBitrate; this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > C && this.resetEstimator(C), this.clearTimer(), M.warn(`[abr] Fragment ${t.sn}${i ? " part " + i.index : ""} of level ${t.level} is loading too slowly;
        Time to underbuffer: ${g.toFixed(3)} s
        Estimated load time for current fragment: ${L.toFixed(3)} s
        Estimated load time for down switch fragment: ${D.toFixed(3)} s
        TTFB estimate: ${0 | m} ms
        Current BW estimate: ${R(E) ? 0 | E : "Unknown"} bps
        New BW estimate: ${0 | this.getBwEstimate()} bps
        Switching to level ${e} @ ${0 | C} bps`), r.trigger(b.FRAG_LOAD_EMERGENCY_ABORTED, { frag: t, part: i, stats: l })
          }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners()
        } resetEstimator(e) { e && (M.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator() } initEstimator() { let e = this.hls.config; return new EwmaBandWidthEstimator(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate) } registerListeners() { let { hls: e } = this; e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.FRAG_LOADING, this.onFragLoading, this), e.on(b.FRAG_LOADED, this.onFragLoaded, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this), e.on(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(b.LEVEL_LOADED, this.onLevelLoaded, this), e.on(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(b.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(b.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e && (e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.FRAG_LOADING, this.onFragLoading, this), e.off(b.FRAG_LOADED, this.onFragLoaded, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this), e.off(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(b.LEVEL_LOADED, this.onLevelLoaded, this), e.off(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(b.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(b.ERROR, this.onError, this)) } destroy() { this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null } onManifestLoading(e, t) { this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer() } onLevelsUpdated() { this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null } onMaxAutoLevelUpdated() { this.firstSelection = -1, this.nextAutoLevelKey = "" } onFragLoading(e, t) { let i = t.frag; if (!this.ignoreFragment(i)) { if (!i.bitrateTest) { var r; this.fragCurrent = i, this.partCurrent = null != (r = t.part) ? r : null } this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100) } } onLevelSwitching(e, t) { this.clearTimer() } onError(e, t) { if (!t.fatal) switch (t.details) { case k.BUFFER_ADD_CODEC_ERROR: case k.BUFFER_APPEND_ERROR: this.lastLoadedFragLevel = -1, this.firstSelection = -1; break; case k.FRAG_LOAD_TIMEOUT: { let e = t.frag, { fragCurrent: i, partCurrent: r } = this; if (e && i && e.sn === i.sn && e.level === i.level) { let t = performance.now(), i = r ? r.stats : e.stats, s = t - i.loading.start, a = i.loading.first ? i.loading.first - i.loading.start : -1, n = i.loaded && a > -1; if (n) { let e = this.bwEstimator.getEstimateTTFB(); this.bwEstimator.sample(s - Math.min(e, a), i.loaded) } else this.bwEstimator.sampleTTFB(s) } } } } getTimeToLoadFrag(e, t, i, r) { let s = r ? this.lastLevelLoadSec : 0; return e + i / t + s } onLevelLoaded(e, t) { let i = this.hls.config, { loading: r } = t.stats, s = r.end - r.start; R(s) && (this.lastLevelLoadSec = s / 1e3), t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD) } onFragLoaded(e, { frag: t, part: i }) { let r = i ? i.stats : t.stats; if (t.type === et.MAIN && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start), !this.ignoreFragment(t)) { if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) { let e = i ? i.duration : t.duration, s = this.hls.levels[t.level], a = (s.loaded ? s.loaded.bytes : 0) + r.loaded, n = (s.loaded ? s.loaded.duration : 0) + e; s.loaded = { bytes: a, duration: n }, s.realBitrate = Math.round(8 * a / n) } if (t.bitrateTest) { let e = { stats: r, frag: t, part: i, id: t.type }; this.onFragBuffered(b.FRAG_BUFFERED, e), t.bitrateTest = !1 } else this.lastLoadedFragLevel = t.level } } onFragBuffered(e, t) { let { frag: i, part: r } = t, s = null != r && r.stats.loaded ? r.stats : i.stats; if (s.aborted || this.ignoreFragment(i)) return; let a = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB()); this.bwEstimator.sample(a, s.loaded), s.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0 } ignoreFragment(e) { return e.type !== et.MAIN || "initSegment" === e.sn } clearTimer() { this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1) } get firstAutoLevel() { let { maxAutoLevel: e, minAutoLevel: t } = this.hls, i = this.getBwEstimate(), r = this.hls.config.maxStarvationDelay, s = this.findBestLevel(i, t, e, 0, r, 1, 1); if (s > -1) return s; let a = this.hls.firstLevel, n = Math.min(Math.max(a, t), e); return M.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${n}`), n } get forcedAutoLevel() { return this.nextAutoLevelKey ? -1 : this._nextAutoLevel } get nextAutoLevel() { let e = this.forcedAutoLevel, t = this.bwEstimator, i = t.canEstimate(), r = this.lastLoadedFragLevel > -1; if (-1 !== e && (!i || !r || this.nextAutoLevelKey === this.getAutoLevelKey())) return e; let s = i && r ? this.getNextABRAutoLevel() : this.firstAutoLevel; if (-1 !== e) { let t = this.hls.levels; if (t.length > Math.max(e, s) && t[e].loadError <= t[s].loadError) return e } return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s } getAutoLevelKey() { return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}` } getNextABRAutoLevel() { let { fragCurrent: e, partCurrent: t, hls: i } = this, { maxAutoLevel: r, config: s, minAutoLevel: a } = i, n = t ? t.duration : e ? e.duration : 0, l = this.getBwEstimate(), o = this.getStarvationDelay(), h = s.abrBandWidthFactor, d = s.abrBandWidthUpFactor; if (o) { let e = this.findBestLevel(l, a, r, o, 0, h, d); if (e >= 0) return e } let u = n ? Math.min(n, s.maxStarvationDelay) : s.maxStarvationDelay; if (!o) { let e = this.bitrateTestDelay; if (e) { let t = n ? Math.min(n, s.maxLoadingDelay) : s.maxLoadingDelay; u = t - e, M.info(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * u)} ms`), h = d = 1 } } let c = this.findBestLevel(l, a, r, o, u, h, d); if (M.info(`[abr] ${o ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${c}`), c > -1) return c; let f = i.levels[a], g = i.levels[i.loadLevel]; return (null == f ? void 0 : f.bitrate) < (null == g ? void 0 : g.bitrate) ? a : i.loadLevel } getStarvationDelay() { let e = this.hls, t = e.media; if (!t) return 1 / 0; let i = t && 0 !== t.playbackRate ? Math.abs(t.playbackRate) : 1, r = e.mainForwardBufferInfo; return (r ? r.len : 0) / i } getBwEstimate() { return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate } findBestLevel(e, t, i, r, s, a, n) { var l, o; let h; let d = r + s, u = this.lastLoadedFragLevel, c = -1 === u ? this.hls.firstLevel : u, { fragCurrent: f, partCurrent: g } = this, { levels: m, allAudioTracks: p, loadLevel: E, config: T } = this.hls; if (1 === m.length) return 0; let y = m[c], v = !!(null != y && null != (l = y.details) && l.live), S = -1 === E || -1 === u, A = "SDR", L = (null == y ? void 0 : y.frameRate) || 0, { audioPreference: I, videoPreference: D } = T, b = this.audioTracksByGroup || (this.audioTracksByGroup = p.reduce((e, t) => { let i = e.groups[t.groupId]; i || (i = e.groups[t.groupId] = { tracks: [], channels: { 2: 0 }, hasDefault: !1, hasAutoSelect: !1 }), i.tracks.push(t); let r = t.channels || "2"; return i.channels[r] = (i.channels[r] || 0) + 1, i.hasDefault = i.hasDefault || t.default, i.hasAutoSelect = i.hasAutoSelect || t.autoselect, i.hasDefault && (e.hasDefaultAudio = !0), i.hasAutoSelect && (e.hasAutoSelectAudio = !0), e }, { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} })); if (S) { if (-1 !== this.firstSelection) return this.firstSelection; let r = this.codecTiers || (this.codecTiers = m.slice(t, i + 1).reduce((e, t) => { if (!t.codecSet) return e; let i = t.audioGroups, r = e[t.codecSet]; r || (e[t.codecSet] = r = { minBitrate: 1 / 0, minHeight: 1 / 0, minFramerate: 1 / 0, maxScore: 0, videoRanges: { SDR: 0 }, channels: { 2: 0 }, hasDefaultAudio: !i, fragmentError: 0 }), r.minBitrate = Math.min(r.minBitrate, t.bitrate); let s = Math.min(t.height, t.width); return r.minHeight = Math.min(r.minHeight, s), r.minFramerate = Math.min(r.minFramerate, t.frameRate), r.maxScore = Math.max(r.maxScore, t.score), r.fragmentError += t.fragmentError, r.videoRanges[t.videoRange] = (r.videoRanges[t.videoRange] || 0) + 1, i && i.forEach(e => { if (!e) return; let t = b.groups[e]; r.hasDefaultAudio = r.hasDefaultAudio || b.hasDefaultAudio ? t.hasDefault : t.hasAutoSelect || !b.hasDefaultAudio && !b.hasAutoSelectAudio, Object.keys(t.channels).forEach(e => { r.channels[e] = (r.channels[e] || 0) + t.channels[e] }) }), e }, {})), s = function (e, t, i, r, s) { var a; let n, l; let o = Object.keys(e), h = null == r ? void 0 : r.channels, d = null == r ? void 0 : r.audioCodec, u = h && 2 === parseInt(h), c = !0, f = !1, g = 1 / 0, m = 1 / 0, p = 1 / 0, E = 0, T = [], { preferHDR: y, allowedVideoRanges: v } = (n = !1, l = [], (a = t) && (n = "SDR" !== a, l = [a]), s && (l = s.allowedVideoRanges || ea.slice(0), l = (n = void 0 !== s.preferHDR ? s.preferHDR : function () { if ("function" == typeof matchMedia) { let e = matchMedia("(dynamic-range: high)"), t = matchMedia("bad query"); if (e.media !== t.media) return !0 === e.matches } return !1 }()) ? l.filter(e => "SDR" !== e) : ["SDR"]), { preferHDR: n, allowedVideoRanges: l }); for (let t = o.length; t--;) { let i = e[o[t]]; c = i.channels[2] > 0, g = Math.min(g, i.minHeight), m = Math.min(m, i.minFramerate), p = Math.min(p, i.minBitrate); let r = v.filter(e => i.videoRanges[e] > 0); r.length > 0 && (f = !0, T = r) } g = R(g) ? g : 0, m = R(m) ? m : 0; let S = Math.max(1080, g), A = Math.max(30, m); i = Math.max(p = R(p) ? p : i, i), f || (t = void 0, T = []); let L = o.reduce((t, r) => { let s = e[r]; if (r === t) return t; if (s.minBitrate > i) return logStartCodecCandidateIgnored(r, `min bitrate of ${s.minBitrate} > current estimate of ${i}`), t; if (!s.hasDefaultAudio) return logStartCodecCandidateIgnored(r, "no renditions with default or auto-select sound found"), t; if (d && r.indexOf(d.substring(0, 4)) % 5 != 0) return logStartCodecCandidateIgnored(r, `audio codec preference "${d}" not found`), t; if (h && !u) { if (!s.channels[h]) return logStartCodecCandidateIgnored(r, `no renditions with ${h} channel sound found (channels options: ${Object.keys(s.channels)})`), t } else if ((!d || u) && c && 0 === s.channels["2"]) return logStartCodecCandidateIgnored(r, "no renditions with stereo sound found"), t; return s.minHeight > S ? (logStartCodecCandidateIgnored(r, `min resolution of ${s.minHeight} > maximum of ${S}`), t) : s.minFramerate > A ? (logStartCodecCandidateIgnored(r, `min framerate of ${s.minFramerate} > maximum of ${A}`), t) : T.some(e => s.videoRanges[e] > 0) ? s.maxScore < E ? (logStartCodecCandidateIgnored(r, `max score of ${s.maxScore} < selected max of ${E}`), t) : t && (codecsSetSelectionPreferenceValue(r) >= codecsSetSelectionPreferenceValue(t) || s.fragmentError > e[t].fragmentError) ? t : (E = s.maxScore, r) : (logStartCodecCandidateIgnored(r, `no variants with VIDEO-RANGE of ${JSON.stringify(T)} found`), t) }, void 0); return { codecSet: L, videoRanges: T, preferHDR: y, minFramerate: m, minBitrate: p } }(r, A, e, I, D), { codecSet: a, videoRanges: n, minFramerate: l, minBitrate: o, preferHDR: d } = s; h = a, A = d ? n[n.length - 1] : n[0], L = l, e = Math.max(e, o), M.log(`[abr] picked start tier ${JSON.stringify(s)}`) } else h = null == y ? void 0 : y.codecSet, A = null == y ? void 0 : y.videoRange; let C = g ? g.duration : f ? f.duration : 0, k = this.bwEstimator.getEstimateTTFB() / 1e3, P = []; for (let l = i; l >= t; l--) { let t; let f = m[l], p = l > c; if (!f) continue; if (T.useMediaCapabilities && !f.supportedResult && !f.supportedPromise) { let t = navigator.mediaCapabilities; "function" == typeof (null == t ? void 0 : t.decodingInfo) && function (e, t, i, r, s, a) { let n = e.audioCodec ? e.audioGroups : null, l = null == a ? void 0 : a.audioCodec, o = null == a ? void 0 : a.channels, h = o ? parseInt(o) : l ? 1 / 0 : 2, d = null; if (null != n && n.length) try { d = 1 === n.length && n[0] ? t.groups[n[0]].channels : n.reduce((e, i) => { if (i) { let r = t.groups[i]; if (!r) throw Error(`Audio track group ${i} not found`); Object.keys(r.channels).forEach(t => { e[t] = (e[t] || 0) + r.channels[t] }) } return e }, { 2: 0 }) } catch (e) { return !0 } return void 0 !== e.videoCodec && (e.width > 1920 && e.height > 1088 || e.height > 1920 && e.width > 1088 || e.frameRate > Math.max(r, 30) || "SDR" !== e.videoRange && e.videoRange !== i || e.bitrate > Math.max(s, 8e6)) || !!d && R(h) && Object.keys(d).some(e => parseInt(e) > h) }(f, b, A, L, e, I) ? (f.supportedPromise = function (e, t, i) { let r = e.videoCodec, s = e.audioCodec; if (!r || !s || !i) return Promise.resolve(ed); let a = { width: e.width, height: e.height, bitrate: Math.ceil(Math.max(.9 * e.bitrate, e.averageBitrate)), framerate: e.frameRate || 30 }, n = e.videoRange; "SDR" !== n && (a.transferFunction = n.toLowerCase()); let l = r.split(",").map(e => ({ type: "media-source", video: _objectSpread2(_objectSpread2({}, a), {}, { contentType: mimeTypeForCodec(e, "video") }) })); return s && e.audioGroups && e.audioGroups.forEach(e => { var i; e && (null == (i = t.groups[e]) || i.tracks.forEach(t => { if (t.groupId === e) { let e = t.channels || "", i = parseFloat(e); R(i) && i > 2 && l.push.apply(l, s.split(",").map(e => ({ type: "media-source", audio: { contentType: mimeTypeForCodec(e, "audio"), channels: "" + i } }))) } })) }), Promise.all(l.map(e => { let t = function (e) { let { audio: t, video: i } = e, r = i || t; if (r) { let e = r.contentType.split('"')[1]; if (i) return `r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction || "sd"}_${e}_${Math.ceil(i.bitrate / 1e5)}`; if (t) return `c${t.channels}${t.spatialRendering ? "s" : "n"}_${e}` } return "" }(e); return eu[t] || (eu[t] = i.decodingInfo(e)) })).then(e => ({ supported: !e.some(e => !e.supported), configurations: l, decodingInfoResults: e })).catch(e => ({ supported: !1, configurations: l, decodingInfoResults: [], error: e })) }(f, b, t), f.supportedPromise.then(e => { if (!this.hls) return; f.supportedResult = e; let t = this.hls.levels, i = t.indexOf(f); e.error ? M.warn(`[abr] MediaCapabilities decodingInfo error: "${e.error}" for level ${i} ${JSON.stringify(e)}`) : !e.supported && (M.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${i} ${JSON.stringify(e)}`), i > -1 && t.length > 1 && (M.log(`[abr] Removing unsupported level ${i}`), this.hls.removeLevel(i))) })) : f.supportedResult = ed } if (h && f.codecSet !== h || A && f.videoRange !== A || p && L > f.frameRate || !p && L > 0 && L < f.frameRate || f.supportedResult && !(null != (o = f.supportedResult.decodingInfoResults) && o[0].smooth)) { P.push(l); continue } let D = f.details, _ = (g ? null == D ? void 0 : D.partTarget : null == D ? void 0 : D.averagetargetduration) || C; t = p ? n * e : a * e; let x = C && r >= 2 * C && 0 === s ? m[l].averageBitrate : m[l].maxBitrate, w = this.getTimeToLoadFrag(k, t, x * _, void 0 === D), F = t >= x && (l === u || 0 === f.loadError && 0 === f.fragmentError) && (w <= k || !R(w) || v && !this.bitrateTestDelay || w < d); if (F) { let e = this.forcedAutoLevel; return l !== E && (-1 === e || e !== E) && (P.length && M.trace(`[abr] Skipped level(s) ${P.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${m[P[0]].codecs}" ${m[P[0]].videoRange}; not compatible with "${y.codecs}" ${A}`), M.info(`[abr] switch candidate:${c}->${l} adjustedbw(${Math.round(t)})-bitrate=${Math.round(t - x)} ttfb:${k.toFixed(1)} avgDuration:${_.toFixed(1)} maxFetchDuration:${d.toFixed(1)} fetchDuration:${w.toFixed(1)} firstSelection:${S} codecSet:${h} videoRange:${A} hls.loadLevel:${E}`)), S && (this.firstSelection = l), l } } return -1 } set nextAutoLevel(e) { let { maxAutoLevel: t, minAutoLevel: i } = this.hls, r = Math.min(Math.max(e, i), t); this._nextAutoLevel !== r && (this.nextAutoLevelKey = "", this._nextAutoLevel = r) }
      }, bufferController: class { constructor(e) { this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = e => { this.hls && this.hls.pauseBuffering() }, this._onStartStreaming = e => { this.hls && this.hls.resumeBuffering() }, this._onMediaSourceOpen = () => { let { media: e, mediaSource: t } = this; this.log("Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(b.MEDIA_ATTACHED, { media: e, mediaSource: t })), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks() }, this._onMediaSourceClose = () => { this.log("Media source closed") }, this._onMediaSourceEnded = () => { this.log("Media source ended") }, this._onMediaEmptied = () => { let { mediaSrc: e, _objectUrl: t } = this; e !== t && M.error(`Media element src was set while attaching MediaSource (${t} > ${e})`) }, this.hls = e; let t = "[buffer-controller]"; this.appendSource = e.config.preferManagedMediaSource && "undefined" != typeof self && self.ManagedMediaSource, this.log = M.log.bind(M, t), this.warn = M.warn.bind(M, t), this.error = M.error.bind(M, t), this._initSourceBuffer(), this.registerListeners() } hasSourceTypes() { return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0 } destroy() { this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null } registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.BUFFER_RESET, this.onBufferReset, this), e.on(b.BUFFER_APPENDING, this.onBufferAppending, this), e.on(b.BUFFER_CODECS, this.onBufferCodecs, this), e.on(b.BUFFER_EOS, this.onBufferEos, this), e.on(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(b.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(b.FRAG_PARSED, this.onFragParsed, this), e.on(b.FRAG_CHANGED, this.onFragChanged, this) } unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.BUFFER_RESET, this.onBufferReset, this), e.off(b.BUFFER_APPENDING, this.onBufferAppending, this), e.off(b.BUFFER_CODECS, this.onBufferCodecs, this), e.off(b.BUFFER_EOS, this.onBufferEos, this), e.off(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(b.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(b.FRAG_PARSED, this.onFragParsed, this), e.off(b.FRAG_CHANGED, this.onFragChanged, this) } _initSourceBuffer() { this.sourceBuffer = {}, this.operationQueue = new BufferOperationQueue(this.sourceBuffer), this.listeners = { audio: [], video: [], audiovideo: [] }, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.lastMpegAudioChunk = null } onManifestLoading() { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null } onManifestParsed(e, t) { let i = 2; (!t.audio || t.video) && t.altAudio || (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`) } onMediaAttaching(e, t) { let i = this.media = t.media, r = getMediaSource(this.appendSource); if (i && r) { var s; let e = this.mediaSource = new r; this.log(`created media source: ${null == (s = e.constructor) ? void 0 : s.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming)); let t = this._objectUrl = self.URL.createObjectURL(e); if (this.appendSource) try { i.removeAttribute("src"); let r = self.ManagedMediaSource; i.disableRemotePlayback = i.disableRemotePlayback || r && e instanceof r, removeSourceChildren(i), function (e, t) { let i = self.document.createElement("source"); i.type = "video/mp4", i.src = t, e.appendChild(i) }(i, t), i.load() } catch (e) { i.src = t } else i.src = t; i.addEventListener("emptied", this._onMediaEmptied) } } onMediaDetaching() { let { media: e, mediaSource: t, _objectUrl: i } = this; if (t) { if (this.log("media source detaching"), "open" === t.readyState) try { t.endOfStream() } catch (e) { this.warn(`onMediaDetaching: ${e.message} while calling endOfStream`) } this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (t.removeEventListener("startstreaming", this._onStartStreaming), t.removeEventListener("endstreaming", this._onEndStreaming)), e && (e.removeEventListener("emptied", this._onMediaEmptied), i && self.URL.revokeObjectURL(i), this.mediaSrc === i ? (e.removeAttribute("src"), this.appendSource && removeSourceChildren(e), e.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {} } this.hls.trigger(b.MEDIA_DETACHED, void 0) } onBufferReset() { this.getSourceBufferTypes().forEach(e => { this.resetBuffer(e) }), this._initSourceBuffer() } resetBuffer(e) { let t = this.sourceBuffer[e]; try { if (t) { var i; this.removeBufferListeners(e), this.sourceBuffer[e] = void 0, null != (i = this.mediaSource) && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t) } } catch (t) { this.warn(`onBufferReset ${e}`, t) } } onBufferCodecs(e, t) { let i = this.getSourceBufferTypes().length, r = Object.keys(t); if (r.forEach(e => { if (i) { let i = this.tracks[e]; if (i && "function" == typeof i.buffer.changeType) { var r; let { id: s, codec: a, levelCodec: n, container: l, metadata: o } = t[e], h = pickMostCompleteCodecName(i.codec, i.levelCodec), d = null == h ? void 0 : h.replace(eb, "$1"), u = pickMostCompleteCodecName(a, n), c = null == (r = u) ? void 0 : r.replace(eb, "$1"); if (u && d !== c) { "audio" === e.slice(0, 5) && (u = getCodecCompatibleName(u, this.appendSource)); let t = `${l};codecs=${u}`; this.appendChangeType(e, t), this.log(`switching codec ${h} to ${u}`), this.tracks[e] = { buffer: i.buffer, codec: a, container: l, levelCodec: n, metadata: o, id: s } } } } else this.pendingTracks[e] = t[e] }), i) return; let s = Math.max(this.bufferCodecEventsExpected - 1, 0); this.bufferCodecEventsExpected !== s && (this.log(`${s} bufferCodec event(s) expected ${r.join(",")}`), this.bufferCodecEventsExpected = s), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks() } appendChangeType(e, t) { let { operationQueue: i } = this; i.append({ execute: () => { let r = this.sourceBuffer[e]; r && (this.log(`changing ${e} sourceBuffer type to ${t}`), r.changeType(t)), i.shiftAndExecuteNext(e) }, onStart: () => { }, onComplete: () => { }, onError: t => { this.warn(`Failed to change ${e} SourceBuffer type`, t) } }, e, !!this.pendingTracks[e]) } onBufferAppending(e, t) { let { hls: i, operationQueue: r, tracks: s } = this, { data: a, type: n, frag: l, part: o, chunkMeta: h } = t, d = h.buffering[n], u = self.performance.now(); d.start = u; let c = l.stats.buffering, f = o ? o.stats.buffering : null; 0 === c.start && (c.start = u), f && 0 === f.start && (f.start = u); let g = s.audio, m = !1; "audio" === n && (null == g ? void 0 : g.container) === "audio/mpeg" && (m = !this.lastMpegAudioChunk || 1 === h.id || this.lastMpegAudioChunk.sn !== h.sn, this.lastMpegAudioChunk = h); let p = l.start; r.append({ execute: () => { if (d.executeStart = self.performance.now(), m) { let e = this.sourceBuffer[n]; if (e) { let t = p - e.timestampOffset; Math.abs(t) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${p} (delta: ${t}) sn: ${l.sn})`), e.timestampOffset = p) } } this.appendExecutor(a, n) }, onStart: () => { }, onComplete: () => { let e = self.performance.now(); d.executeEnd = d.end = e, 0 === c.first && (c.first = e), f && 0 === f.first && (f.first = e); let { sourceBuffer: t } = this, i = {}; for (let e in t) i[e] = BufferHelper.getBuffered(t[e]); this.appendErrors[n] = 0, "audio" === n || "video" === n ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(b.BUFFER_APPENDED, { type: n, frag: l, part: o, chunkMeta: h, parent: l.type, timeRanges: i }) }, onError: e => { let t = { type: C.MEDIA_ERROR, parent: l.type, details: k.BUFFER_APPEND_ERROR, sourceBufferName: n, frag: l, part: o, chunkMeta: h, error: e, err: e, fatal: !1 }; if (e.code === DOMException.QUOTA_EXCEEDED_ERR) t.details = k.BUFFER_FULL_ERROR; else { let e = ++this.appendErrors[n]; t.details = k.BUFFER_APPEND_ERROR, this.warn(`Failed ${e}/${i.config.appendErrorMaxRetry} times to append segment in "${n}" sourceBuffer`), e >= i.config.appendErrorMaxRetry && (t.fatal = !0) } i.trigger(b.ERROR, t) } }, n, !!this.pendingTracks[n]) } onBufferFlushing(e, t) { let { operationQueue: i } = this, flushOperation = e => ({ execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset), onStart: () => { }, onComplete: () => { this.hls.trigger(b.BUFFER_FLUSHED, { type: e }) }, onError: t => { this.warn(`Failed to remove from ${e} SourceBuffer`, t) } }); t.type ? i.append(flushOperation(t.type), t.type) : this.getSourceBufferTypes().forEach(e => { i.append(flushOperation(e), e) }) } onFragParsed(e, t) { let { frag: i, part: r } = t, s = [], a = r ? r.elementaryStreams : i.elementaryStreams; a[F.AUDIOVIDEO] ? s.push("audiovideo") : (a[F.AUDIO] && s.push("audio"), a[F.VIDEO] && s.push("video")), 0 === s.length && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers(() => { let e = self.performance.now(); i.stats.buffering.end = e, r && (r.stats.buffering.end = e); let t = r ? r.stats : i.stats; this.hls.trigger(b.FRAG_BUFFERED, { frag: i, part: r, stats: t, id: i.type }) }, s) } onFragChanged(e, t) { this.trimBuffers() } onBufferEos(e, t) { let i = this.getSourceBufferTypes().reduce((e, i) => { let r = this.sourceBuffer[i]; return !r || t.type && t.type !== i || (r.ending = !0, r.ended || (r.ended = !0, this.log(`${i} sourceBuffer now EOS`))), e && !!(!r || r.ended) }, !0); i && (this.log("Queueing mediaSource.endOfStream()"), this.blockBuffers(() => { this.getSourceBufferTypes().forEach(e => { let t = this.sourceBuffer[e]; t && (t.ending = !1) }); let { mediaSource: e } = this; if (!e || "open" !== e.readyState) { e && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`); return } this.log("Calling mediaSource.endOfStream()"), e.endOfStream() })) } onLevelUpdated(e, { details: t }) { t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration()) } trimBuffers() { let { hls: e, details: t, media: i } = this; if (!i || null === t) return; let r = this.getSourceBufferTypes(); if (!r.length) return; let s = e.config, a = i.currentTime, n = t.levelTargetDuration, l = t.live && null !== s.liveBackBufferLength ? s.liveBackBufferLength : s.backBufferLength; if (R(l) && l > 0) { let e = Math.max(l, n), t = Math.floor(a / n) * n - e; this.flushBackBuffer(a, n, t) } if (R(s.frontBufferFlushThreshold) && s.frontBufferFlushThreshold > 0) { let e = Math.max(s.maxBufferLength, s.frontBufferFlushThreshold), t = Math.max(e, n), i = Math.floor(a / n) * n + t; this.flushFrontBuffer(a, n, i) } } flushBackBuffer(e, t, i) { let { details: r, sourceBuffer: s } = this, a = this.getSourceBufferTypes(); a.forEach(a => { let n = s[a]; if (n) { let s = BufferHelper.getBuffered(n); if (s.length > 0 && i > s.start(0)) { if (this.hls.trigger(b.BACK_BUFFER_REACHED, { bufferEnd: i }), null != r && r.live) this.hls.trigger(b.LIVE_BACK_BUFFER_REACHED, { bufferEnd: i }); else if (n.ended && s.end(s.length - 1) - e < 2 * t) { this.log(`Cannot flush ${a} back buffer while SourceBuffer is in ended state`); return } this.hls.trigger(b.BUFFER_FLUSHING, { startOffset: 0, endOffset: i, type: a }) } } }) } flushFrontBuffer(e, t, i) { let { sourceBuffer: r } = this, s = this.getSourceBufferTypes(); s.forEach(s => { let a = r[s]; if (a) { let r = BufferHelper.getBuffered(a), n = r.length; if (n < 2) return; let l = r.start(n - 1), o = r.end(n - 1); if (i > l || e >= l && e <= o) return; if (a.ended && e - o < 2 * t) { this.log(`Cannot flush ${s} front buffer while SourceBuffer is in ended state`); return } this.hls.trigger(b.BUFFER_FLUSHING, { startOffset: l, endOffset: 1 / 0, type: s }) } }) } updateMediaElementDuration() { if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return; let { details: e, hls: t, media: i, mediaSource: r } = this, s = e.fragments[0].start + e.totalduration, a = i.duration, n = R(r.duration) ? r.duration : 0; e.live && t.config.liveDurationInfinity ? (r.duration = 1 / 0, this.updateSeekableRange(e)) : (s > n && s > a || !R(a)) && (this.log(`Updating Media Source duration to ${s.toFixed(3)}`), r.duration = s) } updateSeekableRange(e) { let t = this.mediaSource, i = e.fragments, r = i.length; if (r && e.live && null != t && t.setLiveSeekableRange) { let r = Math.max(0, i[0].start), s = Math.max(r, r + e.totalduration); this.log(`Media Source duration is set to ${t.duration}. Setting seekable range to ${r}-${s}.`), t.setLiveSeekableRange(r, s) } } checkPendingTracks() { let { bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: i } = this, r = Object.keys(i).length; if (r && (!e || 2 === r || "audiovideo" in i)) { this.createSourceBuffers(i), this.pendingTracks = {}; let e = this.getSourceBufferTypes(); if (e.length) this.hls.trigger(b.BUFFER_CREATED, { tracks: this.tracks }), e.forEach(e => { t.executeNext(e) }); else { let e = Error("could not create source buffer for media codec(s)"); this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: !0, error: e, reason: e.message }) } } } createSourceBuffers(e) { let { sourceBuffer: t, mediaSource: i } = this; if (!i) throw Error("createSourceBuffers called when mediaSource was null"); for (let r in e) if (!t[r]) { let s = e[r]; if (!s) throw Error(`source buffer exists for track ${r}, however track does not`); let a = s.levelCodec || s.codec; a && "audio" === r.slice(0, 5) && (a = getCodecCompatibleName(a, this.appendSource)); let n = `${s.container};codecs=${a}`; this.log(`creating sourceBuffer(${n})`); try { let e = t[r] = i.addSourceBuffer(n); this.addBufferListener(r, "updatestart", this._onSBUpdateStart), this.addBufferListener(r, "updateend", this._onSBUpdateEnd), this.addBufferListener(r, "error", this._onSBUpdateError), this.appendSource && this.addBufferListener(r, "bufferedchange", (e, t) => { let i = t.removedRanges; null != i && i.length && this.hls.trigger(b.BUFFER_FLUSHED, { type: r }) }), this.tracks[r] = { buffer: e, codec: a, container: s.container, levelCodec: s.levelCodec, metadata: s.metadata, id: s.id } } catch (e) { this.error(`error while trying to add sourceBuffer: ${e.message}`), this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_ADD_CODEC_ERROR, fatal: !1, error: e, sourceBufferName: r, mimeType: n }) } } } get mediaSrc() { var e; let t = (null == (e = this.media) ? void 0 : e.firstChild) || this.media; return null == t ? void 0 : t.src } _onSBUpdateStart(e) { let { operationQueue: t } = this, i = t.current(e); i.onStart() } _onSBUpdateEnd(e) { var t; if ((null == (t = this.mediaSource) ? void 0 : t.readyState) === "closed") { this.resetBuffer(e); return } let { operationQueue: i } = this, r = i.current(e); r.onComplete(), i.shiftAndExecuteNext(e) } _onSBUpdateError(e, t) { var i; let r = Error(`${e} SourceBuffer error. MediaSource readyState: ${null == (i = this.mediaSource) ? void 0 : i.readyState}`); this.error(`${r}`, t), this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_APPENDING_ERROR, sourceBufferName: e, error: r, fatal: !1 }); let s = this.operationQueue.current(e); s && s.onError(r) } removeExecutor(e, t, i) { let { media: r, mediaSource: s, operationQueue: a, sourceBuffer: n } = this, l = n[e]; if (!r || !s || !l) { this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), a.shiftAndExecuteNext(e); return } let o = R(r.duration) ? r.duration : 1 / 0, h = R(s.duration) ? s.duration : 1 / 0, d = Math.max(0, t), u = Math.min(i, o, h); u > d && (!l.ending || l.ended) ? (l.ended = !1, this.log(`Removing [${d},${u}] from the ${e} SourceBuffer`), l.remove(d, u)) : a.shiftAndExecuteNext(e) } appendExecutor(e, t) { let i = this.sourceBuffer[t]; if (!i) { if (!this.pendingTracks[t]) throw Error(`Attempting to append to the ${t} SourceBuffer, but it does not exist`); return } i.ended = !1, i.appendBuffer(e) } blockBuffers(e, t = this.getSourceBufferTypes()) { if (!t.length) { this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e); return } let { operationQueue: i } = this, r = t.map(e => i.appendBlocker(e)); Promise.all(r).then(() => { e(), t.forEach(e => { let t = this.sourceBuffer[e]; null != t && t.updating || i.shiftAndExecuteNext(e) }) }) } getSourceBufferTypes() { return Object.keys(this.sourceBuffer) } addBufferListener(e, t, i) { let r = this.sourceBuffer[e]; if (!r) return; let s = i.bind(this, e); this.listeners[e].push({ event: t, listener: s }), r.addEventListener(t, s) } removeBufferListeners(e) { let t = this.sourceBuffer[e]; t && this.listeners[e].forEach(e => { t.removeEventListener(e.event, e.listener) }) } }, capLevelController: CapLevelController, errorController: class { constructor(e) { this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = M.log.bind(M, "[info]:"), this.warn = M.warn.bind(M, "[warning]:"), this.error = M.error.bind(M, "[error]:"), this.registerListeners() } registerListeners() { let e = this.hls; e.on(b.ERROR, this.onError, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.LEVEL_UPDATED, this.onLevelUpdated, this) } unregisterListeners() { let e = this.hls; e && (e.off(b.ERROR, this.onError, this), e.off(b.ERROR, this.onErrorOut, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.LEVEL_UPDATED, this.onLevelUpdated, this)) } destroy() { this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {} } startLoad(e) { } stopLoad() { this.playlistError = 0 } getVariantLevelIndex(e) { return (null == e ? void 0 : e.type) === et.MAIN ? e.level : this.hls.loadLevel } onManifestLoading() { this.playlistError = 0, this.penalizedRenditions = {} } onLevelUpdated() { this.playlistError = 0 } onError(e, t) { var i, r, s, a; if (t.fatal) return; let n = this.hls, l = t.context; switch (t.details) { case k.FRAG_LOAD_ERROR: case k.FRAG_LOAD_TIMEOUT: case k.KEY_LOAD_ERROR: case k.KEY_LOAD_TIMEOUT: t.errorAction = this.getFragRetryOrSwitchAction(t); return; case k.FRAG_PARSING_ERROR: if (null != (i = t.frag) && i.gap) { t.errorAction = { action: eo.DoNothing, flags: eh.None }; return } case k.FRAG_GAP: case k.FRAG_DECRYPT_ERROR: t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = eo.SendAlternateToPenaltyBox; return; case k.LEVEL_EMPTY_ERROR: case k.LEVEL_PARSING_ERROR: { let e = t.parent === et.MAIN ? t.level : n.loadLevel; t.details === k.LEVEL_EMPTY_ERROR && null != (s = t.context) && null != (a = s.levelDetails) && a.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e)) } return; case k.LEVEL_LOAD_ERROR: case k.LEVEL_LOAD_TIMEOUT: "number" == typeof (null == l ? void 0 : l.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l.level)); return; case k.AUDIO_TRACK_LOAD_ERROR: case k.AUDIO_TRACK_LOAD_TIMEOUT: case k.SUBTITLE_LOAD_ERROR: case k.SUBTITLE_TRACK_LOAD_TIMEOUT: if (l) { let e = n.levels[n.loadLevel]; e && (l.type === ee.AUDIO_TRACK && e.hasAudioGroup(l.groupId) || l.type === ee.SUBTITLE_TRACK && e.hasSubtitleGroup(l.groupId)) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.loadLevel), t.errorAction.action = eo.SendAlternateToPenaltyBox, t.errorAction.flags = eh.MoveAllAlternatesMatchingHost) } return; case k.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: { let e = n.levels[n.loadLevel], i = null == e ? void 0 : e.attrs["HDCP-LEVEL"]; i ? t.errorAction = { action: eo.SendAlternateToPenaltyBox, flags: eh.MoveAllAlternatesMatchingHDCP, hdcpLevel: i } : this.keySystemError(t) } return; case k.BUFFER_ADD_CODEC_ERROR: case k.REMUX_ALLOC_ERROR: case k.BUFFER_APPEND_ERROR: t.errorAction = this.getLevelSwitchAction(t, null != (r = t.level) ? r : n.loadLevel); return; case k.INTERNAL_EXCEPTION: case k.BUFFER_APPENDING_ERROR: case k.BUFFER_FULL_ERROR: case k.LEVEL_SWITCH_ERROR: case k.BUFFER_STALLED_ERROR: case k.BUFFER_SEEK_OVER_HOLE: case k.BUFFER_NUDGE_ON_STALL: t.errorAction = { action: eo.DoNothing, flags: eh.None }; return }t.type === C.KEY_SYSTEM_ERROR && this.keySystemError(t) } keySystemError(e) { let t = this.getVariantLevelIndex(e.frag); e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t) } getPlaylistRetryOrSwitchAction(e, t) { let i = this.hls, r = getRetryConfig(i.config.playlistLoadPolicy, e), s = this.playlistError++, a = shouldRetry(r, s, isTimeoutError(e), e.response); if (a) return { action: eo.RetryRequest, flags: eh.None, retryConfig: r, retryCount: s }; let n = this.getLevelSwitchAction(e, t); return r && (n.retryConfig = r, n.retryCount = s), n } getFragRetryOrSwitchAction(e) { let t = this.hls, i = this.getVariantLevelIndex(e.frag), r = t.levels[i], { fragLoadPolicy: s, keyLoadPolicy: a } = t.config, n = getRetryConfig(e.details.startsWith("key") ? a : s, e), l = t.levels.reduce((e, t) => e + t.fragmentError, 0); if (r) { e.details !== k.FRAG_GAP && r.fragmentError++; let t = shouldRetry(n, l, isTimeoutError(e), e.response); if (t) return { action: eo.RetryRequest, flags: eh.None, retryConfig: n, retryCount: l } } let o = this.getLevelSwitchAction(e, i); return n && (o.retryConfig = n, o.retryCount = l), o } getLevelSwitchAction(e, t) { let i = this.hls; null == t && (t = i.loadLevel); let r = this.hls.levels[t]; if (r) { var s, a, n, l; let t = e.details; r.loadError++, t === k.BUFFER_APPEND_ERROR && r.fragmentError++; let o = -1, { levels: h, loadLevel: d, minAutoLevel: u, maxAutoLevel: c } = i; i.autoLevelEnabled || (i.loadLevel = -1); let f = null == (s = e.frag) ? void 0 : s.type, g = f === et.AUDIO && t === k.FRAG_PARSING_ERROR || "audio" === e.sourceBufferName && (t === k.BUFFER_ADD_CODEC_ERROR || t === k.BUFFER_APPEND_ERROR), m = g && h.some(({ audioCodec: e }) => r.audioCodec !== e), p = "video" === e.sourceBufferName && (t === k.BUFFER_ADD_CODEC_ERROR || t === k.BUFFER_APPEND_ERROR), E = p && h.some(({ codecSet: e, audioCodec: t }) => r.codecSet !== e && r.audioCodec === t), { type: T, groupId: y } = null != (a = e.context) ? a : {}; for (let i = h.length; i--;) { let s = (i + d) % h.length; if (s !== d && s >= u && s <= c && 0 === h[s].loadError) { let i = h[s]; if (t === k.FRAG_GAP && e.frag) { let t = h[s].details; if (t) { let i = findFragmentByPTS(e.frag, t.fragments, e.frag.start); if (null != i && i.gap) continue } } else if (T === ee.AUDIO_TRACK && i.hasAudioGroup(y) || T === ee.SUBTITLE_TRACK && i.hasSubtitleGroup(y)) continue; else if (f === et.AUDIO && null != (n = r.audioGroups) && n.some(e => i.hasAudioGroup(e)) || f === et.SUBTITLE && null != (l = r.subtitleGroups) && l.some(e => i.hasSubtitleGroup(e)) || m && r.audioCodec === i.audioCodec || !m && r.audioCodec !== i.audioCodec || E && r.codecSet === i.codecSet) continue; o = s; break } } if (o > -1 && i.loadLevel !== o) return e.levelRetry = !0, this.playlistError = 0, { action: eo.SendAlternateToPenaltyBox, flags: eh.None, nextAutoLevel: o } } return { action: eo.SendAlternateToPenaltyBox, flags: eh.MoveAllAlternatesMatchingHost } } onErrorOut(e, t) { var i; switch (null == (i = t.errorAction) ? void 0 : i.action) { case eo.DoNothing: break; case eo.SendAlternateToPenaltyBox: this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === k.FRAG_GAP ? /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()) : t.fatal = !0; case eo.RetryRequest: }if (t.fatal) { this.hls.stopLoad(); return } } sendAlternateToPenaltyBox(e) { let t = this.hls, i = e.errorAction; if (!i) return; let { flags: r, hdcpLevel: s, nextAutoLevel: a } = i; switch (r) { case eh.None: this.switchLevel(e, a); break; case eh.MoveAllAlternatesMatchingHDCP: s && (t.maxHdcpLevel = es[es.indexOf(s) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`) }i.resolved || this.switchLevel(e, a) } switchLevel(e, t) { void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel) } }, fpsController: class { constructor(e) { this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners() } setStreamController(e) { this.streamController = e } registerListeners() { this.hls.on(b.MEDIA_ATTACHING, this.onMediaAttaching, this) } unregisterListeners() { this.hls.off(b.MEDIA_ATTACHING, this.onMediaAttaching, this) } destroy() { this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null } onMediaAttaching(e, t) { let i = this.hls.config; if (i.capLevelOnFPSDrop) { let e = t.media instanceof self.HTMLVideoElement ? t.media : null; this.media = e, e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod) } } checkFPS(e, t, i) { let r = performance.now(); if (t) { if (this.lastTime) { let e = r - this.lastTime, s = i - this.lastDroppedFrames, a = t - this.lastDecodedFrames, n = this.hls; if (n.trigger(b.FPS_DROP, { currentDropped: s, currentDecoded: a, totalDroppedFrames: i }), 1e3 * s / e > 0 && s > n.config.fpsDroppedMonitoringThreshold * a) { let e = n.currentLevel; M.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e), e > 0 && (-1 === n.autoLevelCapping || n.autoLevelCapping >= e) && (e -= 1, n.trigger(b.FPS_DROP_LEVEL_CAPPING, { level: e, droppedLevel: n.currentLevel }), n.autoLevelCapping = e, this.streamController.nextLevelSwitch()) } } this.lastTime = r, this.lastDroppedFrames = i, this.lastDecodedFrames = t } } checkFPSInterval() { let e = this.media; if (e) { if (this.isVideoPlaybackQualityAvailable) { let t = e.getVideoPlaybackQuality(); this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames) } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount) } } }, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrEwmaDefaultEstimateMax: 5e6, abrBandWidthFactor: .95, abrBandWidthUpFactor: .7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, drmSystems: {}, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: $, testBandwidth: !0, progressive: !1, lowLatencyMode: !0, cmcd: void 0, enableDateRangeMetadataCues: !0, enableEmsgMetadataCues: !0, enableID3MetadataCues: !0, useMediaCapabilities: !0, certLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null } }, keyLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" }, errorRetry: { maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" } } }, manifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1 / 0, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, playlistLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, fragLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 12e4, timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, steeringManifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3
    }, { cueHandler: { newCue(e, t, i, r) { let s, a, n, l, o; let h = [], d = self.VTTCue || self.TextTrackCue; for (let c = 0; c < r.rows.length; c++)if (s = r.rows[c], n = !0, l = 0, o = "", !s.isEmpty()) { var u; for (let e = 0; e < s.chars.length; e++)eX.test(s.chars[e].uchar) && n ? l++ : (o += s.chars[e].uchar, n = !1); s.cueStartTime = t, t === i && (i += 1e-4), l >= 16 ? l-- : l++; let r = fixLineBreaks(o.trim()), f = generateCueId(t, i, r); null != e && null != (u = e.cues) && u.getCueById(f) || ((a = new d(t, i, r)).id = f, a.line = c + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)), h.push(a)) } return e && h.length && (h.sort((e, t) => "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line), h.forEach(t => addCueToTrack(e, t))), h } }, enableWebVTT: !0, enableIMSC1: !0, enableCEA708Captions: !0, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es", captionsTextTrack3Label: "Unknown CC", captionsTextTrack3LanguageCode: "", captionsTextTrack4Label: "Unknown CC", captionsTextTrack4LanguageCode: "", renderTextTracksNatively: !0 }), {}, { subtitleStreamController: class extends BaseStreamController { constructor(e, t, i) { super(e, t, i, "[subtitle-stream-controller]", et.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null } _registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.LEVEL_LOADED, this.onLevelLoaded, this), e.on(b.ERROR, this.onError, this), e.on(b.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(b.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(b.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(b.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.LEVEL_LOADED, this.onLevelLoaded, this), e.off(b.ERROR, this.onError, this), e.off(b.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(b.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(b.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(b.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this) } startLoad(e) { this.stopLoad(), this.state = em.IDLE, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } onManifestLoading() { this.mainDetails = null, this.fragmentTracker.removeAllFragments() } onMediaDetaching() { this.tracksBuffered = [], super.onMediaDetaching() } onLevelLoaded(e, t) { this.mainDetails = t.details } onSubtitleFragProcessed(e, t) { let i; let { frag: r, success: s } = t; if (this.fragPrevious = r, this.state = em.IDLE, !s) return; let a = this.tracksBuffered[this.currentTrackId]; if (!a) return; let n = r.start; for (let e = 0; e < a.length; e++)if (n >= a[e].start && n <= a[e].end) { i = a[e]; break } let l = r.start + r.duration; i ? i.end = l : (i = { start: n, end: l }, a.push(i)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null) } onBufferFlushing(e, t) { let { startOffset: i, endOffset: r } = t; if (0 === i && r !== Number.POSITIVE_INFINITY) { let e = r - 1; if (e <= 0) return; t.endOffsetSubtitles = Math.max(0, e), this.tracksBuffered.forEach(t => { for (let i = 0; i < t.length;) { if (t[i].end <= e) { t.shift(); continue } if (t[i].start < e) t[i].start = e; else break; i++ } }), this.fragmentTracker.removeFragmentsInRange(i, e, et.SUBTITLE) } } onFragBuffered(e, t) { if (!this.loadedmetadata && t.frag.type === et.MAIN) { var i; null != (i = this.media) && i.buffered.length && (this.loadedmetadata = !0) } } onError(e, t) { let i = t.frag; (null == i ? void 0 : i.type) === et.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== em.STOPPED && (this.state = em.IDLE)) } onSubtitleTracksUpdated(e, { subtitleTracks: t }) { if (this.levels && subtitleOptionsIdentical(this.levels, t)) { this.levels = t.map(e => new Level(e)); return } this.tracksBuffered = [], this.levels = t.map(e => { let t = new Level(e); return this.tracksBuffered[t.id] = [], t }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, et.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null } onSubtitleTrackSwitch(e, t) { var i; if (this.currentTrackId = t.id, !(null != (i = this.levels) && i.length) || -1 === this.currentTrackId) { this.clearInterval(); return } let r = this.levels[this.currentTrackId]; null != r && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(500) } onSubtitleTrackLoaded(e, t) { var i, r; let { currentTrackId: s, levels: a } = this, { details: n, id: l } = t; if (!a) { this.warn(`Subtitle tracks were reset while loading level ${l}`); return } let o = a[s]; if (l >= a.length || l !== s || !o) return; this.log(`Subtitle track ${l} loaded [${n.startSN},${n.endSN}]${n.lastPartSn ? `[part-${n.lastPartSn}-${n.lastPartIndex}]` : ""},duration:${n.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges; let h = 0; if (n.live || null != (i = o.details) && i.live) { let e = this.mainDetails; if (n.deltaUpdateFailed || !e) return; let t = e.fragments[0]; o.details ? 0 === (h = this.alignPlaylists(n, o.details, null == (r = this.levelLastLoaded) ? void 0 : r.details)) && t && addSliding(n, h = t.start) : n.hasProgramDateTime && e.hasProgramDateTime ? (alignMediaPlaylistByPDT(n, e), h = n.fragments[0].start) : t && addSliding(n, h = t.start) } if (o.details = n, this.levelLastLoaded = o, this.startFragRequested || !this.mainDetails && n.live || this.setStartPosition(this.mainDetails || n, h), this.tick(), n.live && !this.fragCurrent && this.media && this.state === em.IDLE) { let e = findFragmentByPTS(null, n.fragments, this.media.currentTime, 0); e || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0) } } _handleFragmentLoadComplete(e) { let { frag: t, payload: i } = e, r = t.decryptdata, s = this.hls; if (!this.fragContextChanged(t) && i && i.byteLength > 0 && null != r && r.key && r.iv && "AES-128" === r.method) { let e = performance.now(); this.decrypter.decrypt(new Uint8Array(i), r.key.buffer, r.iv.buffer).catch(e => { throw s.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.FRAG_DECRYPT_ERROR, fatal: !1, error: e, reason: e.message, frag: t }), e }).then(i => { let r = performance.now(); s.trigger(b.FRAG_DECRYPTED, { frag: t, payload: i, stats: { tstart: e, tdecrypt: r } }) }).catch(e => { this.warn(`${e.name}: ${e.message}`), this.state = em.IDLE }) } } doTick() { if (!this.media) { this.state = em.IDLE; return } if (this.state === em.IDLE) { let { currentTrackId: e, levels: t } = this, i = null == t ? void 0 : t[e]; if (!i || !t.length || !i.details) return; let { config: r } = this, s = this.getLoadPosition(), a = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, r.maxBufferHole), { end: n, len: l } = a, o = this.getFwdBufferInfo(this.media, et.MAIN), h = i.details, d = this.getMaxBufferLength(null == o ? void 0 : o.len) + h.levelTargetDuration; if (l > d) return; let u = h.fragments, c = u.length, f = h.edge, g = null, m = this.fragPrevious; if (n < f) { let e = r.maxFragLookUpTolerance, t = n > f - e ? 0 : e; (g = findFragmentByPTS(m, u, Math.max(u[0].start, n), t)) || !m || !(m.start < u[0].start) || (g = u[0]) } else g = u[c - 1]; if (!g) return; if ("initSegment" !== (g = this.mapToInitFragWhenRequired(g)).sn) { let e = g.sn - h.startSN, t = u[e - 1]; t && t.cc === g.cc && this.fragmentTracker.getState(t) === ec.NOT_LOADED && (g = t) } this.fragmentTracker.getState(g) === ec.NOT_LOADED && this.loadFragment(g, i, n) } } getMaxBufferLength(e) { let t = super.getMaxBufferLength(); return e ? Math.max(t, e) : t } loadFragment(e, t, i) { this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) } get mediaBufferTimeRanges() { return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []) } }, subtitleTrackController: class extends BasePlaylistController { constructor(e) { super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.onTextTracksChanged = () => { if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return; let e = null, t = filterSubtitleTracks(this.media.textTracks); for (let i = 0; i < t.length; i++)if ("hidden" === t[i].mode) e = t[i]; else if ("showing" === t[i].mode) { e = t[i]; break } let i = this.findTrackForTextTrack(e); this.subtitleTrack !== i && this.setSubtitleTrack(i) }, this.registerListeners() } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy() } get subtitleDisplay() { return this._subtitleDisplay } set subtitleDisplay(e) { this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes() } registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.LEVEL_LOADING, this.onLevelLoading, this), e.on(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(b.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(b.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.LEVEL_LOADING, this.onLevelLoading, this), e.off(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(b.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(b.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange)) } pollTrackChange(e) { self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e) } onMediaDetaching() { if (!this.media) return; self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId); let e = filterSubtitleTracks(this.media.textTracks); e.forEach(e => { clearCurrentCues(e) }), this.subtitleTrack = -1, this.media = null } onManifestLoading() { this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.subtitleTracks } onSubtitleTrackLoaded(e, t) { let { id: i, groupId: r, details: s } = t, a = this.tracksInGroup[i]; if (!a || a.groupId !== r) { this.warn(`Subtitle track with id:${i} and group:${r} not found in active group ${null == a ? void 0 : a.groupId}`); return } let n = a.details; a.details = t.details, this.log(`Subtitle track ${i} "${a.name}" lang:${a.lang} group:${r} loaded [${s.startSN}-${s.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, n) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { let t = this.hls.levels[e]; if (!t) return; let i = t.subtitleGroups || null, r = this.groupIds, s = this.currentTrack; if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some(e => (null == r ? void 0 : r.indexOf(e)) === -1)) { this.groupIds = i, this.trackId = -1, this.currentTrack = null; let e = this.tracks.filter(e => !i || -1 !== i.indexOf(e.groupId)); if (e.length) this.selectDefaultTrack && !e.some(e => e.default) && (this.selectDefaultTrack = !1), e.forEach((e, t) => { e.id = t }); else if (!s && !this.tracksInGroup.length) return; this.tracksInGroup = e; let t = this.hls.config.subtitlePreference; if (!s && t) { this.selectDefaultTrack = !1; let i = findMatchingOption(t, e); if (i > -1) s = e[i]; else { let e = findMatchingOption(t, this.tracks); s = this.tracks[e] } } let r = this.findTrackId(s); -1 === r && s && (r = this.findTrackId(null)), this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${null == i ? void 0 : i.join(",")}" group-id`), this.hls.trigger(b.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: e }), -1 !== r && -1 === this.trackId && this.setSubtitleTrack(r) } else this.shouldReloadPlaylist(s) && this.setSubtitleTrack(this.trackId) } findTrackId(e) { let t = this.tracksInGroup, i = this.selectDefaultTrack; for (let r = 0; r < t.length; r++) { let s = t[r]; if ((!i || s.default) && (i || e) && (!e || matchesOption(s, e))) return r } if (e) { for (let i = 0; i < t.length; i++) { let r = t[i]; if (mediaAttributesIdentical(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i } for (let i = 0; i < t.length; i++) { let r = t[i]; if (mediaAttributesIdentical(e.attrs, r.attrs, ["LANGUAGE"])) return i } } return -1 } findTrackForTextTrack(e) { if (e) { let t = this.tracksInGroup; for (let i = 0; i < t.length; i++) { let r = t[i]; if (subtitleTrackMatchesTextTrack(r, e)) return i } } return -1 } onError(e, t) { !t.fatal && t.context && (t.context.type !== ee.SUBTITLE_TRACK || t.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(t.context.groupId) || this.checkRetry(t)) } get allSubtitleTracks() { return this.tracks } get subtitleTracks() { return this.tracksInGroup } get subtitleTrack() { return this.trackId } set subtitleTrack(e) { this.selectDefaultTrack = !1, this.setSubtitleTrack(e) } setSubtitleOption(e) { if (this.hls.config.subtitlePreference = e, e) { let t = this.allSubtitleTracks; if (this.selectDefaultTrack = !1, t.length) { let i = this.currentTrack; if (i && matchesOption(e, i)) return i; let r = findMatchingOption(e, this.tracksInGroup); if (r > -1) { let e = this.tracksInGroup[r]; return this.setSubtitleTrack(r), e } if (i); else { let i = findMatchingOption(e, t); if (i > -1) return t[i] } } } return null } loadPlaylist(e) { super.loadPlaylist(); let t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { let i = t.id, r = t.groupId, s = t.url; if (e) try { s = e.addDirectives(s) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } this.log(`Loading subtitle playlist for id ${i}`), this.hls.trigger(b.SUBTITLE_TRACK_LOADING, { url: s, id: i, groupId: r, deliveryDirectives: e || null }) } } toggleTrackModes() { let e; let { media: t } = this; if (!t) return; let i = filterSubtitleTracks(t.textTracks), r = this.currentTrack; if (!r || (e = i.filter(e => subtitleTrackMatchesTextTrack(r, e))[0]) || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`), [].slice.call(i).forEach(t => { "disabled" !== t.mode && t !== e && (t.mode = "disabled") }), e) { let t = this.subtitleDisplay ? "showing" : "hidden"; e.mode !== t && (e.mode = t) } } setSubtitleTrack(e) { let t = this.tracksInGroup; if (!this.media) { this.queuedDefaultTrack = e; return } if (e < -1 || e >= t.length || !R(e)) { this.warn(`Invalid subtitle track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; let i = this.currentTrack, r = t[e] || null; if (this.trackId = e, this.currentTrack = r, this.toggleTrackModes(), !r) { this.hls.trigger(b.SUBTITLE_TRACK_SWITCH, { id: e }); return } let s = !!r.details && !r.details.live; if (e === this.trackId && r === i && s) return; this.log(`Switching to subtitle-track ${e}` + (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : "")); let { id: a, groupId: n = "", name: l, type: o, url: h } = r; this.hls.trigger(b.SUBTITLE_TRACK_SWITCH, { id: a, groupId: n, name: l, type: o, url: h }); let d = this.switchParams(r.url, null == i ? void 0 : i.details); this.loadPlaylist(d) } }, timelineController: class { constructor(e) { this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = newVTTCCs(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, e.on(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(b.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(b.FRAG_LOADING, this.onFragLoading, this), e.on(b.FRAG_LOADED, this.onFragLoaded, this), e.on(b.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(b.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(b.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(b.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(b.BUFFER_FLUSHING, this.onBufferFlushing, this) } destroy() { let { hls: e } = this; e.off(b.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(b.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(b.FRAG_LOADING, this.onFragLoading, this), e.off(b.FRAG_LOADED, this.onFragLoaded, this), e.off(b.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(b.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(b.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(b.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(b.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = null, this.cea608Parser1 = this.cea608Parser2 = void 0 } initCea608Parsers() { if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) { let e = new OutputFilter(this, "textTrack1"), t = new OutputFilter(this, "textTrack2"), i = new OutputFilter(this, "textTrack3"), r = new OutputFilter(this, "textTrack4"); this.cea608Parser1 = new Cea608Parser(1, e, t), this.cea608Parser2 = new Cea608Parser(3, i, r) } } addCues(e, t, i, r, s) { let a = !1; for (let e = s.length; e--;) { var n; let r = s[e], l = (n = r[0], Math.min(r[1], i) - Math.max(n, t)); if (l >= 0 && (r[0] = Math.min(r[0], t), r[1] = Math.max(r[1], i), a = !0, l / (i - t) > .5)) return } if (a || s.push([t, i]), this.config.renderTextTracksNatively) { let s = this.captionsTracks[e]; this.Cues.newCue(s, t, i, r) } else { let s = this.Cues.newCue(null, t, i, r); this.hls.trigger(b.CUES_PARSED, { type: "captions", cues: s, track: e }) } } onInitPtsFound(e, { frag: t, id: i, initPTS: r, timescale: s }) { let { unparsedVttFrags: a } = this; "main" === i && (this.initPTS[t.cc] = { baseTime: r, timescale: s }), a.length && (this.unparsedVttFrags = [], a.forEach(e => { this.onFragLoaded(b.FRAG_LOADED, e) })) } getExistingTrack(e, t) { let { media: i } = this; if (i) for (let r = 0; r < i.textTracks.length; r++) { let s = i.textTracks[r]; if (canReuseVttTextTrack(s, { name: e, lang: t, attrs: {} })) return s } return null } createCaptionsTrack(e) { this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e) } createNativeTrack(e) { if (this.captionsTracks[e]) return; let { captionsProperties: t, captionsTracks: i, media: r } = this, { label: s, languageCode: a } = t[e], n = this.getExistingTrack(s, a); if (n) i[e] = n, clearCurrentCues(i[e]), sendAddTrackEvent(i[e], r); else { let t = this.createTextTrack("captions", s, a); t && (t[e] = !0, i[e] = t) } } createNonNativeTrack(e) { if (this.nonNativeCaptionsTracks[e]) return; let t = this.captionsProperties[e]; if (!t) return; let i = t.label, r = { _id: e, label: i, kind: "captions", default: !!t.media && !!t.media.default, closedCaptions: t.media }; this.nonNativeCaptionsTracks[e] = r, this.hls.trigger(b.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [r] }) } createTextTrack(e, t, i) { let r = this.media; if (r) return r.addTextTrack(e, t, i) } onMediaAttaching(e, t) { this.media = t.media, this._cleanTracks() } onMediaDetaching() { let { captionsTracks: e } = this; Object.keys(e).forEach(t => { clearCurrentCues(e[t]), delete e[t] }), this.nonNativeCaptionsTracks = {} } onManifestLoading() { this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = newVTTCCs(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset()) } _cleanTracks() { let { media: e } = this; if (!e) return; let t = e.textTracks; if (t) for (let e = 0; e < t.length; e++)clearCurrentCues(t[e]) } onSubtitleTracksUpdated(e, t) { let i = t.subtitleTracks || [], r = i.some(e => e.textCodec === eU); if (this.config.enableWebVTT || r && this.config.enableIMSC1) { let e = subtitleOptionsIdentical(this.tracks, i); if (e) { this.tracks = i; return } if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) { let e = this.media, t = e ? filterSubtitleTracks(e.textTracks) : null; if (this.tracks.forEach((e, i) => { let r; if (t) { let i = null; for (let r = 0; r < t.length; r++)if (t[r] && canReuseVttTextTrack(t[r], e)) { i = t[r], t[r] = null; break } i && (r = i) } if (r) clearCurrentCues(r); else { let t = captionsOrSubtitlesFromCharacteristics(e); (r = this.createTextTrack(t, e.name, e.lang)) && (r.mode = "disabled") } r && this.textTracks.push(r) }), null != t && t.length) { let e = t.filter(e => null !== e).map(e => e.label); e.length && M.warn(`Media element contains unused subtitle tracks: ${e.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`) } } else if (this.tracks.length) { let e = this.tracks.map(e => ({ label: e.name, kind: e.type.toLowerCase(), default: e.default, subtitleTrack: e })); this.hls.trigger(b.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: e }) } } } onManifestLoaded(e, t) { this.config.enableCEA708Captions && t.captions && t.captions.forEach(e => { let t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId); if (!t) return; let i = `textTrack${t[1]}`, r = this.captionsProperties[i]; r && (r.label = e.name, e.lang && (r.languageCode = e.lang), r.media = e) }) } closedCaptionsForLevel(e) { let t = this.hls.levels[e.level]; return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"] } onFragLoading(e, t) { this.initCea608Parsers(); let { cea608Parser1: i, cea608Parser2: r, lastCc: s, lastSn: a, lastPartIndex: n } = this; if (this.enabled && i && r && t.frag.type === et.MAIN) { var l, o; let { cc: e, sn: h } = t.frag, d = null != (l = null == t ? void 0 : null == (o = t.part) ? void 0 : o.index) ? l : -1; h === a + 1 || h === a && d === n + 1 || e === s || (i.reset(), r.reset()), this.lastCc = e, this.lastSn = h, this.lastPartIndex = d } } onFragLoaded(e, t) { let { frag: i, payload: r } = t; if (i.type === et.SUBTITLE) { if (r.byteLength) { let e = i.decryptdata, s = "stats" in t; if (null == e || !e.encrypted || s) { let e = this.tracks[i.level], s = this.vttCCs; s[i.cc] || (s[i.cc] = { start: i.start, prevCC: this.prevCC, new: !0 }, this.prevCC = i.cc), e && e.textCodec === eU ? this._parseIMSC1(i, r) : this._parseVTTs(t) } } else this.hls.trigger(b.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: i, error: Error("Empty subtitle payload") }) } } _parseIMSC1(e, t) { let i = this.hls; parseIMSC1(t, this.initPTS[e.cc], t => { this._appendCues(t, e.level), i.trigger(b.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e }) }, t => { M.log(`Failed to parse IMSC1: ${t}`), i.trigger(b.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e, error: t }) }) } _parseVTTs(e) { var t; let { frag: i, payload: r } = e, { initPTS: s, unparsedVttFrags: a } = this, n = s.length - 1; if (!s[i.cc] && -1 === n) { a.push(e); return } let l = this.hls, o = null != (t = i.initSegment) && t.data ? appendUint8Array(i.initSegment.data, new Uint8Array(r)) : r; !function (e, t, i, r, s, a, n) { let l; let o = new VTTParser, h = utf8ArrayToStr(new Uint8Array(e)).trim().replace(eN, "\n").split("\n"), d = [], u = t ? function (e, t = 1) { return toTimescaleFromBase(e, 9e4, 1 / t) }(t.baseTime, t.timescale) : 0, c = "00:00.000", f = 0, g = 0, m = !0; o.oncue = function (e) { let a = i[r], n = i.ccOffset, o = (f - u) / 9e4; if (null != a && a.new && (void 0 !== g ? n = i.ccOffset = a.start : calculateOffset(i, r, o)), o) { if (!t) { l = Error("Missing initPTS for VTT MPEGTS"); return } n = o - i.presentationOffset } let h = e.endTime - e.startTime, c = normalizePts((e.startTime + n - g) * 9e4, 9e4 * s) / 9e4; e.startTime = Math.max(c, 0), e.endTime = Math.max(c + h, 0); let m = e.text.trim(); e.text = decodeURIComponent(encodeURIComponent(m)), e.id || (e.id = generateCueId(e.startTime, e.endTime, m)), e.endTime > 0 && d.push(e) }, o.onparsingerror = function (e) { l = e }, o.onflush = function () { if (l) { n(l); return } a(d) }, h.forEach(e => { if (m) { if (startsWith(e, "X-TIMESTAMP-MAP=")) { m = !1, e.slice(16).split(",").forEach(e => { startsWith(e, "LOCAL:") ? c = e.slice(6) : startsWith(e, "MPEGTS:") && (f = parseInt(e.slice(7))) }); try { g = cueString2millis(c) / 1e3 } catch (e) { l = e } return } "" === e && (m = !1) } o.parse(e + "\n") }), o.flush() }(o, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, e => { this._appendCues(e, i.level), l.trigger(b.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: i }) }, t => { let s = "Missing initPTS for VTT MPEGTS" === t.message; s ? a.push(e) : this._fallbackToIMSC1(i, r), M.log(`Failed to parse VTT cue: ${t}`), s && n > i.cc || l.trigger(b.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: i, error: t }) }) } _fallbackToIMSC1(e, t) { let i = this.tracks[e.level]; i.textCodec || parseIMSC1(t, this.initPTS[e.cc], () => { i.textCodec = eU, this._parseIMSC1(e, t) }, () => { i.textCodec = "wvtt" }) } _appendCues(e, t) { let i = this.hls; if (this.config.renderTextTracksNatively) { let i = this.textTracks[t]; if (!i || "disabled" === i.mode) return; e.forEach(e => addCueToTrack(i, e)) } else { let r = this.tracks[t]; if (!r) return; let s = r.default ? "default" : "subtitles" + t; i.trigger(b.CUES_PARSED, { type: "subtitles", cues: e, track: s }) } } onFragDecrypted(e, t) { let { frag: i } = t; i.type === et.SUBTITLE && this.onFragLoaded(b.FRAG_LOADED, t) } onSubtitleTracksCleared() { this.tracks = [], this.captionsTracks = {} } onFragParsingUserdata(e, t) { this.initCea608Parsers(); let { cea608Parser1: i, cea608Parser2: r } = this; if (!this.enabled || !i || !r) return; let { frag: s, samples: a } = t; if (s.type !== et.MAIN || "NONE" !== this.closedCaptionsForLevel(s)) for (let e = 0; e < a.length; e++) { let t = a[e].bytes; if (t) { let s = this.extractCea608Data(t); i.addData(a[e].pts, s[0]), r.addData(a[e].pts, s[1]) } } } onBufferFlushing(e, { startOffset: t, endOffset: i, endOffsetSubtitles: r, type: s }) { let { media: a } = this; if (a && !(a.currentTime < i)) { if (!s || "video" === s) { let { captionsTracks: e } = this; Object.keys(e).forEach(r => removeCuesInRange(e[r], t, i)) } if (this.config.renderTextTracksNatively && 0 === t && void 0 !== r) { let { textTracks: e } = this; Object.keys(e).forEach(i => removeCuesInRange(e[i], t, r)) } } } extractCea608Data(e) { let t = [[], []], i = 31 & e[0], r = 2; for (let s = 0; s < i; s++) { let i = e[r++], s = 127 & e[r++], a = 127 & e[r++]; if (0 === s && 0 === a) continue; let n = (4 & i) != 0; if (n) { let e = 3 & i; (0 === e || 1 === e) && (t[e].push(s), t[e].push(a)) } } return t } }, audioStreamController: class extends BaseStreamController { constructor(e, t, i) { super(e, t, i, "[audio-stream-controller]", et.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null } _registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.LEVEL_LOADED, this.onLevelLoaded, this), e.on(b.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(b.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(b.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(b.ERROR, this.onError, this), e.on(b.BUFFER_RESET, this.onBufferReset, this), e.on(b.BUFFER_CREATED, this.onBufferCreated, this), e.on(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(b.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(b.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.LEVEL_LOADED, this.onLevelLoaded, this), e.off(b.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(b.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(b.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(b.ERROR, this.onError, this), e.off(b.BUFFER_RESET, this.onBufferReset, this), e.off(b.BUFFER_CREATED, this.onBufferCreated, this), e.off(b.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(b.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(b.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this) } onInitPtsFound(e, { frag: t, id: i, initPTS: r, timescale: s }) { if ("main" === i) { let e = t.cc; this.initPTS[t.cc] = { baseTime: r, timescale: s }, this.log(`InitPTS for cc: ${e} found from main: ${r}`), this.videoTrackCC = e, this.state === em.WAITING_INIT_PTS && this.tick() } } startLoad(e) { if (!this.levels) { this.startPosition = e, this.state = em.STOPPED; return } let t = this.lastCurrentTime; this.stopLoad(), this.setInterval(100), t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = em.IDLE) : (this.loadedmetadata = !1, this.state = em.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } doTick() { var e, t; switch (this.state) { case em.IDLE: this.doTickIdle(); break; case em.WAITING_TRACK: { let { levels: t, trackId: i } = this, r = null == t ? void 0 : null == (e = t[i]) ? void 0 : e.details; if (r) { if (this.waitForCdnTuneIn(r)) break; this.state = em.WAITING_INIT_PTS } break } case em.FRAG_LOADING_WAITING_RETRY: { let e = performance.now(), i = this.retryDate; if (!i || e >= i || null != (t = this.media) && t.seeking) { let { levels: e, trackId: t } = this; this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((null == e ? void 0 : e[t]) || null), this.state = em.IDLE } break } case em.WAITING_INIT_PTS: { let e = this.waitingData; if (e) { let { frag: t, part: i, cache: r, complete: s } = e; if (void 0 !== this.initPTS[t.cc]) { this.waitingData = null, this.waitingVideoCC = -1, this.state = em.FRAG_LOADING; let e = r.flush(), a = { frag: t, part: i, payload: e, networkDetails: null }; this._handleFragmentLoadProgress(a), s && super._handleFragmentLoadComplete(a) } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment(); else { let e = this.getLoadPosition(), i = BufferHelper.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole), r = fragmentWithinToleranceTest(i.end, this.config.maxFragLookUpTolerance, t); r < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment()) } } else this.state = em.IDLE } }this.onTickEnd() } clearWaitingFragment() { let e = this.waitingData; e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = em.IDLE) } resetLoadingState() { this.clearWaitingFragment(), super.resetLoadingState() } onTickEnd() { let { media: e } = this; null != e && e.readyState && (this.lastCurrentTime = e.currentTime) } doTickIdle() { let { hls: e, levels: t, media: i, trackId: r } = this, s = e.config; if (!i && (this.startFragRequested || !s.startFragPrefetch) || !(null != t && t[r])) return; let a = t[r], n = a.details; if (!n || n.live && this.levelLastLoaded !== a || this.waitForCdnTuneIn(n)) { this.state = em.WAITING_TRACK; return } let l = this.mediaBuffer ? this.mediaBuffer : this.media; this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, F.AUDIO, et.AUDIO)); let o = this.getFwdBufferInfo(l, et.AUDIO); if (null === o) return; let { bufferedTrack: h, switchingTrack: d } = this; if (!d && this._streamEnded(o, n)) { e.trigger(b.BUFFER_EOS, { type: "audio" }), this.state = em.ENDED; return } let u = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, et.MAIN), c = o.len, f = this.getMaxBufferLength(null == u ? void 0 : u.len), g = n.fragments, m = g[0].start, p = this.flushing ? this.getLoadPosition() : o.end; if (d && i) { let e = this.getLoadPosition(); h && !mediaAttributesIdentical(d.attrs, h.attrs) && (p = e), n.PTSKnown && e < m && (o.end > m || o.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = m + .05) } if (c >= f && !d && p < g[g.length - 1].start) return; let E = this.getNextFragment(p, n), T = !1; if (E && this.isLoopLoading(E, p) && (T = !!E.gap, E = this.getNextFragmentLoopLoading(E, n, o, et.MAIN, f)), !E) { this.bufferFlushed = !0; return } let y = u && E.start > u.end + n.targetduration; if (y || !(null != u && u.len) && o.len) { let e = this.getAppendedFrag(E.start, et.MAIN); if (null === e || (T || (T = !!e.gap || !!y && 0 === u.len), y && !T || T && o.nextStart && o.nextStart < e.end)) return } this.loadFragment(E, a, p) } getMaxBufferLength(e) { let t = super.getMaxBufferLength(); return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t } onMediaDetaching() { this.videoBuffer = null, this.bufferFlushed = this.flushing = !1, super.onMediaDetaching() } onAudioTracksUpdated(e, { audioTracks: t }) { this.resetTransmuxer(), this.levels = t.map(e => new Level(e)) } onAudioTrackSwitching(e, t) { let i = !!t.url; this.trackId = t.id; let { fragCurrent: r } = this; r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)), this.resetLoadingState(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.switchingTrack = t, this.state = em.IDLE, this.flushAudioIfNeeded(t)) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = em.STOPPED), this.tick() } onManifestLoading() { this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = this.flushing = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1 } onLevelLoaded(e, t) { this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(b.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null) } onAudioTrackLoaded(e, t) { var i, r; if (null == this.mainDetails) { this.cachedTrackLoadedData = t; return } let { levels: s } = this, { details: a, id: n } = t; if (!s) { this.warn(`Audio tracks were reset while loading level ${n}`); return } this.log(`Audio track ${n} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`); let l = s[n], o = 0; if (a.live || null != (i = l.details) && i.live) { this.checkLiveUpdate(a); let e = this.mainDetails; if (a.deltaUpdateFailed || !e) return; !l.details && a.hasProgramDateTime && e.hasProgramDateTime ? (alignMediaPlaylistByPDT(a, e), o = a.fragments[0].start) : o = this.alignPlaylists(a, l.details, null == (r = this.levelLastLoaded) ? void 0 : r.details) } l.details = a, this.levelLastLoaded = l, this.startFragRequested || !this.mainDetails && a.live || this.setStartPosition(this.mainDetails || a, o), this.state !== em.WAITING_TRACK || this.waitForCdnTuneIn(a) || (this.state = em.IDLE), this.tick() } _handleFragmentLoadProgress(e) { var t; let { frag: i, part: r, payload: s } = e, { config: a, trackId: n, levels: l } = this; if (!l) { this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`); return } let o = l[n]; if (!o) { this.warn("Audio track is undefined on fragment load progress"); return } let h = o.details; if (!h) { this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(i.start); return } let d = a.defaultAudioCodec || o.audioCodec || "mp4a.40.2", u = this.transmuxer; u || (u = this.transmuxer = new TransmuxerInterface(this.hls, et.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))); let c = this.initPTS[i.cc], f = null == (t = i.initSegment) ? void 0 : t.data; if (void 0 !== c) { let e = r ? r.index : -1, t = -1 !== e, a = new ChunkMetadata(i.level, i.sn, i.stats.chunkCount, s.byteLength, e, t); u.push(s, f, d, "", i, r, h.totalduration, !1, a, c) } else { this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${h.startSN} ,${h.endSN}],track ${n}`); let { cache: e } = this.waitingData = this.waitingData || { frag: i, part: r, cache: new ChunkCache, complete: !1 }; e.push(new Uint8Array(s)), this.waitingVideoCC = this.videoTrackCC, this.state = em.WAITING_INIT_PTS } } _handleFragmentLoadComplete(e) { if (this.waitingData) { this.waitingData.complete = !0; return } super._handleFragmentLoadComplete(e) } onBufferReset() { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1 } onBufferCreated(e, t) { let i = t.tracks.audio; i && (this.mediaBuffer = i.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null) } onFragBuffered(e, t) { let { frag: i, part: r } = t; if (i.type !== et.AUDIO) { if (!this.loadedmetadata && i.type === et.MAIN) { let e = this.videoBuffer || this.media; if (e) { let t = BufferHelper.getBuffered(e); t.length && (this.loadedmetadata = !0) } } return } if (this.fragContextChanged(i)) { this.warn(`Fragment ${i.sn}${r ? " p: " + r.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`); return } if ("initSegment" !== i.sn) { this.fragPrevious = i; let e = this.switchingTrack; e && (this.bufferedTrack = e, this.switchingTrack = null, this.hls.trigger(b.AUDIO_TRACK_SWITCHED, _objectSpread2({}, e))) } this.fragBufferedComplete(i, r) } onError(e, t) { var i; if (t.fatal) { this.state = em.ERROR; return } switch (t.details) { case k.FRAG_GAP: case k.FRAG_PARSING_ERROR: case k.FRAG_DECRYPT_ERROR: case k.FRAG_LOAD_ERROR: case k.FRAG_LOAD_TIMEOUT: case k.KEY_LOAD_ERROR: case k.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(et.AUDIO, t); break; case k.AUDIO_TRACK_LOAD_ERROR: case k.AUDIO_TRACK_LOAD_TIMEOUT: case k.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== em.WAITING_TRACK || (null == (i = t.context) ? void 0 : i.type) !== ee.AUDIO_TRACK || (this.state = em.IDLE); break; case k.BUFFER_APPEND_ERROR: case k.BUFFER_FULL_ERROR: if (!t.parent || "audio" !== t.parent) return; if (t.details === k.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")); break; case k.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } onBufferFlushing(e, { type: t }) { t !== F.VIDEO && (this.flushing = !0) } onBufferFlushed(e, { type: t }) { if (t !== F.VIDEO) { this.flushing = !1, this.bufferFlushed = !0, this.state === em.ENDED && (this.state = em.IDLE); let e = this.mediaBuffer || this.media; e && (this.afterBufferFlushed(e, t, et.AUDIO), this.tick()) } } _handleTransmuxComplete(e) { var t; let i = "audio", { hls: r } = this, { remuxResult: s, chunkMeta: a } = e, n = this.getCurrentContext(a); if (!n) { this.resetWhenMissingContext(a); return } let { frag: l, part: o, level: h } = n, { details: d } = h, { audio: u, text: c, id3: f, initSegment: g } = s; if (this.fragContextChanged(l) || !d) { this.fragmentTracker.removeFragment(l); return } if (this.state = em.PARSING, this.switchingTrack && u && this.completeAudioSwitch(this.switchingTrack), null != g && g.tracks) { let e = l.initSegment || l; this._bufferInitSegment(h, g.tracks, e, a), r.trigger(b.FRAG_PARSING_INIT_SEGMENT, { frag: e, id: i, tracks: g.tracks }) } if (u) { let { startPTS: e, endPTS: t, startDTS: i, endDTS: r } = u; o && (o.elementaryStreams[F.AUDIO] = { startPTS: e, endPTS: t, startDTS: i, endDTS: r }), l.setElementaryStreamInfo(F.AUDIO, e, t, i, r), this.bufferFragmentData(u, l, o, a) } if (null != f && null != (t = f.samples) && t.length) { let e = _extends({ id: i, frag: l, details: d }, f); r.trigger(b.FRAG_PARSING_METADATA, e) } if (c) { let e = _extends({ id: i, frag: l, details: d }, c); r.trigger(b.FRAG_PARSING_USERDATA, e) } } _bufferInitSegment(e, t, i, r) { if (this.state !== em.PARSING) return; t.video && delete t.video; let s = t.audio; if (!s) return; s.id = "audio"; let a = e.audioCodec; this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${a}/${s.codec}]`), a && 1 === a.split(",").length && (s.levelCodec = a), this.hls.trigger(b.BUFFER_CODECS, t); let n = s.initSegment; if (null != n && n.byteLength) { let e = { type: "audio", frag: i, part: null, chunkMeta: r, parent: i.type, data: n }; this.hls.trigger(b.BUFFER_APPENDING, e) } this.tickImmediate() } loadFragment(e, t, i) { let r = this.fragmentTracker.getState(e); if (this.fragCurrent = e, this.switchingTrack || r === ec.NOT_LOADED || r === ec.PARTIAL) { var s; if ("initSegment" === e.sn) this._loadInitSegment(e, t); else if (null != (s = t.details) && s.live && !this.initPTS[e.cc]) { this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = em.WAITING_INIT_PTS; let i = this.mainDetails; i && i.fragments[0].start !== t.details.fragments[0].start && alignMediaPlaylistByPDT(t.details, i) } else this.startFragRequested = !0, super.loadFragment(e, t, i) } else this.clearTrackerIfNeeded(e) } flushAudioIfNeeded(e) { let { media: t, bufferedTrack: i } = this, r = null == i ? void 0 : i.attrs, s = e.attrs; t && r && (r.CHANNELS !== s.CHANNELS || i.name !== e.name || i.lang !== e.lang) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) } completeAudioSwitch(e) { let { hls: t } = this; this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(b.AUDIO_TRACK_SWITCHED, _objectSpread2({}, e)) } }, audioTrackController: class extends BasePlaylistController { constructor(e) { super(e, "[audio-track-controller]"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners() } registerListeners() { let { hls: e } = this; e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.LEVEL_LOADING, this.onLevelLoading, this), e.on(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(b.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(b.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.LEVEL_LOADING, this.onLevelLoading, this), e.off(b.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(b.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(b.ERROR, this.onError, this) } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy() } onManifestLoading() { this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.audioTracks || [] } onAudioTrackLoaded(e, t) { let { id: i, groupId: r, details: s } = t, a = this.tracksInGroup[i]; if (!a || a.groupId !== r) { this.warn(`Audio track with id:${i} and group:${r} not found in active group ${null == a ? void 0 : a.groupId}`); return } let n = a.details; a.details = t.details, this.log(`Audio track ${i} "${a.name}" lang:${a.lang} group:${r} loaded [${s.startSN}-${s.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, n) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { let t = this.hls.levels[e]; if (!t) return; let i = t.audioGroups || null, r = this.groupIds, s = this.currentTrack; if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some(e => (null == r ? void 0 : r.indexOf(e)) === -1)) { this.groupIds = i, this.trackId = -1, this.currentTrack = null; let e = this.tracks.filter(e => !i || -1 !== i.indexOf(e.groupId)); if (e.length) this.selectDefaultTrack && !e.some(e => e.default) && (this.selectDefaultTrack = !1), e.forEach((e, t) => { e.id = t }); else if (!s && !this.tracksInGroup.length) return; this.tracksInGroup = e; let t = this.hls.config.audioPreference; if (!s && t) { let i = findMatchingOption(t, e, audioMatchPredicate); if (i > -1) s = e[i]; else { let e = findMatchingOption(t, this.tracks); s = this.tracks[e] } } let r = this.findTrackId(s); -1 === r && s && (r = this.findTrackId(null)), this.log(`Updating audio tracks, ${e.length} track(s) found in group(s): ${null == i ? void 0 : i.join(",")}`), this.hls.trigger(b.AUDIO_TRACKS_UPDATED, { audioTracks: e }); let n = this.trackId; if (-1 !== r && -1 === n) this.setAudioTrack(r); else if (e.length && -1 === n) { var a; let t = Error(`No audio track selected for current audio group-ID(s): ${null == (a = this.groupIds) ? void 0 : a.join(",")} track count: ${e.length}`); this.warn(t.message), this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.AUDIO_TRACK_LOAD_ERROR, fatal: !0, error: t }) } } else this.shouldReloadPlaylist(s) && this.setAudioTrack(this.trackId) } onError(e, t) { !t.fatal && t.context && (t.context.type !== ee.AUDIO_TRACK || t.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(t.context.groupId) || (this.requestScheduled = -1, this.checkRetry(t))) } get allAudioTracks() { return this.tracks } get audioTracks() { return this.tracksInGroup } get audioTrack() { return this.trackId } set audioTrack(e) { this.selectDefaultTrack = !1, this.setAudioTrack(e) } setAudioOption(e) { let t = this.hls; if (t.config.audioPreference = e, e) { let i = this.allAudioTracks; if (this.selectDefaultTrack = !1, i.length) { let r = this.currentTrack; if (r && matchesOption(e, r, audioMatchPredicate)) return r; let s = findMatchingOption(e, this.tracksInGroup, audioMatchPredicate); if (s > -1) { let e = this.tracksInGroup[s]; return this.setAudioTrack(s), e } if (r) { let r = t.loadLevel; -1 === r && (r = t.firstAutoLevel); let s = function (e, t, i, r, s) { let a = t[r], n = t.reduce((e, t, i) => { let r = t.uri, s = e[r] || (e[r] = []); return s.push(i), e }, {}), l = n[a.uri]; l.length > 1 && (r = Math.max.apply(Math, l)); let o = a.videoRange, h = a.frameRate, d = a.codecSet.substring(0, 4), u = searchDownAndUpList(t, r, t => { if (t.videoRange !== o || t.frameRate !== h || t.codecSet.substring(0, 4) !== d) return !1; let r = t.audioGroups, a = i.filter(e => !r || -1 !== r.indexOf(e.groupId)); return findMatchingOption(e, a, s) > -1 }); return u > -1 ? u : searchDownAndUpList(t, r, t => { let r = t.audioGroups, a = i.filter(e => !r || -1 !== r.indexOf(e.groupId)); return findMatchingOption(e, a, s) > -1 }) }(e, t.levels, i, r, audioMatchPredicate); if (-1 === s) return null; t.nextLoadLevel = s } if (e.channels || e.audioCodec) { let t = findMatchingOption(e, i); if (t > -1) return i[t] } } } return null } setAudioTrack(e) { let t = this.tracksInGroup; if (e < 0 || e >= t.length) { this.warn(`Invalid audio track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; let i = this.currentTrack, r = t[e], s = r.details && !r.details.live; if (e === this.trackId && r === i && s || (this.log(`Switching to audio-track ${e} "${r.name}" lang:${r.lang} group:${r.groupId} channels:${r.channels}`), this.trackId = e, this.currentTrack = r, this.hls.trigger(b.AUDIO_TRACK_SWITCHING, _objectSpread2({}, r)), s)) return; let a = this.switchParams(r.url, null == i ? void 0 : i.details); this.loadPlaylist(a) } findTrackId(e) { let t = this.tracksInGroup; for (let i = 0; i < t.length; i++) { let r = t[i]; if ((!this.selectDefaultTrack || r.default) && (!e || matchesOption(e, r, audioMatchPredicate))) return i } if (e) { let { name: i, lang: r, assocLang: s, characteristics: a, audioCodec: n, channels: l } = e; for (let e = 0; e < t.length; e++) { let o = t[e]; if (matchesOption({ name: i, lang: r, assocLang: s, characteristics: a, audioCodec: n, channels: l }, o, audioMatchPredicate)) return e } for (let i = 0; i < t.length; i++) { let r = t[i]; if (mediaAttributesIdentical(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i } for (let i = 0; i < t.length; i++) { let r = t[i]; if (mediaAttributesIdentical(e.attrs, r.attrs, ["LANGUAGE"])) return i } } return -1 } loadPlaylist(e) { let t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { super.loadPlaylist(); let i = t.id, r = t.groupId, s = t.url; if (e) try { s = e.addDirectives(s) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } this.log(`loading audio-track playlist ${i} "${t.name}" lang:${t.lang} group:${r}`), this.clearTimer(), this.hls.trigger(b.AUDIO_TRACK_LOADING, { url: s, id: i, groupId: r, deliveryDirectives: e || null }) } } }, emeController: EMEController, cmcdController: class { constructor(e) { this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => { this.initialized && (this.starved = !0), this.buffering = !0 }, this.onPlaying = () => { this.initialized || (this.initialized = !0), this.buffering = !1 }, this.applyPlaylistData = e => { try { this.apply(e, { ot: y.MANIFEST, su: !this.initialized }) } catch (e) { M.warn("Could not generate manifest CMCD data.", e) } }, this.applyFragmentData = e => { try { let t = e.frag, i = this.hls.levels[t.level], r = this.getObjectType(t), s = { d: 1e3 * t.duration, ot: r }; (r === y.VIDEO || r === y.AUDIO || r == y.MUXED) && (s.br = i.bitrate / 1e3, s.tb = this.getTopBandwidth(r) / 1e3, s.bl = this.getBufferLength(r)), this.apply(e, s) } catch (e) { M.warn("Could not generate segment CMCD data.", e) } }, this.hls = e; let t = this.config = e.config, { cmcd: i } = t; null != i && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || function () { try { return crypto.randomUUID() } catch (e) { try { let e = URL.createObjectURL(new Blob), t = e.toString(); return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1) } catch (i) { let e = new Date().getTime(), t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => { let i = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" == t ? i : 3 & i | 8).toString(16) }); return t } } }(), this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.includeKeys = i.includeKeys, this.registerListeners()) } registerListeners() { let e = this.hls; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHED, this.onMediaDetached, this), e.on(b.BUFFER_CREATED, this.onBufferCreated, this) } unregisterListeners() { let e = this.hls; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHED, this.onMediaDetached, this), e.off(b.BUFFER_CREATED, this.onBufferCreated, this) } destroy() { this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = null } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying) } onMediaDetached() { this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null) } onBufferCreated(e, t) { var i, r; this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer } createData() { var e; return { v: 1, sf: v.HLS, sid: this.sid, cid: this.cid, pr: null == (e = this.media) ? void 0 : e.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 } } apply(e, t = {}) { _extends(t, this.createData()); let i = t.ot === y.INIT || t.ot === y.VIDEO || t.ot === y.MUXED; this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering); let { includeKeys: r } = this; if (r && (t = Object.keys(t).reduce((e, i) => (r.includes(i) && (e[i] = t[i]), e), {})), this.useHeaders) { var s; e.headers || (e.headers = {}), s = e.headers, _extends(s, function (e, t = {}) { if (!e) return {}; let i = Object.entries(e), r = Object.entries(eH).concat(Object.entries((null == t ? void 0 : t.customHeaderMap) || {})), s = i.reduce((e, t) => { var i; let [s, a] = t, n = (null == (i = r.find(e => e[1].includes(s))) ? void 0 : i[0]) || S.REQUEST; return null != e[n] || (e[n] = {}), e[n][s] = a, e }, {}); return Object.entries(s).reduce((e, [i, r]) => (e[i] = encodeCmcd(r, t), e), {}) }(t, void 0)) } else e.url = function (e, t, i) { let r = function (e, t = {}) { if (!e) return ""; let i = encodeCmcd(e, t); return `CMCD=${encodeURIComponent(i)}` }(t, void 0); if (!r) return e; if (ej.test(e)) return e.replace(ej, r); let s = e.includes("?") ? "&" : "?"; return `${e}${s}${r}` }(e.url, t) } getObjectType(e) { let { type: t } = e; return "subtitle" === t ? y.TIMED_TEXT : "initSegment" === e.sn ? y.INIT : "audio" === t ? y.AUDIO : "main" === t ? this.hls.audioTracks.length ? y.VIDEO : y.MUXED : void 0 } getTopBandwidth(e) { let t, i = 0, r = this.hls; if (e === y.AUDIO) t = r.audioTracks; else { let e = r.maxAutoLevel, i = e > -1 ? e + 1 : r.levels.length; t = r.levels.slice(0, i) } for (let e of t) e.bitrate > i && (i = e.bitrate); return i > 0 ? i : NaN } getBufferLength(e) { let t = this.hls.media, i = e === y.AUDIO ? this.audioBuffer : this.videoBuffer; if (!i || !t) return NaN; let r = BufferHelper.bufferInfo(i, t.currentTime, this.config.maxBufferHole); return 1e3 * r.len } createPlaylistLoader() { let { pLoader: e } = this.config, t = this.applyPlaylistData, i = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new i(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, i, r) { t(e), this.loader.load(e, i, r) } } } createFragmentLoader() { let { fLoader: e } = this.config, t = this.applyFragmentData, i = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new i(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, i, r) { t(e), this.loader.load(e, i, r) } } } }, contentSteeringController: class { constructor(e) { this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = M.log.bind(M, "[content-steering]:"), this.registerListeners() } registerListeners() { let e = this.hls; e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.ERROR, this.onError, this) } unregisterListeners() { let e = this.hls; e && (e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.ERROR, this.onError, this)) } startLoad() { if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) { if (this.updated) { let e = 1e3 * this.timeToLoad - (performance.now() - this.updated); if (e > 0) { this.scheduleRefresh(this.uri, e); return } } this.loadSteeringManifest(this.uri) } } stopLoad() { this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout() } clearTimeout() { -1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1) } destroy() { this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null } removeLevel(e) { let t = this.levels; t && (this.levels = t.filter(t => t !== e)) } onManifestLoading() { this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null } onManifestLoaded(e, t) { let { contentSteering: i } = t; null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad()) } onManifestParsed(e, t) { this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks } onError(e, t) { let { errorAction: i } = t; if ((null == i ? void 0 : i.action) === eo.SendAlternateToPenaltyBox && i.flags === eh.MoveAllAlternatesMatchingHost) { let e = this.levels, r = this.pathwayPriority, s = this.pathwayId; if (t.context) { let { groupId: i, pathwayId: r, type: a } = t.context; i && e ? s = this.getPathwayForGroupId(i, a, s) : r && (s = r) } s in this.penalizedPathways || (this.penalizedPathways[s] = performance.now()), !r && e && (r = e.reduce((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e), [])), r && r.length > 1 && (this.updatePathwayPriority(r), i.resolved = this.pathwayId !== s), i.resolved || M.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${s} levels: ${e ? e.length : e} priorities: ${JSON.stringify(r)} penalized: ${JSON.stringify(this.penalizedPathways)}`) } } filterParsedLevels(e) { this.levels = e; let t = this.getLevelsForPathway(this.pathwayId); if (0 === t.length) { let i = e[0].pathwayId; this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), t = this.getLevelsForPathway(i), this.pathwayId = i } return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e } getLevelsForPathway(e) { return null === this.levels ? [] : this.levels.filter(t => e === t.pathwayId) } updatePathwayPriority(e) { let t; this.pathwayPriority = e; let i = this.penalizedPathways, r = performance.now(); Object.keys(i).forEach(e => { r - i[e] > 3e5 && delete i[e] }); for (let r = 0; r < e.length; r++) { let s = e[r]; if (s in i) continue; if (s === this.pathwayId) return; let a = this.hls.nextLoadLevel, n = this.hls.levels[a]; if ((t = this.getLevelsForPathway(s)).length > 0) { this.log(`Setting Pathway to "${s}"`), this.pathwayId = s, reassignFragmentLevelIndexes(t), this.hls.trigger(b.LEVELS_UPDATED, { levels: t }); let e = this.hls.levels[a]; n && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== n.attrs["STABLE-VARIANT-ID"] && e.bitrate !== n.bitrate && this.log(`Unstable Pathways change from bitrate ${n.bitrate} to ${e.bitrate}`), this.hls.nextLoadLevel = a); break } } } getPathwayForGroupId(e, t, i) { let r = this.getLevelsForPathway(i).concat(this.levels || []); for (let i = 0; i < r.length; i++)if (t === ee.AUDIO_TRACK && r[i].hasAudioGroup(e) || t === ee.SUBTITLE_TRACK && r[i].hasSubtitleGroup(e)) return r[i].pathwayId; return i } clonePathways(e) { let t = this.levels; if (!t) return; let i = {}, r = {}; e.forEach(e => { let { ID: s, "BASE-ID": a, "URI-REPLACEMENT": n } = e; if (t.some(e => e.pathwayId === s)) return; let l = this.getLevelsForPathway(a).map(e => { let t = new AttrList(e.attrs); t["PATHWAY-ID"] = s; let a = t.AUDIO && `${t.AUDIO}_clone_${s}`, l = t.SUBTITLES && `${t.SUBTITLES}_clone_${s}`; a && (i[t.AUDIO] = a, t.AUDIO = a), l && (r[t.SUBTITLES] = l, t.SUBTITLES = l); let o = performUriReplacement(e.uri, t["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", n), h = new Level({ attrs: t, audioCodec: e.audioCodec, bitrate: e.bitrate, height: e.height, name: e.name, url: o, videoCodec: e.videoCodec, width: e.width }); if (e.audioGroups) for (let t = 1; t < e.audioGroups.length; t++)h.addGroupId("audio", `${e.audioGroups[t]}_clone_${s}`); if (e.subtitleGroups) for (let t = 1; t < e.subtitleGroups.length; t++)h.addGroupId("text", `${e.subtitleGroups[t]}_clone_${s}`); return h }); t.push(...l), cloneRenditionGroups(this.audioTracks, i, n, s), cloneRenditionGroups(this.subtitleTracks, r, n, s) }) } loadSteeringManifest(e) { let t; let i = this.hls.config, r = i.loader; this.loader && this.loader.destroy(), this.loader = new r(i); try { t = new self.URL(e) } catch (t) { this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`); return } if ("data:" !== t.protocol) { let e = 0 | (this.hls.bandwidthEstimate || i.abrEwmaDefaultEstimate); t.searchParams.set("_HLS_pathway", this.pathwayId), t.searchParams.set("_HLS_throughput", "" + e) } let s = { responseType: "json", url: t.href }, a = i.steeringManifestLoadPolicy.default, n = a.errorRetry || a.timeoutRetry || {}, l = { loadPolicy: a, timeout: a.maxLoadTimeMs, maxRetry: n.maxNumRetry || 0, retryDelay: n.retryDelayMs || 0, maxRetryDelay: n.maxRetryDelayMs || 0 }; this.log(`Requesting steering manifest: ${t}`), this.loader.load(s, l, { onSuccess: (e, i, r, s) => { this.log(`Loaded steering manifest: "${t}"`); let a = e.data; if (1 !== a.VERSION) { this.log(`Steering VERSION ${a.VERSION} not supported!`); return } this.updated = performance.now(), this.timeToLoad = a.TTL; let { "RELOAD-URI": n, "PATHWAY-CLONES": l, "PATHWAY-PRIORITY": o } = a; if (n) try { this.uri = new self.URL(n, t).href } catch (e) { this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${n}`); return } this.scheduleRefresh(this.uri || r.url), l && this.clonePathways(l); let h = { steeringManifest: a, url: t.toString() }; this.hls.trigger(b.STEERING_MANIFEST_LOADED, h), o && this.updatePathwayPriority(o) }, onError: (e, t, i, r) => { if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`), this.stopLoad(), 410 === e.code) { this.enabled = !1, this.log(`Steering manifest ${t.url} no longer available`); return } let s = 1e3 * this.timeToLoad; if (429 === e.code) { let e = this.loader; if ("function" == typeof (null == e ? void 0 : e.getResponseHeader)) { let t = e.getResponseHeader("Retry-After"); t && (s = 1e3 * parseFloat(t)) } this.log(`Steering manifest ${t.url} rate limited`); return } this.scheduleRefresh(this.uri || t.url, s) }, onTimeout: (e, t, i) => { this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url) } }) } scheduleRefresh(e, t = 1e3 * this.timeToLoad) { this.clearTimeout(), this.reloadTimer = self.setTimeout(() => { var t; let i = null == (t = this.hls) ? void 0 : t.media; if (i && !i.ended) { this.loadSteeringManifest(e); return } this.scheduleRefresh(e, 1e3 * this.timeToLoad) }, t) } } }); let LevelController = class LevelController extends BasePlaylistController { constructor(e, t) { super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(b.LEVEL_LOADED, this.onLevelLoaded, this), e.on(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this), e.on(b.ERROR, this.onError, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(b.LEVEL_LOADED, this.onLevelLoaded, this), e.off(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this), e.off(b.ERROR, this.onError, this) } destroy() { this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy() } stopLoad() { let e = this._levels; e.forEach(e => { e.loadError = 0, e.fragmentError = 0 }), super.stopLoad() } resetLevels() { this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1 } onManifestLoading(e, t) { this.resetLevels() } onManifestLoaded(e, t) { let i = this.hls.config.preferManagedMediaSource, r = [], s = {}, n = {}, l = !1, o = !1, h = !1; t.levels.forEach(e => { var t, d; let u = e.attrs, { audioCodec: c, videoCodec: f } = e; (null == (t = c) ? void 0 : t.indexOf("mp4a.40.34")) !== -1 && (a || (a = /chrome|firefox/i.test(navigator.userAgent)), a && (e.audioCodec = c = void 0)), c && (e.audioCodec = c = getCodecCompatibleName(c, i)), (null == (d = f) ? void 0 : d.indexOf("avc1")) === 0 && (f = e.videoCodec = function (e) { let t = e.split("."); return t.length > 2 ? t.shift() + "." + (parseInt(t.shift()).toString(16) + ("000" + parseInt(t.shift()).toString(16)).slice(-4)) : e }(f)); let { width: g, height: m, unknownCodecs: p } = e; if (l || (l = !!(g && m)), o || (o = !!f), h || (h = !!c), null != p && p.length || c && !areCodecsMediaSourceSupported(c, "audio", i) || f && !areCodecsMediaSourceSupported(f, "video", i)) return; let { CODECS: E, "FRAME-RATE": T, "HDCP-LEVEL": y, "PATHWAY-ID": v, RESOLUTION: S, "VIDEO-RANGE": A } = u, L = `${v || "."}-`, R = `${L}${e.bitrate}-${S}-${T}-${E}-${A}-${y}`; if (s[R]) { if (s[R].uri === e.url || e.attrs["PATHWAY-ID"]) s[R].addGroupId("audio", u.AUDIO), s[R].addGroupId("text", u.SUBTITLES); else { let t = n[R] += 1; e.attrs["PATHWAY-ID"] = Array(t + 1).join("."); let i = new Level(e); s[R] = i, r.push(i) } } else { let t = new Level(e); s[R] = t, n[R] = 1, r.push(t) } }), this.filterAndSortMediaOptions(r, t, l, o, h) } filterAndSortMediaOptions(e, t, i, r, s) { let a = [], n = [], l = e; if ((i || r) && s && (l = l.filter(({ videoCodec: e, videoRange: t, width: i, height: r }) => { var s; return (!!e || !!(i && r)) && !!(s = t) && ea.indexOf(s) > -1 })), 0 === l.length) { Promise.resolve().then(() => { if (this.hls) { t.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(t.levels[0].attrs)}`); let e = Error("no level with compatible codecs found in manifest"); this.hls.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: t.url, error: e, reason: e.message }) } }); return } if (t.audioTracks) { let { preferManagedMediaSource: e } = this.hls.config; assignTrackIdsByGroup(a = t.audioTracks.filter(t => !t.audioCodec || areCodecsMediaSourceSupported(t.audioCodec, "audio", e))) } t.subtitles && assignTrackIdsByGroup(n = t.subtitles); let o = l.slice(0); l.sort((e, t) => { if (e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"]) return (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1; if (i && e.height !== t.height) return e.height - t.height; if (e.frameRate !== t.frameRate) return e.frameRate - t.frameRate; if (e.videoRange !== t.videoRange) return ea.indexOf(e.videoRange) - ea.indexOf(t.videoRange); if (e.videoCodec !== t.videoCodec) { let i = videoCodecPreferenceValue(e.videoCodec), r = videoCodecPreferenceValue(t.videoCodec); if (i !== r) return r - i } if (e.uri === t.uri && e.codecSet !== t.codecSet) { let i = codecsSetSelectionPreferenceValue(e.codecSet), r = codecsSetSelectionPreferenceValue(t.codecSet); if (i !== r) return r - i } return e.averageBitrate !== t.averageBitrate ? e.averageBitrate - t.averageBitrate : 0 }); let h = o[0]; if (this.steering && (l = this.steering.filterParsedLevels(l)).length !== o.length) { for (let e = 0; e < o.length; e++)if (o[e].pathwayId === l[0].pathwayId) { h = o[e]; break } } this._levels = l; for (let e = 0; e < l.length; e++)if (l[e] === h) { var d; this._firstLevel = e; let t = h.bitrate, i = this.hls.bandwidthEstimate; if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${t}`), (null == (d = this.hls.userConfig) ? void 0 : d.abrEwmaDefaultEstimate) === void 0) { let e = Math.min(t, this.hls.config.abrEwmaDefaultEstimateMax); e > i && i === eQ.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = e) } break } let u = s && !r, c = { levels: l, audioTracks: a, subtitleTracks: n, sessionData: t.sessionData, sessionKeys: t.sessionKeys, firstLevel: this._firstLevel, stats: t.stats, audio: s, video: r, altAudio: !u && a.some(e => !!e.url) }; this.hls.trigger(b.MANIFEST_PARSED, c), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition) } get levels() { return 0 === this._levels.length ? null : this._levels } get level() { return this.currentLevelIndex } set level(e) { let t = this._levels; if (0 === t.length) return; if (e < 0 || e >= t.length) { let i = Error("invalid level idx"), r = e < 0; if (this.hls.trigger(b.ERROR, { type: C.OTHER_ERROR, details: k.LEVEL_SWITCH_ERROR, level: e, fatal: r, error: i, reason: i.message }), r) return; e = Math.min(e, t.length - 1) } let i = this.currentLevelIndex, r = this.currentLevel, s = r ? r.attrs["PATHWAY-ID"] : void 0, a = t[e], n = a.attrs["PATHWAY-ID"]; if (this.currentLevelIndex = e, this.currentLevel = a, i === e && a.details && r && s === n) return; this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${n ? " with Pathway " + n : ""} from level ${i}${s ? " with Pathway " + s : ""}`); let l = { level: e, attrs: a.attrs, details: a.details, bitrate: a.bitrate, averageBitrate: a.averageBitrate, maxBitrate: a.maxBitrate, realBitrate: a.realBitrate, width: a.width, height: a.height, codecSet: a.codecSet, audioCodec: a.audioCodec, videoCodec: a.videoCodec, audioGroups: a.audioGroups, subtitleGroups: a.subtitleGroups, loaded: a.loaded, loadError: a.loadError, fragmentError: a.fragmentError, name: a.name, id: a.id, uri: a.uri, url: a.url, urlId: 0, audioGroupIds: a.audioGroupIds, textGroupIds: a.textGroupIds }; this.hls.trigger(b.LEVEL_SWITCHING, l); let o = a.details; if (!o || o.live) { let e = this.switchParams(a.uri, null == r ? void 0 : r.details); this.loadPlaylist(e) } } get manualLevel() { return this.manualLevelIndex } set manualLevel(e) { this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e) } get firstLevel() { return this._firstLevel } set firstLevel(e) { this._firstLevel = e } get startLevel() { if (void 0 === this._startLevel) { let e = this.hls.config.startLevel; return void 0 !== e ? e : this.hls.firstAutoLevel } return this._startLevel } set startLevel(e) { this._startLevel = e } onError(e, t) { !t.fatal && t.context && t.context.type === ee.LEVEL && t.context.level === this.level && this.checkRetry(t) } onFragBuffered(e, { frag: t }) { if (void 0 !== t && t.type === et.MAIN) { let e = t.elementaryStreams; if (!Object.keys(e).some(t => !!e[t])) return; let i = this._levels[t.level]; null != i && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0) } } onLevelLoaded(e, t) { var i, r; let { level: s, details: a } = t, n = this._levels[s]; if (!n) { this.warn(`Invalid level index ${s}`), null != (r = t.deliveryDirectives) && r.skip && (a.deltaUpdateFailed = !0); return } s === this.currentLevelIndex ? (0 === n.fragmentError && (n.loadError = 0), this.playlistLoaded(s, t, n.details)) : null != (i = t.deliveryDirectives) && i.skip && (a.deltaUpdateFailed = !0) } loadPlaylist(e) { super.loadPlaylist(); let t = this.currentLevelIndex, i = this.currentLevel; if (i && this.shouldLoadPlaylist(i)) { let r = i.uri; if (e) try { r = e.addDirectives(r) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } let s = i.attrs["PATHWAY-ID"]; this.log(`Loading level index ${t}${(null == e ? void 0 : e.msn) !== void 0 ? " at sn " + e.msn + " part " + e.part : ""} with${s ? " Pathway " + s : ""} ${r}`), this.clearTimer(), this.hls.trigger(b.LEVEL_LOADING, { url: r, level: t, pathwayId: i.attrs["PATHWAY-ID"], id: 0, deliveryDirectives: e || null }) } } get nextLoadLevel() { return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel } set nextLoadLevel(e) { this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e) } removeLevel(e) { var t; let i = this._levels.filter((t, i) => i !== e || (this.steering && this.steering.removeLevel(t), t === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, t.details && t.details.fragments.forEach(e => e.level = -1)), !1)); reassignFragmentLevelIndexes(i), this._levels = i, this.currentLevelIndex > -1 && null != (t = this.currentLevel) && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(b.LEVELS_UPDATED, { levels: i }) } onLevelsUpdated(e, { levels: t }) { this._levels = t } checkMaxAutoUpdated() { let { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: i } = this.hls; this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(b.MAX_AUTO_LEVEL_UPDATED, { autoLevelCapping: e, levels: this.levels, maxAutoLevel: t, minAutoLevel: this.hls.minAutoLevel, maxHdcpLevel: i })) } }; function assignTrackIdsByGroup(e) { let t = {}; e.forEach(e => { let i = e.groupId || ""; e.id = t[i] = t[i] || 0, t[i]++ }) } let KeyLoader = class KeyLoader { constructor(e) { this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e } abort(e) { for (let i in this.keyUriToKeyInfo) { let r = this.keyUriToKeyInfo[i].loader; if (r) { var t; if (e && e !== (null == (t = r.context) ? void 0 : t.frag.type)) return; r.abort() } } } detach() { for (let e in this.keyUriToKeyInfo) { let t = this.keyUriToKeyInfo[e]; (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e] } } destroy() { for (let e in this.detach(), this.keyUriToKeyInfo) { let t = this.keyUriToKeyInfo[e].loader; t && t.destroy() } this.keyUriToKeyInfo = {} } createKeyLoadError(e, t = k.KEY_LOAD_ERROR, i, r, s) { return new LoadError({ type: C.NETWORK_ERROR, details: t, fatal: !1, frag: e, response: s, error: i, networkDetails: r }) } loadClear(e, t) { if (this.emeController && this.config.emeEnabled) { let { sn: i, cc: r } = e; for (let e = 0; e < t.length; e++) { let s = t[e]; if (r <= s.cc && ("initSegment" === i || "initSegment" === s.sn || i < s.sn)) { this.emeController.selectKeySystemFormat(s).then(e => { s.setKeyFormat(e) }); break } } } } load(e) { return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e) } loadInternal(e, t) { var i, r, s; t && e.setKeyFormat(t); let a = e.decryptdata; if (!a) { let i = Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading"); return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, i)) } let n = a.uri; if (!n) return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, Error(`Invalid key URI: "${n}"`))); let l = this.keyUriToKeyInfo[n]; if (null != (i = l) && i.decryptdata.key) return a.key = l.decryptdata.key, Promise.resolve({ frag: e, keyInfo: l }); if (null != (r = l) && r.keyLoadPromise) switch (null == (s = l.mediaKeySessionContext) ? void 0 : s.keyStatus) { case void 0: case "status-pending": case "usable": case "usable-in-future": return l.keyLoadPromise.then(t => (a.key = t.keyInfo.decryptdata.key, { frag: e, keyInfo: l })) }switch (l = this.keyUriToKeyInfo[n] = { decryptdata: a, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }, a.method) { case "ISO-23001-7": case "SAMPLE-AES": case "SAMPLE-AES-CENC": case "SAMPLE-AES-CTR": if ("identity" === a.keyFormat) return this.loadKeyHTTP(l, e); return this.loadKeyEME(l, e); case "AES-128": return this.loadKeyHTTP(l, e); default: return Promise.reject(this.createKeyLoadError(e, k.KEY_LOAD_ERROR, Error(`Key supplied with unsupported METHOD: "${a.method}"`))) } } loadKeyEME(e, t) { let i = { frag: t, keyInfo: e }; if (this.emeController && this.config.emeEnabled) { let t = this.emeController.loadKey(i); if (t) return (e.keyLoadPromise = t.then(t => (e.mediaKeySessionContext = t, i))).catch(t => { throw e.keyLoadPromise = null, t }) } return Promise.resolve(i) } loadKeyHTTP(e, t) { let i = this.config, r = i.loader, s = new r(i); return t.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((r, a) => { let n = { keyInfo: e, frag: t, responseType: "arraybuffer", url: e.decryptdata.uri }, l = i.keyLoadPolicy.default, o = { loadPolicy: l, timeout: l.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; s.load(n, o, { onSuccess: (e, t, i, s) => { let { frag: n, keyInfo: l, url: o } = i; if (!n.decryptdata || l !== this.keyUriToKeyInfo[o]) return a(this.createKeyLoadError(n, k.KEY_LOAD_ERROR, Error("after key load, decryptdata unset or changed"), s)); l.decryptdata.key = n.decryptdata.key = new Uint8Array(e.data), n.keyLoader = null, l.loader = null, r({ frag: n, keyInfo: l }) }, onError: (e, i, r, s) => { this.resetLoader(i), a(this.createKeyLoadError(t, k.KEY_LOAD_ERROR, Error(`HTTP Error ${e.code} loading key ${e.text}`), r, _objectSpread2({ url: n.url, data: void 0 }, e))) }, onTimeout: (e, i, r) => { this.resetLoader(i), a(this.createKeyLoadError(t, k.KEY_LOAD_TIMEOUT, Error("key loading timed out"), r)) }, onAbort: (e, i, r) => { this.resetLoader(i), a(this.createKeyLoadError(t, k.INTERNAL_ABORTED, Error("key loading aborted"), r)) } }) }) } resetLoader(e) { let { frag: t, keyInfo: i, url: r } = e, s = i.loader; t.keyLoader === s && (t.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[r], s && s.destroy() } }; function getSourceBuffer() { return self.SourceBuffer || self.WebKitSourceBuffer } function isMSESupported() { let e = getMediaSource(); if (!e) return !1; let t = getSourceBuffer(); return !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove } let GapController = class GapController { constructor(e, t, i, r) { this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = i, this.hls = r } destroy() { this.media = null, this.hls = this.fragmentTracker = null } poll(e, t) { let { config: i, media: r, stalled: s } = this; if (null === r) return; let { currentTime: a, seeking: n } = r, l = this.seeking && !n, o = !this.seeking && n; if (this.seeking = n, a !== e) { if (this.moved = !0, n || (this.nudgeRetry = 0), null !== s) { if (this.stallReported) { let e = self.performance.now() - s; M.warn(`playback not stuck anymore @${a}, after ${Math.round(e)}ms`), this.stallReported = !1 } this.stalled = null } return } if (o || l) { this.stalled = null; return } if (r.paused && !n || r.ended || 0 === r.playbackRate || !BufferHelper.getBuffered(r).length) { this.nudgeRetry = 0; return } let h = BufferHelper.bufferInfo(r, a, 0), d = h.nextStart || 0; if (n) { let e = h.len > 2, i = !d || t && t.start <= a || d - a > 2 && !this.fragmentTracker.getPartialFragment(a); if (e || i) return; this.moved = !1 } if (!this.moved && null !== this.stalled) { var u; let e = h.len > 0; if (!e && !d) return; let t = Math.max(d, h.start || 0) - a, i = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, s = null == i ? void 0 : null == (u = i.details) ? void 0 : u.live, n = s ? 2 * i.details.targetduration : 2, l = this.fragmentTracker.getPartialFragment(a); if (t > 0 && (t <= n || l)) { r.paused || this._trySkipBufferHole(l); return } } let c = self.performance.now(); if (null === s) { this.stalled = c; return } let f = c - s; if (!n && f >= 250 && (this._reportStall(h), !this.media)) return; let g = BufferHelper.bufferInfo(r, a, i.maxBufferHole); this._tryFixBufferStall(g, f) } _tryFixBufferStall(e, t) { let { config: i, fragmentTracker: r, media: s } = this; if (null === s) return; let a = s.currentTime, n = r.getPartialFragment(a); if (n) { let e = this._trySkipBufferHole(n); if (e || !this.media) return } (e.len > i.maxBufferHole || e.nextStart && e.nextStart - a < i.maxBufferHole) && t > 1e3 * i.highBufferWatchdogPeriod && (M.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer()) } _reportStall(e) { let { hls: t, media: i, stallReported: r } = this; if (!r && i) { this.stallReported = !0; let r = Error(`Playback stalling at @${i.currentTime} due to low buffer (${JSON.stringify(e)})`); M.warn(r.message), t.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_STALLED_ERROR, fatal: !1, error: r, buffer: e.len }) } } _trySkipBufferHole(e) { let { config: t, hls: i, media: r } = this; if (null === r) return 0; let s = r.currentTime, a = BufferHelper.bufferInfo(r, s, 0), n = s < a.start ? a.start : a.nextStart; if (n) { let l = a.len <= t.maxBufferHole, o = a.len > 0 && a.len < 1 && r.readyState < 3, h = n - s; if (h > 0 && (l || o)) { if (h > t.maxBufferHole) { let { fragmentTracker: t } = this, i = !1; if (0 === s) { let e = t.getAppendedFrag(0, et.MAIN); e && n < e.end && (i = !0) } if (!i) { let i = e || t.getAppendedFrag(s, et.MAIN); if (i) { let e = !1, r = i.end; for (; r < n;) { let i = t.getPartialFragment(r); if (i) r += i.duration; else { e = !0; break } } if (e) return 0 } } } let a = Math.max(n + .05, s + .1); if (M.warn(`skipping hole, adjusting currentTime from ${s} to ${a}`), this.moved = !0, this.stalled = null, r.currentTime = a, e && !e.gap) { let t = Error(`fragment loaded with buffer holes, seeking from ${s} to ${a}`); i.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: t, reason: t.message, frag: e }) } return a } } return 0 } _tryNudgeBuffer() { let { config: e, hls: t, media: i, nudgeRetry: r } = this; if (null === i) return; let s = i.currentTime; if (this.nudgeRetry++, r < e.nudgeMaxRetry) { let a = s + (r + 1) * e.nudgeOffset, n = Error(`Nudging 'currentTime' from ${s} to ${a}`); M.warn(n.message), i.currentTime = a, t.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_NUDGE_ON_STALL, error: n, fatal: !1 }) } else { let i = Error(`Playhead still not moving while enough data buffered @${s} after ${e.nudgeMaxRetry} nudges`); M.error(i.message), t.trigger(b.ERROR, { type: C.MEDIA_ERROR, details: k.BUFFER_STALLED_ERROR, error: i, fatal: !0 }) } } }; let StreamController = class StreamController extends BaseStreamController { constructor(e, t, i) { super(e, t, i, "[stream-controller]", et.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(b.MANIFEST_LOADING, this.onManifestLoading, this), e.on(b.MANIFEST_PARSED, this.onManifestParsed, this), e.on(b.LEVEL_LOADING, this.onLevelLoading, this), e.on(b.LEVEL_LOADED, this.onLevelLoaded, this), e.on(b.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(b.ERROR, this.onError, this), e.on(b.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(b.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(b.BUFFER_CREATED, this.onBufferCreated, this), e.on(b.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(b.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(b.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(b.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(b.MANIFEST_LOADING, this.onManifestLoading, this), e.off(b.MANIFEST_PARSED, this.onManifestParsed, this), e.off(b.LEVEL_LOADED, this.onLevelLoaded, this), e.off(b.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(b.ERROR, this.onError, this), e.off(b.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(b.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(b.BUFFER_CREATED, this.onBufferCreated, this), e.off(b.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(b.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(b.FRAG_BUFFERED, this.onFragBuffered, this) } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying() } startLoad(e) { if (this.levels) { let { lastCurrentTime: t, hls: i } = this; if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) { let e = i.startLevel; -1 === e && (i.config.testBandwidth && this.levels.length > 1 ? (e = 0, this.bitrateTest = !0) : e = i.firstAutoLevel), i.nextLoadLevel = e, this.level = i.loadLevel, this.loadedmetadata = !1 } t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = em.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } else this._forceStartLoad = !0, this.state = em.STOPPED } stopLoad() { this._forceStartLoad = !1, super.stopLoad() } doTick() { switch (this.state) { case em.WAITING_LEVEL: { let { levels: e, level: t } = this, i = null == e ? void 0 : e[t], r = null == i ? void 0 : i.details; if (r && (!r.live || this.levelLastLoaded === i)) { if (this.waitForCdnTuneIn(r)) break; this.state = em.IDLE } else this.hls.nextLoadLevel !== this.level && (this.state = em.IDLE); break } case em.FRAG_LOADING_WAITING_RETRY: { var e; let t = self.performance.now(), i = this.retryDate; if (!i || t >= i || null != (e = this.media) && e.seeking) { let { levels: e, level: t } = this, i = null == e ? void 0 : e[t]; this.resetStartWhenNotLoaded(i || null), this.state = em.IDLE } } }this.state === em.IDLE && this.doTickIdle(), this.onTickEnd() } onTickEnd() { super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged() } doTickIdle() { let { hls: e, levelLastLoaded: t, levels: i, media: r } = this; if (null === t || !r && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return; let s = e.nextLoadLevel; if (!(null != i && i[s])) return; let a = i[s], n = this.getMainFwdBufferInfo(); if (null === n) return; let l = this.getLevelDetails(); if (l && this._streamEnded(n, l)) { let e = {}; this.altAudio && (e.type = "video"), this.hls.trigger(b.BUFFER_EOS, e), this.state = em.ENDED; return } e.loadLevel !== s && -1 === e.manualLevel && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s; let o = a.details; if (!o || this.state === em.WAITING_LEVEL || o.live && this.levelLastLoaded !== a) { this.level = s, this.state = em.WAITING_LEVEL; return } let h = n.len, d = this.getMaxBufferLength(a.maxBitrate); if (h >= d) return; this.backtrackFragment && this.backtrackFragment.start > n.end && (this.backtrackFragment = null); let u = this.backtrackFragment ? this.backtrackFragment.start : n.end, c = this.getNextFragment(u, o); if (this.couldBacktrack && !this.fragPrevious && c && "initSegment" !== c.sn && this.fragmentTracker.getState(c) !== ec.OK) { var f; let e = (null != (f = this.backtrackFragment) ? f : c).sn, t = e - o.startSN, i = o.fragments[t - 1]; i && c.cc === i.cc && (c = i, this.fragmentTracker.removeFragment(i)) } else this.backtrackFragment && n.len && (this.backtrackFragment = null); if (c && this.isLoopLoading(c, u)) { let e = c.gap; if (!e) { let e = this.audioOnly && !this.altAudio ? F.AUDIO : F.VIDEO, t = (e === F.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; t && this.afterBufferFlushed(t, e, et.MAIN) } c = this.getNextFragmentLoopLoading(c, o, n, et.MAIN, d) } c && (!c.initSegment || c.initSegment.data || this.bitrateTest || (c = c.initSegment), this.loadFragment(c, a, u)) } loadFragment(e, t, i) { let r = this.fragmentTracker.getState(e); this.fragCurrent = e, r === ec.NOT_LOADED || r === ec.PARTIAL ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) : this.clearTrackerIfNeeded(e) } getBufferedFrag(e) { return this.fragmentTracker.getBufferedFrag(e, et.MAIN) } followingBufferedFrag(e) { return e ? this.getBufferedFrag(e.end + .5) : null } immediateLevelSwitch() { this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY) } nextLevelSwitch() { let { levels: e, media: t } = this; if (null != t && t.readyState) { let i; let r = this.getAppendedFrag(t.currentTime); r && r.start > 1 && this.flushMainBuffer(0, r.start - 1); let s = this.getLevelDetails(); if (null != s && s.live) { let e = this.getMainFwdBufferInfo(); if (!e || e.len < 2 * s.targetduration) return } if (!t.paused && e) { let t = this.hls.nextLoadLevel, r = e[t], s = this.fragLastKbps; i = s && this.fragCurrent ? this.fragCurrent.duration * r.maxBitrate / (1e3 * s) + 1 : 0 } else i = 0; let a = this.getBufferedFrag(t.currentTime + i); if (a) { let e = this.followingBufferedFrag(a); if (e) { this.abortCurrentFrag(); let t = e.maxStartPTS ? e.maxStartPTS : e.start, i = e.duration, r = Math.max(a.end, t + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, i * (this.couldBacktrack ? .5 : .125)), i * (this.couldBacktrack ? .75 : .25))); this.flushMainBuffer(r, Number.POSITIVE_INFINITY) } } } } abortCurrentFrag() { let e = this.fragCurrent; switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) { case em.KEY_LOADING: case em.FRAG_LOADING: case em.FRAG_LOADING_WAITING_RETRY: case em.PARSING: case em.PARSED: this.state = em.IDLE }this.nextLoadPosition = this.getLoadPosition() } flushMainBuffer(e, t) { super.flushMainBuffer(e, t, this.altAudio ? "video" : null) } onMediaAttached(e, t) { super.onMediaAttached(e, t); let i = t.media; this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new GapController(this.config, i, this.fragmentTracker, this.hls) } onMediaDetaching() { let { media: e } = this; e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching() } onMediaPlaying() { this.tick() } onMediaSeeked() { let e = this.media, t = e ? e.currentTime : null; R(t) && this.log(`Media seeked to ${t.toFixed(3)}`); let i = this.getMainFwdBufferInfo(); if (null === i || 0 === i.len) { this.warn(`Main forward buffer length on "seeked" event ${i ? i.len : "empty"})`); return } this.tick() } onManifestLoading() { this.log("Trigger BUFFER_RESET"), this.hls.trigger(b.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1 } onManifestParsed(e, t) { let i = !1, r = !1; t.levels.forEach(e => { let t = e.audioCodec; t && (i = i || -1 !== t.indexOf("mp4a.40.2"), r = r || -1 !== t.indexOf("mp4a.40.5")) }), this.audioCodecSwitch = i && r && !function () { var e; let t = getSourceBuffer(); return "function" == typeof (null == t ? void 0 : null == (e = t.prototype) ? void 0 : e.changeType) }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1 } onLevelLoading(e, t) { let { levels: i } = this; if (!i || this.state !== em.IDLE) return; let r = i[t.level]; (!r.details || r.details.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(r.details)) && (this.state = em.WAITING_LEVEL) } onLevelLoaded(e, t) { var i, r; let { levels: s } = this, a = t.level, n = t.details, l = n.totalduration; if (!s) { this.warn(`Levels were reset while loading level ${a}`); return } this.log(`Level ${a} loaded [${n.startSN},${n.endSN}]${n.lastPartSn ? `[part-${n.lastPartSn}-${n.lastPartIndex}]` : ""}, cc [${n.startCC}, ${n.endCC}] duration:${l}`); let o = s[a], h = this.fragCurrent; h && (this.state === em.FRAG_LOADING || this.state === em.FRAG_LOADING_WAITING_RETRY) && h.level !== t.level && h.loader && this.abortCurrentFrag(); let d = 0; if (n.live || null != (i = o.details) && i.live) { if (this.checkLiveUpdate(n), n.deltaUpdateFailed) return; d = this.alignPlaylists(n, o.details, null == (r = this.levelLastLoaded) ? void 0 : r.details) } if (o.details = n, this.levelLastLoaded = o, this.hls.trigger(b.LEVEL_UPDATED, { details: n, level: a }), this.state === em.WAITING_LEVEL) { if (this.waitForCdnTuneIn(n)) return; this.state = em.IDLE } this.startFragRequested ? n.live && this.synchronizeToLiveEdge(n) : this.setStartPosition(n, d), this.tick() } _handleFragmentLoadProgress(e) { var t; let { frag: i, part: r, payload: s } = e, { levels: a } = this; if (!a) { this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`); return } let n = a[i.level], l = n.details; if (!l) { this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), this.fragmentTracker.removeFragment(i); return } let o = n.videoCodec, h = l.PTSKnown || !l.live, d = null == (t = i.initSegment) ? void 0 : t.data, u = this._getAudioCodec(n), c = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, et.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), f = r ? r.index : -1, g = -1 !== f, m = new ChunkMetadata(i.level, i.sn, i.stats.chunkCount, s.byteLength, f, g), p = this.initPTS[i.cc]; c.push(s, d, u, o, i, r, l.totalduration, h, m, p) } onAudioTrackSwitching(e, t) { let i = this.altAudio, r = !!t.url; if (!r) { if (this.mediaBuffer !== this.media) { this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media; let e = this.fragCurrent; e && (this.log("Switching to main audio track, cancel main fragment load"), e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.resetLoadingState() } else this.audioOnly && this.resetTransmuxer(); let e = this.hls; i && (e.trigger(b.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: null }), this.fragmentTracker.removeAllFragments()), e.trigger(b.AUDIO_TRACK_SWITCHED, t) } } onAudioTrackSwitched(e, t) { let i = t.id, r = !!this.hls.audioTracks[i].url; if (r) { let e = this.videoBuffer; e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = e) } this.altAudio = r, this.tick() } onBufferCreated(e, t) { let i, r; let s = t.tracks, a = !1; for (let e in s) { let t = s[e]; if ("main" === t.id) { if (r = e, i = t, "video" === e) { let t = s[e]; t && (this.videoBuffer = t.buffer) } } else a = !0 } a && i ? (this.log(`Alternate track found, use ${r}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media } onFragBuffered(e, t) { let { frag: i, part: r } = t; if (i && i.type !== et.MAIN) return; if (this.fragContextChanged(i)) { this.warn(`Fragment ${i.sn}${r ? " p: " + r.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), this.state === em.PARSED && (this.state = em.IDLE); return } let s = r ? r.stats : i.stats; this.fragLastKbps = Math.round(8 * s.total / (s.buffering.end - s.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, r) } onError(e, t) { var i; if (t.fatal) { this.state = em.ERROR; return } switch (t.details) { case k.FRAG_GAP: case k.FRAG_PARSING_ERROR: case k.FRAG_DECRYPT_ERROR: case k.FRAG_LOAD_ERROR: case k.FRAG_LOAD_TIMEOUT: case k.KEY_LOAD_ERROR: case k.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(et.MAIN, t); break; case k.LEVEL_LOAD_ERROR: case k.LEVEL_LOAD_TIMEOUT: case k.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== em.WAITING_LEVEL || (null == (i = t.context) ? void 0 : i.type) !== ee.LEVEL || (this.state = em.IDLE); break; case k.BUFFER_APPEND_ERROR: case k.BUFFER_FULL_ERROR: if (!t.parent || "main" !== t.parent) return; if (t.details === k.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY); break; case k.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } checkBuffer() { let { media: e, gapController: t } = this; if (e && t && e.readyState) { if (this.loadedmetadata || !BufferHelper.getBuffered(e).length) { let e = this.state !== em.IDLE ? this.fragCurrent : null; t.poll(this.lastCurrentTime, e) } this.lastCurrentTime = e.currentTime } } onFragLoadEmergencyAborted() { this.state = em.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate() } onBufferFlushed(e, { type: t }) { if (t !== F.AUDIO || this.audioOnly && !this.altAudio) { let e = (t === F.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; this.afterBufferFlushed(e, t, et.MAIN), this.tick() } } onLevelsUpdated(e, t) { this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = t.levels } swapAudioCodec() { this.audioCodecSwap = !this.audioCodecSwap } seekToStartPos() { let { media: e } = this; if (!e) return; let t = e.currentTime, i = this.startPosition; if (i >= 0 && t < i) { if (e.seeking) { this.log(`could not seek to ${i}, already seeking at ${t}`); return } let r = BufferHelper.getBuffered(e), s = r.length ? r.start(0) : 0, a = s - i; a > 0 && (a < this.config.maxBufferHole || a < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${a} to match buffer start`), i += a, this.startPosition = i), this.log(`seek to target start position ${i} from current time ${t}`), e.currentTime = i } } _getAudioCodec(e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t } _loadBitrateTestFrag(e, t) { e.bitrateTest = !0, this._doFragLoad(e, t).then(i => { let { hls: r } = this; if (!i || this.fragContextChanged(e)) return; t.fragmentError = 0, this.state = em.IDLE, this.startFragRequested = !1, this.bitrateTest = !1; let s = e.stats; s.parsing.start = s.parsing.end = s.buffering.start = s.buffering.end = self.performance.now(), r.trigger(b.FRAG_LOADED, i), e.bitrateTest = !1 }) } _handleTransmuxComplete(e) { var t; let i = "main", { hls: r } = this, { remuxResult: s, chunkMeta: a } = e, n = this.getCurrentContext(a); if (!n) { this.resetWhenMissingContext(a); return } let { frag: l, part: o, level: h } = n, { video: d, text: u, id3: c, initSegment: f } = s, { details: g } = h, m = this.altAudio ? void 0 : s.audio; if (this.fragContextChanged(l)) { this.fragmentTracker.removeFragment(l); return } if (this.state = em.PARSING, f) { if (null != f && f.tracks) { let e = l.initSegment || l; this._bufferInitSegment(h, f.tracks, e, a), r.trigger(b.FRAG_PARSING_INIT_SEGMENT, { frag: e, id: i, tracks: f.tracks }) } let e = f.initPTS, t = f.timescale; R(e) && (this.initPTS[l.cc] = { baseTime: e, timescale: t }, r.trigger(b.INIT_PTS_FOUND, { frag: l, id: i, initPTS: e, timescale: t })) } if (d && g && "initSegment" !== l.sn) { let e = g.fragments[l.sn - 1 - g.startSN], t = l.sn === g.startSN, i = !e || l.cc > e.cc; if (!1 !== s.independent) { let { startPTS: e, endPTS: r, startDTS: s, endDTS: n } = d; if (o) o.elementaryStreams[d.type] = { startPTS: e, endPTS: r, startDTS: s, endDTS: n }; else if (d.firstKeyFrame && d.independent && 1 === a.id && !i && (this.couldBacktrack = !0), d.dropped && d.independent) { let s = this.getMainFwdBufferInfo(), a = (s ? s.end : this.getLoadPosition()) + this.config.maxBufferHole, o = d.firstKeyFramePTS ? d.firstKeyFramePTS : e; if (t || !(a < o - this.config.maxBufferHole) || i) i && (l.gap = !0); else { this.backtrack(l); return } l.setElementaryStreamInfo(d.type, l.start, r, l.start, n, !0) } else t && e > 2 && (l.gap = !0); l.setElementaryStreamInfo(d.type, e, r, s, n), this.backtrackFragment && (this.backtrackFragment = l), this.bufferFragmentData(d, l, o, a, t || i) } else if (t || i) l.gap = !0; else { this.backtrack(l); return } } if (m) { let { startPTS: e, endPTS: t, startDTS: i, endDTS: r } = m; o && (o.elementaryStreams[F.AUDIO] = { startPTS: e, endPTS: t, startDTS: i, endDTS: r }), l.setElementaryStreamInfo(F.AUDIO, e, t, i, r), this.bufferFragmentData(m, l, o, a) } if (g && null != c && null != (t = c.samples) && t.length) { let e = { id: i, frag: l, details: g, samples: c.samples }; r.trigger(b.FRAG_PARSING_METADATA, e) } if (g && u) { let e = { id: i, frag: l, details: g, samples: u.samples }; r.trigger(b.FRAG_PARSING_USERDATA, e) } } _bufferInitSegment(e, t, i, r) { if (this.state !== em.PARSING) return; this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio; let { audio: s, video: a, audiovideo: n } = t; if (s) { let t = e.audioCodec, i = navigator.userAgent.toLowerCase(); this.audioCodecSwitch && (t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== s.metadata.channelCount && -1 === i.indexOf("firefox") && (t = "mp4a.40.5")), t && -1 !== t.indexOf("mp4a.40.5") && -1 !== i.indexOf("android") && "audio/mpeg" !== s.container && (t = "mp4a.40.2", this.log(`Android: force audio codec to ${t}`)), e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`), s.levelCodec = t, s.id = "main", this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${t || ""}/${e.audioCodec || ""}/${s.codec}]`) } a && (a.levelCodec = e.videoCodec, a.id = "main", this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${a.codec}]`)), n && this.log(`Init audiovideo buffer, container:${n.container}, codecs[level/parsed]=[${e.codecs}/${n.codec}]`), this.hls.trigger(b.BUFFER_CODECS, t), Object.keys(t).forEach(e => { let s = t[e], a = s.initSegment; null != a && a.byteLength && this.hls.trigger(b.BUFFER_APPENDING, { type: e, data: a, frag: i, part: null, chunkMeta: r, parent: i.type }) }), this.tickImmediate() } getMainFwdBufferInfo() { return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, et.MAIN) } backtrack(e) { this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = em.IDLE } checkFragmentChanged() { let e = this.media, t = null; if (e && e.readyState > 1 && !1 === e.seeking) { let i = e.currentTime; if (BufferHelper.isBuffered(e, i) ? t = this.getAppendedFrag(i) : BufferHelper.isBuffered(e, i + .1) && (t = this.getAppendedFrag(i + .1)), t) { this.backtrackFragment = null; let e = this.fragPlaying, i = t.level; e && t.sn === e.sn && e.level === i || (this.fragPlaying = t, this.hls.trigger(b.FRAG_CHANGED, { frag: t }), e && e.level === i || this.hls.trigger(b.LEVEL_SWITCHED, { level: i })) } } } get nextLevel() { let e = this.nextBufferedFrag; return e ? e.level : -1 } get currentFrag() { let e = this.media; return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null } get currentProgramDateTime() { let e = this.media; if (e) { let t = e.currentTime, i = this.currentFrag; if (i && R(t) && R(i.programDateTime)) { let e = i.programDateTime + (t - i.start) * 1e3; return new Date(e) } } return null } get currentLevel() { let e = this.currentFrag; return e ? e.level : -1 } get nextBufferedFrag() { let e = this.currentFrag; return e ? this.followingBufferedFrag(e) : null } get forceStartLoad() { return this._forceStartLoad } }; let Hls = class Hls { static get version() { return "1.5.7" } static isMSESupported() { return isMSESupported() } static isSupported() { return function () { if (!isMSESupported()) return !1; let e = getMediaSource(); return "function" == typeof (null == e ? void 0 : e.isTypeSupported) && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(t => e.isTypeSupported(mimeTypeForCodec(t, "video"))) || ["mp4a.40.2", "fLaC"].some(t => e.isTypeSupported(mimeTypeForCodec(t, "audio")))) }() } static getMediaSource() { return getMediaSource() } static get Events() { return b } static get ErrorTypes() { return C } static get ErrorDetails() { return k } static get DefaultConfig() { return Hls.defaultConfig ? Hls.defaultConfig : eQ } static set DefaultConfig(e) { Hls.defaultConfig = e } constructor(e = {}) { this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new eD, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0, function (e, t) { if ("object" == typeof console && !0 === e || "object" == typeof e) { !function (e, ...t) { t.forEach(function (t) { _[t] = e[t] ? e[t].bind(e) : function (e) { let t = self.console[e]; return t ? t.bind(self.console, `[${e}] >`) : noop }(t) }) }(e, "debug", "log", "info", "warn", "error"); try { _.log(`Debug logs enabled for "${t}" in hls.js version 1.5.7`) } catch (e) { _ = P } } else _ = P }(e.debug || !1, "Hls instance"); let t = this.config = function (e, t) { if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'); if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'); let i = function deepCpy(e) { return e && "object" == typeof e ? Array.isArray(e) ? e.map(deepCpy) : Object.keys(e).reduce((t, i) => (t[i] = deepCpy(e[i]), t), {}) : e }(e), r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"]; return ["manifest", "level", "frag"].forEach(e => { let s = `${"level" === e ? "playlist" : e}LoadPolicy`, a = void 0 === t[s], n = []; r.forEach(r => { let l = `${e}Loading${r}`, o = t[l]; if (void 0 !== o && a) { n.push(l); let e = i[s].default; switch (t[s] = { default: e }, r) { case "TimeOut": e.maxLoadTimeMs = o, e.maxTimeToFirstByteMs = o; break; case "MaxRetry": e.errorRetry.maxNumRetry = o, e.timeoutRetry.maxNumRetry = o; break; case "RetryDelay": e.errorRetry.retryDelayMs = o, e.timeoutRetry.retryDelayMs = o; break; case "MaxRetryTimeout": e.errorRetry.maxRetryDelayMs = o, e.timeoutRetry.maxRetryDelayMs = o } } }), n.length && M.warn(`hls.js config: "${n.join('", "')}" setting(s) are deprecated, use "${s}": ${JSON.stringify(t[s])}`) }), _objectSpread2(_objectSpread2({}, i), t) }(Hls.DefaultConfig, e); this.userConfig = e, t.progressive && function (e) { let t = e.loader; if (t !== FetchLoader && t !== XhrLoader) M.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1; else { let t = function () { if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try { return new self.ReadableStream({}), !0 } catch (e) { } return !1 }(); t && (e.loader = FetchLoader, e.progressive = !0, e.enableSoftwareAES = !0, M.log("[config]: Progressive streaming enabled, using FetchLoader")) } }(t); let { abrController: i, bufferController: r, capLevelController: s, errorController: a, fpsController: n } = t, l = new a(this), o = this.abrController = new i(this), h = this.bufferController = new r(this), d = this.capLevelController = new s(this), u = new n(this), c = new PlaylistLoader(this), f = new ID3TrackController(this), g = t.contentSteeringController, m = g ? new g(this) : null, p = this.levelController = new LevelController(this, m), E = new FragmentTracker(this), T = new KeyLoader(this.config), y = this.streamController = new StreamController(this, E, T); d.setStreamController(y), u.setStreamController(y); let v = [c, p, y]; m && v.splice(1, 0, m), this.networkControllers = v; let S = [o, h, d, u, f, E]; this.audioTrackController = this.createController(t.audioTrackController, v); let A = t.audioStreamController; A && v.push(new A(this, E, T)), this.subtitleTrackController = this.createController(t.subtitleTrackController, v); let L = t.subtitleStreamController; L && v.push(new L(this, E, T)), this.createController(t.timelineController, S), T.emeController = this.emeController = this.createController(t.emeController, S), this.cmcdController = this.createController(t.cmcdController, S), this.latencyController = this.createController(LatencyController, S), this.coreComponents = S, v.push(l); let R = l.onErrorOut; "function" == typeof R && this.on(b.ERROR, R, l) } createController(e, t) { if (e) { let i = new e(this); return t && t.push(i), i } return null } on(e, t, i = this) { this._emitter.on(e, t, i) } once(e, t, i = this) { this._emitter.once(e, t, i) } removeAllListeners(e) { this._emitter.removeAllListeners(e) } off(e, t, i = this, r) { this._emitter.off(e, t, i, r) } listeners(e) { return this._emitter.listeners(e) } emit(e, t, i) { return this._emitter.emit(e, t, i) } trigger(e, t) { if (this.config.debug) return this.emit(e, e, t); try { return this.emit(e, e, t) } catch (t) { if (M.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), !this.triggeringException) { this.triggeringException = !0; let i = e === b.ERROR; this.trigger(b.ERROR, { type: C.OTHER_ERROR, details: k.INTERNAL_EXCEPTION, fatal: i, event: e, error: t }), this.triggeringException = !1 } } return !1 } listenerCount(e) { return this._emitter.listenerCount(e) } destroy() { M.log("destroy"), this.trigger(b.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(e => e.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(e => e.destroy()), this.coreComponents.length = 0; let e = this.config; e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null } attachMedia(e) { M.log("attachMedia"), this._media = e, this.trigger(b.MEDIA_ATTACHING, { media: e }) } detachMedia() { M.log("detachMedia"), this.trigger(b.MEDIA_DETACHING, void 0), this._media = null } loadSource(e) { this.stopLoad(); let t = this.media, i = this.url, r = this.url = L.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }); this._autoLevelCapping = -1, this._maxHdcpLevel = null, M.log(`loadSource:${r}`), t && i && (i !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(b.MANIFEST_LOADING, { url: e }) } startLoad(e = -1) { M.log(`startLoad(${e})`), this.started = !0, this.networkControllers.forEach(t => { t.startLoad(e) }) } stopLoad() { M.log("stopLoad"), this.started = !1, this.networkControllers.forEach(e => { e.stopLoad() }) } resumeBuffering() { this.started && this.networkControllers.forEach(e => { "fragmentLoader" in e && e.startLoad(-1) }) } pauseBuffering() { this.networkControllers.forEach(e => { "fragmentLoader" in e && e.stopLoad() }) } swapAudioCodec() { M.log("swapAudioCodec"), this.streamController.swapAudioCodec() } recoverMediaError() { M.log("recoverMediaError"); let e = this._media; this.detachMedia(), e && this.attachMedia(e) } removeLevel(e) { this.levelController.removeLevel(e) } get levels() { let e = this.levelController.levels; return e || [] } get currentLevel() { return this.streamController.currentLevel } set currentLevel(e) { M.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch() } get nextLevel() { return this.streamController.nextLevel } set nextLevel(e) { M.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } get loadLevel() { return this.levelController.level } set loadLevel(e) { M.log(`set loadLevel:${e}`), this.levelController.manualLevel = e } get nextLoadLevel() { return this.levelController.nextLoadLevel } set nextLoadLevel(e) { this.levelController.nextLoadLevel = e } get firstLevel() { return Math.max(this.levelController.firstLevel, this.minAutoLevel) } set firstLevel(e) { M.log(`set firstLevel:${e}`), this.levelController.firstLevel = e } get startLevel() { let e = this.levelController.startLevel; return -1 === e && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e } set startLevel(e) { M.log(`set startLevel:${e}`), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } get capLevelToPlayerSize() { return this.config.capLevelToPlayerSize } set capLevelToPlayerSize(e) { let t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t) } get autoLevelCapping() { return this._autoLevelCapping } get bandwidthEstimate() { let { bwEstimator: e } = this.abrController; return e ? e.getEstimate() : NaN } set bandwidthEstimate(e) { this.abrController.resetEstimator(e) } get ttfbEstimate() { let { bwEstimator: e } = this.abrController; return e ? e.getEstimateTTFB() : NaN } set autoLevelCapping(e) { this._autoLevelCapping !== e && (M.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated()) } get maxHdcpLevel() { return this._maxHdcpLevel } set maxHdcpLevel(e) { es.indexOf(e) > -1 && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated()) } get autoLevelEnabled() { return -1 === this.levelController.manualLevel } get manualLevel() { return this.levelController.manualLevel } get minAutoLevel() { let { levels: e, config: { minAutoBitrate: t } } = this; if (!e) return 0; let i = e.length; for (let r = 0; r < i; r++)if (e[r].maxBitrate >= t) return r; return 0 } get maxAutoLevel() { let e; let { levels: t, autoLevelCapping: i, maxHdcpLevel: r } = this; if (e = -1 === i && null != t && t.length ? t.length - 1 : i, r) for (let i = e; i--;) { let e = t[i].attrs["HDCP-LEVEL"]; if (e && e <= r) return i } return e } get firstAutoLevel() { return this.abrController.firstAutoLevel } get nextAutoLevel() { return this.abrController.nextAutoLevel } set nextAutoLevel(e) { this.abrController.nextAutoLevel = e } get playingDate() { return this.streamController.currentProgramDateTime } get mainForwardBufferInfo() { return this.streamController.getMainFwdBufferInfo() } setAudioOption(e) { var t; return null == (t = this.audioTrackController) ? void 0 : t.setAudioOption(e) } setSubtitleOption(e) { var t; return null == (t = this.subtitleTrackController) || t.setSubtitleOption(e), null } get allAudioTracks() { let e = this.audioTrackController; return e ? e.allAudioTracks : [] } get audioTracks() { let e = this.audioTrackController; return e ? e.audioTracks : [] } get audioTrack() { let e = this.audioTrackController; return e ? e.audioTrack : -1 } set audioTrack(e) { let t = this.audioTrackController; t && (t.audioTrack = e) } get allSubtitleTracks() { let e = this.subtitleTrackController; return e ? e.allSubtitleTracks : [] } get subtitleTracks() { let e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } get subtitleTrack() { let e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 } get media() { return this._media } set subtitleTrack(e) { let t = this.subtitleTrackController; t && (t.subtitleTrack = e) } get subtitleDisplay() { let e = this.subtitleTrackController; return !!e && e.subtitleDisplay } set subtitleDisplay(e) { let t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } get lowLatencyMode() { return this.config.lowLatencyMode } set lowLatencyMode(e) { this.config.lowLatencyMode = e } get liveSyncPosition() { return this.latencyController.liveSyncPosition } get latency() { return this.latencyController.latency } get maxLatency() { return this.latencyController.maxLatency } get targetLatency() { return this.latencyController.targetLatency } get drift() { return this.latencyController.drift } get forceStartLoad() { return this.streamController.forceStartLoad } }; Hls.defaultConfig = void 0
  }
}]);

"use strict"; (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[774], {
  5041: function (n, a, o) {/**
  * @license React
  * react-dom-server-legacy.browser.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */var i = o(50959); function l(n) { for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, o = 1; o < arguments.length; o++)a += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + n + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = Object.prototype.hasOwnProperty, _ = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, N = {}, z = {}; function ja(n) { return !!s.call(z, n) || !s.call(N, n) && (_.test(n) ? z[n] = !0 : (N[n] = !0, !1)) } function r(n, a, o, i, s, _, N) { this.acceptsBooleans = 2 === a || 3 === a || 4 === a, this.attributeName = i, this.attributeNamespace = s, this.mustUseProperty = o, this.propertyName = n, this.type = a, this.sanitizeURL = _, this.removeEmptyString = N } var j = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { j[n] = new r(n, 0, !1, n, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var a = n[0]; j[a] = new r(a, 1, !1, n[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { j[n] = new r(n, 2, !1, n.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { j[n] = new r(n, 2, !1, n, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { j[n] = new r(n, 3, !1, n.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (n) { j[n] = new r(n, 3, !0, n, null, !1, !1) }), ["capture", "download"].forEach(function (n) { j[n] = new r(n, 4, !1, n, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (n) { j[n] = new r(n, 6, !1, n, null, !1, !1) }), ["rowSpan", "start"].forEach(function (n) { j[n] = new r(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var B = /[\-:]([a-z])/g; function la(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var a = n.replace(B, la); j[a] = new r(a, 1, !1, n, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var a = n.replace(B, la); j[a] = new r(a, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var a = n.replace(B, la); j[a] = new r(a, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (n) { j[n] = new r(n, 1, !1, n.toLowerCase(), null, !1, !1) }), j.xlinkHref = new r("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (n) { j[n] = new r(n, 1, !1, n.toLowerCase(), null, !0, !0) }); var $ = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, ee = ["Webkit", "ms", "Moz", "O"]; Object.keys($).forEach(function (n) { ee.forEach(function (a) { $[a = a + n.charAt(0).toUpperCase() + n.substring(1)] = $[n] }) }); var et = /["'&<>]/; function v(n) { if ("boolean" == typeof n || "number" == typeof n) return "" + n; n = "" + n; var a = et.exec(n); if (a) { var o, i = "", s = 0; for (o = a.index; o < n.length; o++) { switch (n.charCodeAt(o)) { case 34: a = "&quot;"; break; case 38: a = "&amp;"; break; case 39: a = "&#x27;"; break; case 60: a = "&lt;"; break; case 62: a = "&gt;"; break; default: continue }s !== o && (i += n.substring(s, o)), s = o + 1, i += a } n = s !== o ? i + n.substring(s, o) : i } return n } var en = /([A-Z])/g, er = /^ms-/, ea = Array.isArray; function w(n, a) { return { insertionMode: n, selectedValue: a } } var eo = new Map; function ta(n, a, o) { if ("object" != typeof o) throw Error(l(62)); for (var i in a = !0, o) if (s.call(o, i)) { var _ = o[i]; if (null != _ && "boolean" != typeof _ && "" !== _) { if (0 === i.indexOf("--")) { var N = v(i); _ = v(("" + _).trim()) } else { N = i; var z = eo.get(N); void 0 !== z || (z = v(N.replace(en, "-$1").toLowerCase().replace(er, "-ms-")), eo.set(N, z)), N = z, _ = "number" == typeof _ ? 0 === _ || s.call($, i) ? "" + _ : _ + "px" : v(("" + _).trim()) } a ? (a = !1, n.push(' style="', N, ":", _)) : n.push(";", N, ":", _) } } a || n.push('"') } function x(n, a, o, i) { switch (o) { case "style": ta(n, a, i); return; case "defaultValue": case "defaultChecked": case "innerHTML": case "suppressContentEditableWarning": case "suppressHydrationWarning": return }if (!(2 < o.length) || "o" !== o[0] && "O" !== o[0] || "n" !== o[1] && "N" !== o[1]) { if (null !== (a = j.hasOwnProperty(o) ? j[o] : null)) { switch (typeof i) { case "function": case "symbol": return; case "boolean": if (!a.acceptsBooleans) return }switch (o = a.attributeName, a.type) { case 3: i && n.push(" ", o, '=""'); break; case 4: !0 === i ? n.push(" ", o, '=""') : !1 !== i && n.push(" ", o, '="', v(i), '"'); break; case 5: isNaN(i) || n.push(" ", o, '="', v(i), '"'); break; case 6: !isNaN(i) && 1 <= i && n.push(" ", o, '="', v(i), '"'); break; default: a.sanitizeURL && (i = "" + i), n.push(" ", o, '="', v(i), '"') } } else if (ja(o)) { switch (typeof i) { case "function": case "symbol": return; case "boolean": if ("data-" !== (a = o.toLowerCase().slice(0, 5)) && "aria-" !== a) return }n.push(" ", o, '="', v(i), '"') } } } function y(n, a, o) { if (null != a) { if (null != o) throw Error(l(60)); if ("object" != typeof a || !("__html" in a)) throw Error(l(61)); null != (a = a.__html) && n.push("" + a) } } function va(n, a, o, i) { n.push(A(o)); var _, N = o = null; for (_ in a) if (s.call(a, _)) { var z = a[_]; if (null != z) switch (_) { case "children": o = z; break; case "dangerouslySetInnerHTML": N = z; break; default: x(n, i, _, z) } } return n.push(">"), y(n, N, o), "string" == typeof o ? (n.push(v(o)), null) : o } var eu = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, es = new Map; function A(n) { var a = es.get(n); if (void 0 === a) { if (!eu.test(n)) throw Error(l(65, n)); a = "<" + n, es.set(n, a) } return a } function za(n, a, o) { if (n.push('<!--$?--><template id="'), null === o) throw Error(l(395)); return n.push(o), n.push('"></template>') } var ec = /[<\u2028\u2029]/g; function Da(n) { return JSON.stringify(n).replace(ec, function (n) { switch (n) { case "<": return "\\u003c"; case "\u2028": return "\\u2028"; case "\u2029": return "\\u2029"; default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React") } }) } function Fa(n, a, o, i) { return o.generateStaticMarkup ? (n.push(v(a)), !1) : ("" === a ? n = i : (i && n.push("<!-- -->"), n.push(v(a)), n = !0), n) } var ef = Object.assign, ep = Symbol.for("react.element"), eg = Symbol.for("react.portal"), em = Symbol.for("react.fragment"), ev = Symbol.for("react.strict_mode"), ey = Symbol.for("react.profiler"), ew = Symbol.for("react.provider"), eS = Symbol.for("react.context"), ex = Symbol.for("react.forward_ref"), eE = Symbol.for("react.suspense"), eC = Symbol.for("react.suspense_list"), e_ = Symbol.for("react.memo"), eT = Symbol.for("react.lazy"), eP = Symbol.for("react.scope"), eF = Symbol.for("react.debug_trace_mode"), eR = Symbol.for("react.legacy_hidden"), eN = Symbol.for("react.default_value"), ez = Symbol.iterator, eL = {}; function Za(n, a) { if (!(n = n.contextTypes)) return eL; var o, i = {}; for (o in n) i[o] = a[o]; return i } var eM = null; function F(n, a) { if (n !== a) { n.context._currentValue2 = n.parentValue, n = n.parent; var o = a.parent; if (null === n) { if (null !== o) throw Error(l(401)) } else { if (null === o) throw Error(l(401)); F(n, o) } a.context._currentValue2 = a.value } } function G(n) { var a = eM; a !== n && (null === a ? function ab(n) { var a = n.parent; null !== a && ab(a), n.context._currentValue2 = n.value }(n) : null === n ? function $a(n) { n.context._currentValue2 = n.parentValue, null !== (n = n.parent) && $a(n) }(a) : a.depth === n.depth ? F(a, n) : a.depth > n.depth ? function bb(n, a) { if (n.context._currentValue2 = n.parentValue, null === (n = n.parent)) throw Error(l(402)); n.depth === a.depth ? F(n, a) : bb(n, a) }(a, n) : function cb(n, a) { var o = a.parent; if (null === o) throw Error(l(402)); n.depth === o.depth ? F(n, o) : cb(n, o), a.context._currentValue2 = a.value }(a, n), eM = n) } var eD = { isMounted: function () { return !1 }, enqueueSetState: function (n, a) { null !== (n = n._reactInternals).queue && n.queue.push(a) }, enqueueReplaceState: function (n, a) { (n = n._reactInternals).replace = !0, n.queue = [a] }, enqueueForceUpdate: function () { } }; function eb(n, a, o, i) { var s = void 0 !== n.state ? n.state : null; n.updater = eD, n.props = o, n.state = s; var _ = { queue: [], replace: !1 }; n._reactInternals = _; var N = a.contextType; if (n.context = "object" == typeof N && null !== N ? N._currentValue2 : i, "function" == typeof (N = a.getDerivedStateFromProps) && (s = null == (N = N(o, s)) ? s : ef({}, s, N), n.state = s), "function" != typeof a.getDerivedStateFromProps && "function" != typeof n.getSnapshotBeforeUpdate && ("function" == typeof n.UNSAFE_componentWillMount || "function" == typeof n.componentWillMount)) { if (a = n.state, "function" == typeof n.componentWillMount && n.componentWillMount(), "function" == typeof n.UNSAFE_componentWillMount && n.UNSAFE_componentWillMount(), a !== n.state && eD.enqueueReplaceState(n, n.state, null), null !== _.queue && 0 < _.queue.length) { if (a = _.queue, N = _.replace, _.queue = null, _.replace = !1, N && 1 === a.length) n.state = a[0]; else { for (_ = N ? a[0] : n.state, s = !0, N = N ? 1 : 0; N < a.length; N++) { var z = a[N]; null != (z = "function" == typeof z ? z.call(n, _, o, i) : z) && (s ? (s = !1, _ = ef({}, _, z)) : ef(_, z)) } n.state = _ } } else _.queue = null } } var eI = { id: 1, overflow: "" }; function gb(n, a, o) { var i = n.id; n = n.overflow; var s = 32 - eO(i) - 1; i &= ~(1 << s), o += 1; var _ = 32 - eO(a) + s; if (30 < _) { var N = s - s % 5; return _ = (i & (1 << N) - 1).toString(32), i >>= N, s -= N, { id: 1 << 32 - eO(a) + s | o << s | i, overflow: _ + n } } return { id: 1 << _ | o << s | i, overflow: n } } var eO = Math.clz32 ? Math.clz32 : function (n) { return 0 == (n >>>= 0) ? 32 : 31 - (eV(n) / eB | 0) | 0 }, eV = Math.log, eB = Math.LN2, eA = "function" == typeof Object.is ? Object.is : function (n, a) { return n === a && (0 !== n || 1 / n == 1 / a) || n != n && a != a }, eU = null, e$ = null, eW = null, eH = null, eQ = !1, eq = !1, eZ = 0, eG = null, eY = 0; function Q() { if (null === eU) throw Error(l(321)); return eU } function pb() { if (0 < eY) throw Error(l(312)); return { memoizedState: null, queue: null, next: null } } function qb() { return null === eH ? null === eW ? (eQ = !1, eW = eH = pb()) : (eQ = !0, eH = eW) : null === eH.next ? (eQ = !1, eH = eH.next = pb()) : (eQ = !0, eH = eH.next), eH } function rb() { e$ = eU = null, eq = !1, eW = null, eY = 0, eH = eG = null } function sb(n, a) { return "function" == typeof a ? a(n) : a } function tb(n, a, o) { if (eU = Q(), eH = qb(), eQ) { var i = eH.queue; if (a = i.dispatch, null !== eG && void 0 !== (o = eG.get(i))) { eG.delete(i), i = eH.memoizedState; do i = n(i, o.action), o = o.next; while (null !== o); return eH.memoizedState = i, [i, a] } return [eH.memoizedState, a] } return n = n === sb ? "function" == typeof a ? a() : a : void 0 !== o ? o(a) : a, eH.memoizedState = n, n = (n = eH.queue = { last: null, dispatch: null }).dispatch = ub.bind(null, eU, n), [eH.memoizedState, n] } function vb(n, a) { if (eU = Q(), eH = qb(), a = void 0 === a ? null : a, null !== eH) { var o = eH.memoizedState; if (null !== o && null !== a) { var i = o[1]; e: if (null === i) i = !1; else { for (var s = 0; s < i.length && s < a.length; s++)if (!eA(a[s], i[s])) { i = !1; break e } i = !0 } if (i) return o[0] } } return n = n(), eH.memoizedState = [n, a], n } function ub(n, a, o) { if (25 <= eY) throw Error(l(301)); if (n === eU) { if (eq = !0, n = { action: o, next: null }, null === eG && (eG = new Map), void 0 === (o = eG.get(a))) eG.set(a, n); else { for (a = o; null !== a.next;)a = a.next; a.next = n } } } function wb() { throw Error(l(394)) } function R() { } var eX = { readContext: function (n) { return n._currentValue2 }, useContext: function (n) { return Q(), n._currentValue2 }, useMemo: vb, useReducer: tb, useRef: function (n) { eU = Q(); var a = (eH = qb()).memoizedState; return null === a ? (n = { current: n }, eH.memoizedState = n) : a }, useState: function (n) { return tb(sb, n) }, useInsertionEffect: R, useLayoutEffect: function () { }, useCallback: function (n, a) { return vb(function () { return n }, a) }, useImperativeHandle: R, useEffect: R, useDebugValue: R, useDeferredValue: function (n) { return Q(), n }, useTransition: function () { return Q(), [!1, wb] }, useId: function () { var n = e$.treeContext, a = n.overflow; n = ((n = n.id) & ~(1 << 32 - eO(n) - 1)).toString(32) + a; var o = eK; if (null === o) throw Error(l(404)); return a = eZ++, n = ":" + o.idPrefix + "R" + n, 0 < a && (n += "H" + a.toString(32)), n + ":" }, useMutableSource: function (n, a) { return Q(), a(n._source) }, useSyncExternalStore: function (n, a, o) { if (void 0 === o) throw Error(l(407)); return o() } }, eK = null, eJ = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher; function zb(n) { return console.error(n), null } function T() { } function Bb(n, a, o, i, s, _, N, z) { n.allPendingTasks++, null === o ? n.pendingRootTasks++ : o.pendingTasks++; var j = { node: a, ping: function () { var a = n.pingedTasks; a.push(j), 1 === a.length && Cb(n) }, blockedBoundary: o, blockedSegment: i, abortSet: s, legacyContext: _, context: N, treeContext: z }; return s.add(j), j } function U(n, a, o, i, s, _) { return { status: 0, id: -1, index: a, parentFlushed: !1, chunks: [], children: [], formatContext: i, boundary: o, lastPushedText: s, textEmbedded: _ } } function V(n, a) { if (null != (n = n.onError(a)) && "string" != typeof n) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof n + '" instead'); return n } function W(n, a) { var o = n.onShellError; o(a), (o = n.onFatalError)(a), null !== n.destination ? (n.status = 2, n.destination.destroy(a)) : (n.status = 1, n.fatalError = a) } function Db(n, a, o, i, s) { for (eU = {}, e$ = a, eZ = 0, n = o(i, s); eq;)eq = !1, eZ = 0, eY += 1, eH = null, n = o(i, s); return rb(), n } function Eb(n, a, o, i) { var s = o.render(), _ = i.childContextTypes; if (null != _) { var N = a.legacyContext; if ("function" != typeof o.getChildContext) i = N; else { for (var z in o = o.getChildContext()) if (!(z in _)) throw Error(l(108, function Xa(n) { if (null == n) return null; if ("function" == typeof n) return n.displayName || n.name || null; if ("string" == typeof n) return n; switch (n) { case em: return "Fragment"; case eg: return "Portal"; case ey: return "Profiler"; case ev: return "StrictMode"; case eE: return "Suspense"; case eC: return "SuspenseList" }if ("object" == typeof n) switch (n.$$typeof) { case eS: return (n.displayName || "Context") + ".Consumer"; case ew: return (n._context.displayName || "Context") + ".Provider"; case ex: var a = n.render; return (n = n.displayName) || (n = "" !== (n = a.displayName || a.name || "") ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case e_: return null !== (a = n.displayName || null) ? a : Xa(n.type) || "Memo"; case eT: a = n._payload, n = n._init; try { return Xa(n(a)) } catch (n) { } }return null }(i) || "Unknown", z)); i = ef({}, N, o) } a.legacyContext = i, X(n, a, s), a.legacyContext = N } else X(n, a, s) } function Fb(n, a) { if (n && n.defaultProps) for (var o in a = ef({}, a), n = n.defaultProps) void 0 === a[o] && (a[o] = n[o]); return a } function X(n, a, o) { if (a.node = o, "object" == typeof o && null !== o) { switch (o.$$typeof) { case ep: !function Gb(n, a, o, _, N) { if ("function" == typeof o) { if (o.prototype && o.prototype.isReactComponent) { N = Za(o, a.legacyContext); var z = o.contextType; eb(z = new o(_, "object" == typeof z && null !== z ? z._currentValue2 : N), o, _, N), Eb(n, a, z, o) } else { z = Za(o, a.legacyContext), N = Db(n, a, o, _, z); var j = 0 !== eZ; if ("object" == typeof N && null !== N && "function" == typeof N.render && void 0 === N.$$typeof) eb(N, o, _, z), Eb(n, a, N, o); else if (j) { _ = a.treeContext, a.treeContext = gb(_, 1, 0); try { X(n, a, N) } finally { a.treeContext = _ } } else X(n, a, N) } } else if ("string" == typeof o) { switch (z = function (n, a, o, _, N) { switch (a) { case "select": n.push(A("select")); var z = null, j = null; for (er in o) if (s.call(o, er)) { var B = o[er]; if (null != B) switch (er) { case "children": z = B; break; case "dangerouslySetInnerHTML": j = B; break; case "defaultValue": case "value": break; default: x(n, _, er, B) } } return n.push(">"), y(n, j, z), z; case "option": j = N.selectedValue, n.push(A("option")); var $, ee, et = B = null, en = null, er = null; for (z in o) if (s.call(o, z)) { var eo = o[z]; if (null != eo) switch (z) { case "children": B = eo; break; case "selected": en = eo; break; case "dangerouslySetInnerHTML": er = eo; break; case "value": et = eo; default: x(n, _, z, eo) } } if (null != j) { if (o = null !== et ? "" + et : ($ = B, ee = "", i.Children.forEach($, function (n) { null != n && (ee += n) }), ee), ea(j)) { for (_ = 0; _ < j.length; _++)if ("" + j[_] === o) { n.push(' selected=""'); break } } else "" + j === o && n.push(' selected=""') } else en && n.push(' selected=""'); return n.push(">"), y(n, er, B), B; case "textarea": for (B in n.push(A("textarea")), er = j = z = null, o) if (s.call(o, B) && null != (et = o[B])) switch (B) { case "children": er = et; break; case "value": z = et; break; case "defaultValue": j = et; break; case "dangerouslySetInnerHTML": throw Error(l(91)); default: x(n, _, B, et) }if (null === z && null !== j && (z = j), n.push(">"), null != er) { if (null != z) throw Error(l(92)); if (ea(er) && 1 < er.length) throw Error(l(93)); z = "" + er } return "string" == typeof z && "\n" === z[0] && n.push("\n"), null !== z && n.push(v("" + z)), null; case "input": for (j in n.push(A("input")), et = er = B = z = null, o) if (s.call(o, j) && null != (en = o[j])) switch (j) { case "children": case "dangerouslySetInnerHTML": throw Error(l(399, "input")); case "defaultChecked": et = en; break; case "defaultValue": B = en; break; case "checked": er = en; break; case "value": z = en; break; default: x(n, _, j, en) }return null !== er ? x(n, _, "checked", er) : null !== et && x(n, _, "checked", et), null !== z ? x(n, _, "value", z) : null !== B && x(n, _, "value", B), n.push("/>"), null; case "menuitem": for (var eu in n.push(A("menuitem")), o) if (s.call(o, eu) && null != (z = o[eu])) switch (eu) { case "children": case "dangerouslySetInnerHTML": throw Error(l(400)); default: x(n, _, eu, z) }return n.push(">"), null; case "title": for (eo in n.push(A("title")), z = null, o) if (s.call(o, eo) && null != (j = o[eo])) switch (eo) { case "children": z = j; break; case "dangerouslySetInnerHTML": throw Error(l(434)); default: x(n, _, eo, j) }return n.push(">"), z; case "listing": case "pre": for (et in n.push(A(a)), j = z = null, o) if (s.call(o, et) && null != (B = o[et])) switch (et) { case "children": z = B; break; case "dangerouslySetInnerHTML": j = B; break; default: x(n, _, et, B) }if (n.push(">"), null != j) { if (null != z) throw Error(l(60)); if ("object" != typeof j || !("__html" in j)) throw Error(l(61)); null != (o = j.__html) && ("string" == typeof o && 0 < o.length && "\n" === o[0] ? n.push("\n", o) : n.push("" + o)) } return "string" == typeof z && "\n" === z[0] && n.push("\n"), z; case "area": case "base": case "br": case "col": case "embed": case "hr": case "img": case "keygen": case "link": case "meta": case "param": case "source": case "track": case "wbr": for (var es in n.push(A(a)), o) if (s.call(o, es) && null != (z = o[es])) switch (es) { case "children": case "dangerouslySetInnerHTML": throw Error(l(399, a)); default: x(n, _, es, z) }return n.push("/>"), null; case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return va(n, o, a, _); case "html": return 0 === N.insertionMode && n.push("<!DOCTYPE html>"), va(n, o, a, _); default: if (-1 === a.indexOf("-") && "string" != typeof o.is) return va(n, o, a, _); for (en in n.push(A(a)), j = z = null, o) if (s.call(o, en) && null != (B = o[en])) switch (en) { case "children": z = B; break; case "dangerouslySetInnerHTML": j = B; break; case "style": ta(n, _, B); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": break; default: ja(en) && "function" != typeof B && "symbol" != typeof B && n.push(" ", en, '="', v(B), '"') }return n.push(">"), y(n, j, z), z } }((N = a.blockedSegment).chunks, o, _, n.responseState, N.formatContext), N.lastPushedText = !1, j = N.formatContext, N.formatContext = function (n, a, o) { switch (a) { case "select": return w(1, null != o.value ? o.value : o.defaultValue); case "svg": return w(2, null); case "math": return w(3, null); case "foreignObject": return w(1, null); case "table": return w(4, null); case "thead": case "tbody": case "tfoot": return w(5, null); case "colgroup": return w(7, null); case "tr": return w(6, null) }return 4 <= n.insertionMode || 0 === n.insertionMode ? w(1, null) : n }(j, o, _), Hb(n, a, z), N.formatContext = j, o) { case "area": case "base": case "br": case "col": case "embed": case "hr": case "img": case "input": case "keygen": case "link": case "meta": case "param": case "source": case "track": case "wbr": break; default: N.chunks.push("</", o, ">") }N.lastPushedText = !1 } else { switch (o) { case eR: case eF: case ev: case ey: case em: case eC: X(n, a, _.children); return; case eP: throw Error(l(343)); case eE: e: { o = a.blockedBoundary, N = a.blockedSegment, z = _.fallback, _ = _.children; var B = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: j = new Set, errorDigest: null }, $ = U(n, N.chunks.length, B, N.formatContext, !1, !1); N.children.push($), N.lastPushedText = !1; var ee = U(n, 0, null, N.formatContext, !1, !1); ee.parentFlushed = !0, a.blockedBoundary = B, a.blockedSegment = ee; try { if (Hb(n, a, _), n.responseState.generateStaticMarkup || ee.lastPushedText && ee.textEmbedded && ee.chunks.push("<!-- -->"), ee.status = 1, Y(B, ee), 0 === B.pendingTasks) break e } catch (a) { ee.status = 4, B.forceClientRender = !0, B.errorDigest = V(n, a) } finally { a.blockedBoundary = o, a.blockedSegment = N } a = Bb(n, z, o, $, j, a.legacyContext, a.context, a.treeContext), n.pingedTasks.push(a) } return }if ("object" == typeof o && null !== o) switch (o.$$typeof) { case ex: if (_ = Db(n, a, o.render, _, N), 0 !== eZ) { o = a.treeContext, a.treeContext = gb(o, 1, 0); try { X(n, a, _) } finally { a.treeContext = o } } else X(n, a, _); return; case e_: _ = Fb(o = o.type, _), Gb(n, a, o, _, N); return; case ew: if (N = _.children, o = o._context, _ = _.value, z = o._currentValue2, o._currentValue2 = _, eM = _ = { parent: j = eM, depth: null === j ? 0 : j.depth + 1, context: o, parentValue: z, value: _ }, a.context = _, X(n, a, N), null === (n = eM)) throw Error(l(403)); _ = n.parentValue, n.context._currentValue2 = _ === eN ? n.context._defaultValue : _, n = eM = n.parent, a.context = n; return; case eS: X(n, a, _ = (_ = _.children)(o._currentValue2)); return; case eT: _ = Fb(o = (N = o._init)(o._payload), _), Gb(n, a, o, _, void 0); return }throw Error(l(130, null == o ? o : typeof o, "")) } }(n, a, o.type, o.props, o.ref); return; case eg: throw Error(l(257)); case eT: var _ = o._init; X(n, a, o = _(o._payload)); return }if (ea(o)) { Ib(n, a, o); return } if ((_ = null === o || "object" != typeof o ? null : "function" == typeof (_ = ez && o[ez] || o["@@iterator"]) ? _ : null) && (_ = _.call(o))) { if (!(o = _.next()).done) { var N = []; do N.push(o.value), o = _.next(); while (!o.done); Ib(n, a, N) } return } throw Error(l(31, "[object Object]" === (n = Object.prototype.toString.call(o)) ? "object with keys {" + Object.keys(o).join(", ") + "}" : n)) } "string" == typeof o ? (_ = a.blockedSegment).lastPushedText = Fa(a.blockedSegment.chunks, o, n.responseState, _.lastPushedText) : "number" == typeof o && ((_ = a.blockedSegment).lastPushedText = Fa(a.blockedSegment.chunks, "" + o, n.responseState, _.lastPushedText)) } function Ib(n, a, o) { for (var i = o.length, s = 0; s < i; s++) { var _ = a.treeContext; a.treeContext = gb(_, i, s); try { Hb(n, a, o[s]) } finally { a.treeContext = _ } } } function Hb(n, a, o) { var i = a.blockedSegment.formatContext, s = a.legacyContext, _ = a.context; try { return X(n, a, o) } catch (j) { if (rb(), "object" == typeof j && null !== j && "function" == typeof j.then) { o = j; var N = a.blockedSegment, z = U(n, N.chunks.length, null, N.formatContext, N.lastPushedText, !0); N.children.push(z), N.lastPushedText = !1, n = Bb(n, a.node, a.blockedBoundary, z, a.abortSet, a.legacyContext, a.context, a.treeContext).ping, o.then(n, n), a.blockedSegment.formatContext = i, a.legacyContext = s, a.context = _, G(_) } else throw a.blockedSegment.formatContext = i, a.legacyContext = s, a.context = _, G(_), j } } function Jb(n) { var a = n.blockedBoundary; (n = n.blockedSegment).status = 3, Kb(this, a, n) } function Y(n, a) { if (0 === a.chunks.length && 1 === a.children.length && null === a.children[0].boundary) { var o = a.children[0]; o.id = a.id, o.parentFlushed = !0, 1 === o.status && Y(n, o) } else n.completedSegments.push(a) } function Kb(n, a, o) { if (null === a) { if (o.parentFlushed) { if (null !== n.completedRootSegment) throw Error(l(389)); n.completedRootSegment = o } n.pendingRootTasks--, 0 === n.pendingRootTasks && (n.onShellError = T, (a = n.onShellReady)()) } else a.pendingTasks--, a.forceClientRender || (0 === a.pendingTasks ? (o.parentFlushed && 1 === o.status && Y(a, o), a.parentFlushed && n.completedBoundaries.push(a), a.fallbackAbortableTasks.forEach(Jb, n), a.fallbackAbortableTasks.clear()) : o.parentFlushed && 1 === o.status && (Y(a, o), 1 === a.completedSegments.length && a.parentFlushed && n.partialBoundaries.push(a))); n.allPendingTasks--, 0 === n.allPendingTasks && (n = n.onAllReady)() } function Cb(n) { if (2 !== n.status) { var a = eM, o = eJ.current; eJ.current = eX; var i = eK; eK = n.responseState; try { var s, _ = n.pingedTasks; for (s = 0; s < _.length; s++) { var N = _[s], z = N.blockedSegment; if (0 === z.status) { G(N.context); try { X(n, N, N.node), n.responseState.generateStaticMarkup || z.lastPushedText && z.textEmbedded && z.chunks.push("<!-- -->"), N.abortSet.delete(N), z.status = 1, Kb(n, N.blockedBoundary, z) } catch (a) { if (rb(), "object" == typeof a && null !== a && "function" == typeof a.then) { var j = N.ping; a.then(j, j) } else { N.abortSet.delete(N), z.status = 4; var B = N.blockedBoundary, $ = V(n, a); null === B ? W(n, a) : (B.pendingTasks--, B.forceClientRender || (B.forceClientRender = !0, B.errorDigest = $, B.parentFlushed && n.clientRenderedBoundaries.push(B))), n.allPendingTasks--, 0 === n.allPendingTasks && (0, n.onAllReady)() } } finally { } } } _.splice(0, s), null !== n.destination && Mb(n, n.destination) } catch (a) { V(n, a), W(n, a) } finally { eK = i, eJ.current = o, o === eX && G(a) } } } function Z(n, a, o) { switch (o.parentFlushed = !0, o.status) { case 0: var i = o.id = n.nextSegmentId++; return o.lastPushedText = !1, o.textEmbedded = !1, n = n.responseState, a.push('<template id="'), a.push(n.placeholderPrefix), n = i.toString(16), a.push(n), a.push('"></template>'); case 1: o.status = 2; var s = !0; i = o.chunks; var _ = 0; o = o.children; for (var N = 0; N < o.length; N++) { for (s = o[N]; _ < s.index; _++)a.push(i[_]); s = Nb(n, a, s) } for (; _ < i.length - 1; _++)a.push(i[_]); return _ < i.length && (s = a.push(i[_])), s; default: throw Error(l(390)) } } function Nb(n, a, o) { var i = o.boundary; if (null === i) return Z(n, a, o); if (i.parentFlushed = !0, i.forceClientRender) return n.responseState.generateStaticMarkup || (i = i.errorDigest, a.push("<!--$!-->"), a.push("<template"), i && (a.push(' data-dgst="'), i = v(i), a.push(i), a.push('"')), a.push("></template>")), Z(n, a, o), n = !!n.responseState.generateStaticMarkup || a.push("<!--/$-->"); if (0 < i.pendingTasks) { i.rootSegmentID = n.nextSegmentId++, 0 < i.completedSegments.length && n.partialBoundaries.push(i); var s = n.responseState, _ = s.nextSuspenseID++; return s = s.boundaryPrefix + _.toString(16), i = i.id = s, za(a, n.responseState, i), Z(n, a, o), a.push("<!--/$-->") } if (i.byteSize > n.progressiveChunkSize) return i.rootSegmentID = n.nextSegmentId++, n.completedBoundaries.push(i), za(a, n.responseState, i.id), Z(n, a, o), a.push("<!--/$-->"); if (n.responseState.generateStaticMarkup || a.push("<!--$-->"), 1 !== (o = i.completedSegments).length) throw Error(l(391)); return Nb(n, a, o[0]), n = !!n.responseState.generateStaticMarkup || a.push("<!--/$-->") } function Ob(n, a, o) { return !function (n, a, o, i) { switch (o.insertionMode) { case 0: case 1: return n.push('<div hidden id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 2: return n.push('<svg aria-hidden="true" style="display:none" id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 3: return n.push('<math aria-hidden="true" style="display:none" id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 4: return n.push('<table hidden id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 5: return n.push('<table hidden><tbody id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 6: return n.push('<table hidden><tr id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); case 7: return n.push('<table hidden><colgroup id="'), n.push(a.segmentPrefix), a = i.toString(16), n.push(a), n.push('">'); default: throw Error(l(397)) } }(a, n.responseState, o.formatContext, o.id), Nb(n, a, o), function (n, a) { switch (a.insertionMode) { case 0: case 1: return n.push("</div>"); case 2: return n.push("</svg>"); case 3: return n.push("</math>"); case 4: return n.push("</table>"); case 5: return n.push("</tbody></table>"); case 6: return n.push("</tr></table>"); case 7: return n.push("</colgroup></table>"); default: throw Error(l(397)) } }(a, o.formatContext) } function Pb(n, a, o) { for (var i = o.completedSegments, s = 0; s < i.length; s++)Qb(n, a, o, i[s]); if (i.length = 0, n = n.responseState, i = o.id, o = o.rootSegmentID, a.push(n.startInlineScript), n.sentCompleteBoundaryFunction ? a.push('$RC("') : (n.sentCompleteBoundaryFunction = !0, a.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), null === i) throw Error(l(395)); return o = o.toString(16), a.push(i), a.push('","'), a.push(n.segmentPrefix), a.push(o), a.push('")</script>') } function Qb(n, a, o, i) { if (2 === i.status) return !0; var s = i.id; if (-1 === s) { if (-1 === (i.id = o.rootSegmentID)) throw Error(l(392)); return Ob(n, a, i) } return Ob(n, a, i), n = n.responseState, a.push(n.startInlineScript), n.sentCompleteSegmentFunction ? a.push('$RS("') : (n.sentCompleteSegmentFunction = !0, a.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), a.push(n.segmentPrefix), s = s.toString(16), a.push(s), a.push('","'), a.push(n.placeholderPrefix), a.push(s), a.push('")</script>') } function Mb(n, a) { try { var o = n.completedRootSegment; if (null !== o && 0 === n.pendingRootTasks) { Nb(n, a, o), n.completedRootSegment = null; var i = n.responseState.bootstrapChunks; for (o = 0; o < i.length - 1; o++)a.push(i[o]); o < i.length && a.push(i[o]) } var s, _ = n.clientRenderedBoundaries; for (s = 0; s < _.length; s++) { var N = _[s]; i = a; var z = n.responseState, j = N.id, B = N.errorDigest, $ = N.errorMessage, ee = N.errorComponentStack; if (i.push(z.startInlineScript), z.sentClientRenderFunction ? i.push('$RX("') : (z.sentClientRenderFunction = !0, i.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), null === j) throw Error(l(395)); if (i.push(j), i.push('"'), B || $ || ee) { i.push(","); var et = Da(B || ""); i.push(et) } if ($ || ee) { i.push(","); var en = Da($ || ""); i.push(en) } if (ee) { i.push(","); var er = Da(ee); i.push(er) } if (!i.push(")</script>")) { n.destination = null, s++, _.splice(0, s); return } } _.splice(0, s); var ea = n.completedBoundaries; for (s = 0; s < ea.length; s++)if (!Pb(n, a, ea[s])) { n.destination = null, s++, ea.splice(0, s); return } ea.splice(0, s); var eo = n.partialBoundaries; for (s = 0; s < eo.length; s++) { var eu = eo[s]; e: { _ = n, N = a; var es = eu.completedSegments; for (z = 0; z < es.length; z++)if (!Qb(_, N, eu, es[z])) { z++, es.splice(0, z); var ec = !1; break e } es.splice(0, z), ec = !0 } if (!ec) { n.destination = null, s++, eo.splice(0, s); return } } eo.splice(0, s); var ef = n.completedBoundaries; for (s = 0; s < ef.length; s++)if (!Pb(n, a, ef[s])) { n.destination = null, s++, ef.splice(0, s); return } ef.splice(0, s) } finally { 0 === n.allPendingTasks && 0 === n.pingedTasks.length && 0 === n.clientRenderedBoundaries.length && 0 === n.completedBoundaries.length && a.push(null) } } function Sb() { } function Tb(n, a, o, i) { var s, _, N, z, j, B, $, ee, et, en, er, ea = !1, eo = null, eu = "", es = { push: function (n) { return null !== n && (eu += n), !0 }, destroy: function (n) { ea = !0, eo = n } }, ec = !1; if (_ = n, N = { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: (s = void 0 === (s = a ? a.identifierPrefix : void 0) ? "" : s) + "P:", segmentPrefix: s + "S:", boundaryPrefix: s + "B:", idPrefix: s, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: o }, z = { insertionMode: 1, selectedValue: null }, j = 1 / 0, B = void 0, $ = function () { ec = !0 }, ee = void 0, et = void 0, en = [], (z = U(N = { destination: null, responseState: N, progressiveChunkSize: void 0 === j ? 12800 : j, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: er = new Set, pingedTasks: en, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === Sb ? zb : Sb, onAllReady: void 0 === B ? T : B, onShellReady: void 0 === $ ? T : $, onShellError: void 0 === ee ? T : ee, onFatalError: void 0 === et ? T : et }, 0, null, z, !1, !1)).parentFlushed = !0, _ = Bb(N, _, null, z, er, eL, null, eI), en.push(_), Cb(n = N), !function (n, a) { try { var o = n.abortableTasks; o.forEach(function (o) { return function Lb(n, a, o) { var i = n.blockedBoundary; n.blockedSegment.status = 3, null === i ? (a.allPendingTasks--, 2 !== a.status && (a.status = 2, null !== a.destination && a.destination.push(null))) : (i.pendingTasks--, i.forceClientRender || (i.forceClientRender = !0, n = void 0 === o ? Error(l(432)) : o, i.errorDigest = a.onError(n), i.parentFlushed && a.clientRenderedBoundaries.push(i)), i.fallbackAbortableTasks.forEach(function (n) { return Lb(n, a, o) }), i.fallbackAbortableTasks.clear(), a.allPendingTasks--, 0 === a.allPendingTasks && (i = a.onAllReady)()) }(o, n, a) }), o.clear(), null !== n.destination && Mb(n, n.destination) } catch (a) { V(n, a), W(n, a) } }(n, i), 1 === n.status) n.status = 2, es.destroy(n.fatalError); else if (2 !== n.status && null === n.destination) { n.destination = es; try { Mb(n, es) } catch (a) { V(n, a), W(n, a) } } if (ea) throw eo; if (!ec) throw Error(l(426)); return eu } a.renderToNodeStream = function () { throw Error(l(207)) }, a.renderToStaticMarkup = function (n, a) { return Tb(n, a, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server') }, a.renderToStaticNodeStream = function () { throw Error(l(208)) }, a.renderToString = function (n, a) { return Tb(n, a, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server') }, a.version = "18.2.0"
  }, 4304: function (n, a, o) {/**
  * @license React
  * react-dom-server.browser.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */var i = o(50959); function k(n) { for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, o = 1; o < arguments.length; o++)a += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + n + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = null, _ = 0; function p(n, a) { if (0 !== a.length) { if (512 < a.length) 0 < _ && (n.enqueue(new Uint8Array(s.buffer, 0, _)), s = new Uint8Array(512), _ = 0), n.enqueue(a); else { var o = s.length - _; o < a.length && (0 === o ? n.enqueue(s) : (s.set(a.subarray(0, o), _), n.enqueue(s), a = a.subarray(o)), s = new Uint8Array(512), _ = 0), s.set(a, _), _ += a.length } } } function t(n, a) { return p(n, a), !0 } function ba(n) { s && 0 < _ && (n.enqueue(new Uint8Array(s.buffer, 0, _)), s = null, _ = 0) } var N = new TextEncoder; function u(n) { return N.encode(n) } function w(n) { return N.encode(n) } function da(n, a) { "function" == typeof n.error ? n.error(a) : n.close() } var z = Object.prototype.hasOwnProperty, j = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, B = {}, $ = {}; function ia(n) { return !!z.call($, n) || !z.call(B, n) && (j.test(n) ? $[n] = !0 : (B[n] = !0, !1)) } function y(n, a, o, i, s, _, N) { this.acceptsBooleans = 2 === a || 3 === a || 4 === a, this.attributeName = i, this.attributeNamespace = s, this.mustUseProperty = o, this.propertyName = n, this.type = a, this.sanitizeURL = _, this.removeEmptyString = N } var ee = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { ee[n] = new y(n, 0, !1, n, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var a = n[0]; ee[a] = new y(a, 1, !1, n[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { ee[n] = new y(n, 2, !1, n.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { ee[n] = new y(n, 2, !1, n, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { ee[n] = new y(n, 3, !1, n.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (n) { ee[n] = new y(n, 3, !0, n, null, !1, !1) }), ["capture", "download"].forEach(function (n) { ee[n] = new y(n, 4, !1, n, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (n) { ee[n] = new y(n, 6, !1, n, null, !1, !1) }), ["rowSpan", "start"].forEach(function (n) { ee[n] = new y(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var et = /[\-:]([a-z])/g; function ka(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var a = n.replace(et, ka); ee[a] = new y(a, 1, !1, n, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var a = n.replace(et, ka); ee[a] = new y(a, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var a = n.replace(et, ka); ee[a] = new y(a, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (n) { ee[n] = new y(n, 1, !1, n.toLowerCase(), null, !1, !1) }), ee.xlinkHref = new y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (n) { ee[n] = new y(n, 1, !1, n.toLowerCase(), null, !0, !0) }); var en = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, er = ["Webkit", "ms", "Moz", "O"]; Object.keys(en).forEach(function (n) { er.forEach(function (a) { en[a = a + n.charAt(0).toUpperCase() + n.substring(1)] = en[n] }) }); var ea = /["'&<>]/; function C(n) { if ("boolean" == typeof n || "number" == typeof n) return "" + n; n = "" + n; var a = ea.exec(n); if (a) { var o, i = "", s = 0; for (o = a.index; o < n.length; o++) { switch (n.charCodeAt(o)) { case 34: a = "&quot;"; break; case 38: a = "&amp;"; break; case 39: a = "&#x27;"; break; case 60: a = "&lt;"; break; case 62: a = "&gt;"; break; default: continue }s !== o && (i += n.substring(s, o)), s = o + 1, i += a } n = s !== o ? i + n.substring(s, o) : i } return n } var eo = /([A-Z])/g, eu = /^ms-/, es = Array.isArray, ec = w("<script>"), ef = w("</script>"), ep = w('<script src="'), eg = w('<script type="module" src="'), em = w('" async=""></script>'), ev = /(<\/|<)(s)(cript)/gi; function ya(n, a, o, i) { return "" + a + ("s" === o ? "\\u0073" : "\\u0053") + i } function D(n, a) { return { insertionMode: n, selectedValue: a } } var ey = w("<!-- -->"); function Da(n, a, o, i) { return "" === a ? i : (i && n.push(ey), n.push(u(C(a))), !0) } var ew = new Map, eS = w(' style="'), ex = w(":"), eE = w(";"); function Ia(n, a, o) { if ("object" != typeof o) throw Error(k(62)); for (var i in a = !0, o) if (z.call(o, i)) { var s = o[i]; if (null != s && "boolean" != typeof s && "" !== s) { if (0 === i.indexOf("--")) { var _ = u(C(i)); s = u(C(("" + s).trim())) } else { _ = i; var N = ew.get(_); void 0 !== N || (N = w(C(_.replace(eo, "-$1").toLowerCase().replace(eu, "-ms-"))), ew.set(_, N)), _ = N, s = "number" == typeof s ? 0 === s || z.call(en, i) ? u("" + s) : u(s + "px") : u(C(("" + s).trim())) } a ? (a = !1, n.push(eS, _, ex, s)) : n.push(eE, _, ex, s) } } a || n.push(eT) } var eC = w(" "), e_ = w('="'), eT = w('"'), eP = w('=""'); function J(n, a, o, i) { switch (o) { case "style": Ia(n, a, i); return; case "defaultValue": case "defaultChecked": case "innerHTML": case "suppressContentEditableWarning": case "suppressHydrationWarning": return }if (!(2 < o.length) || "o" !== o[0] && "O" !== o[0] || "n" !== o[1] && "N" !== o[1]) { if (null !== (a = ee.hasOwnProperty(o) ? ee[o] : null)) { switch (typeof i) { case "function": case "symbol": return; case "boolean": if (!a.acceptsBooleans) return }switch (o = u(a.attributeName), a.type) { case 3: i && n.push(eC, o, eP); break; case 4: !0 === i ? n.push(eC, o, eP) : !1 !== i && n.push(eC, o, e_, u(C(i)), eT); break; case 5: isNaN(i) || n.push(eC, o, e_, u(C(i)), eT); break; case 6: !isNaN(i) && 1 <= i && n.push(eC, o, e_, u(C(i)), eT); break; default: a.sanitizeURL && (i = "" + i), n.push(eC, o, e_, u(C(i)), eT) } } else if (ia(o)) { switch (typeof i) { case "function": case "symbol": return; case "boolean": if ("data-" !== (a = o.toLowerCase().slice(0, 5)) && "aria-" !== a) return }n.push(eC, u(o), e_, u(C(i)), eT) } } } var eF = w(">"), eR = w("/>"); function L(n, a, o) { if (null != a) { if (null != o) throw Error(k(60)); if ("object" != typeof a || !("__html" in a)) throw Error(k(61)); null != (a = a.__html) && n.push(u("" + a)) } } var eN = w(' selected=""'); function Na(n, a, o, i) { n.push(M(o)); var s, _ = o = null; for (s in a) if (z.call(a, s)) { var N = a[s]; if (null != N) switch (s) { case "children": o = N; break; case "dangerouslySetInnerHTML": _ = N; break; default: J(n, i, s, N) } } return n.push(eF), L(n, _, o), "string" == typeof o ? (n.push(u(C(o))), null) : o } var ez = w("\n"), eL = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, eM = new Map; function M(n) { var a = eM.get(n); if (void 0 === a) { if (!eL.test(n)) throw Error(k(65, n)); a = w("<" + n), eM.set(n, a) } return a } var eD = w("<!DOCTYPE html>"), eI = w("</"), eO = w(">"), eV = w('<template id="'), eB = w('"></template>'), eA = w("<!--$-->"), eU = w('<!--$?--><template id="'), e$ = w('"></template>'), eW = w("<!--$!-->"), eH = w("<!--/$-->"), eQ = w("<template"), eq = w('"'), eZ = w(' data-dgst="'); w(' data-msg="'), w(' data-stck="'); var eG = w("></template>"); function fb(n, a, o) { if (p(n, eU), null === o) throw Error(k(395)); return p(n, o), t(n, e$) } var eY = w('<div hidden id="'), eX = w('">'), eK = w("</div>"), eJ = w('<svg aria-hidden="true" style="display:none" id="'), e0 = w('">'), e1 = w("</svg>"), e2 = w('<math aria-hidden="true" style="display:none" id="'), e3 = w('">'), e4 = w("</math>"), e6 = w('<table hidden id="'), e8 = w('">'), e5 = w("</table>"), e9 = w('<table hidden><tbody id="'), e7 = w('">'), tt = w("</tbody></table>"), tn = w('<table hidden><tr id="'), tr = w('">'), tl = w("</tr></table>"), to = w('<table hidden><colgroup id="'), tu = w('">'), ts = w("</colgroup></table>"), td = w('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), tp = w('$RS("'), tm = w('","'), tv = w('")</script>'), ty = w('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), tk = w('$RC("'), tw = w('","'), tS = w('")</script>'), tx = w('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), tE = w('$RX("'), tC = w('"'), t_ = w(")</script>"), tT = w(","), tP = /[<\u2028\u2029]/g; function Sb(n) { return JSON.stringify(n).replace(tP, function (n) { switch (n) { case "<": return "\\u003c"; case "\u2028": return "\\u2028"; case "\u2029": return "\\u2029"; default: throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React") } }) } var tF = Object.assign, tR = Symbol.for("react.element"), tN = Symbol.for("react.portal"), tz = Symbol.for("react.fragment"), tL = Symbol.for("react.strict_mode"), tM = Symbol.for("react.profiler"), tD = Symbol.for("react.provider"), tI = Symbol.for("react.context"), tO = Symbol.for("react.forward_ref"), tV = Symbol.for("react.suspense"), tB = Symbol.for("react.suspense_list"), tA = Symbol.for("react.memo"), tU = Symbol.for("react.lazy"), t$ = Symbol.for("react.scope"), tW = Symbol.for("react.debug_trace_mode"), tH = Symbol.for("react.legacy_hidden"), tQ = Symbol.for("react.default_value"), tq = Symbol.iterator, tZ = {}; function lc(n, a) { if (!(n = n.contextTypes)) return tZ; var o, i = {}; for (o in n) i[o] = a[o]; return i } var tG = null; function P(n, a) { if (n !== a) { n.context._currentValue = n.parentValue, n = n.parent; var o = a.parent; if (null === n) { if (null !== o) throw Error(k(401)) } else { if (null === o) throw Error(k(401)); P(n, o) } a.context._currentValue = a.value } } function Q(n) { var a = tG; a !== n && (null === a ? function nc(n) { var a = n.parent; null !== a && nc(a), n.context._currentValue = n.value }(n) : null === n ? function mc(n) { n.context._currentValue = n.parentValue, null !== (n = n.parent) && mc(n) }(a) : a.depth === n.depth ? P(a, n) : a.depth > n.depth ? function oc(n, a) { if (n.context._currentValue = n.parentValue, null === (n = n.parent)) throw Error(k(402)); n.depth === a.depth ? P(n, a) : oc(n, a) }(a, n) : function pc(n, a) { var o = a.parent; if (null === o) throw Error(k(402)); n.depth === o.depth ? P(n, o) : pc(n, o), a.context._currentValue = a.value }(a, n), tG = n) } var tY = { isMounted: function () { return !1 }, enqueueSetState: function (n, a) { null !== (n = n._reactInternals).queue && n.queue.push(a) }, enqueueReplaceState: function (n, a) { (n = n._reactInternals).replace = !0, n.queue = [a] }, enqueueForceUpdate: function () { } }; function rc(n, a, o, i) { var s = void 0 !== n.state ? n.state : null; n.updater = tY, n.props = o, n.state = s; var _ = { queue: [], replace: !1 }; n._reactInternals = _; var N = a.contextType; if (n.context = "object" == typeof N && null !== N ? N._currentValue : i, "function" == typeof (N = a.getDerivedStateFromProps) && (s = null == (N = N(o, s)) ? s : tF({}, s, N), n.state = s), "function" != typeof a.getDerivedStateFromProps && "function" != typeof n.getSnapshotBeforeUpdate && ("function" == typeof n.UNSAFE_componentWillMount || "function" == typeof n.componentWillMount)) { if (a = n.state, "function" == typeof n.componentWillMount && n.componentWillMount(), "function" == typeof n.UNSAFE_componentWillMount && n.UNSAFE_componentWillMount(), a !== n.state && tY.enqueueReplaceState(n, n.state, null), null !== _.queue && 0 < _.queue.length) { if (a = _.queue, N = _.replace, _.queue = null, _.replace = !1, N && 1 === a.length) n.state = a[0]; else { for (_ = N ? a[0] : n.state, s = !0, N = N ? 1 : 0; N < a.length; N++) { var z = a[N]; null != (z = "function" == typeof z ? z.call(n, _, o, i) : z) && (s ? (s = !1, _ = tF({}, _, z)) : tF(_, z)) } n.state = _ } } else _.queue = null } } var tX = { id: 1, overflow: "" }; function tc(n, a, o) { var i = n.id; n = n.overflow; var s = 32 - tK(i) - 1; i &= ~(1 << s), o += 1; var _ = 32 - tK(a) + s; if (30 < _) { var N = s - s % 5; return _ = (i & (1 << N) - 1).toString(32), i >>= N, s -= N, { id: 1 << 32 - tK(a) + s | o << s | i, overflow: _ + n } } return { id: 1 << _ | o << s | i, overflow: n } } var tK = Math.clz32 ? Math.clz32 : function (n) { return 0 == (n >>>= 0) ? 32 : 31 - (tJ(n) / t0 | 0) | 0 }, tJ = Math.log, t0 = Math.LN2, t1 = "function" == typeof Object.is ? Object.is : function (n, a) { return n === a && (0 !== n || 1 / n == 1 / a) || n != n && a != a }, t2 = null, t3 = null, t4 = null, t6 = null, t8 = !1, t5 = !1, t9 = 0, t7 = null, nt = 0; function W() { if (null === t2) throw Error(k(321)); return t2 } function Ec() { if (0 < nt) throw Error(k(312)); return { memoizedState: null, queue: null, next: null } } function Fc() { return null === t6 ? null === t4 ? (t8 = !1, t4 = t6 = Ec()) : (t8 = !0, t6 = t4) : null === t6.next ? (t8 = !1, t6 = t6.next = Ec()) : (t8 = !0, t6 = t6.next), t6 } function Gc() { t3 = t2 = null, t5 = !1, t4 = null, nt = 0, t6 = t7 = null } function Hc(n, a) { return "function" == typeof a ? a(n) : a } function Ic(n, a, o) { if (t2 = W(), t6 = Fc(), t8) { var i = t6.queue; if (a = i.dispatch, null !== t7 && void 0 !== (o = t7.get(i))) { t7.delete(i), i = t6.memoizedState; do i = n(i, o.action), o = o.next; while (null !== o); return t6.memoizedState = i, [i, a] } return [t6.memoizedState, a] } return n = n === Hc ? "function" == typeof a ? a() : a : void 0 !== o ? o(a) : a, t6.memoizedState = n, n = (n = t6.queue = { last: null, dispatch: null }).dispatch = Jc.bind(null, t2, n), [t6.memoizedState, n] } function Kc(n, a) { if (t2 = W(), t6 = Fc(), a = void 0 === a ? null : a, null !== t6) { var o = t6.memoizedState; if (null !== o && null !== a) { var i = o[1]; e: if (null === i) i = !1; else { for (var s = 0; s < i.length && s < a.length; s++)if (!t1(a[s], i[s])) { i = !1; break e } i = !0 } if (i) return o[0] } } return n = n(), t6.memoizedState = [n, a], n } function Jc(n, a, o) { if (25 <= nt) throw Error(k(301)); if (n === t2) { if (t5 = !0, n = { action: o, next: null }, null === t7 && (t7 = new Map), void 0 === (o = t7.get(a))) t7.set(a, n); else { for (a = o; null !== a.next;)a = a.next; a.next = n } } } function Lc() { throw Error(k(394)) } function Mc() { } var nn = { readContext: function (n) { return n._currentValue }, useContext: function (n) { return W(), n._currentValue }, useMemo: Kc, useReducer: Ic, useRef: function (n) { t2 = W(); var a = (t6 = Fc()).memoizedState; return null === a ? (n = { current: n }, t6.memoizedState = n) : a }, useState: function (n) { return Ic(Hc, n) }, useInsertionEffect: Mc, useLayoutEffect: function () { }, useCallback: function (n, a) { return Kc(function () { return n }, a) }, useImperativeHandle: Mc, useEffect: Mc, useDebugValue: Mc, useDeferredValue: function (n) { return W(), n }, useTransition: function () { return W(), [!1, Lc] }, useId: function () { var n = t3.treeContext, a = n.overflow; n = ((n = n.id) & ~(1 << 32 - tK(n) - 1)).toString(32) + a; var o = nr; if (null === o) throw Error(k(404)); return a = t9++, n = ":" + o.idPrefix + "R" + n, 0 < a && (n += "H" + a.toString(32)), n + ":" }, useMutableSource: function (n, a) { return W(), a(n._source) }, useSyncExternalStore: function (n, a, o) { if (void 0 === o) throw Error(k(407)); return o() } }, nr = null, na = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher; function Qc(n) { return console.error(n), null } function X() { } function Tc(n, a, o, i, s, _, N, z) { n.allPendingTasks++, null === o ? n.pendingRootTasks++ : o.pendingTasks++; var j = { node: a, ping: function () { var a = n.pingedTasks; a.push(j), 1 === a.length && Uc(n) }, blockedBoundary: o, blockedSegment: i, abortSet: s, legacyContext: _, context: N, treeContext: z }; return s.add(j), j } function Sc(n, a, o, i, s, _) { return { status: 0, id: -1, index: a, parentFlushed: !1, chunks: [], children: [], formatContext: i, boundary: o, lastPushedText: s, textEmbedded: _ } } function Y(n, a) { if (null != (n = n.onError(a)) && "string" != typeof n) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof n + '" instead'); return n } function Vc(n, a) { var o = n.onShellError; o(a), (o = n.onFatalError)(a), null !== n.destination ? (n.status = 2, da(n.destination, a)) : (n.status = 1, n.fatalError = a) } function Wc(n, a, o, i, s) { for (t2 = {}, t3 = a, t9 = 0, n = o(i, s); t5;)t5 = !1, t9 = 0, nt += 1, t6 = null, n = o(i, s); return Gc(), n } function Xc(n, a, o, i) { var s = o.render(), _ = i.childContextTypes; if (null != _) { var N = a.legacyContext; if ("function" != typeof o.getChildContext) i = N; else { for (var z in o = o.getChildContext()) if (!(z in _)) throw Error(k(108, function jc(n) { if (null == n) return null; if ("function" == typeof n) return n.displayName || n.name || null; if ("string" == typeof n) return n; switch (n) { case tz: return "Fragment"; case tN: return "Portal"; case tM: return "Profiler"; case tL: return "StrictMode"; case tV: return "Suspense"; case tB: return "SuspenseList" }if ("object" == typeof n) switch (n.$$typeof) { case tI: return (n.displayName || "Context") + ".Consumer"; case tD: return (n._context.displayName || "Context") + ".Provider"; case tO: var a = n.render; return (n = n.displayName) || (n = "" !== (n = a.displayName || a.name || "") ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case tA: return null !== (a = n.displayName || null) ? a : jc(n.type) || "Memo"; case tU: a = n._payload, n = n._init; try { return jc(n(a)) } catch (n) { } }return null }(i) || "Unknown", z)); i = tF({}, N, o) } a.legacyContext = i, Z(n, a, s), a.legacyContext = N } else Z(n, a, s) } function Yc(n, a) { if (n && n.defaultProps) for (var o in a = tF({}, a), n = n.defaultProps) void 0 === a[o] && (a[o] = n[o]); return a } function Z(n, a, o) { if (a.node = o, "object" == typeof o && null !== o) { switch (o.$$typeof) { case tR: !function Zc(n, a, o, s, _) { if ("function" == typeof o) { if (o.prototype && o.prototype.isReactComponent) { _ = lc(o, a.legacyContext); var N = o.contextType; rc(N = new o(s, "object" == typeof N && null !== N ? N._currentValue : _), o, s, _), Xc(n, a, N, o) } else { N = lc(o, a.legacyContext), _ = Wc(n, a, o, s, N); var j = 0 !== t9; if ("object" == typeof _ && null !== _ && "function" == typeof _.render && void 0 === _.$$typeof) rc(_, o, s, N), Xc(n, a, _, o); else if (j) { s = a.treeContext, a.treeContext = tc(s, 1, 0); try { Z(n, a, _) } finally { a.treeContext = s } } else Z(n, a, _) } } else if ("string" == typeof o) { switch (N = function (n, a, o, s, _) { switch (a) { case "select": n.push(M("select")); var N = null, j = null; for (er in o) if (z.call(o, er)) { var B = o[er]; if (null != B) switch (er) { case "children": N = B; break; case "dangerouslySetInnerHTML": j = B; break; case "defaultValue": case "value": break; default: J(n, s, er, B) } } return n.push(eF), L(n, j, N), N; case "option": j = _.selectedValue, n.push(M("option")); var $, ee, et = B = null, en = null, er = null; for (N in o) if (z.call(o, N)) { var ea = o[N]; if (null != ea) switch (N) { case "children": B = ea; break; case "selected": en = ea; break; case "dangerouslySetInnerHTML": er = ea; break; case "value": et = ea; default: J(n, s, N, ea) } } if (null != j) { if (o = null !== et ? "" + et : ($ = B, ee = "", i.Children.forEach($, function (n) { null != n && (ee += n) }), ee), es(j)) { for (s = 0; s < j.length; s++)if ("" + j[s] === o) { n.push(eN); break } } else "" + j === o && n.push(eN) } else en && n.push(eN); return n.push(eF), L(n, er, B), B; case "textarea": for (B in n.push(M("textarea")), er = j = N = null, o) if (z.call(o, B) && null != (et = o[B])) switch (B) { case "children": er = et; break; case "value": N = et; break; case "defaultValue": j = et; break; case "dangerouslySetInnerHTML": throw Error(k(91)); default: J(n, s, B, et) }if (null === N && null !== j && (N = j), n.push(eF), null != er) { if (null != N) throw Error(k(92)); if (es(er) && 1 < er.length) throw Error(k(93)); N = "" + er } return "string" == typeof N && "\n" === N[0] && n.push(ez), null !== N && n.push(u(C("" + N))), null; case "input": for (j in n.push(M("input")), et = er = B = N = null, o) if (z.call(o, j) && null != (en = o[j])) switch (j) { case "children": case "dangerouslySetInnerHTML": throw Error(k(399, "input")); case "defaultChecked": et = en; break; case "defaultValue": B = en; break; case "checked": er = en; break; case "value": N = en; break; default: J(n, s, j, en) }return null !== er ? J(n, s, "checked", er) : null !== et && J(n, s, "checked", et), null !== N ? J(n, s, "value", N) : null !== B && J(n, s, "value", B), n.push(eR), null; case "menuitem": for (var eo in n.push(M("menuitem")), o) if (z.call(o, eo) && null != (N = o[eo])) switch (eo) { case "children": case "dangerouslySetInnerHTML": throw Error(k(400)); default: J(n, s, eo, N) }return n.push(eF), null; case "title": for (ea in n.push(M("title")), N = null, o) if (z.call(o, ea) && null != (j = o[ea])) switch (ea) { case "children": N = j; break; case "dangerouslySetInnerHTML": throw Error(k(434)); default: J(n, s, ea, j) }return n.push(eF), N; case "listing": case "pre": for (et in n.push(M(a)), j = N = null, o) if (z.call(o, et) && null != (B = o[et])) switch (et) { case "children": N = B; break; case "dangerouslySetInnerHTML": j = B; break; default: J(n, s, et, B) }if (n.push(eF), null != j) { if (null != N) throw Error(k(60)); if ("object" != typeof j || !("__html" in j)) throw Error(k(61)); null != (o = j.__html) && ("string" == typeof o && 0 < o.length && "\n" === o[0] ? n.push(ez, u(o)) : n.push(u("" + o))) } return "string" == typeof N && "\n" === N[0] && n.push(ez), N; case "area": case "base": case "br": case "col": case "embed": case "hr": case "img": case "keygen": case "link": case "meta": case "param": case "source": case "track": case "wbr": for (var eu in n.push(M(a)), o) if (z.call(o, eu) && null != (N = o[eu])) switch (eu) { case "children": case "dangerouslySetInnerHTML": throw Error(k(399, a)); default: J(n, s, eu, N) }return n.push(eR), null; case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return Na(n, o, a, s); case "html": return 0 === _.insertionMode && n.push(eD), Na(n, o, a, s); default: if (-1 === a.indexOf("-") && "string" != typeof o.is) return Na(n, o, a, s); for (en in n.push(M(a)), j = N = null, o) if (z.call(o, en) && null != (B = o[en])) switch (en) { case "children": N = B; break; case "dangerouslySetInnerHTML": j = B; break; case "style": Ia(n, s, B); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": break; default: ia(en) && "function" != typeof B && "symbol" != typeof B && n.push(eC, u(en), e_, u(C(B)), eT) }return n.push(eF), L(n, j, N), N } }((_ = a.blockedSegment).chunks, o, s, n.responseState, _.formatContext), _.lastPushedText = !1, j = _.formatContext, _.formatContext = function (n, a, o) { switch (a) { case "select": return D(1, null != o.value ? o.value : o.defaultValue); case "svg": return D(2, null); case "math": return D(3, null); case "foreignObject": return D(1, null); case "table": return D(4, null); case "thead": case "tbody": case "tfoot": return D(5, null); case "colgroup": return D(7, null); case "tr": return D(6, null) }return 4 <= n.insertionMode || 0 === n.insertionMode ? D(1, null) : n }(j, o, s), $c(n, a, N), _.formatContext = j, o) { case "area": case "base": case "br": case "col": case "embed": case "hr": case "img": case "input": case "keygen": case "link": case "meta": case "param": case "source": case "track": case "wbr": break; default: _.chunks.push(eI, u(o), eO) }_.lastPushedText = !1 } else { switch (o) { case tH: case tW: case tL: case tM: case tz: case tB: Z(n, a, s.children); return; case t$: throw Error(k(343)); case tV: e: { o = a.blockedBoundary, _ = a.blockedSegment, N = s.fallback, s = s.children; var B = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: j = new Set, errorDigest: null }, $ = Sc(n, _.chunks.length, B, _.formatContext, !1, !1); _.children.push($), _.lastPushedText = !1; var ee = Sc(n, 0, null, _.formatContext, !1, !1); ee.parentFlushed = !0, a.blockedBoundary = B, a.blockedSegment = ee; try { if ($c(n, a, s), ee.lastPushedText && ee.textEmbedded && ee.chunks.push(ey), ee.status = 1, ad(B, ee), 0 === B.pendingTasks) break e } catch (a) { ee.status = 4, B.forceClientRender = !0, B.errorDigest = Y(n, a) } finally { a.blockedBoundary = o, a.blockedSegment = _ } a = Tc(n, N, o, $, j, a.legacyContext, a.context, a.treeContext), n.pingedTasks.push(a) } return }if ("object" == typeof o && null !== o) switch (o.$$typeof) { case tO: if (s = Wc(n, a, o.render, s, _), 0 !== t9) { o = a.treeContext, a.treeContext = tc(o, 1, 0); try { Z(n, a, s) } finally { a.treeContext = o } } else Z(n, a, s); return; case tA: s = Yc(o = o.type, s), Zc(n, a, o, s, _); return; case tD: if (_ = s.children, o = o._context, s = s.value, N = o._currentValue, o._currentValue = s, tG = s = { parent: j = tG, depth: null === j ? 0 : j.depth + 1, context: o, parentValue: N, value: s }, a.context = s, Z(n, a, _), null === (n = tG)) throw Error(k(403)); s = n.parentValue, n.context._currentValue = s === tQ ? n.context._defaultValue : s, n = tG = n.parent, a.context = n; return; case tI: Z(n, a, s = (s = s.children)(o._currentValue)); return; case tU: s = Yc(o = (_ = o._init)(o._payload), s), Zc(n, a, o, s, void 0); return }throw Error(k(130, null == o ? o : typeof o, "")) } }(n, a, o.type, o.props, o.ref); return; case tN: throw Error(k(257)); case tU: var s = o._init; Z(n, a, o = s(o._payload)); return }if (es(o)) { bd(n, a, o); return } if ((s = null === o || "object" != typeof o ? null : "function" == typeof (s = tq && o[tq] || o["@@iterator"]) ? s : null) && (s = s.call(o))) { if (!(o = s.next()).done) { var _ = []; do _.push(o.value), o = s.next(); while (!o.done); bd(n, a, _) } return } throw Error(k(31, "[object Object]" === (n = Object.prototype.toString.call(o)) ? "object with keys {" + Object.keys(o).join(", ") + "}" : n)) } "string" == typeof o ? (s = a.blockedSegment).lastPushedText = Da(a.blockedSegment.chunks, o, n.responseState, s.lastPushedText) : "number" == typeof o && ((s = a.blockedSegment).lastPushedText = Da(a.blockedSegment.chunks, "" + o, n.responseState, s.lastPushedText)) } function bd(n, a, o) { for (var i = o.length, s = 0; s < i; s++) { var _ = a.treeContext; a.treeContext = tc(_, i, s); try { $c(n, a, o[s]) } finally { a.treeContext = _ } } } function $c(n, a, o) { var i = a.blockedSegment.formatContext, s = a.legacyContext, _ = a.context; try { return Z(n, a, o) } catch (j) { if (Gc(), "object" == typeof j && null !== j && "function" == typeof j.then) { o = j; var N = a.blockedSegment, z = Sc(n, N.chunks.length, null, N.formatContext, N.lastPushedText, !0); N.children.push(z), N.lastPushedText = !1, n = Tc(n, a.node, a.blockedBoundary, z, a.abortSet, a.legacyContext, a.context, a.treeContext).ping, o.then(n, n), a.blockedSegment.formatContext = i, a.legacyContext = s, a.context = _, Q(_) } else throw a.blockedSegment.formatContext = i, a.legacyContext = s, a.context = _, Q(_), j } } function cd(n) { var a = n.blockedBoundary; (n = n.blockedSegment).status = 3, dd(this, a, n) } function ad(n, a) { if (0 === a.chunks.length && 1 === a.children.length && null === a.children[0].boundary) { var o = a.children[0]; o.id = a.id, o.parentFlushed = !0, 1 === o.status && ad(n, o) } else n.completedSegments.push(a) } function dd(n, a, o) { if (null === a) { if (o.parentFlushed) { if (null !== n.completedRootSegment) throw Error(k(389)); n.completedRootSegment = o } n.pendingRootTasks--, 0 === n.pendingRootTasks && (n.onShellError = X, (a = n.onShellReady)()) } else a.pendingTasks--, a.forceClientRender || (0 === a.pendingTasks ? (o.parentFlushed && 1 === o.status && ad(a, o), a.parentFlushed && n.completedBoundaries.push(a), a.fallbackAbortableTasks.forEach(cd, n), a.fallbackAbortableTasks.clear()) : o.parentFlushed && 1 === o.status && (ad(a, o), 1 === a.completedSegments.length && a.parentFlushed && n.partialBoundaries.push(a))); n.allPendingTasks--, 0 === n.allPendingTasks && (n = n.onAllReady)() } function Uc(n) { if (2 !== n.status) { var a = tG, o = na.current; na.current = nn; var i = nr; nr = n.responseState; try { var s, _ = n.pingedTasks; for (s = 0; s < _.length; s++) { var N = _[s], z = N.blockedSegment; if (0 === z.status) { Q(N.context); try { Z(n, N, N.node), z.lastPushedText && z.textEmbedded && z.chunks.push(ey), N.abortSet.delete(N), z.status = 1, dd(n, N.blockedBoundary, z) } catch (a) { if (Gc(), "object" == typeof a && null !== a && "function" == typeof a.then) { var j = N.ping; a.then(j, j) } else { N.abortSet.delete(N), z.status = 4; var B = N.blockedBoundary, $ = Y(n, a); null === B ? Vc(n, a) : (B.pendingTasks--, B.forceClientRender || (B.forceClientRender = !0, B.errorDigest = $, B.parentFlushed && n.clientRenderedBoundaries.push(B))), n.allPendingTasks--, 0 === n.allPendingTasks && (0, n.onAllReady)() } } finally { } } } _.splice(0, s), null !== n.destination && fd(n, n.destination) } catch (a) { Y(n, a), Vc(n, a) } finally { nr = i, na.current = o, o === nn && Q(a) } } } function gd(n, a, o) { switch (o.parentFlushed = !0, o.status) { case 0: var i = o.id = n.nextSegmentId++; return o.lastPushedText = !1, o.textEmbedded = !1, n = n.responseState, p(a, eV), p(a, n.placeholderPrefix), p(a, n = u(i.toString(16))), t(a, eB); case 1: o.status = 2; var s = !0; i = o.chunks; var _ = 0; o = o.children; for (var N = 0; N < o.length; N++) { for (s = o[N]; _ < s.index; _++)p(a, i[_]); s = hd(n, a, s) } for (; _ < i.length - 1; _++)p(a, i[_]); return _ < i.length && (s = t(a, i[_])), s; default: throw Error(k(390)) } } function hd(n, a, o) { var i = o.boundary; if (null === i) return gd(n, a, o); if (i.parentFlushed = !0, i.forceClientRender) i = i.errorDigest, t(a, eW), p(a, eQ), i && (p(a, eZ), p(a, u(C(i))), p(a, eq)), t(a, eG), gd(n, a, o); else if (0 < i.pendingTasks) { i.rootSegmentID = n.nextSegmentId++, 0 < i.completedSegments.length && n.partialBoundaries.push(i); var s = n.responseState, _ = s.nextSuspenseID++; s = w(s.boundaryPrefix + _.toString(16)), i = i.id = s, fb(a, n.responseState, i), gd(n, a, o) } else if (i.byteSize > n.progressiveChunkSize) i.rootSegmentID = n.nextSegmentId++, n.completedBoundaries.push(i), fb(a, n.responseState, i.id), gd(n, a, o); else { if (t(a, eA), 1 !== (o = i.completedSegments).length) throw Error(k(391)); hd(n, a, o[0]) } return t(a, eH) } function id(n, a, o) { return !function (n, a, o, i) { switch (o.insertionMode) { case 0: case 1: return p(n, eY), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, eX); case 2: return p(n, eJ), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, e0); case 3: return p(n, e2), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, e3); case 4: return p(n, e6), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, e8); case 5: return p(n, e9), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, e7); case 6: return p(n, tn), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, tr); case 7: return p(n, to), p(n, a.segmentPrefix), p(n, u(i.toString(16))), t(n, tu); default: throw Error(k(397)) } }(a, n.responseState, o.formatContext, o.id), hd(n, a, o), function (n, a) { switch (a.insertionMode) { case 0: case 1: return t(n, eK); case 2: return t(n, e1); case 3: return t(n, e4); case 4: return t(n, e5); case 5: return t(n, tt); case 6: return t(n, tl); case 7: return t(n, ts); default: throw Error(k(397)) } }(a, o.formatContext) } function jd(n, a, o) { for (var i = o.completedSegments, s = 0; s < i.length; s++)kd(n, a, o, i[s]); if (i.length = 0, n = n.responseState, i = o.id, o = o.rootSegmentID, p(a, n.startInlineScript), n.sentCompleteBoundaryFunction ? p(a, tk) : (n.sentCompleteBoundaryFunction = !0, p(a, ty)), null === i) throw Error(k(395)); return o = u(o.toString(16)), p(a, i), p(a, tw), p(a, n.segmentPrefix), p(a, o), t(a, tS) } function kd(n, a, o, i) { if (2 === i.status) return !0; var s = i.id; if (-1 === s) { if (-1 === (i.id = o.rootSegmentID)) throw Error(k(392)); return id(n, a, i) } return id(n, a, i), p(a, (n = n.responseState).startInlineScript), n.sentCompleteSegmentFunction ? p(a, tp) : (n.sentCompleteSegmentFunction = !0, p(a, td)), p(a, n.segmentPrefix), p(a, s = u(s.toString(16))), p(a, tm), p(a, n.placeholderPrefix), p(a, s), t(a, tv) } function fd(n, a) { s = new Uint8Array(512), _ = 0; try { var o = n.completedRootSegment; if (null !== o && 0 === n.pendingRootTasks) { hd(n, a, o), n.completedRootSegment = null; var i = n.responseState.bootstrapChunks; for (o = 0; o < i.length - 1; o++)p(a, i[o]); o < i.length && t(a, i[o]) } var N, z = n.clientRenderedBoundaries; for (N = 0; N < z.length; N++) { var j = z[N]; i = a; var B = n.responseState, $ = j.id, ee = j.errorDigest, et = j.errorMessage, en = j.errorComponentStack; if (p(i, B.startInlineScript), B.sentClientRenderFunction ? p(i, tE) : (B.sentClientRenderFunction = !0, p(i, tx)), null === $) throw Error(k(395)); if (p(i, $), p(i, tC), (ee || et || en) && (p(i, tT), p(i, u(Sb(ee || "")))), (et || en) && (p(i, tT), p(i, u(Sb(et || "")))), en && (p(i, tT), p(i, u(Sb(en)))), !t(i, t_)) { n.destination = null, N++, z.splice(0, N); return } } z.splice(0, N); var er = n.completedBoundaries; for (N = 0; N < er.length; N++)if (!jd(n, a, er[N])) { n.destination = null, N++, er.splice(0, N); return } er.splice(0, N), ba(a), s = new Uint8Array(512), _ = 0; var ea = n.partialBoundaries; for (N = 0; N < ea.length; N++) { var eo = ea[N]; e: { z = n, j = a; var eu = eo.completedSegments; for (B = 0; B < eu.length; B++)if (!kd(z, j, eo, eu[B])) { B++, eu.splice(0, B); var es = !1; break e } eu.splice(0, B), es = !0 } if (!es) { n.destination = null, N++, ea.splice(0, N); return } } ea.splice(0, N); var ec = n.completedBoundaries; for (N = 0; N < ec.length; N++)if (!jd(n, a, ec[N])) { n.destination = null, N++, ec.splice(0, N); return } ec.splice(0, N) } finally { ba(a), 0 === n.allPendingTasks && 0 === n.pingedTasks.length && 0 === n.clientRenderedBoundaries.length && 0 === n.completedBoundaries.length && a.close() } } function ld(n, a) { try { var o = n.abortableTasks; o.forEach(function (o) { return function ed(n, a, o) { var i = n.blockedBoundary; n.blockedSegment.status = 3, null === i ? (a.allPendingTasks--, 2 !== a.status && (a.status = 2, null !== a.destination && a.destination.close())) : (i.pendingTasks--, i.forceClientRender || (i.forceClientRender = !0, n = void 0 === o ? Error(k(432)) : o, i.errorDigest = a.onError(n), i.parentFlushed && a.clientRenderedBoundaries.push(i)), i.fallbackAbortableTasks.forEach(function (n) { return ed(n, a, o) }), i.fallbackAbortableTasks.clear(), a.allPendingTasks--, 0 === a.allPendingTasks && (i = a.onAllReady)()) }(o, n, a) }), o.clear(), null !== n.destination && fd(n, n.destination) } catch (a) { Y(n, a), Vc(n, a) } } a.renderToReadableStream = function (n, a) { return new Promise(function (o, i) { var s, _, N, z, j, B, $, ee, et, en, er, ea, eo, eu, es = new Promise(function (n, a) { eu = n, eo = a }), ey = (_ = n, N = function (n, a, o, i, s) { n = void 0 === n ? "" : n, a = void 0 === a ? ec : w('<script nonce="' + C(a) + '">'); var _ = []; if (void 0 !== o && _.push(a, u(("" + o).replace(ev, ya)), ef), void 0 !== i) for (o = 0; o < i.length; o++)_.push(ep, u(C(i[o])), em); if (void 0 !== s) for (i = 0; i < s.length; i++)_.push(eg, u(C(s[i])), em); return { bootstrapChunks: _, startInlineScript: a, placeholderPrefix: w(n + "P:"), segmentPrefix: w(n + "S:"), boundaryPrefix: n + "B:", idPrefix: n, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 } }(a ? a.identifierPrefix : void 0, a ? a.nonce : void 0, a ? a.bootstrapScriptContent : void 0, a ? a.bootstrapScripts : void 0, a ? a.bootstrapModules : void 0), z = D("http://www.w3.org/2000/svg" === (s = a ? a.namespaceURI : void 0) ? 2 : "http://www.w3.org/1998/Math/MathML" === s ? 3 : 0, null), j = a ? a.progressiveChunkSize : void 0, B = a ? a.onError : void 0, $ = eu, ee = function () { var n = new ReadableStream({ type: "bytes", pull: function (n) { if (1 === ey.status) ey.status = 2, da(n, ey.fatalError); else if (2 !== ey.status && null === ey.destination) { ey.destination = n; try { fd(ey, n) } catch (n) { Y(ey, n), Vc(ey, n) } } }, cancel: function () { ld(ey) } }, { highWaterMark: 0 }); n.allReady = es, o(n) }, et = function (n) { es.catch(function () { }), i(n) }, en = eo, er = [], (z = Sc(N = { destination: null, responseState: N, progressiveChunkSize: void 0 === j ? 12800 : j, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: ea = new Set, pingedTasks: er, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === B ? Qc : B, onAllReady: void 0 === $ ? X : $, onShellReady: void 0 === ee ? X : ee, onShellError: void 0 === et ? X : et, onFatalError: void 0 === en ? X : en }, 0, null, z, !1, !1)).parentFlushed = !0, _ = Tc(N, _, null, z, ea, tZ, null, tX), er.push(_), N); if (a && a.signal) { var ew = a.signal, q = function () { ld(ey, ew.reason), ew.removeEventListener("abort", q) }; ew.addEventListener("abort", q) } Uc(ey) }) }, a.version = "18.2.0"
  }, 53746: function (n, a, o) {/**
  * @license React
  * react-dom.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */var i, s, _, N, z, j, B = o(50959), $ = o(22962); function p(n) { for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, o = 1; o < arguments.length; o++)a += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + n + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var ee = new Set, et = {}; function fa(n, a) { ha(n, a), ha(n + "Capture", a) } function ha(n, a) { for (et[n] = a, n = 0; n < a.length; n++)ee.add(a[n]) } var en = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement), er = Object.prototype.hasOwnProperty, ea = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, eo = {}, eu = {}; function v(n, a, o, i, s, _, N) { this.acceptsBooleans = 2 === a || 3 === a || 4 === a, this.attributeName = i, this.attributeNamespace = s, this.mustUseProperty = o, this.propertyName = n, this.type = a, this.sanitizeURL = _, this.removeEmptyString = N } var es = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { es[n] = new v(n, 0, !1, n, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var a = n[0]; es[a] = new v(a, 1, !1, n[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { es[n] = new v(n, 2, !1, n.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { es[n] = new v(n, 2, !1, n, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { es[n] = new v(n, 3, !1, n.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (n) { es[n] = new v(n, 3, !0, n, null, !1, !1) }), ["capture", "download"].forEach(function (n) { es[n] = new v(n, 4, !1, n, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (n) { es[n] = new v(n, 6, !1, n, null, !1, !1) }), ["rowSpan", "start"].forEach(function (n) { es[n] = new v(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var ec = /[\-:]([a-z])/g; function sa(n) { return n[1].toUpperCase() } function ta(n, a, o, i) { var s, _ = es.hasOwnProperty(a) ? es[a] : null; (null !== _ ? 0 !== _.type : i || !(2 < a.length) || "o" !== a[0] && "O" !== a[0] || "n" !== a[1] && "N" !== a[1]) && (function (n, a, o, i) { if (null == a || function (n, a, o, i) { if (null !== o && 0 === o.type) return !1; switch (typeof a) { case "function": case "symbol": return !0; case "boolean": if (i) return !1; if (null !== o) return !o.acceptsBooleans; return "data-" !== (n = n.toLowerCase().slice(0, 5)) && "aria-" !== n; default: return !1 } }(n, a, o, i)) return !0; if (i) return !1; if (null !== o) switch (o.type) { case 3: return !a; case 4: return !1 === a; case 5: return isNaN(a); case 6: return isNaN(a) || 1 > a }return !1 }(a, o, _, i) && (o = null), i || null === _ ? (s = a, (!!er.call(eu, s) || !er.call(eo, s) && (ea.test(s) ? eu[s] = !0 : (eo[s] = !0, !1))) && (null === o ? n.removeAttribute(a) : n.setAttribute(a, "" + o))) : _.mustUseProperty ? n[_.propertyName] = null === o ? 3 !== _.type && "" : o : (a = _.attributeName, i = _.attributeNamespace, null === o ? n.removeAttribute(a) : (o = 3 === (_ = _.type) || 4 === _ && !0 === o ? "" : "" + o, i ? n.setAttributeNS(i, a, o) : n.setAttribute(a, o)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var a = n.replace(ec, sa); es[a] = new v(a, 1, !1, n, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var a = n.replace(ec, sa); es[a] = new v(a, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var a = n.replace(ec, sa); es[a] = new v(a, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (n) { es[n] = new v(n, 1, !1, n.toLowerCase(), null, !1, !1) }), es.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (n) { es[n] = new v(n, 1, !1, n.toLowerCase(), null, !0, !0) }); var ef = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ep = Symbol.for("react.element"), eg = Symbol.for("react.portal"), em = Symbol.for("react.fragment"), ev = Symbol.for("react.strict_mode"), ey = Symbol.for("react.profiler"), ew = Symbol.for("react.provider"), eS = Symbol.for("react.context"), ex = Symbol.for("react.forward_ref"), eE = Symbol.for("react.suspense"), eC = Symbol.for("react.suspense_list"), e_ = Symbol.for("react.memo"), eT = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var eP = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var eF = Symbol.iterator; function Ka(n) { return null === n || "object" != typeof n ? null : "function" == typeof (n = eF && n[eF] || n["@@iterator"]) ? n : null } var eR, eN = Object.assign; function Ma(n) { if (void 0 === eR) try { throw Error() } catch (n) { var a = n.stack.trim().match(/\n( *(at )?)/); eR = a && a[1] || "" } return "\n" + eR + n } var ez = !1; function Oa(n, a) { if (!n || ez) return ""; ez = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (a) { if (a = function () { throw Error() }, Object.defineProperty(a.prototype, "props", { set: function () { throw Error() } }), "object" == typeof Reflect && Reflect.construct) { try { Reflect.construct(a, []) } catch (n) { var i = n } Reflect.construct(n, [], a) } else { try { a.call() } catch (n) { i = n } n.call(a.prototype) } } else { try { throw Error() } catch (n) { i = n } n() } } catch (a) { if (a && i && "string" == typeof a.stack) { for (var s = a.stack.split("\n"), _ = i.stack.split("\n"), N = s.length - 1, z = _.length - 1; 1 <= N && 0 <= z && s[N] !== _[z];)z--; for (; 1 <= N && 0 <= z; N--, z--)if (s[N] !== _[z]) { if (1 !== N || 1 !== z) do if (N--, 0 > --z || s[N] !== _[z]) { var j = "\n" + s[N].replace(" at new ", " at "); return n.displayName && j.includes("<anonymous>") && (j = j.replace("<anonymous>", n.displayName)), j } while (1 <= N && 0 <= z); break } } } finally { ez = !1, Error.prepareStackTrace = o } return (n = n ? n.displayName || n.name : "") ? Ma(n) : "" } function Sa(n) { switch (typeof n) { case "boolean": case "number": case "string": case "undefined": case "object": return n; default: return "" } } function Ta(n) { var a = n.type; return (n = n.nodeName) && "input" === n.toLowerCase() && ("checkbox" === a || "radio" === a) } function Va(n) { n._valueTracker || (n._valueTracker = function (n) { var a = Ta(n) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(n.constructor.prototype, a), i = "" + n[a]; if (!n.hasOwnProperty(a) && void 0 !== o && "function" == typeof o.get && "function" == typeof o.set) { var s = o.get, _ = o.set; return Object.defineProperty(n, a, { configurable: !0, get: function () { return s.call(this) }, set: function (n) { i = "" + n, _.call(this, n) } }), Object.defineProperty(n, a, { enumerable: o.enumerable }), { getValue: function () { return i }, setValue: function (n) { i = "" + n }, stopTracking: function () { n._valueTracker = null, delete n[a] } } } }(n)) } function Wa(n) { if (!n) return !1; var a = n._valueTracker; if (!a) return !0; var o = a.getValue(), i = ""; return n && (i = Ta(n) ? n.checked ? "true" : "false" : n.value), (n = i) !== o && (a.setValue(n), !0) } function Xa(n) { if (void 0 === (n = n || ("undefined" != typeof document ? document : void 0))) return null; try { return n.activeElement || n.body } catch (a) { return n.body } } function Ya(n, a) { var o = a.checked; return eN({}, a, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != o ? o : n._wrapperState.initialChecked }) } function Za(n, a) { var o = null == a.defaultValue ? "" : a.defaultValue, i = null != a.checked ? a.checked : a.defaultChecked; o = Sa(null != a.value ? a.value : o), n._wrapperState = { initialChecked: i, initialValue: o, controlled: "checkbox" === a.type || "radio" === a.type ? null != a.checked : null != a.value } } function ab(n, a) { null != (a = a.checked) && ta(n, "checked", a, !1) } function bb(n, a) { ab(n, a); var o = Sa(a.value), i = a.type; if (null != o) "number" === i ? (0 === o && "" === n.value || n.value != o) && (n.value = "" + o) : n.value !== "" + o && (n.value = "" + o); else if ("submit" === i || "reset" === i) { n.removeAttribute("value"); return } a.hasOwnProperty("value") ? cb(n, a.type, o) : a.hasOwnProperty("defaultValue") && cb(n, a.type, Sa(a.defaultValue)), null == a.checked && null != a.defaultChecked && (n.defaultChecked = !!a.defaultChecked) } function db(n, a, o) { if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) { var i = a.type; if (!("submit" !== i && "reset" !== i || void 0 !== a.value && null !== a.value)) return; a = "" + n._wrapperState.initialValue, o || a === n.value || (n.value = a), n.defaultValue = a } "" !== (o = n.name) && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, "" !== o && (n.name = o) } function cb(n, a, o) { ("number" !== a || Xa(n.ownerDocument) !== n) && (null == o ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + o && (n.defaultValue = "" + o)) } var eL = Array.isArray; function fb(n, a, o, i) { if (n = n.options, a) { a = {}; for (var s = 0; s < o.length; s++)a["$" + o[s]] = !0; for (o = 0; o < n.length; o++)s = a.hasOwnProperty("$" + n[o].value), n[o].selected !== s && (n[o].selected = s), s && i && (n[o].defaultSelected = !0) } else { for (s = 0, o = "" + Sa(o), a = null; s < n.length; s++) { if (n[s].value === o) { n[s].selected = !0, i && (n[s].defaultSelected = !0); return } null !== a || n[s].disabled || (a = n[s]) } null !== a && (a.selected = !0) } } function gb(n, a) { if (null != a.dangerouslySetInnerHTML) throw Error(p(91)); return eN({}, a, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue }) } function hb(n, a) { var o = a.value; if (null == o) { if (o = a.children, a = a.defaultValue, null != o) { if (null != a) throw Error(p(92)); if (eL(o)) { if (1 < o.length) throw Error(p(93)); o = o[0] } a = o } null == a && (a = ""), o = a } n._wrapperState = { initialValue: Sa(o) } } function ib(n, a) { var o = Sa(a.value), i = Sa(a.defaultValue); null != o && ((o = "" + o) !== n.value && (n.value = o), null == a.defaultValue && n.defaultValue !== o && (n.defaultValue = o)), null != i && (n.defaultValue = "" + i) } function jb(n) { var a = n.textContent; a === n._wrapperState.initialValue && "" !== a && null !== a && (n.value = a) } function kb(n) { switch (n) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function lb(n, a) { return null == n || "http://www.w3.org/1999/xhtml" === n ? kb(a) : "http://www.w3.org/2000/svg" === n && "foreignObject" === a ? "http://www.w3.org/1999/xhtml" : n } var eM, eD, eI = (eM = function (n, a) { if ("http://www.w3.org/2000/svg" !== n.namespaceURI || "innerHTML" in n) n.innerHTML = a; else { for ((eD = eD || document.createElement("div")).innerHTML = "<svg>" + a.valueOf().toString() + "</svg>", a = eD.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (; a.firstChild;)n.appendChild(a.firstChild) } }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function (n, a, o, i) { MSApp.execUnsafeLocalFunction(function () { return eM(n, a, o, i) }) } : eM); function ob(n, a) { if (a) { var o = n.firstChild; if (o && o === n.lastChild && 3 === o.nodeType) { o.nodeValue = a; return } } n.textContent = a } var eO = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, eV = ["Webkit", "ms", "Moz", "O"]; function rb(n, a, o) { return null == a || "boolean" == typeof a || "" === a ? "" : o || "number" != typeof a || 0 === a || eO.hasOwnProperty(n) && eO[n] ? ("" + a).trim() : a + "px" } function sb(n, a) { for (var o in n = n.style, a) if (a.hasOwnProperty(o)) { var i = 0 === o.indexOf("--"), s = rb(o, a[o], i); "float" === o && (o = "cssFloat"), i ? n.setProperty(o, s) : n[o] = s } } Object.keys(eO).forEach(function (n) { eV.forEach(function (a) { eO[a = a + n.charAt(0).toUpperCase() + n.substring(1)] = eO[n] }) }); var eB = eN({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ub(n, a) { if (a) { if (eB[n] && (null != a.children || null != a.dangerouslySetInnerHTML)) throw Error(p(137, n)); if (null != a.dangerouslySetInnerHTML) { if (null != a.children) throw Error(p(60)); if ("object" != typeof a.dangerouslySetInnerHTML || !("__html" in a.dangerouslySetInnerHTML)) throw Error(p(61)) } if (null != a.style && "object" != typeof a.style) throw Error(p(62)) } } function vb(n, a) { if (-1 === n.indexOf("-")) return "string" == typeof a.is; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var eA = null; function xb(n) { return (n = n.target || n.srcElement || window).correspondingUseElement && (n = n.correspondingUseElement), 3 === n.nodeType ? n.parentNode : n } var eU = null, e$ = null, eW = null; function Bb(n) { if (n = Cb(n)) { if ("function" != typeof eU) throw Error(p(280)); var a = n.stateNode; a && (a = Db(a), eU(n.stateNode, n.type, a)) } } function Eb(n) { e$ ? eW ? eW.push(n) : eW = [n] : e$ = n } function Fb() { if (e$) { var n = e$, a = eW; if (eW = e$ = null, Bb(n), a) for (n = 0; n < a.length; n++)Bb(a[n]) } } function Gb(n, a) { return n(a) } function Hb() { } var eH = !1; function Jb(n, a, o) { if (eH) return n(a, o); eH = !0; try { return Gb(n, a, o) } finally { eH = !1, (null !== e$ || null !== eW) && (Hb(), Fb()) } } function Kb(n, a) { var o = n.stateNode; if (null === o) return null; var i = Db(o); if (null === i) return null; switch (o = i[a], a) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (i = !("button" === (n = n.type) || "input" === n || "select" === n || "textarea" === n)), n = !i; break; default: n = !1 }if (n) return null; if (o && "function" != typeof o) throw Error(p(231, a, typeof o)); return o } var eQ = !1; if (en) try { var eq = {}; Object.defineProperty(eq, "passive", { get: function () { eQ = !0 } }), window.addEventListener("test", eq, eq), window.removeEventListener("test", eq, eq) } catch (n) { eQ = !1 } function Nb(n, a, o, i, s, _, N, z, j) { var B = Array.prototype.slice.call(arguments, 3); try { a.apply(o, B) } catch (n) { this.onError(n) } } var eZ = !1, eG = null, eY = !1, eX = null, eK = { onError: function (n) { eZ = !0, eG = n } }; function Tb(n, a, o, i, s, _, N, z, j) { eZ = !1, eG = null, Nb.apply(eK, arguments) } function Vb(n) { var a = n, o = n; if (n.alternate) for (; a.return;)a = a.return; else { n = a; do 0 != (4098 & (a = n).flags) && (o = a.return), n = a.return; while (n) } return 3 === a.tag ? o : null } function Wb(n) { if (13 === n.tag) { var a = n.memoizedState; if (null === a && null !== (n = n.alternate) && (a = n.memoizedState), null !== a) return a.dehydrated } return null } function Xb(n) { if (Vb(n) !== n) throw Error(p(188)) } function Zb(n) { return null !== (n = function (n) { var a = n.alternate; if (!a) { if (null === (a = Vb(n))) throw Error(p(188)); return a !== n ? null : n } for (var o = n, i = a; ;) { var s = o.return; if (null === s) break; var _ = s.alternate; if (null === _) { if (null !== (i = s.return)) { o = i; continue } break } if (s.child === _.child) { for (_ = s.child; _;) { if (_ === o) return Xb(s), n; if (_ === i) return Xb(s), a; _ = _.sibling } throw Error(p(188)) } if (o.return !== i.return) o = s, i = _; else { for (var N = !1, z = s.child; z;) { if (z === o) { N = !0, o = s, i = _; break } if (z === i) { N = !0, i = s, o = _; break } z = z.sibling } if (!N) { for (z = _.child; z;) { if (z === o) { N = !0, o = _, i = s; break } if (z === i) { N = !0, i = _, o = s; break } z = z.sibling } if (!N) throw Error(p(189)) } } if (o.alternate !== i) throw Error(p(190)) } if (3 !== o.tag) throw Error(p(188)); return o.stateNode.current === o ? n : a }(n)) ? function $b(n) { if (5 === n.tag || 6 === n.tag) return n; for (n = n.child; null !== n;) { var a = $b(n); if (null !== a) return a; n = n.sibling } return null }(n) : null } var eJ = $.unstable_scheduleCallback, e0 = $.unstable_cancelCallback, e1 = $.unstable_shouldYield, e2 = $.unstable_requestPaint, e3 = $.unstable_now, e4 = $.unstable_getCurrentPriorityLevel, e6 = $.unstable_ImmediatePriority, e8 = $.unstable_UserBlockingPriority, e5 = $.unstable_NormalPriority, e9 = $.unstable_LowPriority, e7 = $.unstable_IdlePriority, tt = null, tn = null, tr = Math.clz32 ? Math.clz32 : function (n) { return 0 == (n >>>= 0) ? 32 : 31 - (tl(n) / to | 0) | 0 }, tl = Math.log, to = Math.LN2, tu = 64, ts = 4194304; function tc(n) { switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & n; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & n; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return n } } function uc(n, a) { var o = n.pendingLanes; if (0 === o) return 0; var i = 0, s = n.suspendedLanes, _ = n.pingedLanes, N = 268435455 & o; if (0 !== N) { var z = N & ~s; 0 !== z ? i = tc(z) : 0 != (_ &= N) && (i = tc(_)) } else 0 != (N = o & ~s) ? i = tc(N) : 0 !== _ && (i = tc(_)); if (0 === i) return 0; if (0 !== a && a !== i && 0 == (a & s) && ((s = i & -i) >= (_ = a & -a) || 16 === s && 0 != (4194240 & _))) return a; if (0 != (4 & i) && (i |= 16 & o), 0 !== (a = n.entangledLanes)) for (n = n.entanglements, a &= i; 0 < a;)s = 1 << (o = 31 - tr(a)), i |= n[o], a &= ~s; return i } function xc(n) { return 0 != (n = -1073741825 & n.pendingLanes) ? n : 1073741824 & n ? 1073741824 : 0 } function yc() { var n = tu; return 0 == (4194240 & (tu <<= 1)) && (tu = 64), n } function zc(n) { for (var a = [], o = 0; 31 > o; o++)a.push(n); return a } function Ac(n, a, o) { n.pendingLanes |= a, 536870912 !== a && (n.suspendedLanes = 0, n.pingedLanes = 0), (n = n.eventTimes)[a = 31 - tr(a)] = o } function Cc(n, a) { var o = n.entangledLanes |= a; for (n = n.entanglements; o;) { var i = 31 - tr(o), s = 1 << i; s & a | n[i] & a && (n[i] |= a), o &= ~s } } var td = 0; function Dc(n) { return 1 < (n &= -n) ? 4 < n ? 0 != (268435455 & n) ? 16 : 536870912 : 4 : 1 } var tp, tm, tv, ty, tk, tw = !1, tS = [], tx = null, tE = null, tC = null, t_ = new Map, tT = new Map, tP = [], tF = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Sc(n, a) { switch (n) { case "focusin": case "focusout": tx = null; break; case "dragenter": case "dragleave": tE = null; break; case "mouseover": case "mouseout": tC = null; break; case "pointerover": case "pointerout": t_.delete(a.pointerId); break; case "gotpointercapture": case "lostpointercapture": tT.delete(a.pointerId) } } function Tc(n, a, o, i, s, _) { return null === n || n.nativeEvent !== _ ? (n = { blockedOn: a, domEventName: o, eventSystemFlags: i, nativeEvent: _, targetContainers: [s] }, null !== a && null !== (a = Cb(a)) && tm(a)) : (n.eventSystemFlags |= i, a = n.targetContainers, null !== s && -1 === a.indexOf(s) && a.push(s)), n } function Vc(n) { var a = Wc(n.target); if (null !== a) { var o = Vb(a); if (null !== o) { if (13 === (a = o.tag)) { if (null !== (a = Wb(o))) { n.blockedOn = a, tk(n.priority, function () { tv(o) }); return } } else if (3 === a && o.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = 3 === o.tag ? o.stateNode.containerInfo : null; return } } } n.blockedOn = null } function Xc(n) { if (null !== n.blockedOn) return !1; for (var a = n.targetContainers; 0 < a.length;) { var o = Yc(n.domEventName, n.eventSystemFlags, a[0], n.nativeEvent); if (null !== o) return null !== (a = Cb(o)) && tm(a), n.blockedOn = o, !1; var i = new (o = n.nativeEvent).constructor(o.type, o); eA = i, o.target.dispatchEvent(i), eA = null, a.shift() } return !0 } function Zc(n, a, o) { Xc(n) && o.delete(a) } function $c() { tw = !1, null !== tx && Xc(tx) && (tx = null), null !== tE && Xc(tE) && (tE = null), null !== tC && Xc(tC) && (tC = null), t_.forEach(Zc), tT.forEach(Zc) } function ad(n, a) { n.blockedOn === a && (n.blockedOn = null, tw || (tw = !0, $.unstable_scheduleCallback($.unstable_NormalPriority, $c))) } function bd(n) { function b(a) { return ad(a, n) } if (0 < tS.length) { ad(tS[0], n); for (var a = 1; a < tS.length; a++) { var o = tS[a]; o.blockedOn === n && (o.blockedOn = null) } } for (null !== tx && ad(tx, n), null !== tE && ad(tE, n), null !== tC && ad(tC, n), t_.forEach(b), tT.forEach(b), a = 0; a < tP.length; a++)(o = tP[a]).blockedOn === n && (o.blockedOn = null); for (; 0 < tP.length && null === (a = tP[0]).blockedOn;)Vc(a), null === a.blockedOn && tP.shift() } var tR = ef.ReactCurrentBatchConfig, tN = !0; function ed(n, a, o, i) { var s = td, _ = tR.transition; tR.transition = null; try { td = 1, fd(n, a, o, i) } finally { td = s, tR.transition = _ } } function gd(n, a, o, i) { var s = td, _ = tR.transition; tR.transition = null; try { td = 4, fd(n, a, o, i) } finally { td = s, tR.transition = _ } } function fd(n, a, o, i) { if (tN) { var s = Yc(n, a, o, i); if (null === s) hd(n, a, i, tz, o), Sc(n, i); else if (function (n, a, o, i, s) { switch (a) { case "focusin": return tx = Tc(tx, n, a, o, i, s), !0; case "dragenter": return tE = Tc(tE, n, a, o, i, s), !0; case "mouseover": return tC = Tc(tC, n, a, o, i, s), !0; case "pointerover": var _ = s.pointerId; return t_.set(_, Tc(t_.get(_) || null, n, a, o, i, s)), !0; case "gotpointercapture": return _ = s.pointerId, tT.set(_, Tc(tT.get(_) || null, n, a, o, i, s)), !0 }return !1 }(s, n, a, o, i)) i.stopPropagation(); else if (Sc(n, i), 4 & a && -1 < tF.indexOf(n)) { for (; null !== s;) { var _ = Cb(s); if (null !== _ && tp(_), null === (_ = Yc(n, a, o, i)) && hd(n, a, i, tz, o), _ === s) break; s = _ } null !== s && i.stopPropagation() } else hd(n, a, i, null, o) } } var tz = null; function Yc(n, a, o, i) { if (tz = null, null !== (n = Wc(n = xb(i)))) { if (null === (a = Vb(n))) n = null; else if (13 === (o = a.tag)) { if (null !== (n = Wb(a))) return n; n = null } else if (3 === o) { if (a.stateNode.current.memoizedState.isDehydrated) return 3 === a.tag ? a.stateNode.containerInfo : null; n = null } else a !== n && (n = null) } return tz = n, null } function jd(n) { switch (n) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (e4()) { case e6: return 1; case e8: return 4; case e5: case e9: return 16; case e7: return 536870912; default: return 16 }default: return 16 } } var tL = null, tM = null, tD = null; function nd() { if (tD) return tD; var n, a, o = tM, i = o.length, s = "value" in tL ? tL.value : tL.textContent, _ = s.length; for (n = 0; n < i && o[n] === s[n]; n++); var N = i - n; for (a = 1; a <= N && o[i - a] === s[_ - a]; a++); return tD = s.slice(n, 1 < a ? 1 - a : void 0) } function od(n) { var a = n.keyCode; return "charCode" in n ? 0 === (n = n.charCode) && 13 === a && (n = 13) : n = a, 10 === n && (n = 13), 32 <= n || 13 === n ? n : 0 } function pd() { return !0 } function qd() { return !1 } function rd(n) { function b(a, o, i, s, _) { for (var N in this._reactName = a, this._targetInst = i, this.type = o, this.nativeEvent = s, this.target = _, this.currentTarget = null, n) n.hasOwnProperty(N) && (a = n[N], this[N] = a ? a(s) : s[N]); return this.isDefaultPrevented = (null != s.defaultPrevented ? s.defaultPrevented : !1 === s.returnValue) ? pd : qd, this.isPropagationStopped = qd, this } return eN(b.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : "unknown" != typeof n.returnValue && (n.returnValue = !1), this.isDefaultPrevented = pd) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : "unknown" != typeof n.cancelBubble && (n.cancelBubble = !0), this.isPropagationStopped = pd) }, persist: function () { }, isPersistent: pd }), b } var tI, tO, tV, tB = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, tA = rd(tB), tU = eN({}, tB, { view: 0, detail: 0 }), t$ = rd(tU), tW = eN({}, tU, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function (n) { return void 0 === n.relatedTarget ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== tV && (tV && "mousemove" === n.type ? (tI = n.screenX - tV.screenX, tO = n.screenY - tV.screenY) : tO = tI = 0, tV = n), tI) }, movementY: function (n) { return "movementY" in n ? n.movementY : tO } }), tH = rd(tW), tQ = rd(eN({}, tW, { dataTransfer: 0 })), tq = rd(eN({}, tU, { relatedTarget: 0 })), tZ = rd(eN({}, tB, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), tG = rd(eN({}, tB, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } })), tY = rd(eN({}, tB, { data: 0 })), tX = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, tK = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, tJ = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Pd(n) { var a = this.nativeEvent; return a.getModifierState ? a.getModifierState(n) : !!(n = tJ[n]) && !!a[n] } function zd() { return Pd } var t0 = rd(eN({}, tU, { key: function (n) { if (n.key) { var a = tX[n.key] || n.key; if ("Unidentified" !== a) return a } return "keypress" === n.type ? 13 === (n = od(n)) ? "Enter" : String.fromCharCode(n) : "keydown" === n.type || "keyup" === n.type ? tK[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function (n) { return "keypress" === n.type ? od(n) : 0 }, keyCode: function (n) { return "keydown" === n.type || "keyup" === n.type ? n.keyCode : 0 }, which: function (n) { return "keypress" === n.type ? od(n) : "keydown" === n.type || "keyup" === n.type ? n.keyCode : 0 } })), t1 = rd(eN({}, tW, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), t2 = rd(eN({}, tU, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd })), t3 = rd(eN({}, tB, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), t4 = rd(eN({}, tW, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 })), t6 = [9, 13, 27, 32], t8 = en && "CompositionEvent" in window, t5 = null; en && "documentMode" in document && (t5 = document.documentMode); var t9 = en && "TextEvent" in window && !t5, t7 = en && (!t8 || t5 && 8 < t5 && 11 >= t5), nt = !1; function ge(n, a) { switch (n) { case "keyup": return -1 !== t6.indexOf(a.keyCode); case "keydown": return 229 !== a.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function he(n) { return "object" == typeof (n = n.detail) && "data" in n ? n.data : null } var nn = !1, nr = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function me(n) { var a = n && n.nodeName && n.nodeName.toLowerCase(); return "input" === a ? !!nr[n.type] : "textarea" === a } function ne(n, a, o, i) { Eb(i), 0 < (a = oe(a, "onChange")).length && (o = new tA("onChange", "change", null, o, i), n.push({ event: o, listeners: a })) } var na = null, no = null; function re(n) { se(n, 0) } function te(n) { if (Wa(ue(n))) return n } function ve(n, a) { if ("change" === n) return a } var nu = !1; if (en) { if (en) { var ns = "oninput" in document; if (!ns) { var np = document.createElement("div"); np.setAttribute("oninput", "return;"), ns = "function" == typeof np.oninput } i = ns } else i = !1; nu = i && (!document.documentMode || 9 < document.documentMode) } function Ae() { na && (na.detachEvent("onpropertychange", Be), no = na = null) } function Be(n) { if ("value" === n.propertyName && te(no)) { var a = []; ne(a, no, n, xb(n)), Jb(re, a) } } function Ce(n, a, o) { "focusin" === n ? (Ae(), na = a, no = o, na.attachEvent("onpropertychange", Be)) : "focusout" === n && Ae() } function De(n) { if ("selectionchange" === n || "keyup" === n || "keydown" === n) return te(no) } function Ee(n, a) { if ("click" === n) return te(a) } function Fe(n, a) { if ("input" === n || "change" === n) return te(a) } var nh = "function" == typeof Object.is ? Object.is : function (n, a) { return n === a && (0 !== n || 1 / n == 1 / a) || n != n && a != a }; function Ie(n, a) { if (nh(n, a)) return !0; if ("object" != typeof n || null === n || "object" != typeof a || null === a) return !1; var o = Object.keys(n), i = Object.keys(a); if (o.length !== i.length) return !1; for (i = 0; i < o.length; i++) { var s = o[i]; if (!er.call(a, s) || !nh(n[s], a[s])) return !1 } return !0 } function Je(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function Ke(n, a) { var o, i = Je(n); for (n = 0; i;) { if (3 === i.nodeType) { if (o = n + i.textContent.length, n <= a && o >= a) return { node: i, offset: a - n }; n = o } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = Je(i) } } function Me() { for (var n = window, a = Xa(); a instanceof n.HTMLIFrameElement;) { try { var o = "string" == typeof a.contentWindow.location.href } catch (n) { o = !1 } if (o) n = a.contentWindow; else break; a = Xa(n.document) } return a } function Ne(n) { var a = n && n.nodeName && n.nodeName.toLowerCase(); return a && ("input" === a && ("text" === n.type || "search" === n.type || "tel" === n.type || "url" === n.type || "password" === n.type) || "textarea" === a || "true" === n.contentEditable) } var ng = en && "documentMode" in document && 11 >= document.documentMode, nm = null, nb = null, nv = null, ny = !1; function Ue(n, a, o) { var i = o.window === o ? o.document : 9 === o.nodeType ? o : o.ownerDocument; ny || null == nm || nm !== Xa(i) || (i = "selectionStart" in (i = nm) && Ne(i) ? { start: i.selectionStart, end: i.selectionEnd } : { anchorNode: (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }, nv && Ie(nv, i) || (nv = i, 0 < (i = oe(nb, "onSelect")).length && (a = new tA("onSelect", "select", null, a, o), n.push({ event: a, listeners: i }), a.target = nm))) } function Ve(n, a) { var o = {}; return o[n.toLowerCase()] = a.toLowerCase(), o["Webkit" + n] = "webkit" + a, o["Moz" + n] = "moz" + a, o } var nk = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, nw = {}, nS = {}; function Ze(n) { if (nw[n]) return nw[n]; if (!nk[n]) return n; var a, o = nk[n]; for (a in o) if (o.hasOwnProperty(a) && a in nS) return nw[n] = o[a]; return n } en && (nS = document.createElement("div").style, "AnimationEvent" in window || (delete nk.animationend.animation, delete nk.animationiteration.animation, delete nk.animationstart.animation), "TransitionEvent" in window || delete nk.transitionend.transition); var nx = Ze("animationend"), nE = Ze("animationiteration"), nC = Ze("animationstart"), n_ = Ze("transitionend"), nT = new Map, nP = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ff(n, a) { nT.set(n, a), fa(a, [n]) } for (var nF = 0; nF < nP.length; nF++) { var nR = nP[nF]; ff(nR.toLowerCase(), "on" + (nR[0].toUpperCase() + nR.slice(1))) } ff(nx, "onAnimationEnd"), ff(nE, "onAnimationIteration"), ff(nC, "onAnimationStart"), ff("dblclick", "onDoubleClick"), ff("focusin", "onFocus"), ff("focusout", "onBlur"), ff(n_, "onTransitionEnd"), ha("onMouseEnter", ["mouseout", "mouseover"]), ha("onMouseLeave", ["mouseout", "mouseover"]), ha("onPointerEnter", ["pointerout", "pointerover"]), ha("onPointerLeave", ["pointerout", "pointerover"]), fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var nN = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nz = new Set("cancel close invalid load scroll toggle".split(" ").concat(nN)); function nf(n, a, o) { var i = n.type || "unknown-event"; n.currentTarget = o, function (n, a, o, i, s, _, N, z, j) { if (Tb.apply(this, arguments), eZ) { if (eZ) { var B = eG; eZ = !1, eG = null } else throw Error(p(198)); eY || (eY = !0, eX = B) } }(i, a, void 0, n), n.currentTarget = null } function se(n, a) { a = 0 != (4 & a); for (var o = 0; o < n.length; o++) { var i = n[o], s = i.event; i = i.listeners; e: { var _ = void 0; if (a) for (var N = i.length - 1; 0 <= N; N--) { var z = i[N], j = z.instance, B = z.currentTarget; if (z = z.listener, j !== _ && s.isPropagationStopped()) break e; nf(s, z, B), _ = j } else for (N = 0; N < i.length; N++) { if (j = (z = i[N]).instance, B = z.currentTarget, z = z.listener, j !== _ && s.isPropagationStopped()) break e; nf(s, z, B), _ = j } } } if (eY) throw n = eX, eY = !1, eX = null, n } function D(n, a) { var o = a[nQ]; void 0 === o && (o = a[nQ] = new Set); var i = n + "__bubble"; o.has(i) || (pf(a, n, 2, !1), o.add(i)) } function qf(n, a, o) { var i = 0; a && (i |= 4), pf(o, n, i, a) } var nL = "_reactListening" + Math.random().toString(36).slice(2); function sf(n) { if (!n[nL]) { n[nL] = !0, ee.forEach(function (a) { "selectionchange" !== a && (nz.has(a) || qf(a, !1, n), qf(a, !0, n)) }); var a = 9 === n.nodeType ? n : n.ownerDocument; null === a || a[nL] || (a[nL] = !0, qf("selectionchange", !1, a)) } } function pf(n, a, o, i) { switch (jd(a)) { case 1: var s = ed; break; case 4: s = gd; break; default: s = fd }o = s.bind(null, a, o, n), s = void 0, eQ && ("touchstart" === a || "touchmove" === a || "wheel" === a) && (s = !0), i ? void 0 !== s ? n.addEventListener(a, o, { capture: !0, passive: s }) : n.addEventListener(a, o, !0) : void 0 !== s ? n.addEventListener(a, o, { passive: s }) : n.addEventListener(a, o, !1) } function hd(n, a, o, i, s) { var _ = i; if (0 == (1 & a) && 0 == (2 & a) && null !== i) e: for (; ;) { if (null === i) return; var N = i.tag; if (3 === N || 4 === N) { var z = i.stateNode.containerInfo; if (z === s || 8 === z.nodeType && z.parentNode === s) break; if (4 === N) for (N = i.return; null !== N;) { var j = N.tag; if ((3 === j || 4 === j) && ((j = N.stateNode.containerInfo) === s || 8 === j.nodeType && j.parentNode === s)) return; N = N.return } for (; null !== z;) { if (null === (N = Wc(z))) return; if (5 === (j = N.tag) || 6 === j) { i = _ = N; continue e } z = z.parentNode } } i = i.return } Jb(function () { var i = _, s = xb(o), N = []; e: { var z = nT.get(n); if (void 0 !== z) { var j = tA, B = n; switch (n) { case "keypress": if (0 === od(o)) break e; case "keydown": case "keyup": j = t0; break; case "focusin": B = "focus", j = tq; break; case "focusout": B = "blur", j = tq; break; case "beforeblur": case "afterblur": j = tq; break; case "click": if (2 === o.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": j = tH; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": j = tQ; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": j = t2; break; case nx: case nE: case nC: j = tZ; break; case n_: j = t3; break; case "scroll": j = t$; break; case "wheel": j = t4; break; case "copy": case "cut": case "paste": j = tG; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": j = t1 }var $ = 0 != (4 & a), ee = !$ && "scroll" === n, et = $ ? null !== z ? z + "Capture" : null : z; $ = []; for (var en, er = i; null !== er;) { var ea = (en = er).stateNode; if (5 === en.tag && null !== ea && (en = ea, null !== et && null != (ea = Kb(er, et)) && $.push(tf(er, ea, en))), ee) break; er = er.return } 0 < $.length && (z = new j(z, B, null, o, s), N.push({ event: z, listeners: $ })) } } if (0 == (7 & a)) { if (z = "mouseover" === n || "pointerover" === n, j = "mouseout" === n || "pointerout" === n, !(z && o !== eA && (B = o.relatedTarget || o.fromElement) && (Wc(B) || B[nH])) && (j || z) && (z = s.window === s ? s : (z = s.ownerDocument) ? z.defaultView || z.parentWindow : window, j ? (B = o.relatedTarget || o.toElement, j = i, null !== (B = B ? Wc(B) : null) && (ee = Vb(B), B !== ee || 5 !== B.tag && 6 !== B.tag) && (B = null)) : (j = null, B = i), j !== B)) { if ($ = tH, ea = "onMouseLeave", et = "onMouseEnter", er = "mouse", ("pointerout" === n || "pointerover" === n) && ($ = t1, ea = "onPointerLeave", et = "onPointerEnter", er = "pointer"), ee = null == j ? z : ue(j), en = null == B ? z : ue(B), (z = new $(ea, er + "leave", j, o, s)).target = ee, z.relatedTarget = en, ea = null, Wc(s) === i && (($ = new $(et, er + "enter", B, o, s)).target = en, $.relatedTarget = ee, ea = $), ee = ea, j && B) t: { for ($ = j, et = B, er = 0, en = $; en; en = vf(en))er++; for (en = 0, ea = et; ea; ea = vf(ea))en++; for (; 0 < er - en;)$ = vf($), er--; for (; 0 < en - er;)et = vf(et), en--; for (; er--;) { if ($ === et || null !== et && $ === et.alternate) break t; $ = vf($), et = vf(et) } $ = null } else $ = null; null !== j && wf(N, z, j, $, !1), null !== B && null !== ee && wf(N, ee, B, $, !0) } e: { if ("select" === (j = (z = i ? ue(i) : window).nodeName && z.nodeName.toLowerCase()) || "input" === j && "file" === z.type) var eo, eu = ve; else if (me(z)) { if (nu) eu = Fe; else { eu = De; var es = Ce } } else (j = z.nodeName) && "input" === j.toLowerCase() && ("checkbox" === z.type || "radio" === z.type) && (eu = Ee); if (eu && (eu = eu(n, i))) { ne(N, eu, o, s); break e } es && es(n, z, i), "focusout" === n && (es = z._wrapperState) && es.controlled && "number" === z.type && cb(z, "number", z.value) } switch (es = i ? ue(i) : window, n) { case "focusin": (me(es) || "true" === es.contentEditable) && (nm = es, nb = i, nv = null); break; case "focusout": nv = nb = nm = null; break; case "mousedown": ny = !0; break; case "contextmenu": case "mouseup": case "dragend": ny = !1, Ue(N, o, s); break; case "selectionchange": if (ng) break; case "keydown": case "keyup": Ue(N, o, s) }if (t8) t: { switch (n) { case "compositionstart": var ec = "onCompositionStart"; break t; case "compositionend": ec = "onCompositionEnd"; break t; case "compositionupdate": ec = "onCompositionUpdate"; break t }ec = void 0 } else nn ? ge(n, o) && (ec = "onCompositionEnd") : "keydown" === n && 229 === o.keyCode && (ec = "onCompositionStart"); ec && (t7 && "ko" !== o.locale && (nn || "onCompositionStart" !== ec ? "onCompositionEnd" === ec && nn && (eo = nd()) : (tM = "value" in (tL = s) ? tL.value : tL.textContent, nn = !0)), 0 < (es = oe(i, ec)).length && (ec = new tY(ec, n, null, o, s), N.push({ event: ec, listeners: es }), eo ? ec.data = eo : null !== (eo = he(o)) && (ec.data = eo))), (eo = t9 ? function (n, a) { switch (n) { case "compositionend": return he(a); case "keypress": if (32 !== a.which) return null; return nt = !0, " "; case "textInput": return " " === (n = a.data) && nt ? null : n; default: return null } }(n, o) : function (n, a) { if (nn) return "compositionend" === n || !t8 && ge(n, a) ? (n = nd(), tD = tM = tL = null, nn = !1, n) : null; switch (n) { case "paste": default: return null; case "keypress": if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) { if (a.char && 1 < a.char.length) return a.char; if (a.which) return String.fromCharCode(a.which) } return null; case "compositionend": return t7 && "ko" !== a.locale ? null : a.data } }(n, o)) && 0 < (i = oe(i, "onBeforeInput")).length && (s = new tY("onBeforeInput", "beforeinput", null, o, s), N.push({ event: s, listeners: i }), s.data = eo) } se(N, a) }) } function tf(n, a, o) { return { instance: n, listener: a, currentTarget: o } } function oe(n, a) { for (var o = a + "Capture", i = []; null !== n;) { var s = n, _ = s.stateNode; 5 === s.tag && null !== _ && (s = _, null != (_ = Kb(n, o)) && i.unshift(tf(n, _, s)), null != (_ = Kb(n, a)) && i.push(tf(n, _, s))), n = n.return } return i } function vf(n) { if (null === n) return null; do n = n.return; while (n && 5 !== n.tag); return n || null } function wf(n, a, o, i, s) { for (var _ = a._reactName, N = []; null !== o && o !== i;) { var z = o, j = z.alternate, B = z.stateNode; if (null !== j && j === i) break; 5 === z.tag && null !== B && (z = B, s ? null != (j = Kb(o, _)) && N.unshift(tf(o, j, z)) : s || null != (j = Kb(o, _)) && N.push(tf(o, j, z))), o = o.return } 0 !== N.length && n.push({ event: a, listeners: N }) } var nM = /\r\n?/g, nj = /\u0000|\uFFFD/g; function zf(n) { return ("string" == typeof n ? n : "" + n).replace(nM, "\n").replace(nj, "") } function Af(n, a, o) { if (a = zf(a), zf(n) !== a && o) throw Error(p(425)) } function Bf() { } var nD = null, nI = null; function Ef(n, a) { return "textarea" === n || "noscript" === n || "string" == typeof a.children || "number" == typeof a.children || "object" == typeof a.dangerouslySetInnerHTML && null !== a.dangerouslySetInnerHTML && null != a.dangerouslySetInnerHTML.__html } var nO = "function" == typeof setTimeout ? setTimeout : void 0, nV = "function" == typeof clearTimeout ? clearTimeout : void 0, nB = "function" == typeof Promise ? Promise : void 0, nA = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== nB ? function (n) { return nB.resolve(null).then(n).catch(If) } : nO; function If(n) { setTimeout(function () { throw n }) } function Kf(n, a) { var o = a, i = 0; do { var s = o.nextSibling; if (n.removeChild(o), s && 8 === s.nodeType) { if ("/$" === (o = s.data)) { if (0 === i) { n.removeChild(s), bd(a); return } i-- } else "$" !== o && "$?" !== o && "$!" !== o || i++ } o = s } while (o); bd(a) } function Lf(n) { for (; null != n; n = n.nextSibling) { var a = n.nodeType; if (1 === a || 3 === a) break; if (8 === a) { if ("$" === (a = n.data) || "$!" === a || "$?" === a) break; if ("/$" === a) return null } } return n } function Mf(n) { n = n.previousSibling; for (var a = 0; n;) { if (8 === n.nodeType) { var o = n.data; if ("$" === o || "$!" === o || "$?" === o) { if (0 === a) return n; a-- } else "/$" === o && a++ } n = n.previousSibling } return null } var nU = Math.random().toString(36).slice(2), n$ = "__reactFiber$" + nU, nW = "__reactProps$" + nU, nH = "__reactContainer$" + nU, nQ = "__reactEvents$" + nU, nq = "__reactListeners$" + nU, nZ = "__reactHandles$" + nU; function Wc(n) { var a = n[n$]; if (a) return a; for (var o = n.parentNode; o;) { if (a = o[nH] || o[n$]) { if (o = a.alternate, null !== a.child || null !== o && null !== o.child) for (n = Mf(n); null !== n;) { if (o = n[n$]) return o; n = Mf(n) } return a } o = (n = o).parentNode } return null } function Cb(n) { return (n = n[n$] || n[nH]) && (5 === n.tag || 6 === n.tag || 13 === n.tag || 3 === n.tag) ? n : null } function ue(n) { if (5 === n.tag || 6 === n.tag) return n.stateNode; throw Error(p(33)) } function Db(n) { return n[nW] || null } var nG = [], nY = -1; function Uf(n) { return { current: n } } function E(n) { 0 > nY || (n.current = nG[nY], nG[nY] = null, nY--) } function G(n, a) { nG[++nY] = n.current, n.current = a } var nX = {}, nK = Uf(nX), nJ = Uf(!1), n0 = nX; function Yf(n, a) { var o = n.type.contextTypes; if (!o) return nX; var i = n.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === a) return i.__reactInternalMemoizedMaskedChildContext; var s, _ = {}; for (s in o) _[s] = a[s]; return i && ((n = n.stateNode).__reactInternalMemoizedUnmaskedChildContext = a, n.__reactInternalMemoizedMaskedChildContext = _), _ } function Zf(n) { return null != (n = n.childContextTypes) } function $f() { E(nJ), E(nK) } function ag(n, a, o) { if (nK.current !== nX) throw Error(p(168)); G(nK, a), G(nJ, o) } function bg(n, a, o) { var i = n.stateNode; if (a = a.childContextTypes, "function" != typeof i.getChildContext) return o; for (var s in i = i.getChildContext()) if (!(s in a)) throw Error(p(108, function (n) { var a = n.type; switch (n.tag) { case 24: return "Cache"; case 9: return (a.displayName || "Context") + ".Consumer"; case 10: return (a._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return n = (n = a.render).displayName || n.name || "", a.displayName || ("" !== n ? "ForwardRef(" + n + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return a; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return function Qa(n) { if (null == n) return null; if ("function" == typeof n) return n.displayName || n.name || null; if ("string" == typeof n) return n; switch (n) { case em: return "Fragment"; case eg: return "Portal"; case ey: return "Profiler"; case ev: return "StrictMode"; case eE: return "Suspense"; case eC: return "SuspenseList" }if ("object" == typeof n) switch (n.$$typeof) { case eS: return (n.displayName || "Context") + ".Consumer"; case ew: return (n._context.displayName || "Context") + ".Provider"; case ex: var a = n.render; return (n = n.displayName) || (n = "" !== (n = a.displayName || a.name || "") ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case e_: return null !== (a = n.displayName || null) ? a : Qa(n.type) || "Memo"; case eT: a = n._payload, n = n._init; try { return Qa(n(a)) } catch (n) { } }return null }(a); case 8: return a === ev ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" == typeof a) return a.displayName || a.name || null; if ("string" == typeof a) return a }return null }(n) || "Unknown", s)); return eN({}, o, i) } function cg(n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || nX, n0 = nK.current, G(nK, n), G(nJ, nJ.current), !0 } function dg(n, a, o) { var i = n.stateNode; if (!i) throw Error(p(169)); o ? (n = bg(n, a, n0), i.__reactInternalMemoizedMergedChildContext = n, E(nJ), E(nK), G(nK, n)) : E(nJ), G(nJ, o) } var n1 = null, n2 = !1, n3 = !1; function hg(n) { null === n1 ? n1 = [n] : n1.push(n) } function jg() { if (!n3 && null !== n1) { n3 = !0; var n = 0, a = td; try { var o = n1; for (td = 1; n < o.length; n++) { var i = o[n]; do i = i(!0); while (null !== i) } n1 = null, n2 = !1 } catch (a) { throw null !== n1 && (n1 = n1.slice(n + 1)), eJ(e6, jg), a } finally { td = a, n3 = !1 } } return null } var n4 = [], n6 = 0, n8 = null, n5 = 0, n9 = [], n7 = 0, rt = null, rn = 1, rr = ""; function tg(n, a) { n4[n6++] = n5, n4[n6++] = n8, n8 = n, n5 = a } function ug(n, a, o) { n9[n7++] = rn, n9[n7++] = rr, n9[n7++] = rt, rt = n; var i = rn; n = rr; var s = 32 - tr(i) - 1; i &= ~(1 << s), o += 1; var _ = 32 - tr(a) + s; if (30 < _) { var N = s - s % 5; _ = (i & (1 << N) - 1).toString(32), i >>= N, s -= N, rn = 1 << 32 - tr(a) + s | o << s | i, rr = _ + n } else rn = 1 << _ | o << s | i, rr = n } function vg(n) { null !== n.return && (tg(n, 1), ug(n, 1, 0)) } function wg(n) { for (; n === n8;)n8 = n4[--n6], n4[n6] = null, n5 = n4[--n6], n4[n6] = null; for (; n === rt;)rt = n9[--n7], n9[n7] = null, rr = n9[--n7], n9[n7] = null, rn = n9[--n7], n9[n7] = null } var ra = null, rl = null, ro = !1, ru = null; function Ag(n, a) { var o = Bg(5, null, null, 0); o.elementType = "DELETED", o.stateNode = a, o.return = n, null === (a = n.deletions) ? (n.deletions = [o], n.flags |= 16) : a.push(o) } function Cg(n, a) { switch (n.tag) { case 5: var o = n.type; return null !== (a = 1 !== a.nodeType || o.toLowerCase() !== a.nodeName.toLowerCase() ? null : a) && (n.stateNode = a, ra = n, rl = Lf(a.firstChild), !0); case 6: return null !== (a = "" === n.pendingProps || 3 !== a.nodeType ? null : a) && (n.stateNode = a, ra = n, rl = null, !0); case 13: return null !== (a = 8 !== a.nodeType ? null : a) && (o = null !== rt ? { id: rn, overflow: rr } : null, n.memoizedState = { dehydrated: a, treeContext: o, retryLane: 1073741824 }, (o = Bg(18, null, null, 0)).stateNode = a, o.return = n, n.child = o, ra = n, rl = null, !0); default: return !1 } } function Dg(n) { return 0 != (1 & n.mode) && 0 == (128 & n.flags) } function Eg(n) { if (ro) { var a = rl; if (a) { var o = a; if (!Cg(n, a)) { if (Dg(n)) throw Error(p(418)); a = Lf(o.nextSibling); var i = ra; a && Cg(n, a) ? Ag(i, o) : (n.flags = -4097 & n.flags | 2, ro = !1, ra = n) } } else { if (Dg(n)) throw Error(p(418)); n.flags = -4097 & n.flags | 2, ro = !1, ra = n } } } function Fg(n) { for (n = n.return; null !== n && 5 !== n.tag && 3 !== n.tag && 13 !== n.tag;)n = n.return; ra = n } function Gg(n) { if (n !== ra) return !1; if (!ro) return Fg(n), ro = !0, !1; if ((a = 3 !== n.tag) && !(a = 5 !== n.tag) && (a = "head" !== (a = n.type) && "body" !== a && !Ef(n.type, n.memoizedProps)), a && (a = rl)) { if (Dg(n)) throw Hg(), Error(p(418)); for (; a;)Ag(n, a), a = Lf(a.nextSibling) } if (Fg(n), 13 === n.tag) { if (!(n = null !== (n = n.memoizedState) ? n.dehydrated : null)) throw Error(p(317)); e: { for (a = 0, n = n.nextSibling; n;) { if (8 === n.nodeType) { var a, o = n.data; if ("/$" === o) { if (0 === a) { rl = Lf(n.nextSibling); break e } a-- } else "$" !== o && "$!" !== o && "$?" !== o || a++ } n = n.nextSibling } rl = null } } else rl = ra ? Lf(n.stateNode.nextSibling) : null; return !0 } function Hg() { for (var n = rl; n;)n = Lf(n.nextSibling) } function Ig() { rl = ra = null, ro = !1 } function Jg(n) { null === ru ? ru = [n] : ru.push(n) } var rs = ef.ReactCurrentBatchConfig; function Lg(n, a) { if (n && n.defaultProps) for (var o in a = eN({}, a), n = n.defaultProps) void 0 === a[o] && (a[o] = n[o]); return a } var rf = Uf(null), rp = null, rg = null, rm = null; function Qg() { rm = rg = rp = null } function Rg(n) { var a = rf.current; E(rf), n._currentValue = a } function Sg(n, a, o) { for (; null !== n;) { var i = n.alternate; if ((n.childLanes & a) !== a ? (n.childLanes |= a, null !== i && (i.childLanes |= a)) : null !== i && (i.childLanes & a) !== a && (i.childLanes |= a), n === o) break; n = n.return } } function Tg(n, a) { rp = n, rm = rg = null, null !== (n = n.dependencies) && null !== n.firstContext && (0 != (n.lanes & a) && (rq = !0), n.firstContext = null) } function Vg(n) { var a = n._currentValue; if (rm !== n) { if (n = { context: n, memoizedValue: a, next: null }, null === rg) { if (null === rp) throw Error(p(308)); rg = n, rp.dependencies = { lanes: 0, firstContext: n } } else rg = rg.next = n } return a } var rv = null; function Xg(n) { null === rv ? rv = [n] : rv.push(n) } function Yg(n, a, o, i) { var s = a.interleaved; return null === s ? (o.next = o, Xg(a)) : (o.next = s.next, s.next = o), a.interleaved = o, Zg(n, i) } function Zg(n, a) { n.lanes |= a; var o = n.alternate; for (null !== o && (o.lanes |= a), o = n, n = n.return; null !== n;)n.childLanes |= a, null !== (o = n.alternate) && (o.childLanes |= a), o = n, n = n.return; return 3 === o.tag ? o.stateNode : null } var ry = !1; function ah(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function bh(n, a) { n = n.updateQueue, a.updateQueue === n && (a.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function ch(n, a) { return { eventTime: n, lane: a, tag: 0, payload: null, callback: null, next: null } } function dh(n, a, o) { var i = n.updateQueue; if (null === i) return null; if (i = i.shared, 0 != (2 & r8)) { var s = i.pending; return null === s ? a.next = a : (a.next = s.next, s.next = a), i.pending = a, Zg(n, o) } return null === (s = i.interleaved) ? (a.next = a, Xg(i)) : (a.next = s.next, s.next = a), i.interleaved = a, Zg(n, o) } function eh(n, a, o) { if (null !== (a = a.updateQueue) && (a = a.shared, 0 != (4194240 & o))) { var i = a.lanes; i &= n.pendingLanes, o |= i, a.lanes = o, Cc(n, o) } } function fh(n, a) { var o = n.updateQueue, i = n.alternate; if (null !== i && o === (i = i.updateQueue)) { var s = null, _ = null; if (null !== (o = o.firstBaseUpdate)) { do { var N = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null }; null === _ ? s = _ = N : _ = _.next = N, o = o.next } while (null !== o); null === _ ? s = _ = a : _ = _.next = a } else s = _ = a; o = { baseState: i.baseState, firstBaseUpdate: s, lastBaseUpdate: _, shared: i.shared, effects: i.effects }, n.updateQueue = o; return } null === (n = o.lastBaseUpdate) ? o.firstBaseUpdate = a : n.next = a, o.lastBaseUpdate = a } function gh(n, a, o, i) { var s = n.updateQueue; ry = !1; var _ = s.firstBaseUpdate, N = s.lastBaseUpdate, z = s.shared.pending; if (null !== z) { s.shared.pending = null; var j = z, B = j.next; j.next = null, null === N ? _ = B : N.next = B, N = j; var $ = n.alternate; null !== $ && (z = ($ = $.updateQueue).lastBaseUpdate) !== N && (null === z ? $.firstBaseUpdate = B : z.next = B, $.lastBaseUpdate = j) } if (null !== _) { var ee = s.baseState; for (N = 0, $ = B = j = null, z = _; ;) { var et = z.lane, en = z.eventTime; if ((i & et) === et) { null !== $ && ($ = $.next = { eventTime: en, lane: 0, tag: z.tag, payload: z.payload, callback: z.callback, next: null }); e: { var er = n, ea = z; switch (et = a, en = o, ea.tag) { case 1: if ("function" == typeof (er = ea.payload)) { ee = er.call(en, ee, et); break e } ee = er; break e; case 3: er.flags = -65537 & er.flags | 128; case 0: if (null == (et = "function" == typeof (er = ea.payload) ? er.call(en, ee, et) : er)) break e; ee = eN({}, ee, et); break e; case 2: ry = !0 } } null !== z.callback && 0 !== z.lane && (n.flags |= 64, null === (et = s.effects) ? s.effects = [z] : et.push(z)) } else en = { eventTime: en, lane: et, tag: z.tag, payload: z.payload, callback: z.callback, next: null }, null === $ ? (B = $ = en, j = ee) : $ = $.next = en, N |= et; if (null === (z = z.next)) { if (null === (z = s.shared.pending)) break; z = (et = z).next, et.next = null, s.lastBaseUpdate = et, s.shared.pending = null } } if (null === $ && (j = ee), s.baseState = j, s.firstBaseUpdate = B, s.lastBaseUpdate = $, null !== (a = s.shared.interleaved)) { s = a; do N |= s.lane, s = s.next; while (s !== a) } else null === _ && (s.shared.lanes = 0); aa |= N, n.lanes = N, n.memoizedState = ee } } function ih(n, a, o) { if (n = a.effects, a.effects = null, null !== n) for (a = 0; a < n.length; a++) { var i = n[a], s = i.callback; if (null !== s) { if (i.callback = null, i = o, "function" != typeof s) throw Error(p(191, s)); s.call(i) } } } var rk = (new B.Component).refs; function kh(n, a, o, i) { o = null == (o = o(i, a = n.memoizedState)) ? a : eN({}, a, o), n.memoizedState = o, 0 === n.lanes && (n.updateQueue.baseState = o) } var rw = { isMounted: function (n) { return !!(n = n._reactInternals) && Vb(n) === n }, enqueueSetState: function (n, a, o) { n = n._reactInternals; var i = L(), s = lh(n), _ = ch(i, s); _.payload = a, null != o && (_.callback = o), null !== (a = dh(n, _, s)) && (mh(a, n, s, i), eh(a, n, s)) }, enqueueReplaceState: function (n, a, o) { n = n._reactInternals; var i = L(), s = lh(n), _ = ch(i, s); _.tag = 1, _.payload = a, null != o && (_.callback = o), null !== (a = dh(n, _, s)) && (mh(a, n, s, i), eh(a, n, s)) }, enqueueForceUpdate: function (n, a) { n = n._reactInternals; var o = L(), i = lh(n), s = ch(o, i); s.tag = 2, null != a && (s.callback = a), null !== (a = dh(n, s, i)) && (mh(a, n, i, o), eh(a, n, i)) } }; function oh(n, a, o, i, s, _, N) { return "function" == typeof (n = n.stateNode).shouldComponentUpdate ? n.shouldComponentUpdate(i, _, N) : !a.prototype || !a.prototype.isPureReactComponent || !Ie(o, i) || !Ie(s, _) } function ph(n, a, o) { var i = !1, s = nX, _ = a.contextType; return "object" == typeof _ && null !== _ ? _ = Vg(_) : (s = Zf(a) ? n0 : nK.current, _ = (i = null != (i = a.contextTypes)) ? Yf(n, s) : nX), a = new a(o, _), n.memoizedState = null !== a.state && void 0 !== a.state ? a.state : null, a.updater = rw, n.stateNode = a, a._reactInternals = n, i && ((n = n.stateNode).__reactInternalMemoizedUnmaskedChildContext = s, n.__reactInternalMemoizedMaskedChildContext = _), a } function qh(n, a, o, i) { n = a.state, "function" == typeof a.componentWillReceiveProps && a.componentWillReceiveProps(o, i), "function" == typeof a.UNSAFE_componentWillReceiveProps && a.UNSAFE_componentWillReceiveProps(o, i), a.state !== n && rw.enqueueReplaceState(a, a.state, null) } function rh(n, a, o, i) { var s = n.stateNode; s.props = o, s.state = n.memoizedState, s.refs = rk, ah(n); var _ = a.contextType; "object" == typeof _ && null !== _ ? s.context = Vg(_) : (_ = Zf(a) ? n0 : nK.current, s.context = Yf(n, _)), s.state = n.memoizedState, "function" == typeof (_ = a.getDerivedStateFromProps) && (kh(n, a, _, o), s.state = n.memoizedState), "function" == typeof a.getDerivedStateFromProps || "function" == typeof s.getSnapshotBeforeUpdate || "function" != typeof s.UNSAFE_componentWillMount && "function" != typeof s.componentWillMount || (a = s.state, "function" == typeof s.componentWillMount && s.componentWillMount(), "function" == typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount(), a !== s.state && rw.enqueueReplaceState(s, s.state, null), gh(n, o, s, i), s.state = n.memoizedState), "function" == typeof s.componentDidMount && (n.flags |= 4194308) } function sh(n, a, o) { if (null !== (n = o.ref) && "function" != typeof n && "object" != typeof n) { if (o._owner) { if (o = o._owner) { if (1 !== o.tag) throw Error(p(309)); var i = o.stateNode } if (!i) throw Error(p(147, n)); var s = i, _ = "" + n; return null !== a && null !== a.ref && "function" == typeof a.ref && a.ref._stringRef === _ ? a.ref : ((a = function (n) { var a = s.refs; a === rk && (a = s.refs = {}), null === n ? delete a[_] : a[_] = n })._stringRef = _, a) } if ("string" != typeof n) throw Error(p(284)); if (!o._owner) throw Error(p(290, n)) } return n } function th(n, a) { throw Error(p(31, "[object Object]" === (n = Object.prototype.toString.call(a)) ? "object with keys {" + Object.keys(a).join(", ") + "}" : n)) } function uh(n) { return (0, n._init)(n._payload) } function vh(n) { function b(a, o) { if (n) { var i = a.deletions; null === i ? (a.deletions = [o], a.flags |= 16) : i.push(o) } } function c(a, o) { if (!n) return null; for (; null !== o;)b(a, o), o = o.sibling; return null } function d(n, a) { for (n = new Map; null !== a;)null !== a.key ? n.set(a.key, a) : n.set(a.index, a), a = a.sibling; return n } function e(n, a) { return (n = wh(n, a)).index = 0, n.sibling = null, n } function f(a, o, i) { return (a.index = i, n) ? null !== (i = a.alternate) ? (i = i.index) < o ? (a.flags |= 2, o) : i : (a.flags |= 2, o) : (a.flags |= 1048576, o) } function g(a) { return n && null === a.alternate && (a.flags |= 2), a } function h(n, a, o, i) { return null === a || 6 !== a.tag ? (a = xh(o, n.mode, i)).return = n : (a = e(a, o)).return = n, a } function k(n, a, o, i) { var s = o.type; return s === em ? m(n, a, o.props.children, i, o.key) : (null !== a && (a.elementType === s || "object" == typeof s && null !== s && s.$$typeof === eT && uh(s) === a.type) ? (i = e(a, o.props)).ref = sh(n, a, o) : (i = yh(o.type, o.key, o.props, null, n.mode, i)).ref = sh(n, a, o), i.return = n, i) } function l(n, a, o, i) { return null === a || 4 !== a.tag || a.stateNode.containerInfo !== o.containerInfo || a.stateNode.implementation !== o.implementation ? (a = zh(o, n.mode, i)).return = n : (a = e(a, o.children || [])).return = n, a } function m(n, a, o, i, s) { return null === a || 7 !== a.tag ? (a = Ah(o, n.mode, i, s)).return = n : (a = e(a, o)).return = n, a } function q(n, a, o) { if ("string" == typeof a && "" !== a || "number" == typeof a) return (a = xh("" + a, n.mode, o)).return = n, a; if ("object" == typeof a && null !== a) { switch (a.$$typeof) { case ep: return (o = yh(a.type, a.key, a.props, null, n.mode, o)).ref = sh(n, null, a), o.return = n, o; case eg: return (a = zh(a, n.mode, o)).return = n, a; case eT: return q(n, (0, a._init)(a._payload), o) }if (eL(a) || Ka(a)) return (a = Ah(a, n.mode, o, null)).return = n, a; th(n, a) } return null } function r(n, a, o, i) { var s = null !== a ? a.key : null; if ("string" == typeof o && "" !== o || "number" == typeof o) return null !== s ? null : h(n, a, "" + o, i); if ("object" == typeof o && null !== o) { switch (o.$$typeof) { case ep: return o.key === s ? k(n, a, o, i) : null; case eg: return o.key === s ? l(n, a, o, i) : null; case eT: return r(n, a, (s = o._init)(o._payload), i) }if (eL(o) || Ka(o)) return null !== s ? null : m(n, a, o, i, null); th(n, o) } return null } function y(n, a, o, i, s) { if ("string" == typeof i && "" !== i || "number" == typeof i) return h(a, n = n.get(o) || null, "" + i, s); if ("object" == typeof i && null !== i) { switch (i.$$typeof) { case ep: return k(a, n = n.get(null === i.key ? o : i.key) || null, i, s); case eg: return l(a, n = n.get(null === i.key ? o : i.key) || null, i, s); case eT: return y(n, a, o, (0, i._init)(i._payload), s) }if (eL(i) || Ka(i)) return m(a, n = n.get(o) || null, i, s, null); th(a, i) } return null } return function J(a, o, i, s) { if ("object" == typeof i && null !== i && i.type === em && null === i.key && (i = i.props.children), "object" == typeof i && null !== i) { switch (i.$$typeof) { case ep: e: { for (var _ = i.key, N = o; null !== N;) { if (N.key === _) { if ((_ = i.type) === em) { if (7 === N.tag) { c(a, N.sibling), (o = e(N, i.props.children)).return = a, a = o; break e } } else if (N.elementType === _ || "object" == typeof _ && null !== _ && _.$$typeof === eT && uh(_) === N.type) { c(a, N.sibling), (o = e(N, i.props)).ref = sh(a, N, i), o.return = a, a = o; break e } c(a, N); break } b(a, N), N = N.sibling } i.type === em ? ((o = Ah(i.props.children, a.mode, s, i.key)).return = a, a = o) : ((s = yh(i.type, i.key, i.props, null, a.mode, s)).ref = sh(a, o, i), s.return = a, a = s) } return g(a); case eg: e: { for (N = i.key; null !== o;) { if (o.key === N) { if (4 === o.tag && o.stateNode.containerInfo === i.containerInfo && o.stateNode.implementation === i.implementation) { c(a, o.sibling), (o = e(o, i.children || [])).return = a, a = o; break e } c(a, o); break } b(a, o), o = o.sibling } (o = zh(i, a.mode, s)).return = a, a = o } return g(a); case eT: return J(a, o, (N = i._init)(i._payload), s) }if (eL(i)) return function (a, o, i, s) { for (var _ = null, N = null, z = o, j = o = 0, B = null; null !== z && j < i.length; j++) { z.index > j ? (B = z, z = null) : B = z.sibling; var $ = r(a, z, i[j], s); if (null === $) { null === z && (z = B); break } n && z && null === $.alternate && b(a, z), o = f($, o, j), null === N ? _ = $ : N.sibling = $, N = $, z = B } if (j === i.length) return c(a, z), ro && tg(a, j), _; if (null === z) { for (; j < i.length; j++)null !== (z = q(a, i[j], s)) && (o = f(z, o, j), null === N ? _ = z : N.sibling = z, N = z); return ro && tg(a, j), _ } for (z = d(a, z); j < i.length; j++)null !== (B = y(z, a, j, i[j], s)) && (n && null !== B.alternate && z.delete(null === B.key ? j : B.key), o = f(B, o, j), null === N ? _ = B : N.sibling = B, N = B); return n && z.forEach(function (n) { return b(a, n) }), ro && tg(a, j), _ }(a, o, i, s); if (Ka(i)) return function (a, o, i, s) { var _ = Ka(i); if ("function" != typeof _) throw Error(p(150)); if (null == (i = _.call(i))) throw Error(p(151)); for (var N = _ = null, z = o, j = o = 0, B = null, $ = i.next(); null !== z && !$.done; j++, $ = i.next()) { z.index > j ? (B = z, z = null) : B = z.sibling; var ee = r(a, z, $.value, s); if (null === ee) { null === z && (z = B); break } n && z && null === ee.alternate && b(a, z), o = f(ee, o, j), null === N ? _ = ee : N.sibling = ee, N = ee, z = B } if ($.done) return c(a, z), ro && tg(a, j), _; if (null === z) { for (; !$.done; j++, $ = i.next())null !== ($ = q(a, $.value, s)) && (o = f($, o, j), null === N ? _ = $ : N.sibling = $, N = $); return ro && tg(a, j), _ } for (z = d(a, z); !$.done; j++, $ = i.next())null !== ($ = y(z, a, j, $.value, s)) && (n && null !== $.alternate && z.delete(null === $.key ? j : $.key), o = f($, o, j), null === N ? _ = $ : N.sibling = $, N = $); return n && z.forEach(function (n) { return b(a, n) }), ro && tg(a, j), _ }(a, o, i, s); th(a, i) } return "string" == typeof i && "" !== i || "number" == typeof i ? (i = "" + i, null !== o && 6 === o.tag ? (c(a, o.sibling), (o = e(o, i)).return = a) : (c(a, o), (o = xh(i, a.mode, s)).return = a), g(a = o)) : c(a, o) } } var rS = vh(!0), rx = vh(!1), rE = {}, rC = Uf(rE), r_ = Uf(rE), rT = Uf(rE); function Hh(n) { if (n === rE) throw Error(p(174)); return n } function Ih(n, a) { switch (G(rT, a), G(r_, n), G(rC, rE), n = a.nodeType) { case 9: case 11: a = (a = a.documentElement) ? a.namespaceURI : lb(null, ""); break; default: a = lb(a = (n = 8 === n ? a.parentNode : a).namespaceURI || null, n = n.tagName) }E(rC), G(rC, a) } function Jh() { E(rC), E(r_), E(rT) } function Kh(n) { Hh(rT.current); var a = Hh(rC.current), o = lb(a, n.type); a !== o && (G(r_, n), G(rC, o)) } function Lh(n) { r_.current === n && (E(rC), E(r_)) } var rP = Uf(0); function Mh(n) { for (var a = n; null !== a;) { if (13 === a.tag) { var o = a.memoizedState; if (null !== o && (null === (o = o.dehydrated) || "$?" === o.data || "$!" === o.data)) return a } else if (19 === a.tag && void 0 !== a.memoizedProps.revealOrder) { if (0 != (128 & a.flags)) return a } else if (null !== a.child) { a.child.return = a, a = a.child; continue } if (a === n) break; for (; null === a.sibling;) { if (null === a.return || a.return === n) return null; a = a.return } a.sibling.return = a.return, a = a.sibling } return null } var rF = []; function Oh() { for (var n = 0; n < rF.length; n++)rF[n]._workInProgressVersionPrimary = null; rF.length = 0 } var rR = ef.ReactCurrentDispatcher, rN = ef.ReactCurrentBatchConfig, rz = 0, rL = null, rM = null, rD = null, rI = !1, rO = !1, rV = 0, rB = 0; function Q() { throw Error(p(321)) } function Wh(n, a) { if (null === a) return !1; for (var o = 0; o < a.length && o < n.length; o++)if (!nh(n[o], a[o])) return !1; return !0 } function Xh(n, a, o, i, s, _) { if (rz = _, rL = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, rR.current = null === n || null === n.memoizedState ? rU : r$, n = o(i, s), rO) { _ = 0; do { if (rO = !1, rV = 0, 25 <= _) throw Error(p(301)); _ += 1, rD = rM = null, a.updateQueue = null, rR.current = rW, n = o(i, s) } while (rO) } if (rR.current = rA, a = null !== rM && null !== rM.next, rz = 0, rD = rM = rL = null, rI = !1, a) throw Error(p(300)); return n } function bi() { var n = 0 !== rV; return rV = 0, n } function ci() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === rD ? rL.memoizedState = rD = n : rD = rD.next = n, rD } function di() { if (null === rM) { var n = rL.alternate; n = null !== n ? n.memoizedState : null } else n = rM.next; var a = null === rD ? rL.memoizedState : rD.next; if (null !== a) rD = a, rM = n; else { if (null === n) throw Error(p(310)); n = { memoizedState: (rM = n).memoizedState, baseState: rM.baseState, baseQueue: rM.baseQueue, queue: rM.queue, next: null }, null === rD ? rL.memoizedState = rD = n : rD = rD.next = n } return rD } function ei(n, a) { return "function" == typeof a ? a(n) : a } function fi(n) { var a = di(), o = a.queue; if (null === o) throw Error(p(311)); o.lastRenderedReducer = n; var i = rM, s = i.baseQueue, _ = o.pending; if (null !== _) { if (null !== s) { var N = s.next; s.next = _.next, _.next = N } i.baseQueue = s = _, o.pending = null } if (null !== s) { _ = s.next, i = i.baseState; var z = N = null, j = null, B = _; do { var $ = B.lane; if ((rz & $) === $) null !== j && (j = j.next = { lane: 0, action: B.action, hasEagerState: B.hasEagerState, eagerState: B.eagerState, next: null }), i = B.hasEagerState ? B.eagerState : n(i, B.action); else { var ee = { lane: $, action: B.action, hasEagerState: B.hasEagerState, eagerState: B.eagerState, next: null }; null === j ? (z = j = ee, N = i) : j = j.next = ee, rL.lanes |= $, aa |= $ } B = B.next } while (null !== B && B !== _); null === j ? N = i : j.next = z, nh(i, a.memoizedState) || (rq = !0), a.memoizedState = i, a.baseState = N, a.baseQueue = j, o.lastRenderedState = i } if (null !== (n = o.interleaved)) { s = n; do _ = s.lane, rL.lanes |= _, aa |= _, s = s.next; while (s !== n) } else null === s && (o.lanes = 0); return [a.memoizedState, o.dispatch] } function gi(n) { var a = di(), o = a.queue; if (null === o) throw Error(p(311)); o.lastRenderedReducer = n; var i = o.dispatch, s = o.pending, _ = a.memoizedState; if (null !== s) { o.pending = null; var N = s = s.next; do _ = n(_, N.action), N = N.next; while (N !== s); nh(_, a.memoizedState) || (rq = !0), a.memoizedState = _, null === a.baseQueue && (a.baseState = _), o.lastRenderedState = _ } return [_, i] } function hi() { } function ii(n, a) { var o = rL, i = di(), s = a(), _ = !nh(i.memoizedState, s); if (_ && (i.memoizedState = s, rq = !0), i = i.queue, ji(ki.bind(null, o, i, n), [n]), i.getSnapshot !== a || _ || null !== rD && 1 & rD.memoizedState.tag) { if (o.flags |= 2048, li(9, mi.bind(null, o, i, s, a), void 0, null), null === r5) throw Error(p(349)); 0 != (30 & rz) || ni(o, a, s) } return s } function ni(n, a, o) { n.flags |= 16384, n = { getSnapshot: a, value: o }, null === (a = rL.updateQueue) ? (a = { lastEffect: null, stores: null }, rL.updateQueue = a, a.stores = [n]) : null === (o = a.stores) ? a.stores = [n] : o.push(n) } function mi(n, a, o, i) { a.value = o, a.getSnapshot = i, oi(a) && pi(n) } function ki(n, a, o) { return o(function () { oi(a) && pi(n) }) } function oi(n) { var a = n.getSnapshot; n = n.value; try { var o = a(); return !nh(n, o) } catch (n) { return !0 } } function pi(n) { var a = Zg(n, 1); null !== a && mh(a, n, 1, -1) } function qi(n) { var a = ci(); return "function" == typeof n && (n = n()), a.memoizedState = a.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: n }, a.queue = n, n = n.dispatch = ri.bind(null, rL, n), [a.memoizedState, n] } function li(n, a, o, i) { return n = { tag: n, create: a, destroy: o, deps: i, next: null }, null === (a = rL.updateQueue) ? (a = { lastEffect: null, stores: null }, rL.updateQueue = a, a.lastEffect = n.next = n) : null === (o = a.lastEffect) ? a.lastEffect = n.next = n : (i = o.next, o.next = n, n.next = i, a.lastEffect = n), n } function si() { return di().memoizedState } function ti(n, a, o, i) { var s = ci(); rL.flags |= n, s.memoizedState = li(1 | a, o, void 0, void 0 === i ? null : i) } function ui(n, a, o, i) { var s = di(); i = void 0 === i ? null : i; var _ = void 0; if (null !== rM) { var N = rM.memoizedState; if (_ = N.destroy, null !== i && Wh(i, N.deps)) { s.memoizedState = li(a, o, _, i); return } } rL.flags |= n, s.memoizedState = li(1 | a, o, _, i) } function vi(n, a) { return ti(8390656, 8, n, a) } function ji(n, a) { return ui(2048, 8, n, a) } function wi(n, a) { return ui(4, 2, n, a) } function xi(n, a) { return ui(4, 4, n, a) } function yi(n, a) { return "function" == typeof a ? (a(n = n()), function () { a(null) }) : null != a ? (n = n(), a.current = n, function () { a.current = null }) : void 0 } function zi(n, a, o) { return o = null != o ? o.concat([n]) : null, ui(4, 4, yi.bind(null, a, n), o) } function Ai() { } function Bi(n, a) { var o = di(); a = void 0 === a ? null : a; var i = o.memoizedState; return null !== i && null !== a && Wh(a, i[1]) ? i[0] : (o.memoizedState = [n, a], n) } function Ci(n, a) { var o = di(); a = void 0 === a ? null : a; var i = o.memoizedState; return null !== i && null !== a && Wh(a, i[1]) ? i[0] : (n = n(), o.memoizedState = [n, a], n) } function Di(n, a, o) { return 0 == (21 & rz) ? (n.baseState && (n.baseState = !1, rq = !0), n.memoizedState = o) : (nh(o, a) || (o = yc(), rL.lanes |= o, aa |= o, n.baseState = !0), a) } function Ei(n, a) { var o = td; td = 0 !== o && 4 > o ? o : 4, n(!0); var i = rN.transition; rN.transition = {}; try { n(!1), a() } finally { td = o, rN.transition = i } } function Fi() { return di().memoizedState } function Gi(n, a, o) { var i = lh(n); o = { lane: i, action: o, hasEagerState: !1, eagerState: null, next: null }, Hi(n) ? Ii(a, o) : null !== (o = Yg(n, a, o, i)) && (mh(o, n, i, L()), Ji(o, a, i)) } function ri(n, a, o) { var i = lh(n), s = { lane: i, action: o, hasEagerState: !1, eagerState: null, next: null }; if (Hi(n)) Ii(a, s); else { var _ = n.alternate; if (0 === n.lanes && (null === _ || 0 === _.lanes) && null !== (_ = a.lastRenderedReducer)) try { var N = a.lastRenderedState, z = _(N, o); if (s.hasEagerState = !0, s.eagerState = z, nh(z, N)) { var j = a.interleaved; null === j ? (s.next = s, Xg(a)) : (s.next = j.next, j.next = s), a.interleaved = s; return } } catch (n) { } finally { } null !== (o = Yg(n, a, s, i)) && (mh(o, n, i, s = L()), Ji(o, a, i)) } } function Hi(n) { var a = n.alternate; return n === rL || null !== a && a === rL } function Ii(n, a) { rO = rI = !0; var o = n.pending; null === o ? a.next = a : (a.next = o.next, o.next = a), n.pending = a } function Ji(n, a, o) { if (0 != (4194240 & o)) { var i = a.lanes; i &= n.pendingLanes, o |= i, a.lanes = o, Cc(n, o) } } var rA = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: !1 }, rU = { readContext: Vg, useCallback: function (n, a) { return ci().memoizedState = [n, void 0 === a ? null : a], n }, useContext: Vg, useEffect: vi, useImperativeHandle: function (n, a, o) { return o = null != o ? o.concat([n]) : null, ti(4194308, 4, yi.bind(null, a, n), o) }, useLayoutEffect: function (n, a) { return ti(4194308, 4, n, a) }, useInsertionEffect: function (n, a) { return ti(4, 2, n, a) }, useMemo: function (n, a) { var o = ci(); return a = void 0 === a ? null : a, n = n(), o.memoizedState = [n, a], n }, useReducer: function (n, a, o) { var i = ci(); return a = void 0 !== o ? o(a) : a, i.memoizedState = i.baseState = a, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: a }, i.queue = n, n = n.dispatch = Gi.bind(null, rL, n), [i.memoizedState, n] }, useRef: function (n) { return n = { current: n }, ci().memoizedState = n }, useState: qi, useDebugValue: Ai, useDeferredValue: function (n) { return ci().memoizedState = n }, useTransition: function () { var n = qi(!1), a = n[0]; return n = Ei.bind(null, n[1]), ci().memoizedState = n, [a, n] }, useMutableSource: function () { }, useSyncExternalStore: function (n, a, o) { var i = rL, s = ci(); if (ro) { if (void 0 === o) throw Error(p(407)); o = o() } else { if (o = a(), null === r5) throw Error(p(349)); 0 != (30 & rz) || ni(i, a, o) } s.memoizedState = o; var _ = { value: o, getSnapshot: a }; return s.queue = _, vi(ki.bind(null, i, _, n), [n]), i.flags |= 2048, li(9, mi.bind(null, i, _, o, a), void 0, null), o }, useId: function () { var n = ci(), a = r5.identifierPrefix; if (ro) { var o = rr, i = rn; a = ":" + a + "R" + (o = (i & ~(1 << 32 - tr(i) - 1)).toString(32) + o), 0 < (o = rV++) && (a += "H" + o.toString(32)), a += ":" } else a = ":" + a + "r" + (o = rB++).toString(32) + ":"; return n.memoizedState = a }, unstable_isNewReconciler: !1 }, r$ = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: fi, useRef: si, useState: function () { return fi(ei) }, useDebugValue: Ai, useDeferredValue: function (n) { return Di(di(), rM.memoizedState, n) }, useTransition: function () { return [fi(ei)[0], di().memoizedState] }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: !1 }, rW = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function () { return gi(ei) }, useDebugValue: Ai, useDeferredValue: function (n) { var a = di(); return null === rM ? a.memoizedState = n : Di(a, rM.memoizedState, n) }, useTransition: function () { return [gi(ei)[0], di().memoizedState] }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: !1 }; function Ki(n, a) { try { var o = "", i = a; do o += function (n) { switch (n.tag) { case 5: return Ma(n.type); case 16: return Ma("Lazy"); case 13: return Ma("Suspense"); case 19: return Ma("SuspenseList"); case 0: case 2: case 15: return n = Oa(n.type, !1); case 11: return n = Oa(n.type.render, !1); case 1: return n = Oa(n.type, !0); default: return "" } }(i), i = i.return; while (i); var s = o } catch (n) { s = "\nError generating stack: " + n.message + "\n" + n.stack } return { value: n, source: a, stack: s, digest: null } } function Li(n, a, o) { return { value: n, source: null, stack: null != o ? o : null, digest: null != a ? a : null } } function Mi(n, a) { try { console.error(a.value) } catch (n) { setTimeout(function () { throw n }) } } var rH = "function" == typeof WeakMap ? WeakMap : Map; function Oi(n, a, o) { (o = ch(-1, o)).tag = 3, o.payload = { element: null }; var i = a.value; return o.callback = function () { am || (am = !0, av = i), Mi(n, a) }, o } function Ri(n, a, o) { (o = ch(-1, o)).tag = 3; var i = n.type.getDerivedStateFromError; if ("function" == typeof i) { var s = a.value; o.payload = function () { return i(s) }, o.callback = function () { Mi(n, a) } } var _ = n.stateNode; return null !== _ && "function" == typeof _.componentDidCatch && (o.callback = function () { Mi(n, a), "function" != typeof i && (null === ay ? ay = new Set([this]) : ay.add(this)); var o = a.stack; this.componentDidCatch(a.value, { componentStack: null !== o ? o : "" }) }), o } function Ti(n, a, o) { var i = n.pingCache; if (null === i) { i = n.pingCache = new rH; var s = new Set; i.set(a, s) } else void 0 === (s = i.get(a)) && (s = new Set, i.set(a, s)); s.has(o) || (s.add(o), n = Ui.bind(null, n, a, o), a.then(n, n)) } function Vi(n) { do { var a; if ((a = 13 === n.tag) && (a = null === (a = n.memoizedState) || null !== a.dehydrated), a) return n; n = n.return } while (null !== n); return null } function Wi(n, a, o, i, s) { return 0 == (1 & n.mode) ? n === a ? n.flags |= 65536 : (n.flags |= 128, o.flags |= 131072, o.flags &= -52805, 1 === o.tag && (null === o.alternate ? o.tag = 17 : ((a = ch(-1, 1)).tag = 2, dh(o, a, 1))), o.lanes |= 1) : (n.flags |= 65536, n.lanes = s), n } var rQ = ef.ReactCurrentOwner, rq = !1; function Yi(n, a, o, i) { a.child = null === n ? rx(a, null, o, i) : rS(a, n.child, o, i) } function Zi(n, a, o, i, s) { o = o.render; var _ = a.ref; return (Tg(a, s), i = Xh(n, a, o, i, _, s), o = bi(), null === n || rq) ? (ro && o && vg(a), a.flags |= 1, Yi(n, a, i, s), a.child) : (a.updateQueue = n.updateQueue, a.flags &= -2053, n.lanes &= ~s, $i(n, a, s)) } function aj(n, a, o, i, s) { if (null === n) { var _ = o.type; return "function" != typeof _ || bj(_) || void 0 !== _.defaultProps || null !== o.compare || void 0 !== o.defaultProps ? ((n = yh(o.type, null, i, a, a.mode, s)).ref = a.ref, n.return = a, a.child = n) : (a.tag = 15, a.type = _, cj(n, a, _, i, s)) } if (_ = n.child, 0 == (n.lanes & s)) { var N = _.memoizedProps; if ((o = null !== (o = o.compare) ? o : Ie)(N, i) && n.ref === a.ref) return $i(n, a, s) } return a.flags |= 1, (n = wh(_, i)).ref = a.ref, n.return = a, a.child = n } function cj(n, a, o, i, s) { if (null !== n) { var _ = n.memoizedProps; if (Ie(_, i) && n.ref === a.ref) { if (rq = !1, a.pendingProps = i = _, 0 == (n.lanes & s)) return a.lanes = n.lanes, $i(n, a, s); 0 != (131072 & n.flags) && (rq = !0) } } return dj(n, a, o, i, s) } function ej(n, a, o) { var i = a.pendingProps, s = i.children, _ = null !== n ? n.memoizedState : null; if ("hidden" === i.mode) { if (0 == (1 & a.mode)) a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(at, ae), ae |= o; else { if (0 == (1073741824 & o)) return n = null !== _ ? _.baseLanes | o : o, a.lanes = a.childLanes = 1073741824, a.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, a.updateQueue = null, G(at, ae), ae |= n, null; a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = null !== _ ? _.baseLanes : o, G(at, ae), ae |= i } } else null !== _ ? (i = _.baseLanes | o, a.memoizedState = null) : i = o, G(at, ae), ae |= i; return Yi(n, a, s, o), a.child } function hj(n, a) { var o = a.ref; (null === n && null !== o || null !== n && n.ref !== o) && (a.flags |= 512, a.flags |= 2097152) } function dj(n, a, o, i, s) { var _ = Zf(o) ? n0 : nK.current; return (_ = Yf(a, _), Tg(a, s), o = Xh(n, a, o, i, _, s), i = bi(), null === n || rq) ? (ro && i && vg(a), a.flags |= 1, Yi(n, a, o, s), a.child) : (a.updateQueue = n.updateQueue, a.flags &= -2053, n.lanes &= ~s, $i(n, a, s)) } function ij(n, a, o, i, s) { if (Zf(o)) { var _ = !0; cg(a) } else _ = !1; if (Tg(a, s), null === a.stateNode) jj(n, a), ph(a, o, i), rh(a, o, i, s), i = !0; else if (null === n) { var N = a.stateNode, z = a.memoizedProps; N.props = z; var j = N.context, B = o.contextType; B = "object" == typeof B && null !== B ? Vg(B) : Yf(a, B = Zf(o) ? n0 : nK.current); var $ = o.getDerivedStateFromProps, ee = "function" == typeof $ || "function" == typeof N.getSnapshotBeforeUpdate; ee || "function" != typeof N.UNSAFE_componentWillReceiveProps && "function" != typeof N.componentWillReceiveProps || (z !== i || j !== B) && qh(a, N, i, B), ry = !1; var et = a.memoizedState; N.state = et, gh(a, i, N, s), j = a.memoizedState, z !== i || et !== j || nJ.current || ry ? ("function" == typeof $ && (kh(a, o, $, i), j = a.memoizedState), (z = ry || oh(a, o, z, i, et, j, B)) ? (ee || "function" != typeof N.UNSAFE_componentWillMount && "function" != typeof N.componentWillMount || ("function" == typeof N.componentWillMount && N.componentWillMount(), "function" == typeof N.UNSAFE_componentWillMount && N.UNSAFE_componentWillMount()), "function" == typeof N.componentDidMount && (a.flags |= 4194308)) : ("function" == typeof N.componentDidMount && (a.flags |= 4194308), a.memoizedProps = i, a.memoizedState = j), N.props = i, N.state = j, N.context = B, i = z) : ("function" == typeof N.componentDidMount && (a.flags |= 4194308), i = !1) } else { N = a.stateNode, bh(n, a), z = a.memoizedProps, B = a.type === a.elementType ? z : Lg(a.type, z), N.props = B, ee = a.pendingProps, et = N.context, j = "object" == typeof (j = o.contextType) && null !== j ? Vg(j) : Yf(a, j = Zf(o) ? n0 : nK.current); var en = o.getDerivedStateFromProps; ($ = "function" == typeof en || "function" == typeof N.getSnapshotBeforeUpdate) || "function" != typeof N.UNSAFE_componentWillReceiveProps && "function" != typeof N.componentWillReceiveProps || (z !== ee || et !== j) && qh(a, N, i, j), ry = !1, et = a.memoizedState, N.state = et, gh(a, i, N, s); var er = a.memoizedState; z !== ee || et !== er || nJ.current || ry ? ("function" == typeof en && (kh(a, o, en, i), er = a.memoizedState), (B = ry || oh(a, o, B, i, et, er, j) || !1) ? ($ || "function" != typeof N.UNSAFE_componentWillUpdate && "function" != typeof N.componentWillUpdate || ("function" == typeof N.componentWillUpdate && N.componentWillUpdate(i, er, j), "function" == typeof N.UNSAFE_componentWillUpdate && N.UNSAFE_componentWillUpdate(i, er, j)), "function" == typeof N.componentDidUpdate && (a.flags |= 4), "function" == typeof N.getSnapshotBeforeUpdate && (a.flags |= 1024)) : ("function" != typeof N.componentDidUpdate || z === n.memoizedProps && et === n.memoizedState || (a.flags |= 4), "function" != typeof N.getSnapshotBeforeUpdate || z === n.memoizedProps && et === n.memoizedState || (a.flags |= 1024), a.memoizedProps = i, a.memoizedState = er), N.props = i, N.state = er, N.context = j, i = B) : ("function" != typeof N.componentDidUpdate || z === n.memoizedProps && et === n.memoizedState || (a.flags |= 4), "function" != typeof N.getSnapshotBeforeUpdate || z === n.memoizedProps && et === n.memoizedState || (a.flags |= 1024), i = !1) } return kj(n, a, o, i, _, s) } function kj(n, a, o, i, s, _) { hj(n, a); var N = 0 != (128 & a.flags); if (!i && !N) return s && dg(a, o, !1), $i(n, a, _); i = a.stateNode, rQ.current = a; var z = N && "function" != typeof o.getDerivedStateFromError ? null : i.render(); return a.flags |= 1, null !== n && N ? (a.child = rS(a, n.child, null, _), a.child = rS(a, null, z, _)) : Yi(n, a, z, _), a.memoizedState = i.state, s && dg(a, o, !0), a.child } function lj(n) { var a = n.stateNode; a.pendingContext ? ag(n, a.pendingContext, a.pendingContext !== a.context) : a.context && ag(n, a.context, !1), Ih(n, a.containerInfo) } function mj(n, a, o, i, s) { return Ig(), Jg(s), a.flags |= 256, Yi(n, a, o, i), a.child } var rZ = { dehydrated: null, treeContext: null, retryLane: 0 }; function oj(n) { return { baseLanes: n, cachePool: null, transitions: null } } function pj(n, a, o) { var i, s = a.pendingProps, _ = rP.current, N = !1, z = 0 != (128 & a.flags); if ((i = z) || (i = (null === n || null !== n.memoizedState) && 0 != (2 & _)), i ? (N = !0, a.flags &= -129) : (null === n || null !== n.memoizedState) && (_ |= 1), G(rP, 1 & _), null === n) return (Eg(a), null !== (n = a.memoizedState) && null !== (n = n.dehydrated)) ? (0 == (1 & a.mode) ? a.lanes = 1 : "$!" === n.data ? a.lanes = 8 : a.lanes = 1073741824, null) : (z = s.children, n = s.fallback, N ? (s = a.mode, N = a.child, z = { mode: "hidden", children: z }, 0 == (1 & s) && null !== N ? (N.childLanes = 0, N.pendingProps = z) : N = qj(z, s, 0, null), n = Ah(n, s, o, null), N.return = a, n.return = a, N.sibling = n, a.child = N, a.child.memoizedState = oj(o), a.memoizedState = rZ, n) : rj(a, z)); if (null !== (_ = n.memoizedState) && null !== (i = _.dehydrated)) return function (n, a, o, i, s, _, N) { if (o) return 256 & a.flags ? (a.flags &= -257, tj(n, a, N, i = Li(Error(p(422))))) : null !== a.memoizedState ? (a.child = n.child, a.flags |= 128, null) : (_ = i.fallback, s = a.mode, i = qj({ mode: "visible", children: i.children }, s, 0, null), _ = Ah(_, s, N, null), _.flags |= 2, i.return = a, _.return = a, i.sibling = _, a.child = i, 0 != (1 & a.mode) && rS(a, n.child, null, N), a.child.memoizedState = oj(N), a.memoizedState = rZ, _); if (0 == (1 & a.mode)) return tj(n, a, N, null); if ("$!" === s.data) { if (i = s.nextSibling && s.nextSibling.dataset) var z = i.dgst; return i = z, tj(n, a, N, i = Li(_ = Error(p(419)), i, void 0)) } if (z = 0 != (N & n.childLanes), rq || z) { if (null !== (i = r5)) { switch (N & -N) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }0 !== (s = 0 != (s & (i.suspendedLanes | N)) ? 0 : s) && s !== _.retryLane && (_.retryLane = s, Zg(n, s), mh(i, n, s, -1)) } return uj(), tj(n, a, N, i = Li(Error(p(421)))) } return "$?" === s.data ? (a.flags |= 128, a.child = n.child, a = vj.bind(null, n), s._reactRetry = a, null) : (n = _.treeContext, rl = Lf(s.nextSibling), ra = a, ro = !0, ru = null, null !== n && (n9[n7++] = rn, n9[n7++] = rr, n9[n7++] = rt, rn = n.id, rr = n.overflow, rt = a), a = rj(a, i.children), a.flags |= 4096, a) }(n, a, z, s, i, _, o); if (N) { N = s.fallback, z = a.mode, i = (_ = n.child).sibling; var j = { mode: "hidden", children: s.children }; return 0 == (1 & z) && a.child !== _ ? ((s = a.child).childLanes = 0, s.pendingProps = j, a.deletions = null) : (s = wh(_, j)).subtreeFlags = 14680064 & _.subtreeFlags, null !== i ? N = wh(i, N) : (N = Ah(N, z, o, null), N.flags |= 2), N.return = a, s.return = a, s.sibling = N, a.child = s, s = N, N = a.child, z = null === (z = n.child.memoizedState) ? oj(o) : { baseLanes: z.baseLanes | o, cachePool: null, transitions: z.transitions }, N.memoizedState = z, N.childLanes = n.childLanes & ~o, a.memoizedState = rZ, s } return n = (N = n.child).sibling, s = wh(N, { mode: "visible", children: s.children }), 0 == (1 & a.mode) && (s.lanes = o), s.return = a, s.sibling = null, null !== n && (null === (o = a.deletions) ? (a.deletions = [n], a.flags |= 16) : o.push(n)), a.child = s, a.memoizedState = null, s } function rj(n, a) { return (a = qj({ mode: "visible", children: a }, n.mode, 0, null)).return = n, n.child = a } function tj(n, a, o, i) { return null !== i && Jg(i), rS(a, n.child, null, o), n = rj(a, a.pendingProps.children), n.flags |= 2, a.memoizedState = null, n } function wj(n, a, o) { n.lanes |= a; var i = n.alternate; null !== i && (i.lanes |= a), Sg(n.return, a, o) } function xj(n, a, o, i, s) { var _ = n.memoizedState; null === _ ? n.memoizedState = { isBackwards: a, rendering: null, renderingStartTime: 0, last: i, tail: o, tailMode: s } : (_.isBackwards = a, _.rendering = null, _.renderingStartTime = 0, _.last = i, _.tail = o, _.tailMode = s) } function yj(n, a, o) { var i = a.pendingProps, s = i.revealOrder, _ = i.tail; if (Yi(n, a, i.children, o), 0 != (2 & (i = rP.current))) i = 1 & i | 2, a.flags |= 128; else { if (null !== n && 0 != (128 & n.flags)) e: for (n = a.child; null !== n;) { if (13 === n.tag) null !== n.memoizedState && wj(n, o, a); else if (19 === n.tag) wj(n, o, a); else if (null !== n.child) { n.child.return = n, n = n.child; continue } if (n === a) break; for (; null === n.sibling;) { if (null === n.return || n.return === a) break e; n = n.return } n.sibling.return = n.return, n = n.sibling } i &= 1 } if (G(rP, i), 0 == (1 & a.mode)) a.memoizedState = null; else switch (s) { case "forwards": for (s = null, o = a.child; null !== o;)null !== (n = o.alternate) && null === Mh(n) && (s = o), o = o.sibling; null === (o = s) ? (s = a.child, a.child = null) : (s = o.sibling, o.sibling = null), xj(a, !1, s, o, _); break; case "backwards": for (o = null, s = a.child, a.child = null; null !== s;) { if (null !== (n = s.alternate) && null === Mh(n)) { a.child = s; break } n = s.sibling, s.sibling = o, o = s, s = n } xj(a, !0, o, null, _); break; case "together": xj(a, !1, null, null, void 0); break; default: a.memoizedState = null }return a.child } function jj(n, a) { 0 == (1 & a.mode) && null !== n && (n.alternate = null, a.alternate = null, a.flags |= 2) } function $i(n, a, o) { if (null !== n && (a.dependencies = n.dependencies), aa |= a.lanes, 0 == (o & a.childLanes)) return null; if (null !== n && a.child !== n.child) throw Error(p(153)); if (null !== a.child) { for (o = wh(n = a.child, n.pendingProps), a.child = o, o.return = a; null !== n.sibling;)n = n.sibling, (o = o.sibling = wh(n, n.pendingProps)).return = a; o.sibling = null } return a.child } function Ej(n, a) { if (!ro) switch (n.tailMode) { case "hidden": a = n.tail; for (var o = null; null !== a;)null !== a.alternate && (o = a), a = a.sibling; null === o ? n.tail = null : o.sibling = null; break; case "collapsed": o = n.tail; for (var i = null; null !== o;)null !== o.alternate && (i = o), o = o.sibling; null === i ? a || null === n.tail ? n.tail = null : n.tail.sibling = null : i.sibling = null } } function S(n) { var a = null !== n.alternate && n.alternate.child === n.child, o = 0, i = 0; if (a) for (var s = n.child; null !== s;)o |= s.lanes | s.childLanes, i |= 14680064 & s.subtreeFlags, i |= 14680064 & s.flags, s.return = n, s = s.sibling; else for (s = n.child; null !== s;)o |= s.lanes | s.childLanes, i |= s.subtreeFlags, i |= s.flags, s.return = n, s = s.sibling; return n.subtreeFlags |= i, n.childLanes = o, a } s = function (n, a) { for (var o = a.child; null !== o;) { if (5 === o.tag || 6 === o.tag) n.appendChild(o.stateNode); else if (4 !== o.tag && null !== o.child) { o.child.return = o, o = o.child; continue } if (o === a) break; for (; null === o.sibling;) { if (null === o.return || o.return === a) return; o = o.return } o.sibling.return = o.return, o = o.sibling } }, _ = function () { }, N = function (n, a, o, i) { var s = n.memoizedProps; if (s !== i) { n = a.stateNode, Hh(rC.current); var _, N = null; switch (o) { case "input": s = Ya(n, s), i = Ya(n, i), N = []; break; case "select": s = eN({}, s, { value: void 0 }), i = eN({}, i, { value: void 0 }), N = []; break; case "textarea": s = gb(n, s), i = gb(n, i), N = []; break; default: "function" != typeof s.onClick && "function" == typeof i.onClick && (n.onclick = Bf) }for (B in ub(o, i), o = null, s) if (!i.hasOwnProperty(B) && s.hasOwnProperty(B) && null != s[B]) { if ("style" === B) { var z = s[B]; for (_ in z) z.hasOwnProperty(_) && (o || (o = {}), o[_] = "") } else "dangerouslySetInnerHTML" !== B && "children" !== B && "suppressContentEditableWarning" !== B && "suppressHydrationWarning" !== B && "autoFocus" !== B && (et.hasOwnProperty(B) ? N || (N = []) : (N = N || []).push(B, null)) } for (B in i) { var j = i[B]; if (z = null != s ? s[B] : void 0, i.hasOwnProperty(B) && j !== z && (null != j || null != z)) { if ("style" === B) { if (z) { for (_ in z) !z.hasOwnProperty(_) || j && j.hasOwnProperty(_) || (o || (o = {}), o[_] = ""); for (_ in j) j.hasOwnProperty(_) && z[_] !== j[_] && (o || (o = {}), o[_] = j[_]) } else o || (N || (N = []), N.push(B, o)), o = j } else "dangerouslySetInnerHTML" === B ? (j = j ? j.__html : void 0, z = z ? z.__html : void 0, null != j && z !== j && (N = N || []).push(B, j)) : "children" === B ? "string" != typeof j && "number" != typeof j || (N = N || []).push(B, "" + j) : "suppressContentEditableWarning" !== B && "suppressHydrationWarning" !== B && (et.hasOwnProperty(B) ? (null != j && "onScroll" === B && D("scroll", n), N || z === j || (N = [])) : (N = N || []).push(B, j)) } } o && (N = N || []).push("style", o); var B = N; (a.updateQueue = B) && (a.flags |= 4) } }, z = function (n, a, o, i) { o !== i && (a.flags |= 4) }; var rG = !1, rY = !1, rX = "function" == typeof WeakSet ? WeakSet : Set, rK = null; function Mj(n, a) { var o = n.ref; if (null !== o) { if ("function" == typeof o) try { o(null) } catch (o) { W(n, a, o) } else o.current = null } } function Nj(n, a, o) { try { o() } catch (o) { W(n, a, o) } } var rJ = !1; function Qj(n, a, o) { var i = a.updateQueue; if (null !== (i = null !== i ? i.lastEffect : null)) { var s = i = i.next; do { if ((s.tag & n) === n) { var _ = s.destroy; s.destroy = void 0, void 0 !== _ && Nj(a, o, _) } s = s.next } while (s !== i) } } function Rj(n, a) { if (null !== (a = null !== (a = a.updateQueue) ? a.lastEffect : null)) { var o = a = a.next; do { if ((o.tag & n) === n) { var i = o.create; o.destroy = i() } o = o.next } while (o !== a) } } function Sj(n) { var a = n.ref; if (null !== a) { var o = n.stateNode; n.tag, n = o, "function" == typeof a ? a(n) : a.current = n } } function Uj(n) { return 5 === n.tag || 3 === n.tag || 4 === n.tag } function Vj(n) { e: for (; ;) { for (; null === n.sibling;) { if (null === n.return || Uj(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; 5 !== n.tag && 6 !== n.tag && 18 !== n.tag;) { if (2 & n.flags || null === n.child || 4 === n.tag) continue e; n.child.return = n, n = n.child } if (!(2 & n.flags)) return n.stateNode } } var r0 = null, r1 = !1; function Zj(n, a, o) { for (o = o.child; null !== o;)ak(n, a, o), o = o.sibling } function ak(n, a, o) { if (tn && "function" == typeof tn.onCommitFiberUnmount) try { tn.onCommitFiberUnmount(tt, o) } catch (n) { } switch (o.tag) { case 5: rY || Mj(o, a); case 6: var i = r0, s = r1; r0 = null, Zj(n, a, o), r0 = i, r1 = s, null !== r0 && (r1 ? (n = r0, o = o.stateNode, 8 === n.nodeType ? n.parentNode.removeChild(o) : n.removeChild(o)) : r0.removeChild(o.stateNode)); break; case 18: null !== r0 && (r1 ? (n = r0, o = o.stateNode, 8 === n.nodeType ? Kf(n.parentNode, o) : 1 === n.nodeType && Kf(n, o), bd(n)) : Kf(r0, o.stateNode)); break; case 4: i = r0, s = r1, r0 = o.stateNode.containerInfo, r1 = !0, Zj(n, a, o), r0 = i, r1 = s; break; case 0: case 11: case 14: case 15: if (!rY && null !== (i = o.updateQueue) && null !== (i = i.lastEffect)) { s = i = i.next; do { var _ = s, N = _.destroy; _ = _.tag, void 0 !== N && (0 != (2 & _) ? Nj(o, a, N) : 0 != (4 & _) && Nj(o, a, N)), s = s.next } while (s !== i) } Zj(n, a, o); break; case 1: if (!rY && (Mj(o, a), "function" == typeof (i = o.stateNode).componentWillUnmount)) try { i.props = o.memoizedProps, i.state = o.memoizedState, i.componentWillUnmount() } catch (n) { W(o, a, n) } Zj(n, a, o); break; case 21: default: Zj(n, a, o); break; case 22: 1 & o.mode ? (rY = (i = rY) || null !== o.memoizedState, Zj(n, a, o), rY = i) : Zj(n, a, o) } } function bk(n) { var a = n.updateQueue; if (null !== a) { n.updateQueue = null; var o = n.stateNode; null === o && (o = n.stateNode = new rX), a.forEach(function (a) { var i = ck.bind(null, n, a); o.has(a) || (o.add(a), a.then(i, i)) }) } } function dk(n, a) { var o = a.deletions; if (null !== o) for (var i = 0; i < o.length; i++) { var s = o[i]; try { var _ = a, N = _; e: for (; null !== N;) { switch (N.tag) { case 5: r0 = N.stateNode, r1 = !1; break e; case 3: case 4: r0 = N.stateNode.containerInfo, r1 = !0; break e }N = N.return } if (null === r0) throw Error(p(160)); ak(n, _, s), r0 = null, r1 = !1; var z = s.alternate; null !== z && (z.return = null), s.return = null } catch (n) { W(s, a, n) } } if (12854 & a.subtreeFlags) for (a = a.child; null !== a;)ek(a, n), a = a.sibling } function ek(n, a) { var o = n.alternate, i = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: if (dk(a, n), fk(n), 4 & i) { try { Qj(3, n, n.return), Rj(3, n) } catch (a) { W(n, n.return, a) } try { Qj(5, n, n.return) } catch (a) { W(n, n.return, a) } } break; case 1: dk(a, n), fk(n), 512 & i && null !== o && Mj(o, o.return); break; case 5: if (dk(a, n), fk(n), 512 & i && null !== o && Mj(o, o.return), 32 & n.flags) { var s = n.stateNode; try { ob(s, "") } catch (a) { W(n, n.return, a) } } if (4 & i && null != (s = n.stateNode)) { var _ = n.memoizedProps, N = null !== o ? o.memoizedProps : _, z = n.type, j = n.updateQueue; if (n.updateQueue = null, null !== j) try { "input" === z && "radio" === _.type && null != _.name && ab(s, _), vb(z, N); var B = vb(z, _); for (N = 0; N < j.length; N += 2) { var $ = j[N], ee = j[N + 1]; "style" === $ ? sb(s, ee) : "dangerouslySetInnerHTML" === $ ? eI(s, ee) : "children" === $ ? ob(s, ee) : ta(s, $, ee, B) } switch (z) { case "input": bb(s, _); break; case "textarea": ib(s, _); break; case "select": var et = s._wrapperState.wasMultiple; s._wrapperState.wasMultiple = !!_.multiple; var en = _.value; null != en ? fb(s, !!_.multiple, en, !1) : !!_.multiple !== et && (null != _.defaultValue ? fb(s, !!_.multiple, _.defaultValue, !0) : fb(s, !!_.multiple, _.multiple ? [] : "", !1)) }s[nW] = _ } catch (a) { W(n, n.return, a) } } break; case 6: if (dk(a, n), fk(n), 4 & i) { if (null === n.stateNode) throw Error(p(162)); s = n.stateNode, _ = n.memoizedProps; try { s.nodeValue = _ } catch (a) { W(n, n.return, a) } } break; case 3: if (dk(a, n), fk(n), 4 & i && null !== o && o.memoizedState.isDehydrated) try { bd(a.containerInfo) } catch (a) { W(n, n.return, a) } break; case 4: default: dk(a, n), fk(n); break; case 13: dk(a, n), fk(n), 8192 & (s = n.child).flags && (_ = null !== s.memoizedState, s.stateNode.isHidden = _, _ && (null === s.alternate || null === s.alternate.memoizedState) && (ac = e3())), 4 & i && bk(n); break; case 22: if ($ = null !== o && null !== o.memoizedState, 1 & n.mode ? (rY = (B = rY) || $, dk(a, n), rY = B) : dk(a, n), fk(n), 8192 & i) { if (B = null !== n.memoizedState, (n.stateNode.isHidden = B) && !$ && 0 != (1 & n.mode)) for (rK = n, $ = n.child; null !== $;) { for (ee = rK = $; null !== rK;) { switch (en = (et = rK).child, et.tag) { case 0: case 11: case 14: case 15: Qj(4, et, et.return); break; case 1: Mj(et, et.return); var er = et.stateNode; if ("function" == typeof er.componentWillUnmount) { i = et, o = et.return; try { a = i, er.props = a.memoizedProps, er.state = a.memoizedState, er.componentWillUnmount() } catch (n) { W(i, o, n) } } break; case 5: Mj(et, et.return); break; case 22: if (null !== et.memoizedState) { hk(ee); continue } }null !== en ? (en.return = et, rK = en) : hk(ee) } $ = $.sibling } e: for ($ = null, ee = n; ;) { if (5 === ee.tag) { if (null === $) { $ = ee; try { s = ee.stateNode, B ? (_ = s.style, "function" == typeof _.setProperty ? _.setProperty("display", "none", "important") : _.display = "none") : (z = ee.stateNode, N = null != (j = ee.memoizedProps.style) && j.hasOwnProperty("display") ? j.display : null, z.style.display = rb("display", N)) } catch (a) { W(n, n.return, a) } } } else if (6 === ee.tag) { if (null === $) try { ee.stateNode.nodeValue = B ? "" : ee.memoizedProps } catch (a) { W(n, n.return, a) } } else if ((22 !== ee.tag && 23 !== ee.tag || null === ee.memoizedState || ee === n) && null !== ee.child) { ee.child.return = ee, ee = ee.child; continue } if (ee === n) break; for (; null === ee.sibling;) { if (null === ee.return || ee.return === n) break e; $ === ee && ($ = null), ee = ee.return } $ === ee && ($ = null), ee.sibling.return = ee.return, ee = ee.sibling } } break; case 19: dk(a, n), fk(n), 4 & i && bk(n); case 21: } } function fk(n) { var a = n.flags; if (2 & a) { try { e: { for (var o = n.return; null !== o;) { if (Uj(o)) { var i = o; break e } o = o.return } throw Error(p(160)) } switch (i.tag) { case 5: var s = i.stateNode; 32 & i.flags && (ob(s, ""), i.flags &= -33); var _ = Vj(n); !function Xj(n, a, o) { var i = n.tag; if (5 === i || 6 === i) n = n.stateNode, a ? o.insertBefore(n, a) : o.appendChild(n); else if (4 !== i && null !== (n = n.child)) for (Xj(n, a, o), n = n.sibling; null !== n;)Xj(n, a, o), n = n.sibling }(n, _, s); break; case 3: case 4: var N = i.stateNode.containerInfo, z = Vj(n); !function Wj(n, a, o) { var i = n.tag; if (5 === i || 6 === i) n = n.stateNode, a ? 8 === o.nodeType ? o.parentNode.insertBefore(n, a) : o.insertBefore(n, a) : (8 === o.nodeType ? (a = o.parentNode).insertBefore(n, o) : (a = o).appendChild(n), null != (o = o._reactRootContainer) || null !== a.onclick || (a.onclick = Bf)); else if (4 !== i && null !== (n = n.child)) for (Wj(n, a, o), n = n.sibling; null !== n;)Wj(n, a, o), n = n.sibling }(n, z, N); break; default: throw Error(p(161)) } } catch (a) { W(n, n.return, a) } n.flags &= -3 } 4096 & a && (n.flags &= -4097) } function lk(n) { for (; null !== rK;) { var a = rK; if (0 != (8772 & a.flags)) { var o = a.alternate; try { if (0 != (8772 & a.flags)) switch (a.tag) { case 0: case 11: case 15: rY || Rj(5, a); break; case 1: var i = a.stateNode; if (4 & a.flags && !rY) { if (null === o) i.componentDidMount(); else { var s = a.elementType === a.type ? o.memoizedProps : Lg(a.type, o.memoizedProps); i.componentDidUpdate(s, o.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } } var _ = a.updateQueue; null !== _ && ih(a, _, i); break; case 3: var N = a.updateQueue; if (null !== N) { if (o = null, null !== a.child) switch (a.child.tag) { case 5: case 1: o = a.child.stateNode }ih(a, N, o) } break; case 5: var z = a.stateNode; if (null === o && 4 & a.flags) { o = z; var j = a.memoizedProps; switch (a.type) { case "button": case "input": case "select": case "textarea": j.autoFocus && o.focus(); break; case "img": j.src && (o.src = j.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === a.memoizedState) { var B = a.alternate; if (null !== B) { var $ = B.memoizedState; if (null !== $) { var ee = $.dehydrated; null !== ee && bd(ee) } } } break; default: throw Error(p(163)) }rY || 512 & a.flags && Sj(a) } catch (n) { W(a, a.return, n) } } if (a === n) { rK = null; break } if (null !== (o = a.sibling)) { o.return = a.return, rK = o; break } rK = a.return } } function hk(n) { for (; null !== rK;) { var a = rK; if (a === n) { rK = null; break } var o = a.sibling; if (null !== o) { o.return = a.return, rK = o; break } rK = a.return } } function kk(n) { for (; null !== rK;) { var a = rK; try { switch (a.tag) { case 0: case 11: case 15: var o = a.return; try { Rj(4, a) } catch (n) { W(a, o, n) } break; case 1: var i = a.stateNode; if ("function" == typeof i.componentDidMount) { var s = a.return; try { i.componentDidMount() } catch (n) { W(a, s, n) } } var _ = a.return; try { Sj(a) } catch (n) { W(a, _, n) } break; case 5: var N = a.return; try { Sj(a) } catch (n) { W(a, N, n) } } } catch (n) { W(a, a.return, n) } if (a === n) { rK = null; break } var z = a.sibling; if (null !== z) { z.return = a.return, rK = z; break } rK = a.return } } var r2 = Math.ceil, r3 = ef.ReactCurrentDispatcher, r4 = ef.ReactCurrentOwner, r6 = ef.ReactCurrentBatchConfig, r8 = 0, r5 = null, r9 = null, r7 = 0, ae = 0, at = Uf(0), an = 0, ar = null, aa = 0, ao = 0, au = 0, ai = null, as = null, ac = 0, af = 1 / 0, ap = null, am = !1, av = null, ay = null, aw = !1, aS = null, ax = 0, aE = 0, aC = null, a_ = -1, aT = 0; function L() { return 0 != (6 & r8) ? e3() : -1 !== a_ ? a_ : a_ = e3() } function lh(n) { return 0 == (1 & n.mode) ? 1 : 0 != (2 & r8) && 0 !== r7 ? r7 & -r7 : null !== rs.transition ? (0 === aT && (aT = yc()), aT) : 0 !== (n = td) ? n : n = void 0 === (n = window.event) ? 16 : jd(n.type) } function mh(n, a, o, i) { if (50 < aE) throw aE = 0, aC = null, Error(p(185)); Ac(n, o, i), (0 == (2 & r8) || n !== r5) && (n === r5 && (0 == (2 & r8) && (ao |= o), 4 === an && Dk(n, r7)), Ek(n, i), 1 === o && 0 === r8 && 0 == (1 & a.mode) && (af = e3() + 500, n2 && jg())) } function Ek(n, a) { var o, i, s, _ = n.callbackNode; !function (n, a) { for (var o = n.suspendedLanes, i = n.pingedLanes, s = n.expirationTimes, _ = n.pendingLanes; 0 < _;) { var N = 31 - tr(_), z = 1 << N, j = s[N]; -1 === j ? (0 == (z & o) || 0 != (z & i)) && (s[N] = function (n, a) { switch (n) { case 1: case 2: case 4: return a + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return a + 5e3; default: return -1 } }(z, a)) : j <= a && (n.expiredLanes |= z), _ &= ~z } }(n, a); var N = uc(n, n === r5 ? r7 : 0); if (0 === N) null !== _ && e0(_), n.callbackNode = null, n.callbackPriority = 0; else if (a = N & -N, n.callbackPriority !== a) { if (null != _ && e0(_), 1 === a) 0 === n.tag ? (s = Fk.bind(null, n), n2 = !0, hg(s)) : hg(Fk.bind(null, n)), nA(function () { 0 == (6 & r8) && jg() }), _ = null; else { switch (Dc(N)) { case 1: _ = e6; break; case 4: _ = e8; break; case 16: default: _ = e5; break; case 536870912: _ = e7 }_ = eJ(_, Hk.bind(null, n)) } n.callbackPriority = a, n.callbackNode = _ } } function Hk(n, a) { if (a_ = -1, aT = 0, 0 != (6 & r8)) throw Error(p(327)); var o = n.callbackNode; if (Ik() && n.callbackNode !== o) return null; var i = uc(n, n === r5 ? r7 : 0); if (0 === i) return null; if (0 != (30 & i) || 0 != (i & n.expiredLanes) || a) a = Jk(n, i); else { a = i; var s = r8; r8 |= 2; var _ = Kk(); for ((r5 !== n || r7 !== a) && (ap = null, af = e3() + 500, Lk(n, a)); ;)try { !function () { for (; null !== r9 && !e1();)Vk(r9) }(); break } catch (a) { Nk(n, a) } Qg(), r3.current = _, r8 = s, null !== r9 ? a = 0 : (r5 = null, r7 = 0, a = an) } if (0 !== a) { if (2 === a && 0 !== (s = xc(n)) && (i = s, a = Ok(n, s)), 1 === a) throw o = ar, Lk(n, 0), Dk(n, i), Ek(n, e3()), o; if (6 === a) Dk(n, i); else { if (s = n.current.alternate, 0 == (30 & i) && !function (n) { for (var a = n; ;) { if (16384 & a.flags) { var o = a.updateQueue; if (null !== o && null !== (o = o.stores)) for (var i = 0; i < o.length; i++) { var s = o[i], _ = s.getSnapshot; s = s.value; try { if (!nh(_(), s)) return !1 } catch (n) { return !1 } } } if (o = a.child, 16384 & a.subtreeFlags && null !== o) o.return = a, a = o; else { if (a === n) break; for (; null === a.sibling;) { if (null === a.return || a.return === n) return !0; a = a.return } a.sibling.return = a.return, a = a.sibling } } return !0 }(s) && (2 === (a = Jk(n, i)) && 0 !== (_ = xc(n)) && (i = _, a = Ok(n, _)), 1 === a)) throw o = ar, Lk(n, 0), Dk(n, i), Ek(n, e3()), o; switch (n.finishedWork = s, n.finishedLanes = i, a) { case 0: case 1: throw Error(p(345)); case 2: case 5: Qk(n, as, ap); break; case 3: if (Dk(n, i), (130023424 & i) === i && 10 < (a = ac + 500 - e3())) { if (0 !== uc(n, 0)) break; if (((s = n.suspendedLanes) & i) !== i) { L(), n.pingedLanes |= n.suspendedLanes & s; break } n.timeoutHandle = nO(Qk.bind(null, n, as, ap), a); break } Qk(n, as, ap); break; case 4: if (Dk(n, i), (4194240 & i) === i) break; for (s = -1, a = n.eventTimes; 0 < i;) { var N = 31 - tr(i); _ = 1 << N, (N = a[N]) > s && (s = N), i &= ~_ } if (i = s, 10 < (i = (120 > (i = e3() - i) ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * r2(i / 1960)) - i)) { n.timeoutHandle = nO(Qk.bind(null, n, as, ap), i); break } Qk(n, as, ap); break; default: throw Error(p(329)) } } } return Ek(n, e3()), n.callbackNode === o ? Hk.bind(null, n) : null } function Ok(n, a) { var o = ai; return n.current.memoizedState.isDehydrated && (Lk(n, a).flags |= 256), 2 !== (n = Jk(n, a)) && (a = as, as = o, null !== a && Gj(a)), n } function Gj(n) { null === as ? as = n : as.push.apply(as, n) } function Dk(n, a) { for (a &= ~au, a &= ~ao, n.suspendedLanes |= a, n.pingedLanes &= ~a, n = n.expirationTimes; 0 < a;) { var o = 31 - tr(a), i = 1 << o; n[o] = -1, a &= ~i } } function Fk(n) { if (0 != (6 & r8)) throw Error(p(327)); Ik(); var a = uc(n, 0); if (0 == (1 & a)) return Ek(n, e3()), null; var o = Jk(n, a); if (0 !== n.tag && 2 === o) { var i = xc(n); 0 !== i && (a = i, o = Ok(n, i)) } if (1 === o) throw o = ar, Lk(n, 0), Dk(n, a), Ek(n, e3()), o; if (6 === o) throw Error(p(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = a, Qk(n, as, ap), Ek(n, e3()), null } function Rk(n, a) { var o = r8; r8 |= 1; try { return n(a) } finally { 0 === (r8 = o) && (af = e3() + 500, n2 && jg()) } } function Sk(n) { null !== aS && 0 === aS.tag && 0 == (6 & r8) && Ik(); var a = r8; r8 |= 1; var o = r6.transition, i = td; try { if (r6.transition = null, td = 1, n) return n() } finally { td = i, r6.transition = o, 0 == (6 & (r8 = a)) && jg() } } function Ij() { ae = at.current, E(at) } function Lk(n, a) { n.finishedWork = null, n.finishedLanes = 0; var o = n.timeoutHandle; if (-1 !== o && (n.timeoutHandle = -1, nV(o)), null !== r9) for (o = r9.return; null !== o;) { var i = o; switch (wg(i), i.tag) { case 1: null != (i = i.type.childContextTypes) && $f(); break; case 3: Jh(), E(nJ), E(nK), Oh(); break; case 5: Lh(i); break; case 4: Jh(); break; case 13: case 19: E(rP); break; case 10: Rg(i.type._context); break; case 22: case 23: Ij() }o = o.return } if (r5 = n, r9 = n = wh(n.current, null), r7 = ae = a, an = 0, ar = null, au = ao = aa = 0, as = ai = null, null !== rv) { for (a = 0; a < rv.length; a++)if (null !== (i = (o = rv[a]).interleaved)) { o.interleaved = null; var s = i.next, _ = o.pending; if (null !== _) { var N = _.next; _.next = s, i.next = N } o.pending = i } rv = null } return n } function Nk(n, a) { for (; ;) { var o = r9; try { if (Qg(), rR.current = rA, rI) { for (var i = rL.memoizedState; null !== i;) { var s = i.queue; null !== s && (s.pending = null), i = i.next } rI = !1 } if (rz = 0, rD = rM = rL = null, rO = !1, rV = 0, r4.current = null, null === o || null === o.return) { an = 1, ar = a, r9 = null; break } e: { var _ = n, N = o.return, z = o, j = a; if (a = r7, z.flags |= 32768, null !== j && "object" == typeof j && "function" == typeof j.then) { var B = j, $ = z, ee = $.tag; if (0 == (1 & $.mode) && (0 === ee || 11 === ee || 15 === ee)) { var et = $.alternate; et ? ($.updateQueue = et.updateQueue, $.memoizedState = et.memoizedState, $.lanes = et.lanes) : ($.updateQueue = null, $.memoizedState = null) } var en = Vi(N); if (null !== en) { en.flags &= -257, Wi(en, N, z, _, a), 1 & en.mode && Ti(_, B, a), a = en, j = B; var er = a.updateQueue; if (null === er) { var ea = new Set; ea.add(j), a.updateQueue = ea } else er.add(j); break e } if (0 == (1 & a)) { Ti(_, B, a), uj(); break e } j = Error(p(426)) } else if (ro && 1 & z.mode) { var eo = Vi(N); if (null !== eo) { 0 == (65536 & eo.flags) && (eo.flags |= 256), Wi(eo, N, z, _, a), Jg(Ki(j, z)); break e } } _ = j = Ki(j, z), 4 !== an && (an = 2), null === ai ? ai = [_] : ai.push(_), _ = N; do { switch (_.tag) { case 3: _.flags |= 65536, a &= -a, _.lanes |= a; var eu = Oi(_, j, a); fh(_, eu); break e; case 1: z = j; var es = _.type, ec = _.stateNode; if (0 == (128 & _.flags) && ("function" == typeof es.getDerivedStateFromError || null !== ec && "function" == typeof ec.componentDidCatch && (null === ay || !ay.has(ec)))) { _.flags |= 65536, a &= -a, _.lanes |= a; var ef = Ri(_, z, a); fh(_, ef); break e } }_ = _.return } while (null !== _) } Tk(o) } catch (n) { a = n, r9 === o && null !== o && (r9 = o = o.return); continue } break } } function Kk() { var n = r3.current; return r3.current = rA, null === n ? rA : n } function uj() { (0 === an || 3 === an || 2 === an) && (an = 4), null === r5 || 0 == (268435455 & aa) && 0 == (268435455 & ao) || Dk(r5, r7) } function Jk(n, a) { var o = r8; r8 |= 2; var i = Kk(); for ((r5 !== n || r7 !== a) && (ap = null, Lk(n, a)); ;)try { !function () { for (; null !== r9;)Vk(r9) }(); break } catch (a) { Nk(n, a) } if (Qg(), r8 = o, r3.current = i, null !== r9) throw Error(p(261)); return r5 = null, r7 = 0, an } function Vk(n) { var a = j(n.alternate, n, ae); n.memoizedProps = n.pendingProps, null === a ? Tk(n) : r9 = a, r4.current = null } function Tk(n) { var a = n; do { var o = a.alternate; if (n = a.return, 0 == (32768 & a.flags)) { if (null !== (o = function (n, a, o) { var i = a.pendingProps; switch (wg(a), a.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return S(a), null; case 1: case 17: return Zf(a.type) && $f(), S(a), null; case 3: return i = a.stateNode, Jh(), E(nJ), E(nK), Oh(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (null === n || null === n.child) && (Gg(a) ? a.flags |= 4 : null === n || n.memoizedState.isDehydrated && 0 == (256 & a.flags) || (a.flags |= 1024, null !== ru && (Gj(ru), ru = null))), _(n, a), S(a), null; case 5: Lh(a); var j = Hh(rT.current); if (o = a.type, null !== n && null != a.stateNode) N(n, a, o, i, j), n.ref !== a.ref && (a.flags |= 512, a.flags |= 2097152); else { if (!i) { if (null === a.stateNode) throw Error(p(166)); return S(a), null } if (n = Hh(rC.current), Gg(a)) { i = a.stateNode, o = a.type; var B = a.memoizedProps; switch (i[n$] = a, i[nW] = B, n = 0 != (1 & a.mode), o) { case "dialog": D("cancel", i), D("close", i); break; case "iframe": case "object": case "embed": D("load", i); break; case "video": case "audio": for (j = 0; j < nN.length; j++)D(nN[j], i); break; case "source": D("error", i); break; case "img": case "image": case "link": D("error", i), D("load", i); break; case "details": D("toggle", i); break; case "input": Za(i, B), D("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!B.multiple }, D("invalid", i); break; case "textarea": hb(i, B), D("invalid", i) }for (var $ in ub(o, B), j = null, B) if (B.hasOwnProperty($)) { var ee = B[$]; "children" === $ ? "string" == typeof ee ? i.textContent !== ee && (!0 !== B.suppressHydrationWarning && Af(i.textContent, ee, n), j = ["children", ee]) : "number" == typeof ee && i.textContent !== "" + ee && (!0 !== B.suppressHydrationWarning && Af(i.textContent, ee, n), j = ["children", "" + ee]) : et.hasOwnProperty($) && null != ee && "onScroll" === $ && D("scroll", i) } switch (o) { case "input": Va(i), db(i, B, !0); break; case "textarea": Va(i), jb(i); break; case "select": case "option": break; default: "function" == typeof B.onClick && (i.onclick = Bf) }i = j, a.updateQueue = i, null !== i && (a.flags |= 4) } else { $ = 9 === j.nodeType ? j : j.ownerDocument, "http://www.w3.org/1999/xhtml" === n && (n = kb(o)), "http://www.w3.org/1999/xhtml" === n ? "script" === o ? ((n = $.createElement("div")).innerHTML = "<script></script>", n = n.removeChild(n.firstChild)) : "string" == typeof i.is ? n = $.createElement(o, { is: i.is }) : (n = $.createElement(o), "select" === o && ($ = n, i.multiple ? $.multiple = !0 : i.size && ($.size = i.size))) : n = $.createElementNS(n, o), n[n$] = a, n[nW] = i, s(n, a, !1, !1), a.stateNode = n; e: { switch ($ = vb(o, i), o) { case "dialog": D("cancel", n), D("close", n), j = i; break; case "iframe": case "object": case "embed": D("load", n), j = i; break; case "video": case "audio": for (j = 0; j < nN.length; j++)D(nN[j], n); j = i; break; case "source": D("error", n), j = i; break; case "img": case "image": case "link": D("error", n), D("load", n), j = i; break; case "details": D("toggle", n), j = i; break; case "input": Za(n, i), j = Ya(n, i), D("invalid", n); break; case "option": default: j = i; break; case "select": n._wrapperState = { wasMultiple: !!i.multiple }, j = eN({}, i, { value: void 0 }), D("invalid", n); break; case "textarea": hb(n, i), j = gb(n, i), D("invalid", n) }for (B in ub(o, j), ee = j) if (ee.hasOwnProperty(B)) { var en = ee[B]; "style" === B ? sb(n, en) : "dangerouslySetInnerHTML" === B ? null != (en = en ? en.__html : void 0) && eI(n, en) : "children" === B ? "string" == typeof en ? ("textarea" !== o || "" !== en) && ob(n, en) : "number" == typeof en && ob(n, "" + en) : "suppressContentEditableWarning" !== B && "suppressHydrationWarning" !== B && "autoFocus" !== B && (et.hasOwnProperty(B) ? null != en && "onScroll" === B && D("scroll", n) : null != en && ta(n, B, en, $)) } switch (o) { case "input": Va(n), db(n, i, !1); break; case "textarea": Va(n), jb(n); break; case "option": null != i.value && n.setAttribute("value", "" + Sa(i.value)); break; case "select": n.multiple = !!i.multiple, null != (B = i.value) ? fb(n, !!i.multiple, B, !1) : null != i.defaultValue && fb(n, !!i.multiple, i.defaultValue, !0); break; default: "function" == typeof j.onClick && (n.onclick = Bf) }switch (o) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (a.flags |= 4) } null !== a.ref && (a.flags |= 512, a.flags |= 2097152) } return S(a), null; case 6: if (n && null != a.stateNode) z(n, a, n.memoizedProps, i); else { if ("string" != typeof i && null === a.stateNode) throw Error(p(166)); if (o = Hh(rT.current), Hh(rC.current), Gg(a)) { if (i = a.stateNode, o = a.memoizedProps, i[n$] = a, (B = i.nodeValue !== o) && null !== (n = ra)) switch (n.tag) { case 3: Af(i.nodeValue, o, 0 != (1 & n.mode)); break; case 5: !0 !== n.memoizedProps.suppressHydrationWarning && Af(i.nodeValue, o, 0 != (1 & n.mode)) }B && (a.flags |= 4) } else (i = (9 === o.nodeType ? o : o.ownerDocument).createTextNode(i))[n$] = a, a.stateNode = i } return S(a), null; case 13: if (E(rP), i = a.memoizedState, null === n || null !== n.memoizedState && null !== n.memoizedState.dehydrated) { if (ro && null !== rl && 0 != (1 & a.mode) && 0 == (128 & a.flags)) Hg(), Ig(), a.flags |= 98560, B = !1; else if (B = Gg(a), null !== i && null !== i.dehydrated) { if (null === n) { if (!B) throw Error(p(318)); if (!(B = null !== (B = a.memoizedState) ? B.dehydrated : null)) throw Error(p(317)); B[n$] = a } else Ig(), 0 == (128 & a.flags) && (a.memoizedState = null), a.flags |= 4; S(a), B = !1 } else null !== ru && (Gj(ru), ru = null), B = !0; if (!B) return 65536 & a.flags ? a : null } if (0 != (128 & a.flags)) return a.lanes = o, a; return (i = null !== i) != (null !== n && null !== n.memoizedState) && i && (a.child.flags |= 8192, 0 != (1 & a.mode) && (null === n || 0 != (1 & rP.current) ? 0 === an && (an = 3) : uj())), null !== a.updateQueue && (a.flags |= 4), S(a), null; case 4: return Jh(), _(n, a), null === n && sf(a.stateNode.containerInfo), S(a), null; case 10: return Rg(a.type._context), S(a), null; case 19: if (E(rP), null === (B = a.memoizedState)) return S(a), null; if (i = 0 != (128 & a.flags), null === ($ = B.rendering)) { if (i) Ej(B, !1); else { if (0 !== an || null !== n && 0 != (128 & n.flags)) for (n = a.child; null !== n;) { if (null !== ($ = Mh(n))) { for (a.flags |= 128, Ej(B, !1), null !== (i = $.updateQueue) && (a.updateQueue = i, a.flags |= 4), a.subtreeFlags = 0, i = o, o = a.child; null !== o;)B = o, n = i, B.flags &= 14680066, null === ($ = B.alternate) ? (B.childLanes = 0, B.lanes = n, B.child = null, B.subtreeFlags = 0, B.memoizedProps = null, B.memoizedState = null, B.updateQueue = null, B.dependencies = null, B.stateNode = null) : (B.childLanes = $.childLanes, B.lanes = $.lanes, B.child = $.child, B.subtreeFlags = 0, B.deletions = null, B.memoizedProps = $.memoizedProps, B.memoizedState = $.memoizedState, B.updateQueue = $.updateQueue, B.type = $.type, n = $.dependencies, B.dependencies = null === n ? null : { lanes: n.lanes, firstContext: n.firstContext }), o = o.sibling; return G(rP, 1 & rP.current | 2), a.child } n = n.sibling } null !== B.tail && e3() > af && (a.flags |= 128, i = !0, Ej(B, !1), a.lanes = 4194304) } } else { if (!i) { if (null !== (n = Mh($))) { if (a.flags |= 128, i = !0, null !== (o = n.updateQueue) && (a.updateQueue = o, a.flags |= 4), Ej(B, !0), null === B.tail && "hidden" === B.tailMode && !$.alternate && !ro) return S(a), null } else 2 * e3() - B.renderingStartTime > af && 1073741824 !== o && (a.flags |= 128, i = !0, Ej(B, !1), a.lanes = 4194304) } B.isBackwards ? ($.sibling = a.child, a.child = $) : (null !== (o = B.last) ? o.sibling = $ : a.child = $, B.last = $) } if (null !== B.tail) return a = B.tail, B.rendering = a, B.tail = a.sibling, B.renderingStartTime = e3(), a.sibling = null, o = rP.current, G(rP, i ? 1 & o | 2 : 1 & o), a; return S(a), null; case 22: case 23: return Ij(), i = null !== a.memoizedState, null !== n && null !== n.memoizedState !== i && (a.flags |= 8192), i && 0 != (1 & a.mode) ? 0 != (1073741824 & ae) && (S(a), 6 & a.subtreeFlags && (a.flags |= 8192)) : S(a), null; case 24: case 25: return null }throw Error(p(156, a.tag)) }(o, a, ae))) { r9 = o; return } } else { if (null !== (o = function (n, a) { switch (wg(a), a.tag) { case 1: return Zf(a.type) && $f(), 65536 & (n = a.flags) ? (a.flags = -65537 & n | 128, a) : null; case 3: return Jh(), E(nJ), E(nK), Oh(), 0 != (65536 & (n = a.flags)) && 0 == (128 & n) ? (a.flags = -65537 & n | 128, a) : null; case 5: return Lh(a), null; case 13: if (E(rP), null !== (n = a.memoizedState) && null !== n.dehydrated) { if (null === a.alternate) throw Error(p(340)); Ig() } return 65536 & (n = a.flags) ? (a.flags = -65537 & n | 128, a) : null; case 19: return E(rP), null; case 4: return Jh(), null; case 10: return Rg(a.type._context), null; case 22: case 23: return Ij(), null; default: return null } }(o, a))) { o.flags &= 32767, r9 = o; return } if (null !== n) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { an = 6, r9 = null; return } } if (null !== (a = a.sibling)) { r9 = a; return } r9 = a = n } while (null !== a); 0 === an && (an = 5) } function Qk(n, a, o) { var i = td, s = r6.transition; try { r6.transition = null, td = 1, function (n, a, o, i) { do Ik(); while (null !== aS); if (0 != (6 & r8)) throw Error(p(327)); o = n.finishedWork; var s = n.finishedLanes; if (null !== o) { if (n.finishedWork = null, n.finishedLanes = 0, o === n.current) throw Error(p(177)); n.callbackNode = null, n.callbackPriority = 0; var _ = o.lanes | o.childLanes; if (function (n, a) { var o = n.pendingLanes & ~a; n.pendingLanes = a, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= a, n.mutableReadLanes &= a, n.entangledLanes &= a, a = n.entanglements; var i = n.eventTimes; for (n = n.expirationTimes; 0 < o;) { var s = 31 - tr(o), _ = 1 << s; a[s] = 0, i[s] = -1, n[s] = -1, o &= ~_ } }(n, _), n === r5 && (r9 = r5 = null, r7 = 0), 0 == (2064 & o.subtreeFlags) && 0 == (2064 & o.flags) || aw || (aw = !0, N = e5, z = function () { return Ik(), null }, eJ(N, z)), _ = 0 != (15990 & o.flags), 0 != (15990 & o.subtreeFlags) || _) { _ = r6.transition, r6.transition = null; var N, z, j, B, $, ee = td; td = 1; var et = r8; r8 |= 4, r4.current = null, function (n, a) { if (nD = tN, Ne(n = Me())) { if ("selectionStart" in n) var o = { start: n.selectionStart, end: n.selectionEnd }; else e: { var i = (o = (o = n.ownerDocument) && o.defaultView || window).getSelection && o.getSelection(); if (i && 0 !== i.rangeCount) { o = i.anchorNode; var s, _ = i.anchorOffset, N = i.focusNode; i = i.focusOffset; try { o.nodeType, N.nodeType } catch (n) { o = null; break e } var z = 0, j = -1, B = -1, $ = 0, ee = 0, et = n, en = null; t: for (; ;) { for (; et !== o || 0 !== _ && 3 !== et.nodeType || (j = z + _), et !== N || 0 !== i && 3 !== et.nodeType || (B = z + i), 3 === et.nodeType && (z += et.nodeValue.length), null !== (s = et.firstChild);)en = et, et = s; for (; ;) { if (et === n) break t; if (en === o && ++$ === _ && (j = z), en === N && ++ee === i && (B = z), null !== (s = et.nextSibling)) break; en = (et = en).parentNode } et = s } o = -1 === j || -1 === B ? null : { start: j, end: B } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (nI = { focusedElem: n, selectionRange: o }, tN = !1, rK = a; null !== rK;)if (n = (a = rK).child, 0 != (1028 & a.subtreeFlags) && null !== n) n.return = a, rK = n; else for (; null !== rK;) { a = rK; try { var er = a.alternate; if (0 != (1024 & a.flags)) switch (a.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== er) { var ea = er.memoizedProps, eo = er.memoizedState, eu = a.stateNode, es = eu.getSnapshotBeforeUpdate(a.elementType === a.type ? ea : Lg(a.type, ea), eo); eu.__reactInternalSnapshotBeforeUpdate = es } break; case 3: var ec = a.stateNode.containerInfo; 1 === ec.nodeType ? ec.textContent = "" : 9 === ec.nodeType && ec.documentElement && ec.removeChild(ec.documentElement); break; default: throw Error(p(163)) } } catch (n) { W(a, a.return, n) } if (null !== (n = a.sibling)) { n.return = a.return, rK = n; break } rK = a.return } er = rJ, rJ = !1 }(n, o), ek(o, n), function (n) { var a = Me(), o = n.focusedElem, i = n.selectionRange; if (a !== o && o && o.ownerDocument && function Le(n, a) { return !!n && !!a && (n === a || (!n || 3 !== n.nodeType) && (a && 3 === a.nodeType ? Le(n, a.parentNode) : "contains" in n ? n.contains(a) : !!n.compareDocumentPosition && !!(16 & n.compareDocumentPosition(a)))) }(o.ownerDocument.documentElement, o)) { if (null !== i && Ne(o)) { if (a = i.start, void 0 === (n = i.end) && (n = a), "selectionStart" in o) o.selectionStart = a, o.selectionEnd = Math.min(n, o.value.length); else if ((n = (a = o.ownerDocument || document) && a.defaultView || window).getSelection) { n = n.getSelection(); var s = o.textContent.length, _ = Math.min(i.start, s); i = void 0 === i.end ? _ : Math.min(i.end, s), !n.extend && _ > i && (s = i, i = _, _ = s), s = Ke(o, _); var N = Ke(o, i); s && N && (1 !== n.rangeCount || n.anchorNode !== s.node || n.anchorOffset !== s.offset || n.focusNode !== N.node || n.focusOffset !== N.offset) && ((a = a.createRange()).setStart(s.node, s.offset), n.removeAllRanges(), _ > i ? (n.addRange(a), n.extend(N.node, N.offset)) : (a.setEnd(N.node, N.offset), n.addRange(a))) } } for (a = [], n = o; n = n.parentNode;)1 === n.nodeType && a.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for ("function" == typeof o.focus && o.focus(), o = 0; o < a.length; o++)(n = a[o]).element.scrollLeft = n.left, n.element.scrollTop = n.top } }(nI), tN = !!nD, nI = nD = null, n.current = o, j = o, B = n, $ = s, rK = j, function jk(n, a, o) { for (var i = 0 != (1 & n.mode); null !== rK;) { var s = rK, _ = s.child; if (22 === s.tag && i) { var N = null !== s.memoizedState || rG; if (!N) { var z = s.alternate, j = null !== z && null !== z.memoizedState || rY; z = rG; var B = rY; if (rG = N, (rY = j) && !B) for (rK = s; null !== rK;)j = (N = rK).child, 22 === N.tag && null !== N.memoizedState ? kk(s) : null !== j ? (j.return = N, rK = j) : kk(s); for (; null !== _;)rK = _, jk(_, a, o), _ = _.sibling; rK = s, rG = z, rY = B } lk(n, a, o) } else 0 != (8772 & s.subtreeFlags) && null !== _ ? (_.return = s, rK = _) : lk(n, a, o) } }(j, B, $), e2(), r8 = et, td = ee, r6.transition = _ } else n.current = o; if (aw && (aw = !1, aS = n, ax = s), 0 === (_ = n.pendingLanes) && (ay = null), function (n) { if (tn && "function" == typeof tn.onCommitFiberRoot) try { tn.onCommitFiberRoot(tt, n, void 0, 128 == (128 & n.current.flags)) } catch (n) { } }(o.stateNode, i), Ek(n, e3()), null !== a) for (i = n.onRecoverableError, o = 0; o < a.length; o++)i((s = a[o]).value, { componentStack: s.stack, digest: s.digest }); if (am) throw am = !1, n = av, av = null, n; 0 != (1 & ax) && 0 !== n.tag && Ik(), 0 != (1 & (_ = n.pendingLanes)) ? n === aC ? aE++ : (aE = 0, aC = n) : aE = 0, jg() } }(n, a, o, i) } finally { r6.transition = s, td = i } return null } function Ik() { if (null !== aS) { var n = Dc(ax), a = r6.transition, o = td; try { if (r6.transition = null, td = 16 > n ? 16 : n, null === aS) var i = !1; else { if (n = aS, aS = null, ax = 0, 0 != (6 & r8)) throw Error(p(331)); var s = r8; for (r8 |= 4, rK = n.current; null !== rK;) { var _ = rK, N = _.child; if (0 != (16 & rK.flags)) { var z = _.deletions; if (null !== z) { for (var j = 0; j < z.length; j++) { var B = z[j]; for (rK = B; null !== rK;) { var $ = rK; switch ($.tag) { case 0: case 11: case 15: Qj(8, $, _) }var ee = $.child; if (null !== ee) ee.return = $, rK = ee; else for (; null !== rK;) { var et = ($ = rK).sibling, en = $.return; if (!function Tj(n) { var a = n.alternate; null !== a && (n.alternate = null, Tj(a)), n.child = null, n.deletions = null, n.sibling = null, 5 === n.tag && null !== (a = n.stateNode) && (delete a[n$], delete a[nW], delete a[nQ], delete a[nq], delete a[nZ]), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null }($), $ === B) { rK = null; break } if (null !== et) { et.return = en, rK = et; break } rK = en } } } var er = _.alternate; if (null !== er) { var ea = er.child; if (null !== ea) { er.child = null; do { var eo = ea.sibling; ea.sibling = null, ea = eo } while (null !== ea) } } rK = _ } } if (0 != (2064 & _.subtreeFlags) && null !== N) N.return = _, rK = N; else for (; null !== rK;) { if (_ = rK, 0 != (2048 & _.flags)) switch (_.tag) { case 0: case 11: case 15: Qj(9, _, _.return) }var eu = _.sibling; if (null !== eu) { eu.return = _.return, rK = eu; break } rK = _.return } } var es = n.current; for (rK = es; null !== rK;) { var ec = (N = rK).child; if (0 != (2064 & N.subtreeFlags) && null !== ec) ec.return = N, rK = ec; else for (N = es; null !== rK;) { if (z = rK, 0 != (2048 & z.flags)) try { switch (z.tag) { case 0: case 11: case 15: Rj(9, z) } } catch (n) { W(z, z.return, n) } if (z === N) { rK = null; break } var ef = z.sibling; if (null !== ef) { ef.return = z.return, rK = ef; break } rK = z.return } } if (r8 = s, jg(), tn && "function" == typeof tn.onPostCommitFiberRoot) try { tn.onPostCommitFiberRoot(tt, n) } catch (n) { } i = !0 } return i } finally { td = o, r6.transition = a } } return !1 } function Yk(n, a, o) { a = Oi(n, a = Ki(o, a), 1), n = dh(n, a, 1), a = L(), null !== n && (Ac(n, 1, a), Ek(n, a)) } function W(n, a, o) { if (3 === n.tag) Yk(n, n, o); else for (; null !== a;) { if (3 === a.tag) { Yk(a, n, o); break } if (1 === a.tag) { var i = a.stateNode; if ("function" == typeof a.type.getDerivedStateFromError || "function" == typeof i.componentDidCatch && (null === ay || !ay.has(i))) { n = Ri(a, n = Ki(o, n), 1), a = dh(a, n, 1), n = L(), null !== a && (Ac(a, 1, n), Ek(a, n)); break } } a = a.return } } function Ui(n, a, o) { var i = n.pingCache; null !== i && i.delete(a), a = L(), n.pingedLanes |= n.suspendedLanes & o, r5 === n && (r7 & o) === o && (4 === an || 3 === an && (130023424 & r7) === r7 && 500 > e3() - ac ? Lk(n, 0) : au |= o), Ek(n, a) } function Zk(n, a) { 0 === a && (0 == (1 & n.mode) ? a = 1 : (a = ts, 0 == (130023424 & (ts <<= 1)) && (ts = 4194304))); var o = L(); null !== (n = Zg(n, a)) && (Ac(n, a, o), Ek(n, o)) } function vj(n) { var a = n.memoizedState, o = 0; null !== a && (o = a.retryLane), Zk(n, o) } function ck(n, a) { var o = 0; switch (n.tag) { case 13: var i = n.stateNode, s = n.memoizedState; null !== s && (o = s.retryLane); break; case 19: i = n.stateNode; break; default: throw Error(p(314)) }null !== i && i.delete(a), Zk(n, o) } function al(n, a, o, i) { this.tag = n, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Bg(n, a, o, i) { return new al(n, a, o, i) } function bj(n) { return !(!(n = n.prototype) || !n.isReactComponent) } function wh(n, a) { var o = n.alternate; return null === o ? ((o = Bg(n.tag, a, n.key, n.mode)).elementType = n.elementType, o.type = n.type, o.stateNode = n.stateNode, o.alternate = n, n.alternate = o) : (o.pendingProps = a, o.type = n.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = 14680064 & n.flags, o.childLanes = n.childLanes, o.lanes = n.lanes, o.child = n.child, o.memoizedProps = n.memoizedProps, o.memoizedState = n.memoizedState, o.updateQueue = n.updateQueue, a = n.dependencies, o.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }, o.sibling = n.sibling, o.index = n.index, o.ref = n.ref, o } function yh(n, a, o, i, s, _) { var N = 2; if (i = n, "function" == typeof n) bj(n) && (N = 1); else if ("string" == typeof n) N = 5; else e: switch (n) { case em: return Ah(o.children, s, _, a); case ev: N = 8, s |= 8; break; case ey: return (n = Bg(12, o, a, 2 | s)).elementType = ey, n.lanes = _, n; case eE: return (n = Bg(13, o, a, s)).elementType = eE, n.lanes = _, n; case eC: return (n = Bg(19, o, a, s)).elementType = eC, n.lanes = _, n; case eP: return qj(o, s, _, a); default: if ("object" == typeof n && null !== n) switch (n.$$typeof) { case ew: N = 10; break e; case eS: N = 9; break e; case ex: N = 11; break e; case e_: N = 14; break e; case eT: N = 16, i = null; break e }throw Error(p(130, null == n ? n : typeof n, "")) }return (a = Bg(N, o, a, s)).elementType = n, a.type = i, a.lanes = _, a } function Ah(n, a, o, i) { return (n = Bg(7, n, i, a)).lanes = o, n } function qj(n, a, o, i) { return (n = Bg(22, n, i, a)).elementType = eP, n.lanes = o, n.stateNode = { isHidden: !1 }, n } function xh(n, a, o) { return (n = Bg(6, n, null, a)).lanes = o, n } function zh(n, a, o) { return (a = Bg(4, null !== n.children ? n.children : [], n.key, a)).lanes = o, a.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, a } function bl(n, a, o, i, s) { this.tag = a, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = i, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null } function cl(n, a, o, i, s, _, N, z, j) { return n = new bl(n, a, o, z, j), 1 === a ? (a = 1, !0 === _ && (a |= 8)) : a = 0, _ = Bg(3, null, null, a), n.current = _, _.stateNode = n, _.memoizedState = { element: i, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah(_), n } function el(n) { if (!n) return nX; n = n._reactInternals; e: { if (Vb(n) !== n || 1 !== n.tag) throw Error(p(170)); var a = n; do { switch (a.tag) { case 3: a = a.stateNode.context; break e; case 1: if (Zf(a.type)) { a = a.stateNode.__reactInternalMemoizedMergedChildContext; break e } }a = a.return } while (null !== a); throw Error(p(171)) } if (1 === n.tag) { var o = n.type; if (Zf(o)) return bg(n, o, a) } return a } function fl(n, a, o, i, s, _, N, z, j) { return (n = cl(o, i, !0, n, s, _, N, z, j)).context = el(null), o = n.current, (_ = ch(i = L(), s = lh(o))).callback = null != a ? a : null, dh(o, _, s), n.current.lanes = s, Ac(n, s, i), Ek(n, i), n } function gl(n, a, o, i) { var s = a.current, _ = L(), N = lh(s); return o = el(o), null === a.context ? a.context = o : a.pendingContext = o, (a = ch(_, N)).payload = { element: n }, null !== (i = void 0 === i ? null : i) && (a.callback = i), null !== (n = dh(s, a, N)) && (mh(n, s, N, _), eh(n, s, N)), N } function hl(n) { return (n = n.current).child ? (n.child.tag, n.child.stateNode) : null } function il(n, a) { if (null !== (n = n.memoizedState) && null !== n.dehydrated) { var o = n.retryLane; n.retryLane = 0 !== o && o < a ? o : a } } function jl(n, a) { il(n, a), (n = n.alternate) && il(n, a) } j = function (n, a, o) { if (null !== n) { if (n.memoizedProps !== a.pendingProps || nJ.current) rq = !0; else { if (0 == (n.lanes & o) && 0 == (128 & a.flags)) return rq = !1, function (n, a, o) { switch (a.tag) { case 3: lj(a), Ig(); break; case 5: Kh(a); break; case 1: Zf(a.type) && cg(a); break; case 4: Ih(a, a.stateNode.containerInfo); break; case 10: var i = a.type._context, s = a.memoizedProps.value; G(rf, i._currentValue), i._currentValue = s; break; case 13: if (null !== (i = a.memoizedState)) { if (null !== i.dehydrated) return G(rP, 1 & rP.current), a.flags |= 128, null; if (0 != (o & a.child.childLanes)) return pj(n, a, o); return G(rP, 1 & rP.current), null !== (n = $i(n, a, o)) ? n.sibling : null } G(rP, 1 & rP.current); break; case 19: if (i = 0 != (o & a.childLanes), 0 != (128 & n.flags)) { if (i) return yj(n, a, o); a.flags |= 128 } if (null !== (s = a.memoizedState) && (s.rendering = null, s.tail = null, s.lastEffect = null), G(rP, rP.current), !i) return null; break; case 22: case 23: return a.lanes = 0, ej(n, a, o) }return $i(n, a, o) }(n, a, o); rq = 0 != (131072 & n.flags) } } else rq = !1, ro && 0 != (1048576 & a.flags) && ug(a, n5, a.index); switch (a.lanes = 0, a.tag) { case 2: var i = a.type; jj(n, a), n = a.pendingProps; var s = Yf(a, nK.current); Tg(a, o), s = Xh(null, a, i, n, s, o); var _ = bi(); return a.flags |= 1, "object" == typeof s && null !== s && "function" == typeof s.render && void 0 === s.$$typeof ? (a.tag = 1, a.memoizedState = null, a.updateQueue = null, Zf(i) ? (_ = !0, cg(a)) : _ = !1, a.memoizedState = null !== s.state && void 0 !== s.state ? s.state : null, ah(a), s.updater = rw, a.stateNode = s, s._reactInternals = a, rh(a, i, n, o), a = kj(null, a, i, !0, _, o)) : (a.tag = 0, ro && _ && vg(a), Yi(null, a, s, o), a = a.child), a; case 16: i = a.elementType; e: { switch (jj(n, a), n = a.pendingProps, i = (s = i._init)(i._payload), a.type = i, s = a.tag = function (n) { if ("function" == typeof n) return bj(n) ? 1 : 0; if (null != n) { if ((n = n.$$typeof) === ex) return 11; if (n === e_) return 14 } return 2 }(i), n = Lg(i, n), s) { case 0: a = dj(null, a, i, n, o); break e; case 1: a = ij(null, a, i, n, o); break e; case 11: a = Zi(null, a, i, n, o); break e; case 14: a = aj(null, a, i, Lg(i.type, n), o); break e }throw Error(p(306, i, "")) } return a; case 0: return i = a.type, s = a.pendingProps, s = a.elementType === i ? s : Lg(i, s), dj(n, a, i, s, o); case 1: return i = a.type, s = a.pendingProps, s = a.elementType === i ? s : Lg(i, s), ij(n, a, i, s, o); case 3: e: { if (lj(a), null === n) throw Error(p(387)); i = a.pendingProps, s = (_ = a.memoizedState).element, bh(n, a), gh(a, i, null, o); var N = a.memoizedState; if (i = N.element, _.isDehydrated) { if (_ = { element: i, isDehydrated: !1, cache: N.cache, pendingSuspenseBoundaries: N.pendingSuspenseBoundaries, transitions: N.transitions }, a.updateQueue.baseState = _, a.memoizedState = _, 256 & a.flags) { s = Ki(Error(p(423)), a), a = mj(n, a, i, o, s); break e } if (i !== s) { s = Ki(Error(p(424)), a), a = mj(n, a, i, o, s); break e } for (rl = Lf(a.stateNode.containerInfo.firstChild), ra = a, ro = !0, ru = null, o = rx(a, null, i, o), a.child = o; o;)o.flags = -3 & o.flags | 4096, o = o.sibling } else { if (Ig(), i === s) { a = $i(n, a, o); break e } Yi(n, a, i, o) } a = a.child } return a; case 5: return Kh(a), null === n && Eg(a), i = a.type, s = a.pendingProps, _ = null !== n ? n.memoizedProps : null, N = s.children, Ef(i, s) ? N = null : null !== _ && Ef(i, _) && (a.flags |= 32), hj(n, a), Yi(n, a, N, o), a.child; case 6: return null === n && Eg(a), null; case 13: return pj(n, a, o); case 4: return Ih(a, a.stateNode.containerInfo), i = a.pendingProps, null === n ? a.child = rS(a, null, i, o) : Yi(n, a, i, o), a.child; case 11: return i = a.type, s = a.pendingProps, s = a.elementType === i ? s : Lg(i, s), Zi(n, a, i, s, o); case 7: return Yi(n, a, a.pendingProps, o), a.child; case 8: case 12: return Yi(n, a, a.pendingProps.children, o), a.child; case 10: e: { if (i = a.type._context, s = a.pendingProps, _ = a.memoizedProps, N = s.value, G(rf, i._currentValue), i._currentValue = N, null !== _) { if (nh(_.value, N)) { if (_.children === s.children && !nJ.current) { a = $i(n, a, o); break e } } else for (null !== (_ = a.child) && (_.return = a); null !== _;) { var z = _.dependencies; if (null !== z) { N = _.child; for (var j = z.firstContext; null !== j;) { if (j.context === i) { if (1 === _.tag) { (j = ch(-1, o & -o)).tag = 2; var B = _.updateQueue; if (null !== B) { var $ = (B = B.shared).pending; null === $ ? j.next = j : (j.next = $.next, $.next = j), B.pending = j } } _.lanes |= o, null !== (j = _.alternate) && (j.lanes |= o), Sg(_.return, o, a), z.lanes |= o; break } j = j.next } } else if (10 === _.tag) N = _.type === a.type ? null : _.child; else if (18 === _.tag) { if (null === (N = _.return)) throw Error(p(341)); N.lanes |= o, null !== (z = N.alternate) && (z.lanes |= o), Sg(N, o, a), N = _.sibling } else N = _.child; if (null !== N) N.return = _; else for (N = _; null !== N;) { if (N === a) { N = null; break } if (null !== (_ = N.sibling)) { _.return = N.return, N = _; break } N = N.return } _ = N } } Yi(n, a, s.children, o), a = a.child } return a; case 9: return s = a.type, i = a.pendingProps.children, Tg(a, o), i = i(s = Vg(s)), a.flags |= 1, Yi(n, a, i, o), a.child; case 14: return s = Lg(i = a.type, a.pendingProps), s = Lg(i.type, s), aj(n, a, i, s, o); case 15: return cj(n, a, a.type, a.pendingProps, o); case 17: return i = a.type, s = a.pendingProps, s = a.elementType === i ? s : Lg(i, s), jj(n, a), a.tag = 1, Zf(i) ? (n = !0, cg(a)) : n = !1, Tg(a, o), ph(a, i, s), rh(a, i, s, o), kj(null, a, i, !0, n, o); case 19: return yj(n, a, o); case 22: return ej(n, a, o) }throw Error(p(156, a.tag)) }; var aP = "function" == typeof reportError ? reportError : function (n) { console.error(n) }; function ml(n) { this._internalRoot = n } function nl(n) { this._internalRoot = n } function ol(n) { return !(!n || 1 !== n.nodeType && 9 !== n.nodeType && 11 !== n.nodeType) } function pl(n) { return !(!n || 1 !== n.nodeType && 9 !== n.nodeType && 11 !== n.nodeType && (8 !== n.nodeType || " react-mount-point-unstable " !== n.nodeValue)) } function ql() { } function sl(n, a, o, i, s) { var _ = o._reactRootContainer; if (_) { var N = _; if ("function" == typeof s) { var z = s; s = function () { var n = hl(N); z.call(n) } } gl(a, N, n, s) } else N = function (n, a, o, i, s) { if (s) { if ("function" == typeof i) { var _ = i; i = function () { var n = hl(N); _.call(n) } } var N = fl(a, i, n, 0, null, !1, !1, "", ql); return n._reactRootContainer = N, n[nH] = N.current, sf(8 === n.nodeType ? n.parentNode : n), Sk(), N } for (; s = n.lastChild;)n.removeChild(s); if ("function" == typeof i) { var z = i; i = function () { var n = hl(j); z.call(n) } } var j = cl(n, 0, !1, null, null, !1, !1, "", ql); return n._reactRootContainer = j, n[nH] = j.current, sf(8 === n.nodeType ? n.parentNode : n), Sk(function () { gl(a, j, o, i) }), j }(o, a, n, s, i); return hl(N) } nl.prototype.render = ml.prototype.render = function (n) { var a = this._internalRoot; if (null === a) throw Error(p(409)); gl(n, a, null, null) }, nl.prototype.unmount = ml.prototype.unmount = function () { var n = this._internalRoot; if (null !== n) { this._internalRoot = null; var a = n.containerInfo; Sk(function () { gl(null, n, null, null) }), a[nH] = null } }, nl.prototype.unstable_scheduleHydration = function (n) { if (n) { var a = ty(); n = { blockedOn: null, target: n, priority: a }; for (var o = 0; o < tP.length && 0 !== a && a < tP[o].priority; o++); tP.splice(o, 0, n), 0 === o && Vc(n) } }, tp = function (n) { switch (n.tag) { case 3: var a = n.stateNode; if (a.current.memoizedState.isDehydrated) { var o = tc(a.pendingLanes); 0 !== o && (Cc(a, 1 | o), Ek(a, e3()), 0 == (6 & r8) && (af = e3() + 500, jg())) } break; case 13: Sk(function () { var a = Zg(n, 1); null !== a && mh(a, n, 1, L()) }), jl(n, 1) } }, tm = function (n) { if (13 === n.tag) { var a = Zg(n, 134217728); null !== a && mh(a, n, 134217728, L()), jl(n, 134217728) } }, tv = function (n) { if (13 === n.tag) { var a = lh(n), o = Zg(n, a); null !== o && mh(o, n, a, L()), jl(n, a) } }, ty = function () { return td }, tk = function (n, a) { var o = td; try { return td = n, a() } finally { td = o } }, eU = function (n, a, o) { switch (a) { case "input": if (bb(n, o), a = o.name, "radio" === o.type && null != a) { for (o = n; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), a = 0; a < o.length; a++) { var i = o[a]; if (i !== n && i.form === n.form) { var s = Db(i); if (!s) throw Error(p(90)); Wa(i), bb(i, s) } } } break; case "textarea": ib(n, o); break; case "select": null != (a = o.value) && fb(n, !!o.multiple, a, !1) } }, Gb = Rk, Hb = Sk; var aF = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, aR = { bundleType: aF.bundleType, version: aF.version, rendererPackageName: aF.rendererPackageName, rendererConfig: aF.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ef.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return null === (n = Zb(n)) ? null : n.stateNode }, findFiberByHostInstance: aF.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var aN = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!aN.isDisabled && aN.supportsFiber) try { tt = aN.inject(aR), tn = aN } catch (n) { } } a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Rk] }, a.createPortal = function (n, a) { var o = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!ol(a)) throw Error(p(200)); return function (n, a, o) { var i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: eg, key: null == i ? null : "" + i, children: n, containerInfo: a, implementation: null } }(n, a, null, o) }, a.createRoot = function (n, a) { if (!ol(n)) throw Error(p(299)); var o = !1, i = "", s = aP; return null != a && (!0 === a.unstable_strictMode && (o = !0), void 0 !== a.identifierPrefix && (i = a.identifierPrefix), void 0 !== a.onRecoverableError && (s = a.onRecoverableError)), a = cl(n, 1, !1, null, null, o, !1, i, s), n[nH] = a.current, sf(8 === n.nodeType ? n.parentNode : n), new ml(a) }, a.findDOMNode = function (n) { if (null == n) return null; if (1 === n.nodeType) return n; var a = n._reactInternals; if (void 0 === a) { if ("function" == typeof n.render) throw Error(p(188)); throw Error(p(268, n = Object.keys(n).join(","))) } return n = null === (n = Zb(a)) ? null : n.stateNode }, a.flushSync = function (n) { return Sk(n) }, a.hydrate = function (n, a, o) { if (!pl(a)) throw Error(p(200)); return sl(null, n, a, !0, o) }, a.hydrateRoot = function (n, a, o) { if (!ol(n)) throw Error(p(405)); var i = null != o && o.hydratedSources || null, s = !1, _ = "", N = aP; if (null != o && (!0 === o.unstable_strictMode && (s = !0), void 0 !== o.identifierPrefix && (_ = o.identifierPrefix), void 0 !== o.onRecoverableError && (N = o.onRecoverableError)), a = fl(a, null, n, 1, null != o ? o : null, s, !1, _, N), n[nH] = a.current, sf(n), i) for (n = 0; n < i.length; n++)s = (s = (o = i[n])._getVersion)(o._source), null == a.mutableSourceEagerHydrationData ? a.mutableSourceEagerHydrationData = [o, s] : a.mutableSourceEagerHydrationData.push(o, s); return new nl(a) }, a.render = function (n, a, o) { if (!pl(a)) throw Error(p(200)); return sl(null, n, a, !1, o) }, a.unmountComponentAtNode = function (n) { if (!pl(n)) throw Error(p(40)); return !!n._reactRootContainer && (Sk(function () { sl(null, null, n, !1, function () { n._reactRootContainer = null, n[nH] = null }) }), !0) }, a.unstable_batchedUpdates = Rk, a.unstable_renderSubtreeIntoContainer = function (n, a, o, i) { if (!pl(o)) throw Error(p(200)); if (null == n || void 0 === n._reactInternals) throw Error(p(38)); return sl(n, a, o, !1, i) }, a.version = "18.2.0-next-9e3b772b8-20220608"
  }, 44478: function (n, a, o) { var i = o(10422); a.createRoot = i.createRoot, a.hydrateRoot = i.hydrateRoot }, 10422: function (n, a, o) { !function checkDCE() { if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE) } catch (n) { console.error(n) } }(), n.exports = o(53746) }, 9995: function (n, a, o) { var i, s; i = o(5041), s = o(4304), i.version, i.renderToString, a.uS = i.renderToStaticMarkup, i.renderToNodeStream, i.renderToStaticNodeStream, s.renderToReadableStream }, 3354: function (n, a, o) {/**
  * @license React
  * react-jsx-runtime.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */var i = o(50959), s = Symbol.for("react.element"), _ = Symbol.for("react.fragment"), N = Object.prototype.hasOwnProperty, z = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, j = { key: !0, ref: !0, __self: !0, __source: !0 }; function q(n, a, o) { var i, _ = {}, B = null, $ = null; for (i in void 0 !== o && (B = "" + o), void 0 !== a.key && (B = "" + a.key), void 0 !== a.ref && ($ = a.ref), a) N.call(a, i) && !j.hasOwnProperty(i) && (_[i] = a[i]); if (n && n.defaultProps) for (i in a = n.defaultProps) void 0 === _[i] && (_[i] = a[i]); return { $$typeof: s, type: n, key: B, ref: $, props: _, _owner: z.current } } a.Fragment = _, a.jsx = q, a.jsxs = q
  }, 95257: function (n, a) {/**
  * @license React
  * react.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */var o = Symbol.for("react.element"), i = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), _ = Symbol.for("react.strict_mode"), N = Symbol.for("react.profiler"), z = Symbol.for("react.provider"), j = Symbol.for("react.context"), B = Symbol.for("react.forward_ref"), $ = Symbol.for("react.suspense"), ee = Symbol.for("react.memo"), et = Symbol.for("react.lazy"), en = Symbol.iterator, er = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, ea = Object.assign, eo = {}; function E(n, a, o) { this.props = n, this.context = a, this.refs = eo, this.updater = o || er } function F() { } function G(n, a, o) { this.props = n, this.context = a, this.refs = eo, this.updater = o || er } E.prototype.isReactComponent = {}, E.prototype.setState = function (n, a) { if ("object" != typeof n && "function" != typeof n && null != n) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, n, a, "setState") }, E.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, "forceUpdate") }, F.prototype = E.prototype; var eu = G.prototype = new F; eu.constructor = G, ea(eu, E.prototype), eu.isPureReactComponent = !0; var es = Array.isArray, ec = Object.prototype.hasOwnProperty, ef = { current: null }, ep = { key: !0, ref: !0, __self: !0, __source: !0 }; function M(n, a, i) { var s, _ = {}, N = null, z = null; if (null != a) for (s in void 0 !== a.ref && (z = a.ref), void 0 !== a.key && (N = "" + a.key), a) ec.call(a, s) && !ep.hasOwnProperty(s) && (_[s] = a[s]); var j = arguments.length - 2; if (1 === j) _.children = i; else if (1 < j) { for (var B = Array(j), $ = 0; $ < j; $++)B[$] = arguments[$ + 2]; _.children = B } if (n && n.defaultProps) for (s in j = n.defaultProps) void 0 === _[s] && (_[s] = j[s]); return { $$typeof: o, type: n, key: N, ref: z, props: _, _owner: ef.current } } function O(n) { return "object" == typeof n && null !== n && n.$$typeof === o } var eg = /\/+/g; function Q(n, a) { var o, i; return "object" == typeof n && null !== n && null != n.key ? (o = "" + n.key, i = { "=": "=0", ":": "=2" }, "$" + o.replace(/[=:]/g, function (n) { return i[n] })) : a.toString(36) } function S(n, a, s) { if (null == n) return n; var _ = [], N = 0; return !function R(n, a, s, _, N) { var z, j, B, $ = typeof n; ("undefined" === $ || "boolean" === $) && (n = null); var ee = !1; if (null === n) ee = !0; else switch ($) { case "string": case "number": ee = !0; break; case "object": switch (n.$$typeof) { case o: case i: ee = !0 } }if (ee) return N = N(ee = n), n = "" === _ ? "." + Q(ee, 0) : _, es(N) ? (s = "", null != n && (s = n.replace(eg, "$&/") + "/"), R(N, a, s, "", function (n) { return n })) : null != N && (O(N) && (z = N, j = s + (!N.key || ee && ee.key === N.key ? "" : ("" + N.key).replace(eg, "$&/") + "/") + n, N = { $$typeof: o, type: z.type, key: j, ref: z.ref, props: z.props, _owner: z._owner }), a.push(N)), 1; if (ee = 0, _ = "" === _ ? "." : _ + ":", es(n)) for (var et = 0; et < n.length; et++) { var er = _ + Q($ = n[et], et); ee += R($, a, s, er, N) } else if ("function" == typeof (er = null === (B = n) || "object" != typeof B ? null : "function" == typeof (B = en && B[en] || B["@@iterator"]) ? B : null)) for (n = er.call(n), et = 0; !($ = n.next()).done;)er = _ + Q($ = $.value, et++), ee += R($, a, s, er, N); else if ("object" === $) throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === (a = String(n)) ? "object with keys {" + Object.keys(n).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead."); return ee }(n, _, "", "", function (n) { return a.call(s, n, N++) }), _ } function T(n) { if (-1 === n._status) { var a = n._result; (a = a()).then(function (a) { (0 === n._status || -1 === n._status) && (n._status = 1, n._result = a) }, function (a) { (0 === n._status || -1 === n._status) && (n._status = 2, n._result = a) }), -1 === n._status && (n._status = 0, n._result = a) } if (1 === n._status) return n._result.default; throw n._result } var em = { current: null }, ev = { transition: null }; a.Children = { map: S, forEach: function (n, a, o) { S(n, function () { a.apply(this, arguments) }, o) }, count: function (n) { var a = 0; return S(n, function () { a++ }), a }, toArray: function (n) { return S(n, function (n) { return n }) || [] }, only: function (n) { if (!O(n)) throw Error("React.Children.only expected to receive a single React element child."); return n } }, a.Component = E, a.Fragment = s, a.Profiler = N, a.PureComponent = G, a.StrictMode = _, a.Suspense = $, a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = { ReactCurrentDispatcher: em, ReactCurrentBatchConfig: ev, ReactCurrentOwner: ef }, a.cloneElement = function (n, a, i) { if (null == n) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + "."); var s = ea({}, n.props), _ = n.key, N = n.ref, z = n._owner; if (null != a) { if (void 0 !== a.ref && (N = a.ref, z = ef.current), void 0 !== a.key && (_ = "" + a.key), n.type && n.type.defaultProps) var j = n.type.defaultProps; for (B in a) ec.call(a, B) && !ep.hasOwnProperty(B) && (s[B] = void 0 === a[B] && void 0 !== j ? j[B] : a[B]) } var B = arguments.length - 2; if (1 === B) s.children = i; else if (1 < B) { j = Array(B); for (var $ = 0; $ < B; $++)j[$] = arguments[$ + 2]; s.children = j } return { $$typeof: o, type: n.type, key: _, ref: N, props: s, _owner: z } }, a.createContext = function (n) { return (n = { $$typeof: j, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: z, _context: n }, n.Consumer = n }, a.createElement = M, a.createFactory = function (n) { var a = M.bind(null, n); return a.type = n, a }, a.createRef = function () { return { current: null } }, a.forwardRef = function (n) { return { $$typeof: B, render: n } }, a.isValidElement = O, a.lazy = function (n) { return { $$typeof: et, _payload: { _status: -1, _result: n }, _init: T } }, a.memo = function (n, a) { return { $$typeof: ee, type: n, compare: void 0 === a ? null : a } }, a.startTransition = function (n) { var a = ev.transition; ev.transition = {}; try { n() } finally { ev.transition = a } }, a.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, a.useCallback = function (n, a) { return em.current.useCallback(n, a) }, a.useContext = function (n) { return em.current.useContext(n) }, a.useDebugValue = function () { }, a.useDeferredValue = function (n) { return em.current.useDeferredValue(n) }, a.useEffect = function (n, a) { return em.current.useEffect(n, a) }, a.useId = function () { return em.current.useId() }, a.useImperativeHandle = function (n, a, o) { return em.current.useImperativeHandle(n, a, o) }, a.useInsertionEffect = function (n, a) { return em.current.useInsertionEffect(n, a) }, a.useLayoutEffect = function (n, a) { return em.current.useLayoutEffect(n, a) }, a.useMemo = function (n, a) { return em.current.useMemo(n, a) }, a.useReducer = function (n, a, o) { return em.current.useReducer(n, a, o) }, a.useRef = function (n) { return em.current.useRef(n) }, a.useState = function (n) { return em.current.useState(n) }, a.useSyncExternalStore = function (n, a, o) { return em.current.useSyncExternalStore(n, a, o) }, a.useTransition = function () { return em.current.useTransition() }, a.version = "18.2.0"
  }, 50959: function (n, a, o) { n.exports = o(95257) }, 11527: function (n, a, o) { n.exports = o(3354) }, 85568: function (n, a) {/**
  * @license React
  * scheduler.production.min.js
  *
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */function f(n, a) { var o = n.length; for (n.push(a); 0 < o;) { var i = o - 1 >>> 1, s = n[i]; if (0 < g(s, a)) n[i] = a, n[o] = s, o = i; else break } } function h(n) { return 0 === n.length ? null : n[0] } function k(n) { if (0 === n.length) return null; var a = n[0], o = n.pop(); if (o !== a) { n[0] = o; for (var i = 0, s = n.length, _ = s >>> 1; i < _;) { var N = 2 * (i + 1) - 1, z = n[N], j = N + 1, B = n[j]; if (0 > g(z, o)) j < s && 0 > g(B, z) ? (n[i] = B, n[j] = o, i = j) : (n[i] = z, n[N] = o, i = N); else if (j < s && 0 > g(B, o)) n[i] = B, n[j] = o, i = j; else break } } return a } function g(n, a) { var o = n.sortIndex - a.sortIndex; return 0 !== o ? o : n.id - a.id } if ("object" == typeof performance && "function" == typeof performance.now) { var o, i = performance; a.unstable_now = function () { return i.now() } } else { var s = Date, _ = s.now(); a.unstable_now = function () { return s.now() - _ } } var N = [], z = [], j = 1, B = null, $ = 3, ee = !1, et = !1, en = !1, er = "function" == typeof setTimeout ? setTimeout : null, ea = "function" == typeof clearTimeout ? clearTimeout : null, eo = "undefined" != typeof setImmediate ? setImmediate : null; function G(n) { for (var a = h(z); null !== a;) { if (null === a.callback) k(z); else if (a.startTime <= n) k(z), a.sortIndex = a.expirationTime, f(N, a); else break; a = h(z) } } function H(n) { if (en = !1, G(n), !et) { if (null !== h(N)) et = !0, I(J); else { var a = h(z); null !== a && K(H, a.startTime - n) } } } function J(n, o) { et = !1, en && (en = !1, ea(ec), ec = -1), ee = !0; var i = $; try { for (G(o), B = h(N); null !== B && (!(B.expirationTime > o) || n && !M());) { var s = B.callback; if ("function" == typeof s) { B.callback = null, $ = B.priorityLevel; var _ = s(B.expirationTime <= o); o = a.unstable_now(), "function" == typeof _ ? B.callback = _ : B === h(N) && k(N), G(o) } else k(N); B = h(N) } if (null !== B) var j = !0; else { var er = h(z); null !== er && K(H, er.startTime - o), j = !1 } return j } finally { B = null, $ = i, ee = !1 } } "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var eu = !1, es = null, ec = -1, ef = 5, ep = -1; function M() { return !(a.unstable_now() - ep < ef) } function R() { if (null !== es) { var n = a.unstable_now(); ep = n; var i = !0; try { i = es(!0, n) } finally { i ? o() : (eu = !1, es = null) } } else eu = !1 } if ("function" == typeof eo) o = function () { eo(R) }; else if ("undefined" != typeof MessageChannel) { var eg = new MessageChannel, em = eg.port2; eg.port1.onmessage = R, o = function () { em.postMessage(null) } } else o = function () { er(R, 0) }; function I(n) { es = n, eu || (eu = !0, o()) } function K(n, o) { ec = er(function () { n(a.unstable_now()) }, o) } a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function (n) { n.callback = null }, a.unstable_continueExecution = function () { et || ee || (et = !0, I(J)) }, a.unstable_forceFrameRate = function (n) { 0 > n || 125 < n ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ef = 0 < n ? Math.floor(1e3 / n) : 5 }, a.unstable_getCurrentPriorityLevel = function () { return $ }, a.unstable_getFirstCallbackNode = function () { return h(N) }, a.unstable_next = function (n) { switch ($) { case 1: case 2: case 3: var a = 3; break; default: a = $ }var o = $; $ = a; try { return n() } finally { $ = o } }, a.unstable_pauseExecution = function () { }, a.unstable_requestPaint = function () { }, a.unstable_runWithPriority = function (n, a) { switch (n) { case 1: case 2: case 3: case 4: case 5: break; default: n = 3 }var o = $; $ = n; try { return a() } finally { $ = o } }, a.unstable_scheduleCallback = function (n, o, i) { var s = a.unstable_now(); switch (i = "object" == typeof i && null !== i && "number" == typeof (i = i.delay) && 0 < i ? s + i : s, n) { case 1: var _ = -1; break; case 2: _ = 250; break; case 5: _ = 1073741823; break; case 4: _ = 1e4; break; default: _ = 5e3 }return _ = i + _, n = { id: j++, callback: o, priorityLevel: n, startTime: i, expirationTime: _, sortIndex: -1 }, i > s ? (n.sortIndex = i, f(z, n), null === h(N) && n === h(z) && (en ? (ea(ec), ec = -1) : en = !0, K(H, i - s))) : (n.sortIndex = _, f(N, n), et || ee || (et = !0, I(J))), n }, a.unstable_shouldYield = M, a.unstable_wrapCallback = function (n) { var a = $; return function () { var o = $; $ = a; try { return n.apply(this, arguments) } finally { $ = o } } }
  }, 22962: function (n, a, o) { n.exports = o(85568) }
}]);

(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[179], {
  48370: function (r, n) { "use strict"; function getDeploymentIdQueryOrEmptyString() { return "" } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getDeploymentIdQueryOrEmptyString", { enumerable: !0, get: function () { return getDeploymentIdQueryOrEmptyString } }) }, 15884: function () { "trimStart" in String.prototype || (String.prototype.trimStart = String.prototype.trimLeft), "trimEnd" in String.prototype || (String.prototype.trimEnd = String.prototype.trimRight), "description" in Symbol.prototype || Object.defineProperty(Symbol.prototype, "description", { configurable: !0, get: function () { var r = /\((.*)\)/.exec(this.toString()); return r ? r[1] : void 0 } }), Array.prototype.flat || (Array.prototype.flat = function (r, n) { return n = this.concat.apply([], this), r > 1 && n.some(Array.isArray) ? n.flat(r - 1) : n }, Array.prototype.flatMap = function (r, n) { return this.map(r, n).flat() }), Promise.prototype.finally || (Promise.prototype.finally = function (r) { if ("function" != typeof r) return this.then(r, r); var n = this.constructor || Promise; return this.then(function (o) { return n.resolve(r()).then(function () { return o }) }, function (o) { return n.resolve(r()).then(function () { throw o }) }) }), Object.fromEntries || (Object.fromEntries = function (r) { return Array.from(r).reduce(function (r, n) { return r[n[0]] = n[1], r }, {}) }), Array.prototype.at || (Array.prototype.at = function (r) { var n = Math.trunc(r) || 0; if (n < 0 && (n += this.length), !(n < 0 || n >= this.length)) return this[n] }) }, 17420: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "addBasePath", { enumerable: !0, get: function () { return addBasePath } }); let l = o(46165), u = o(95958); function addBasePath(r, n) { return (0, u.normalizePathTrailingSlash)((0, l.addPathPrefix)(r, "")) } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 17089: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "addLocale", { enumerable: !0, get: function () { return addLocale } }); let l = o(95958), addLocale = function (r) { for (var n = arguments.length, u = Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)u[s - 1] = arguments[s]; return (0, l.normalizePathTrailingSlash)(o(43715).addLocale(r, ...u)) }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 74089: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { RSC: function () { return o }, ACTION: function () { return l }, NEXT_ROUTER_STATE_TREE: function () { return u }, NEXT_ROUTER_PREFETCH: function () { return s }, NEXT_URL: function () { return f }, RSC_CONTENT_TYPE_HEADER: function () { return d }, RSC_VARY_HEADER: function () { return h }, FLIGHT_PARAMETERS: function () { return g }, NEXT_RSC_UNION_QUERY: function () { return _ } }); let o = "RSC", l = "Next-Action", u = "Next-Router-State-Tree", s = "Next-Router-Prefetch", f = "Next-Url", d = "text/x-component", h = o + ", " + u + ", " + s + ", " + f, g = [[o], [u], [s]], _ = "_rsc"; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 89722: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "detectDomainLocale", { enumerable: !0, get: function () { return detectDomainLocale } }); let detectDomainLocale = function () { for (var r = arguments.length, n = Array(r), l = 0; l < r; l++)n[l] = arguments[l]; return o(79942).detectDomainLocale(...n) }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 22287: function (r, n) { "use strict"; let o; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { addMessageListener: function () { return addMessageListener }, sendMessage: function () { return sendMessage }, connectHMR: function () { return connectHMR } }); let l = []; function addMessageListener(r) { l.push(r) } function sendMessage(r) { if (o && o.readyState === o.OPEN) return o.send(r) } let u = 0; function connectHMR(r) { !function init() { let n; function handleDisconnect() { if (o.onerror = null, o.onclose = null, o.close(), ++u > 25) { window.location.reload(); return } clearTimeout(n), n = setTimeout(init, u > 5 ? 5e3 : 1e3) } o && o.close(); let { hostname: s, port: f } = location, d = function (r) { let n = location.protocol; try { n = new URL(r).protocol } catch (r) { } return "http:" === n ? "ws" : "wss" }(r.assetPrefix || ""), h = r.assetPrefix.replace(/^\/+/, ""), g = d + "://" + s + ":" + f + (h ? "/" + h : ""); h.startsWith("http") && (g = d + "://" + h.split("://")[1]), (o = new window.WebSocket("" + g + r.path)).onopen = function () { u = 0, window.console.log("[HMR] connected") }, o.onerror = handleDisconnect, o.onclose = handleDisconnect, o.onmessage = function (r) { let n = JSON.parse(r.data); for (let r of l) r(n) } }() } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 17815: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "hasBasePath", { enumerable: !0, get: function () { return hasBasePath } }); let l = o(97360); function hasBasePath(r) { return (0, l.pathHasPrefix)(r, "") } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 2555: function (r, n) { "use strict"; let o; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { DOMAttributeNames: function () { return l }, isEqualNode: function () { return isEqualNode }, default: function () { return initHeadManager } }); let l = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv", noModule: "noModule" }; function reactElementToDOM(r) { let { type: n, props: o } = r, u = document.createElement(n); for (let r in o) { if (!o.hasOwnProperty(r) || "children" === r || "dangerouslySetInnerHTML" === r || void 0 === o[r]) continue; let s = l[r] || r.toLowerCase(); "script" === n && ("async" === s || "defer" === s || "noModule" === s) ? u[s] = !!o[r] : u.setAttribute(s, o[r]) } let { children: s, dangerouslySetInnerHTML: f } = o; return f ? u.innerHTML = f.__html || "" : s && (u.textContent = "string" == typeof s ? s : Array.isArray(s) ? s.join("") : ""), u } function isEqualNode(r, n) { if (r instanceof HTMLElement && n instanceof HTMLElement) { let o = n.getAttribute("nonce"); if (o && !r.getAttribute("nonce")) { let l = n.cloneNode(!0); return l.setAttribute("nonce", ""), l.nonce = o, o === r.nonce && r.isEqualNode(l) } } return r.isEqualNode(n) } function initHeadManager() { return { mountedInstances: new Set, updateHead: r => { let n = {}; r.forEach(r => { if ("link" === r.type && r.props["data-optimized-fonts"]) { if (document.querySelector('style[data-href="' + r.props["data-href"] + '"]')) return; r.props.href = r.props["data-href"], r.props["data-href"] = void 0 } let o = n[r.type] || []; o.push(r), n[r.type] = o }); let l = n.title ? n.title[0] : null, u = ""; if (l) { let { children: r } = l.props; u = "string" == typeof r ? r : Array.isArray(r) ? r.join("") : "" } u !== document.title && (document.title = u), ["meta", "base", "link", "style", "script"].forEach(r => { o(r, n[r] || []) }) } } } o = (r, n) => { let o = document.getElementsByTagName("head")[0], l = o.querySelector("meta[name=next-head-count]"), u = Number(l.content), s = []; for (let n = 0, o = l.previousElementSibling; n < u; n++, o = (null == o ? void 0 : o.previousElementSibling) || null) { var f; (null == o ? void 0 : null == (f = o.tagName) ? void 0 : f.toLowerCase()) === r && s.push(o) } let d = n.map(reactElementToDOM).filter(r => { for (let n = 0, o = s.length; n < o; n++) { let o = s[n]; if (isEqualNode(o, r)) return s.splice(n, 1), !1 } return !0 }); s.forEach(r => { var n; return null == (n = r.parentNode) ? void 0 : n.removeChild(r) }), d.forEach(r => o.insertBefore(r, l)), l.content = (u - s.length + d.length).toString() }, ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 34186: function (r, n, o) { "use strict"; let l, u, s, f, d, h, g, _, y, P, b, E; Object.defineProperty(n, "__esModule", { value: !0 }); let S = o(35815); Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { version: function () { return J }, router: function () { return l }, emitter: function () { return Z }, initialize: function () { return initialize }, hydrate: function () { return hydrate } }); let R = o(81351); o(15884); let O = R._(o(50959)), w = R._(o(44478)), A = o(81105), C = R._(o(66656)), x = o(17755), j = o(58745), M = o(1716), L = o(69921), I = o(84800), N = o(31393), D = o(77218), k = R._(o(2555)), F = R._(o(70359)), U = R._(o(3051)), H = o(83134), B = o(58066), W = o(19032), q = o(66697), z = o(66919), G = o(17815), V = o(76668), X = o(18102), Y = o(67069), Q = R._(o(21191)), K = R._(o(69074)), $ = R._(o(39867)), J = "13.5.6", Z = (0, C.default)(), looseToArray = r => [].slice.call(r), ee = !1; let Container = class Container extends O.default.Component { componentDidCatch(r, n) { this.props.fn(r, n) } componentDidMount() { this.scrollToHash(), l.isSsr && (u.isFallback || u.nextExport && ((0, M.isDynamicRoute)(l.pathname) || location.search, 1) || u.props && u.props.__N_SSG && (location.search, 1)) && l.replace(l.pathname + "?" + String((0, L.assign)((0, L.urlQueryToSearchParams)(l.query), new URLSearchParams(location.search))), s, { _h: 1, shallow: !u.isFallback && !ee }).catch(r => { if (!r.cancelled) throw r }) } componentDidUpdate() { this.scrollToHash() } scrollToHash() { let { hash: r } = location; if (!(r = r && r.substring(1))) return; let n = document.getElementById(r); n && setTimeout(() => n.scrollIntoView(), 0) } render() { return this.props.children } }; async function initialize(r) { void 0 === r && (r = {}), K.default.onSpanEnd($.default), u = JSON.parse(document.getElementById("__NEXT_DATA__").textContent), window.__NEXT_DATA__ = u, E = u.defaultLocale; let n = u.assetPrefix || ""; self.__next_set_public_path__("" + n + "/_next/"), (0, I.setConfig)({ serverRuntimeConfig: {}, publicRuntimeConfig: u.runtimeConfig || {} }), s = (0, N.getURL)(), (0, G.hasBasePath)(s) && (s = (0, z.removeBasePath)(s)); { let { normalizeLocalePath: r } = o(26573), { detectDomainLocale: n } = o(79942), { parseRelativeUrl: l } = o(47400), { formatUrl: f } = o(14564); if (u.locales) { let o = l(s), d = r(o.pathname, u.locales); d.detectedLocale ? (o.pathname = d.pathname, s = f(o)) : E = u.locale; let h = n(void 0, window.location.hostname); h && (E = h.defaultLocale) } } if (u.scriptLoader) { let { initScriptLoader: r } = o(99156); r(u.scriptLoader) } f = new F.default(u.buildId, n); let register = r => { let [n, o] = r; return f.routeLoader.onEntrypoint(n, o) }; return window.__NEXT_P && window.__NEXT_P.map(r => setTimeout(() => register(r), 0)), window.__NEXT_P = [], window.__NEXT_P.push = register, (h = (0, k.default)()).getIsSsr = () => l.isSsr, d = document.getElementById("__next"), { assetPrefix: n } } function renderApp(r, n) { return O.default.createElement(r, n) } function AppContainer(r) { var n; let { children: o } = r, u = O.default.useMemo(() => (0, X.adaptForAppRouterInstance)(l), []); return O.default.createElement(Container, { fn: r => renderError({ App: y, err: r }).catch(r => console.error("Error rendering page: ", r)) }, O.default.createElement(V.AppRouterContext.Provider, { value: u }, O.default.createElement(Y.SearchParamsContext.Provider, { value: (0, X.adaptForSearchParams)(l) }, O.default.createElement(X.PathnameContextProviderAdapter, { router: l, isAutoExport: null != (n = self.__NEXT_DATA__.autoExport) && n }, O.default.createElement(Y.PathParamsContext.Provider, { value: (0, X.adaptForPathParams)(l) }, O.default.createElement(x.RouterContext.Provider, { value: (0, B.makePublicRouterInstance)(l) }, O.default.createElement(A.HeadManagerContext.Provider, { value: h }, O.default.createElement(q.ImageConfigContext.Provider, { value: { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image", loader: "default", dangerouslyAllowSVG: !1, unoptimized: !1 } }, o)))))))) } let wrapApp = r => n => { let o = { ...n, Component: b, err: u.err, router: l }; return O.default.createElement(AppContainer, null, renderApp(r, o)) }; function renderError(r) { let { App: n, err: d } = r; return console.error(d), console.error("A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred"), f.loadPage("/_error").then(l => { let { page: u, styleSheets: s } = l; return (null == g ? void 0 : g.Component) === u ? Promise.resolve().then(() => S._(o(11286))).then(l => Promise.resolve().then(() => S._(o(62385))).then(o => (n = o.default, r.App = n, l))).then(r => ({ ErrorComponent: r.default, styleSheets: [] })) : { ErrorComponent: u, styleSheets: s } }).then(o => { var f; let { ErrorComponent: h, styleSheets: g } = o, _ = wrapApp(n), y = { Component: h, AppTree: _, router: l, ctx: { err: d, pathname: u.page, query: u.query, asPath: s, AppTree: _ } }; return Promise.resolve((null == (f = r.props) ? void 0 : f.err) ? r.props : (0, N.loadGetInitialProps)(n, y)).then(n => doRender({ ...r, err: d, Component: h, styleSheets: g, props: n })) }) } function Head(r) { let { callback: n } = r; return O.default.useLayoutEffect(() => n(), [n]), null } let et = { navigationStart: "navigationStart", beforeRender: "beforeRender", afterRender: "afterRender", afterHydrate: "afterHydrate", routeChange: "routeChange" }, er = { hydration: "Next.js-hydration", beforeHydration: "Next.js-before-hydration", routeChangeToRender: "Next.js-route-change-to-render", render: "Next.js-render" }, en = null, ea = !0; function clearMarks() { [et.beforeRender, et.afterHydrate, et.afterRender, et.routeChange].forEach(r => performance.clearMarks(r)) } function markHydrateComplete() { if (!N.ST) return; performance.mark(et.afterHydrate); let r = performance.getEntriesByName(et.beforeRender, "mark").length; r && (performance.measure(er.beforeHydration, et.navigationStart, et.beforeRender), performance.measure(er.hydration, et.beforeRender, et.afterHydrate)), P && performance.getEntriesByName(er.hydration).forEach(P), clearMarks() } function markRenderComplete() { if (!N.ST) return; performance.mark(et.afterRender); let r = performance.getEntriesByName(et.routeChange, "mark"); if (!r.length) return; let n = performance.getEntriesByName(et.beforeRender, "mark").length; n && (performance.measure(er.routeChangeToRender, r[0].name, et.beforeRender), performance.measure(er.render, et.beforeRender, et.afterRender), P && (performance.getEntriesByName(er.render).forEach(P), performance.getEntriesByName(er.routeChangeToRender).forEach(P))), clearMarks(), [er.routeChangeToRender, er.render].forEach(r => performance.clearMeasures(r)) } function Root(r) { let { callbacks: n, children: o } = r; return O.default.useLayoutEffect(() => n.forEach(r => r()), [n]), O.default.useEffect(() => { (0, U.default)(P) }, []), o } function doRender(r) { let n, { App: o, Component: u, props: s, err: f } = r, h = "initial" in r ? void 0 : r.styleSheets; u = u || g.Component, s = s || g.props; let y = { ...s, Component: u, err: f, router: l }; g = y; let P = !1, b = new Promise((r, o) => { _ && _(), n = () => { _ = null, r() }, _ = () => { P = !0, _ = null; let r = Error("Cancel rendering route"); r.cancelled = !0, o(r) } }); function onRootCommit() { n() } !function () { if (!h) return; let r = looseToArray(document.querySelectorAll("style[data-n-href]")), n = new Set(r.map(r => r.getAttribute("data-n-href"))), o = document.querySelector("noscript[data-n-css]"), l = null == o ? void 0 : o.getAttribute("data-n-css"); h.forEach(r => { let { href: o, text: u } = r; if (!n.has(o)) { let r = document.createElement("style"); r.setAttribute("data-n-href", o), r.setAttribute("media", "x"), l && r.setAttribute("nonce", l), document.head.appendChild(r), r.appendChild(document.createTextNode(u)) } }) }(); let E = O.default.createElement(O.default.Fragment, null, O.default.createElement(Head, { callback: function () { if (h && !P) { let r = new Set(h.map(r => r.href)), n = looseToArray(document.querySelectorAll("style[data-n-href]")), o = n.map(r => r.getAttribute("data-n-href")); for (let l = 0; l < o.length; ++l)r.has(o[l]) ? n[l].removeAttribute("media") : n[l].setAttribute("media", "x"); let l = document.querySelector("noscript[data-n-css]"); l && h.forEach(r => { let { href: n } = r, o = document.querySelector('style[data-n-href="' + n + '"]'); o && (l.parentNode.insertBefore(o, l.nextSibling), l = o) }), looseToArray(document.querySelectorAll("link[data-n-p]")).forEach(r => { r.parentNode.removeChild(r) }) } if (r.scroll) { let { x: n, y: o } = r.scroll; (0, j.handleSmoothScroll)(() => { window.scrollTo(n, o) }) } } }), O.default.createElement(AppContainer, null, renderApp(o, y), O.default.createElement(D.Portal, { type: "next-route-announcer" }, O.default.createElement(H.RouteAnnouncer, null)))); return !function (r, n) { N.ST && performance.mark(et.beforeRender); let o = n(ea ? markHydrateComplete : markRenderComplete); if (en) { let r = O.default.startTransition; r(() => { en.render(o) }) } else en = w.default.hydrateRoot(r, o, { onRecoverableError: Q.default }), ea = !1 }(d, r => O.default.createElement(Root, { callbacks: [r, onRootCommit] }, E)), b } async function render(r) { if (r.err) { await renderError(r); return } try { await doRender(r) } catch (o) { let n = (0, W.getProperError)(o); if (n.cancelled) throw n; await renderError({ ...r, err: n }) } } async function hydrate(r) { let n = u.err; try { let r = await f.routeLoader.whenEntrypoint("/_app"); if ("error" in r) throw r.error; let { component: n, exports: o } = r; y = n, o && o.reportWebVitals && (P = r => { let n, { id: l, name: u, startTime: s, value: f, duration: d, entryType: h, entries: g, attribution: _ } = r, y = Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12); g && g.length && (n = g[0].startTime); let P = { id: l || y, name: u, startTime: s || n, value: null == f ? d : f, label: "mark" === h || "measure" === h ? "custom" : "web-vital" }; _ && (P.attribution = _), o.reportWebVitals(P) }); let l = await f.routeLoader.whenEntrypoint(u.page); if ("error" in l) throw l.error; b = l.component } catch (r) { n = (0, W.getProperError)(r) } window.__NEXT_PRELOADREADY && await window.__NEXT_PRELOADREADY(u.dynamicIds), l = (0, B.createRouter)(u.page, u.query, s, { initialProps: u.props, pageLoader: f, App: y, Component: b, wrapApp, err: n, isFallback: !!u.isFallback, subscription: (r, n, o) => render(Object.assign({}, r, { App: n, scroll: o })), locale: u.locale, locales: u.locales, defaultLocale: E, domainLocales: u.domainLocales, isPreview: u.isPreview }), ee = await l._initialMatchesMiddlewarePromise; let o = { App: y, initial: !0, Component: b, props: u.props, err: n }; (null == r ? void 0 : r.beforeRender) && await r.beforeRender(), render(o) } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 22944: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), o(21016); let l = o(34186); window.next = { version: l.version, get router() { return l.router }, emitter: l.emitter }, (0, l.initialize)({}).then(() => (0, l.hydrate)()).catch(console.error), ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 95958: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "normalizePathTrailingSlash", { enumerable: !0, get: function () { return normalizePathTrailingSlash } }); let l = o(6847), u = o(70629), normalizePathTrailingSlash = r => { if (!r.startsWith("/")) return r; let { pathname: n, query: o, hash: s } = (0, u.parsePath)(r); return "" + (0, l.removeTrailingSlash)(n) + o + s }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 21191: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return onRecoverableError } }); let l = o(55209); function onRecoverableError(r) { let n = "function" == typeof reportError ? reportError : r => { window.console.error(r) }; r.digest !== l.NEXT_DYNAMIC_NO_SSR_CODE && n(r) } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 70359: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return PageLoader } }); let l = o(81351), u = o(17420), s = o(87973), f = l._(o(35547)), d = o(17089), h = o(1716), g = o(47400), _ = o(6847), y = o(26629); o(22963); let PageLoader = class PageLoader { getPageList() { return (0, y.getClientBuildManifest)().then(r => r.sortedPages) } getMiddleware() { return window.__MIDDLEWARE_MATCHERS = [{ regexp: ".*", originalSource: "/:path*" }], window.__MIDDLEWARE_MATCHERS } getDataHref(r) { let { asPath: n, href: o, locale: l } = r, { pathname: y, query: P, search: b } = (0, g.parseRelativeUrl)(o), { pathname: E } = (0, g.parseRelativeUrl)(n), S = (0, _.removeTrailingSlash)(y); if ("/" !== S[0]) throw Error('Route name should start with a "/", got "' + S + '"'); return (r => { let n = (0, f.default)((0, _.removeTrailingSlash)((0, d.addLocale)(r, l)), ".json"); return (0, u.addBasePath)("/_next/data/" + this.buildId + n + b, !0) })(r.skipInterpolation ? E : (0, h.isDynamicRoute)(S) ? (0, s.interpolateAs)(y, E, P).result : S) } _isSsg(r) { return this.promisedSsgManifest.then(n => n.has(r)) } loadPage(r) { return this.routeLoader.loadRoute(r).then(r => { if ("component" in r) return { page: r.component, mod: r.exports, styleSheets: r.styles.map(r => ({ href: r.href, text: r.content })) }; throw r.error }) } prefetch(r) { return this.routeLoader.prefetch(r) } constructor(r, n) { this.routeLoader = (0, y.createRouteLoader)(n), this.buildId = r, this.assetPrefix = n, this.promisedSsgManifest = new Promise(r => { window.__SSG_MANIFEST ? r(window.__SSG_MANIFEST) : window.__SSG_MANIFEST_CB = () => { r(window.__SSG_MANIFEST) } }) } }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 3051: function (r, n, o) { "use strict"; let l; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return _default } }); let u = ["CLS", "FCP", "FID", "INP", "LCP", "TTFB"]; location.href; let s = !1; function onReport(r) { l && l(r) } let _default = r => { if (l = r, !s) for (let r of (s = !0, u)) try { let n; n || (n = o(33056)), n["on" + r](onReport) } catch (n) { console.warn("Failed to track " + r + " web-vital", n) } }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 77218: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "Portal", { enumerable: !0, get: function () { return Portal } }); let l = o(50959), u = o(10422), Portal = r => { let { children: n, type: o } = r, [s, f] = (0, l.useState)(null); return (0, l.useEffect)(() => { let r = document.createElement(o); return document.body.appendChild(r), f(r), () => { document.body.removeChild(r) } }, [o]), s ? (0, u.createPortal)(n, s) : null }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 66919: function (r, n, o) { "use strict"; function removeBasePath(r) { return r } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "removeBasePath", { enumerable: !0, get: function () { return removeBasePath } }), o(17815), ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 95263: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "removeLocale", { enumerable: !0, get: function () { return removeLocale } }); let l = o(70629); function removeLocale(r, n) { { let { pathname: o } = (0, l.parsePath)(r), u = o.toLowerCase(), s = null == n ? void 0 : n.toLowerCase(); return n && (u.startsWith("/" + s + "/") || u === "/" + s) ? (o.length === n.length + 1 ? "/" : "") + r.slice(n.length + 1) : r } } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 49974: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { requestIdleCallback: function () { return o }, cancelIdleCallback: function () { return l } }); let o = "undefined" != typeof self && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function (r) { let n = Date.now(); return self.setTimeout(function () { r({ didTimeout: !1, timeRemaining: function () { return Math.max(0, 50 - (Date.now() - n)) } }) }, 1) }, l = "undefined" != typeof self && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function (r) { return clearTimeout(r) }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 44346: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "resolveHref", { enumerable: !0, get: function () { return resolveHref } }); let l = o(69921), u = o(14564), s = o(99076), f = o(31393), d = o(95958), h = o(69414), g = o(50038), _ = o(87973); function resolveHref(r, n, o) { let y; let P = "string" == typeof n ? n : (0, u.formatWithValidation)(n), b = P.match(/^[a-zA-Z]{1,}:\/\//), E = b ? P.slice(b[0].length) : P, S = E.split("?"); if ((S[0] || "").match(/(\/\/|\\)/)) { console.error("Invalid href '" + P + "' passed to next/router in page: '" + r.pathname + "'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href."); let n = (0, f.normalizeRepeatedSlashes)(E); P = (b ? b[0] : "") + n } if (!(0, h.isLocalURL)(P)) return o ? [P] : P; try { y = new URL(P.startsWith("#") ? r.asPath : r.pathname, "http://n") } catch (r) { y = new URL("/", "http://n") } try { let r = new URL(P, y); r.pathname = (0, d.normalizePathTrailingSlash)(r.pathname); let n = ""; if ((0, g.isDynamicRoute)(r.pathname) && r.searchParams && o) { let o = (0, l.searchParamsToUrlQuery)(r.searchParams), { result: f, params: d } = (0, _.interpolateAs)(r.pathname, r.pathname, o); f && (n = (0, u.formatWithValidation)({ pathname: f, hash: r.hash, query: (0, s.omit)(o, d) })) } let f = r.origin === y.origin ? r.href.slice(r.origin.length) : r.href; return o ? [f, n || f] : f } catch (r) { return o ? [P] : P } } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 83134: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { RouteAnnouncer: function () { return RouteAnnouncer }, default: function () { return d } }); let l = o(81351), u = l._(o(50959)), s = o(58066), f = { border: 0, clip: "rect(0 0 0 0)", height: "1px", margin: "-1px", overflow: "hidden", padding: 0, position: "absolute", top: 0, width: "1px", whiteSpace: "nowrap", wordWrap: "normal" }, RouteAnnouncer = () => { let { asPath: r } = (0, s.useRouter)(), [n, o] = u.default.useState(""), l = u.default.useRef(r); return u.default.useEffect(() => { if (l.current !== r) { if (l.current = r, document.title) o(document.title); else { var n; let l = document.querySelector("h1"), u = null != (n = null == l ? void 0 : l.innerText) ? n : null == l ? void 0 : l.textContent; o(u || r) } } }, [r]), u.default.createElement("p", { "aria-live": "assertive", id: "__next-route-announcer__", role: "alert", style: f }, n) }, d = RouteAnnouncer; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 26629: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { markAssetError: function () { return markAssetError }, isAssetError: function () { return isAssetError }, getClientBuildManifest: function () { return getClientBuildManifest }, createRouteLoader: function () { return createRouteLoader } }), o(81351), o(35547); let l = o(45238), u = o(49974), s = o(48370); function withFuture(r, n, o) { let l, u = n.get(r); if (u) return "future" in u ? u.future : Promise.resolve(u); let s = new Promise(r => { l = r }); return n.set(r, u = { resolve: l, future: s }), o ? o().then(r => (l(r), r)).catch(o => { throw n.delete(r), o }) : s } let f = Symbol("ASSET_LOAD_ERROR"); function markAssetError(r) { return Object.defineProperty(r, f, {}) } function isAssetError(r) { return r && f in r } let d = function (r) { try { return r = document.createElement("link"), !!window.MSInputMethodContext && !!document.documentMode || r.relList.supports("prefetch") } catch (r) { return !1 } }(), getAssetQueryString = () => (0, s.getDeploymentIdQueryOrEmptyString)(); function resolvePromiseWithTimeout(r, n, o) { return new Promise((l, s) => { let f = !1; r.then(r => { f = !0, l(r) }).catch(s), (0, u.requestIdleCallback)(() => setTimeout(() => { f || s(o) }, n)) }) } function getClientBuildManifest() { if (self.__BUILD_MANIFEST) return Promise.resolve(self.__BUILD_MANIFEST); let r = new Promise(r => { let n = self.__BUILD_MANIFEST_CB; self.__BUILD_MANIFEST_CB = () => { r(self.__BUILD_MANIFEST), n && n() } }); return resolvePromiseWithTimeout(r, 3800, markAssetError(Error("Failed to load client build manifest"))) } function getFilesForRoute(r, n) { return getClientBuildManifest().then(o => { if (!(n in o)) throw markAssetError(Error("Failed to lookup route: " + n)); let u = o[n].map(n => r + "/_next/" + encodeURI(n)); return { scripts: u.filter(r => r.endsWith(".js")).map(r => (0, l.__unsafeCreateTrustedScriptURL)(r) + getAssetQueryString()), css: u.filter(r => r.endsWith(".css")).map(r => r + getAssetQueryString()) } }) } function createRouteLoader(r) { let n = new Map, o = new Map, l = new Map, s = new Map; function maybeExecuteScript(r) { { var n; let l = o.get(r.toString()); return l || (document.querySelector('script[src^="' + r + '"]') ? Promise.resolve() : (o.set(r.toString(), l = new Promise((o, l) => { (n = document.createElement("script")).onload = o, n.onerror = () => l(markAssetError(Error("Failed to load script: " + r))), n.crossOrigin = void 0, n.src = r, document.body.appendChild(n) })), l)) } } function fetchStyleSheet(r) { let n = l.get(r); return n || l.set(r, n = fetch(r).then(n => { if (!n.ok) throw Error("Failed to load stylesheet: " + r); return n.text().then(n => ({ href: r, content: n })) }).catch(r => { throw markAssetError(r) })), n } return { whenEntrypoint: r => withFuture(r, n), onEntrypoint(r, o) { (o ? Promise.resolve().then(() => o()).then(r => ({ component: r && r.default || r, exports: r }), r => ({ error: r })) : Promise.resolve(void 0)).then(o => { let l = n.get(r); l && "resolve" in l ? o && (n.set(r, o), l.resolve(o)) : (o ? n.set(r, o) : n.delete(r), s.delete(r)) }) }, loadRoute(o, l) { return withFuture(o, s, () => { let u; return resolvePromiseWithTimeout(getFilesForRoute(r, o).then(r => { let { scripts: l, css: u } = r; return Promise.all([n.has(o) ? [] : Promise.all(l.map(maybeExecuteScript)), Promise.all(u.map(fetchStyleSheet))]) }).then(r => this.whenEntrypoint(o).then(n => ({ entrypoint: n, styles: r[1] }))), 3800, markAssetError(Error("Route did not complete loading: " + o))).then(r => { let { entrypoint: n, styles: o } = r, l = Object.assign({ styles: o }, n); return "error" in n ? n : l }).catch(r => { if (l) throw r; return { error: r } }).finally(() => null == u ? void 0 : u()) }) }, prefetch(n) { let o; return (o = navigator.connection) && (o.saveData || /2g/.test(o.effectiveType)) ? Promise.resolve() : getFilesForRoute(r, n).then(r => Promise.all(d ? r.scripts.map(r => { var n, o, l; return n = r.toString(), o = "script", new Promise((r, u) => { let s = '\n      link[rel="prefetch"][href^="' + n + '"],\n      link[rel="preload"][href^="' + n + '"],\n      script[src^="' + n + '"]'; if (document.querySelector(s)) return r(); l = document.createElement("link"), o && (l.as = o), l.rel = "prefetch", l.crossOrigin = void 0, l.onload = r, l.onerror = () => u(markAssetError(Error("Failed to prefetch: " + n))), l.href = n, document.head.appendChild(l) }) }) : [])).then(() => { (0, u.requestIdleCallback)(() => this.loadRoute(n, !0).catch(() => { })) }).catch(() => { }) } } } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 58066: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { Router: function () { return s.default }, default: function () { return P }, withRouter: function () { return h.default }, useRouter: function () { return useRouter }, createRouter: function () { return createRouter }, makePublicRouterInstance: function () { return makePublicRouterInstance } }); let l = o(81351), u = l._(o(50959)), s = l._(o(74063)), f = o(17755), d = l._(o(19032)), h = l._(o(9546)), g = { router: null, readyCallbacks: [], ready(r) { if (this.router) return r(); this.readyCallbacks.push(r) } }, _ = ["pathname", "route", "query", "asPath", "components", "isFallback", "basePath", "locale", "locales", "defaultLocale", "isReady", "isPreview", "isLocaleDomain", "domainLocales"], y = ["push", "replace", "reload", "back", "prefetch", "beforePopState"]; function getRouter() { if (!g.router) throw Error('No router instance found.\nYou should only use "next/router" on the client side of your app.\n'); return g.router } Object.defineProperty(g, "events", { get: () => s.default.events }), _.forEach(r => { Object.defineProperty(g, r, { get() { let n = getRouter(); return n[r] } }) }), y.forEach(r => { g[r] = function () { for (var n = arguments.length, o = Array(n), l = 0; l < n; l++)o[l] = arguments[l]; let u = getRouter(); return u[r](...o) } }), ["routeChangeStart", "beforeHistoryChange", "routeChangeComplete", "routeChangeError", "hashChangeStart", "hashChangeComplete"].forEach(r => { g.ready(() => { s.default.events.on(r, function () { for (var n = arguments.length, o = Array(n), l = 0; l < n; l++)o[l] = arguments[l]; let u = "on" + r.charAt(0).toUpperCase() + r.substring(1); if (g[u]) try { g[u](...o) } catch (r) { console.error("Error when running the Router event: " + u), console.error((0, d.default)(r) ? r.message + "\n" + r.stack : r + "") } }) }) }); let P = g; function useRouter() { let r = u.default.useContext(f.RouterContext); if (!r) throw Error("NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted"); return r } function createRouter() { for (var r = arguments.length, n = Array(r), o = 0; o < r; o++)n[o] = arguments[o]; return g.router = new s.default(...n), g.readyCallbacks.forEach(r => r()), g.readyCallbacks = [], g.router } function makePublicRouterInstance(r) { let n = {}; for (let o of _) { if ("object" == typeof r[o]) { n[o] = Object.assign(Array.isArray(r[o]) ? [] : {}, r[o]); continue } n[o] = r[o] } return n.events = s.default.events, y.forEach(o => { n[o] = function () { for (var n = arguments.length, l = Array(n), u = 0; u < n; u++)l[u] = arguments[u]; return r[o](...l) } }), n } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 99156: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { handleClientScriptLoad: function () { return handleClientScriptLoad }, initScriptLoader: function () { return initScriptLoader }, default: function () { return b } }); let l = o(81351), u = o(35815), s = l._(o(10422)), f = u._(o(50959)), d = o(81105), h = o(2555), g = o(49974), _ = new Map, y = new Set, P = ["onLoad", "onReady", "dangerouslySetInnerHTML", "children", "onError", "strategy", "stylesheets"], insertStylesheets = r => { if (s.default.preinit) { r.forEach(r => { s.default.preinit(r, { as: "style" }) }); return } { let n = document.head; r.forEach(r => { let o = document.createElement("link"); o.type = "text/css", o.rel = "stylesheet", o.href = r, n.appendChild(o) }) } }, loadScript = r => { let { src: n, id: o, onLoad: l = () => { }, onReady: u = null, dangerouslySetInnerHTML: s, children: f = "", strategy: d = "afterInteractive", onError: g, stylesheets: b } = r, E = o || n; if (E && y.has(E)) return; if (_.has(n)) { y.add(E), _.get(n).then(l, g); return } let afterLoad = () => { u && u(), y.add(E) }, S = document.createElement("script"), R = new Promise((r, n) => { S.addEventListener("load", function (n) { r(), l && l.call(this, n), afterLoad() }), S.addEventListener("error", function (r) { n(r) }) }).catch(function (r) { g && g(r) }); for (let [o, l] of (s ? (S.innerHTML = s.__html || "", afterLoad()) : f ? (S.textContent = "string" == typeof f ? f : Array.isArray(f) ? f.join("") : "", afterLoad()) : n && (S.src = n, _.set(n, R)), Object.entries(r))) { if (void 0 === l || P.includes(o)) continue; let r = h.DOMAttributeNames[o] || o.toLowerCase(); S.setAttribute(r, l) } "worker" === d && S.setAttribute("type", "text/partytown"), S.setAttribute("data-nscript", d), b && insertStylesheets(b), document.body.appendChild(S) }; function handleClientScriptLoad(r) { let { strategy: n = "afterInteractive" } = r; "lazyOnload" === n ? window.addEventListener("load", () => { (0, g.requestIdleCallback)(() => loadScript(r)) }) : loadScript(r) } function initScriptLoader(r) { r.forEach(handleClientScriptLoad), function () { let r = [...document.querySelectorAll('[data-nscript="beforeInteractive"]'), ...document.querySelectorAll('[data-nscript="beforePageRender"]')]; r.forEach(r => { let n = r.id || r.getAttribute("src"); y.add(n) }) }() } function Script(r) { let { id: n, src: o = "", onLoad: l = () => { }, onReady: u = null, strategy: h = "afterInteractive", onError: _, stylesheets: P, ...b } = r, { updateScripts: E, scripts: S, getIsSsr: R, appDir: O, nonce: w } = (0, f.useContext)(d.HeadManagerContext), A = (0, f.useRef)(!1); (0, f.useEffect)(() => { let r = n || o; A.current || (u && r && y.has(r) && u(), A.current = !0) }, [u, n, o]); let C = (0, f.useRef)(!1); if ((0, f.useEffect)(() => { !C.current && ("afterInteractive" === h ? loadScript(r) : "lazyOnload" === h && ("complete" === document.readyState ? (0, g.requestIdleCallback)(() => loadScript(r)) : window.addEventListener("load", () => { (0, g.requestIdleCallback)(() => loadScript(r)) })), C.current = !0) }, [r, h]), ("beforeInteractive" === h || "worker" === h) && (E ? (S[h] = (S[h] || []).concat([{ id: n, src: o, onLoad: l, onReady: u, onError: _, ...b }]), E(S)) : R && R() ? y.add(n || o) : R && !R() && loadScript(r)), O) { if (P && P.forEach(r => { s.default.preinit(r, { as: "style" }) }), "beforeInteractive" === h) return o ? (s.default.preload(o, b.integrity ? { as: "script", integrity: b.integrity } : { as: "script" }), f.default.createElement("script", { nonce: w, dangerouslySetInnerHTML: { __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([o]) + ")" } })) : (b.dangerouslySetInnerHTML && (b.children = b.dangerouslySetInnerHTML.__html, delete b.dangerouslySetInnerHTML), f.default.createElement("script", { nonce: w, dangerouslySetInnerHTML: { __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([0, { ...b }]) + ")" } })); "afterInteractive" === h && o && s.default.preload(o, b.integrity ? { as: "script", integrity: b.integrity } : { as: "script" }) } return null } Object.defineProperty(Script, "__nextScript", { value: !0 }); let b = Script; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 39867: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return reportToSocket } }); let l = o(22287); function reportToSocket(r) { if ("ended" !== r.state.state) throw Error("Expected span to be ended"); (0, l.sendMessage)(JSON.stringify({ event: "span-end", startTime: r.startTime, endTime: r.state.endTime, spanName: r.name, attributes: r.attributes })) } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 69074: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return s } }); let l = o(81351), u = l._(o(66656)); let Span = class Span { end(r) { if ("ended" === this.state.state) throw Error("Span has already ended"); this.state = { state: "ended", endTime: null != r ? r : Date.now() }, this.onSpanEnd(this) } constructor(r, n, o) { var l, u; this.name = r, this.attributes = null != (l = n.attributes) ? l : {}, this.startTime = null != (u = n.startTime) ? u : Date.now(), this.onSpanEnd = o, this.state = { state: "inprogress" } } }; let s = new class { startSpan(r, n) { return new Span(r, n, this.handleSpanEnd) } onSpanEnd(r) { return this._emitter.on("spanend", r), () => { this._emitter.off("spanend", r) } } constructor() { this._emitter = (0, u.default)(), this.handleSpanEnd = r => { this._emitter.emit("spanend", r) } } }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 45238: function (r, n) { "use strict"; let o; function __unsafeCreateTrustedScriptURL(r) { var n; return (null == (n = function () { if (void 0 === o) { var r; o = (null == (r = window.trustedTypes) ? void 0 : r.createPolicy("nextjs", { createHTML: r => r, createScript: r => r, createScriptURL: r => r })) || null } return o }()) ? void 0 : n.createScriptURL(r)) || r } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "__unsafeCreateTrustedScriptURL", { enumerable: !0, get: function () { return __unsafeCreateTrustedScriptURL } }), ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 21016: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), o(48370), self.__next_set_public_path__ = r => { o.p = r }, ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 9546: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return withRouter } }); let l = o(81351), u = l._(o(50959)), s = o(58066); function withRouter(r) { function WithRouterWrapper(n) { return u.default.createElement(r, { router: (0, s.useRouter)(), ...n }) } return WithRouterWrapper.getInitialProps = r.getInitialProps, WithRouterWrapper.origGetInitialProps = r.origGetInitialProps, WithRouterWrapper } ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 62385: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return App } }); let l = o(81351), u = l._(o(50959)), s = o(31393); async function appGetInitialProps(r) { let { Component: n, ctx: o } = r, l = await (0, s.loadGetInitialProps)(n, o); return { pageProps: l } } let App = class App extends u.default.Component { render() { let { Component: r, pageProps: n } = this.props; return u.default.createElement(r, n) } }; App.origGetInitialProps = appGetInitialProps, App.getInitialProps = appGetInitialProps, ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 11286: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return Error } }); let l = o(81351), u = l._(o(50959)), s = l._(o(67557)), f = { 400: "Bad Request", 404: "This page could not be found", 405: "Method Not Allowed", 500: "Internal Server Error" }; function _getInitialProps(r) { let { res: n, err: o } = r, l = n && n.statusCode ? n.statusCode : o ? o.statusCode : 404; return { statusCode: l } } let d = { error: { fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"', height: "100vh", textAlign: "center", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center" }, desc: { lineHeight: "48px" }, h1: { display: "inline-block", margin: "0 20px 0 0", paddingRight: 23, fontSize: 24, fontWeight: 500, verticalAlign: "top" }, h2: { fontSize: 14, fontWeight: 400, lineHeight: "28px" }, wrap: { display: "inline-block" } }; let Error = class Error extends u.default.Component { render() { let { statusCode: r, withDarkMode: n = !0 } = this.props, o = this.props.title || f[r] || "An unexpected error has occurred"; return u.default.createElement("div", { style: d.error }, u.default.createElement(s.default, null, u.default.createElement("title", null, r ? r + ": " + o : "Application error: a client-side exception has occurred")), u.default.createElement("div", { style: d.desc }, u.default.createElement("style", { dangerouslySetInnerHTML: { __html: "body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}" + (n ? "@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}" : "") } }), r ? u.default.createElement("h1", { className: "next-error-h1", style: d.h1 }, r) : null, u.default.createElement("div", { style: d.wrap }, u.default.createElement("h2", { style: d.h2 }, this.props.title || r ? o : u.default.createElement(u.default.Fragment, null, "Application error: a client-side exception has occurred (see the browser console for more information)"), ".")))) } }; Error.displayName = "ErrorPage", Error.getInitialProps = _getInitialProps, Error.origGetInitialProps = _getInitialProps, ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 52610: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "AmpStateContext", { enumerable: !0, get: function () { return s } }); let l = o(81351), u = l._(o(50959)), s = u.default.createContext({}) }, 68001: function (r, n) { "use strict"; function isInAmpMode(r) { let { ampFirst: n = !1, hybrid: o = !1, hasQuery: l = !1 } = void 0 === r ? {} : r; return n || o && l } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isInAmpMode", { enumerable: !0, get: function () { return isInAmpMode } }) }, 76668: function (r, n, o) { "use strict"; var l, u; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { CacheStates: function () { return l }, AppRouterContext: function () { return d }, LayoutRouterContext: function () { return h }, GlobalLayoutRouterContext: function () { return g }, TemplateContext: function () { return _ } }); let s = o(81351), f = s._(o(50959)); (u = l || (l = {})).LAZY_INITIALIZED = "LAZYINITIALIZED", u.DATA_FETCH = "DATAFETCH", u.READY = "READY"; let d = f.default.createContext(null), h = f.default.createContext(null), g = f.default.createContext(null), _ = f.default.createContext(null) }, 10178: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "BloomFilter", { enumerable: !0, get: function () { return BloomFilter } }); let BloomFilter = class BloomFilter { static from(r, n) { void 0 === n && (n = .01); let o = new BloomFilter(r.length, n); for (let n of r) o.add(n); return o } export() { let r = { numItems: this.numItems, errorRate: this.errorRate, numBits: this.numBits, numHashes: this.numHashes, bitArray: this.bitArray }; return r } import(r) { this.numItems = r.numItems, this.errorRate = r.errorRate, this.numBits = r.numBits, this.numHashes = r.numHashes, this.bitArray = r.bitArray } add(r) { let n = this.getHashValues(r); n.forEach(r => { this.bitArray[r] = 1 }) } contains(r) { let n = this.getHashValues(r); return n.every(r => this.bitArray[r]) } getHashValues(r) { let n = []; for (let o = 1; o <= this.numHashes; o++) { let l = function (r) { let n = 0; for (let o = 0; o < r.length; o++) { let l = r.charCodeAt(o); n = Math.imul(n ^ l, 1540483477), n ^= n >>> 13, n = Math.imul(n, 1540483477) } return n >>> 0 }("" + r + o) % this.numBits; n.push(l) } return n } constructor(r, n) { this.numItems = r, this.errorRate = n, this.numBits = Math.ceil(-(r * Math.log(n)) / (Math.log(2) * Math.log(2))), this.numHashes = Math.ceil(this.numBits / r * Math.log(2)), this.bitArray = Array(this.numBits).fill(0) } } }, 22963: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { MODERN_BROWSERSLIST_TARGET: function () { return u.default }, COMPILER_NAMES: function () { return s }, INTERNAL_HEADERS: function () { return f }, COMPILER_INDEXES: function () { return d }, PHASE_EXPORT: function () { return h }, PHASE_PRODUCTION_BUILD: function () { return g }, PHASE_PRODUCTION_SERVER: function () { return _ }, PHASE_DEVELOPMENT_SERVER: function () { return y }, PHASE_TEST: function () { return P }, PHASE_INFO: function () { return b }, PAGES_MANIFEST: function () { return E }, APP_PATHS_MANIFEST: function () { return S }, APP_PATH_ROUTES_MANIFEST: function () { return R }, BUILD_MANIFEST: function () { return O }, APP_BUILD_MANIFEST: function () { return w }, FUNCTIONS_CONFIG_MANIFEST: function () { return A }, SUBRESOURCE_INTEGRITY_MANIFEST: function () { return C }, NEXT_FONT_MANIFEST: function () { return x }, EXPORT_MARKER: function () { return j }, EXPORT_DETAIL: function () { return M }, PRERENDER_MANIFEST: function () { return L }, ROUTES_MANIFEST: function () { return I }, IMAGES_MANIFEST: function () { return N }, SERVER_FILES_MANIFEST: function () { return D }, DEV_CLIENT_PAGES_MANIFEST: function () { return k }, MIDDLEWARE_MANIFEST: function () { return F }, DEV_MIDDLEWARE_MANIFEST: function () { return U }, REACT_LOADABLE_MANIFEST: function () { return H }, FONT_MANIFEST: function () { return B }, SERVER_DIRECTORY: function () { return W }, CONFIG_FILES: function () { return q }, BUILD_ID_FILE: function () { return z }, BLOCKED_PAGES: function () { return G }, CLIENT_PUBLIC_FILES_PATH: function () { return V }, CLIENT_STATIC_FILES_PATH: function () { return X }, STRING_LITERAL_DROP_BUNDLE: function () { return Y }, NEXT_BUILTIN_DOCUMENT: function () { return Q }, BARREL_OPTIMIZATION_PREFIX: function () { return K }, CLIENT_REFERENCE_MANIFEST: function () { return $ }, SERVER_REFERENCE_MANIFEST: function () { return J }, MIDDLEWARE_BUILD_MANIFEST: function () { return Z }, MIDDLEWARE_REACT_LOADABLE_MANIFEST: function () { return ee }, CLIENT_STATIC_FILES_RUNTIME_MAIN: function () { return et }, CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: function () { return er }, APP_CLIENT_INTERNALS: function () { return en }, CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: function () { return ea }, CLIENT_STATIC_FILES_RUNTIME_AMP: function () { return eo }, CLIENT_STATIC_FILES_RUNTIME_WEBPACK: function () { return ei }, CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: function () { return el }, CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: function () { return eu }, EDGE_RUNTIME_WEBPACK: function () { return es }, TEMPORARY_REDIRECT_STATUS: function () { return ec }, PERMANENT_REDIRECT_STATUS: function () { return ef }, STATIC_PROPS_ID: function () { return ed }, SERVER_PROPS_ID: function () { return ep }, PAGE_SEGMENT_KEY: function () { return eh }, GOOGLE_FONT_PROVIDER: function () { return em }, OPTIMIZED_FONT_PROVIDERS: function () { return eg }, DEFAULT_SERIF_FONT: function () { return e_ }, DEFAULT_SANS_SERIF_FONT: function () { return ey }, STATIC_STATUS_PAGES: function () { return eP }, TRACE_OUTPUT_VERSION: function () { return ev }, TURBO_TRACE_DEFAULT_MEMORY_LIMIT: function () { return eb }, RSC_MODULE_TYPES: function () { return eE }, EDGE_UNSUPPORTED_NODE_APIS: function () { return eS }, SYSTEM_ENTRYPOINTS: function () { return eR } }); let l = o(81351), u = l._(o(12769)), s = { client: "client", server: "server", edgeServer: "edge-server" }, f = ["x-invoke-path", "x-invoke-status", "x-invoke-error", "x-invoke-query", "x-middleware-invoke"], d = { [s.client]: 0, [s.server]: 1, [s.edgeServer]: 2 }, h = "phase-export", g = "phase-production-build", _ = "phase-production-server", y = "phase-development-server", P = "phase-test", b = "phase-info", E = "pages-manifest.json", S = "app-paths-manifest.json", R = "app-path-routes-manifest.json", O = "build-manifest.json", w = "app-build-manifest.json", A = "functions-config-manifest.json", C = "subresource-integrity-manifest", x = "next-font-manifest", j = "export-marker.json", M = "export-detail.json", L = "prerender-manifest.json", I = "routes-manifest.json", N = "images-manifest.json", D = "required-server-files.json", k = "_devPagesManifest.json", F = "middleware-manifest.json", U = "_devMiddlewareManifest.json", H = "react-loadable-manifest.json", B = "font-manifest.json", W = "server", q = ["next.config.js", "next.config.mjs"], z = "BUILD_ID", G = ["/_document", "/_app", "/_error"], V = "public", X = "static", Y = "__NEXT_DROP_CLIENT_FILE__", Q = "__NEXT_BUILTIN_DOCUMENT__", K = "__barrel_optimize__", $ = "client-reference-manifest", J = "server-reference-manifest", Z = "middleware-build-manifest", ee = "middleware-react-loadable-manifest", et = "main", er = "" + et + "-app", en = "app-pages-internals", ea = "react-refresh", eo = "amp", ei = "webpack", el = "polyfills", eu = Symbol(el), es = "edge-runtime-webpack", ec = 307, ef = 308, ed = "__N_SSG", ep = "__N_SSP", eh = "__PAGE__", em = "https://fonts.googleapis.com/", eg = [{ url: em, preconnect: "https://fonts.gstatic.com" }, { url: "https://use.typekit.net", preconnect: "https://use.typekit.net" }], e_ = { name: "Times New Roman", xAvgCharWidth: 821, azAvgWidth: 854.3953488372093, unitsPerEm: 2048 }, ey = { name: "Arial", xAvgCharWidth: 904, azAvgWidth: 934.5116279069767, unitsPerEm: 2048 }, eP = ["/500"], ev = 1, eb = 6e3, eE = { client: "client", server: "server" }, eS = ["clearImmediate", "setImmediate", "BroadcastChannel", "ByteLengthQueuingStrategy", "CompressionStream", "CountQueuingStrategy", "DecompressionStream", "DomException", "MessageChannel", "MessageEvent", "MessagePort", "ReadableByteStreamController", "ReadableStreamBYOBRequest", "ReadableStreamDefaultController", "TransformStreamDefaultController", "WritableStreamDefaultController"], eR = new Set([et, ea, eo, er]); ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 2912: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "escapeStringRegexp", { enumerable: !0, get: function () { return escapeStringRegexp } }); let o = /[|\\{}()[\]^$+*?.-]/, l = /[|\\{}()[\]^$+*?.-]/g; function escapeStringRegexp(r) { return o.test(r) ? r.replace(l, "\\$&") : r } }, 81105: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "HeadManagerContext", { enumerable: !0, get: function () { return s } }); let l = o(81351), u = l._(o(50959)), s = u.default.createContext({}) }, 67557: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { defaultHead: function () { return defaultHead }, default: function () { return _default } }); let l = o(81351), u = o(35815), s = u._(o(50959)), f = l._(o(48065)), d = o(52610), h = o(81105), g = o(68001); function defaultHead(r) { void 0 === r && (r = !1); let n = [s.default.createElement("meta", { charSet: "utf-8" })]; return r || n.push(s.default.createElement("meta", { name: "viewport", content: "width=device-width" })), n } function onlyReactElement(r, n) { return "string" == typeof n || "number" == typeof n ? r : n.type === s.default.Fragment ? r.concat(s.default.Children.toArray(n.props.children).reduce((r, n) => "string" == typeof n || "number" == typeof n ? r : r.concat(n), [])) : r.concat(n) } o(59010); let _ = ["name", "httpEquiv", "charSet", "itemProp"]; function reduceComponents(r, n) { let { inAmpMode: o } = n; return r.reduce(onlyReactElement, []).reverse().concat(defaultHead(o).reverse()).filter(function () { let r = new Set, n = new Set, o = new Set, l = {}; return u => { let s = !0, f = !1; if (u.key && "number" != typeof u.key && u.key.indexOf("$") > 0) { f = !0; let n = u.key.slice(u.key.indexOf("$") + 1); r.has(n) ? s = !1 : r.add(n) } switch (u.type) { case "title": case "base": n.has(u.type) ? s = !1 : n.add(u.type); break; case "meta": for (let r = 0, n = _.length; r < n; r++) { let n = _[r]; if (u.props.hasOwnProperty(n)) { if ("charSet" === n) o.has(n) ? s = !1 : o.add(n); else { let r = u.props[n], o = l[n] || new Set; ("name" !== n || !f) && o.has(r) ? s = !1 : (o.add(r), l[n] = o) } } } }return s } }()).reverse().map((r, n) => { let l = r.key || n; if (!o && "link" === r.type && r.props.href && ["https://fonts.googleapis.com/css", "https://use.typekit.net/"].some(n => r.props.href.startsWith(n))) { let n = { ...r.props || {} }; return n["data-href"] = n.href, n.href = void 0, n["data-optimized-fonts"] = !0, s.default.cloneElement(r, n) } return s.default.cloneElement(r, { key: l }) }) } let _default = function (r) { let { children: n } = r, o = (0, s.useContext)(d.AmpStateContext), l = (0, s.useContext)(h.HeadManagerContext); return s.default.createElement(f.default, { reduceComponentsToState: reduceComponents, headManager: l, inAmpMode: (0, g.isInAmpMode)(o) }, n) }; ("function" == typeof n.default || "object" == typeof n.default && null !== n.default) && void 0 === n.default.__esModule && (Object.defineProperty(n.default, "__esModule", { value: !0 }), Object.assign(n.default, n), r.exports = n.default) }, 67069: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { SearchParamsContext: function () { return u }, PathnameContext: function () { return s }, PathParamsContext: function () { return f } }); let l = o(50959), u = (0, l.createContext)(null), s = (0, l.createContext)(null), f = (0, l.createContext)(null) }, 79942: function (r, n) { "use strict"; function detectDomainLocale(r, n, o) { if (r) for (let s of (o && (o = o.toLowerCase()), r)) { var l, u; let r = null == (l = s.domain) ? void 0 : l.split(":")[0].toLowerCase(); if (n === r || o === s.defaultLocale.toLowerCase() || (null == (u = s.locales) ? void 0 : u.some(r => r.toLowerCase() === o))) return s } } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "detectDomainLocale", { enumerable: !0, get: function () { return detectDomainLocale } }) }, 26573: function (r, n) { "use strict"; function normalizeLocalePath(r, n) { let o; let l = r.split("/"); return (n || []).some(n => !!l[1] && l[1].toLowerCase() === n.toLowerCase() && (o = n, l.splice(1, 1), r = l.join("/") || "/", !0)), { pathname: r, detectedLocale: o } } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "normalizeLocalePath", { enumerable: !0, get: function () { return normalizeLocalePath } }) }, 66697: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "ImageConfigContext", { enumerable: !0, get: function () { return f } }); let l = o(81351), u = l._(o(50959)), s = o(99521), f = u.default.createContext(s.imageConfigDefault) }, 99521: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { VALID_LOADERS: function () { return o }, imageConfigDefault: function () { return l } }); let o = ["default", "imgix", "cloudinary", "akamai", "custom"], l = { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image", loader: "default", loaderFile: "", domains: [], disableStaticImages: !1, minimumCacheTTL: 60, formats: ["image/webp"], dangerouslyAllowSVG: !1, contentSecurityPolicy: "script-src 'none'; frame-src 'none'; sandbox;", contentDispositionType: "inline", remotePatterns: [], unoptimized: !1 } }, 59109: function (r, n) { "use strict"; function getObjectClassLabel(r) { return Object.prototype.toString.call(r) } function isPlainObject(r) { if ("[object Object]" !== getObjectClassLabel(r)) return !1; let n = Object.getPrototypeOf(r); return null === n || n.hasOwnProperty("isPrototypeOf") } Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { getObjectClassLabel: function () { return getObjectClassLabel }, isPlainObject: function () { return isPlainObject } }) }, 55209: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "NEXT_DYNAMIC_NO_SSR_CODE", { enumerable: !0, get: function () { return o } }); let o = "NEXT_DYNAMIC_NO_SSR_CODE" }, 66656: function (r, n) { "use strict"; function mitt() { let r = Object.create(null); return { on(n, o) { (r[n] || (r[n] = [])).push(o) }, off(n, o) { r[n] && r[n].splice(r[n].indexOf(o) >>> 0, 1) }, emit(n) { for (var o = arguments.length, l = Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)l[u - 1] = arguments[u]; (r[n] || []).slice().map(r => { r(...l) }) } } } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return mitt } }) }, 12769: function (r) { "use strict"; r.exports = ["chrome 64", "edge 79", "firefox 67", "opera 51", "safari 12"] }, 29972: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "denormalizePagePath", { enumerable: !0, get: function () { return denormalizePagePath } }); let l = o(50038), u = o(81988); function denormalizePagePath(r) { let n = (0, u.normalizePathSep)(r); return n.startsWith("/index/") && !(0, l.isDynamicRoute)(n) ? n.slice(6) : "/index" !== n ? n : "/" } }, 21940: function (r, n) { "use strict"; function ensureLeadingSlash(r) { return r.startsWith("/") ? r : "/" + r } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "ensureLeadingSlash", { enumerable: !0, get: function () { return ensureLeadingSlash } }) }, 81988: function (r, n) { "use strict"; function normalizePathSep(r) { return r.replace(/\\/g, "/") } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "normalizePathSep", { enumerable: !0, get: function () { return normalizePathSep } }) }, 17755: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "RouterContext", { enumerable: !0, get: function () { return s } }); let l = o(81351), u = l._(o(50959)), s = u.default.createContext(null) }, 18102: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { adaptForAppRouterInstance: function () { return adaptForAppRouterInstance }, adaptForSearchParams: function () { return adaptForSearchParams }, adaptForPathParams: function () { return adaptForPathParams }, PathnameContextProviderAdapter: function () { return PathnameContextProviderAdapter } }); let l = o(35815), u = l._(o(50959)), s = o(67069), f = o(50038), d = o(16233), h = o(62872); function adaptForAppRouterInstance(r) { return { back() { r.back() }, forward() { r.forward() }, refresh() { r.reload() }, push(n, o) { let { scroll: l } = void 0 === o ? {} : o; r.push(n, void 0, { scroll: l }) }, replace(n, o) { let { scroll: l } = void 0 === o ? {} : o; r.replace(n, void 0, { scroll: l }) }, prefetch(n) { r.prefetch(n) } } } function adaptForSearchParams(r) { return r.isReady && r.query ? (0, d.asPathToSearchParams)(r.asPath) : new URLSearchParams } function adaptForPathParams(r) { if (!r.isReady || !r.query) return null; let n = {}, o = (0, h.getRouteRegex)(r.pathname), l = Object.keys(o.groups); for (let o of l) n[o] = r.query[o]; return n } function PathnameContextProviderAdapter(r) { let { children: n, router: o, ...l } = r, d = (0, u.useRef)(l.isAutoExport), h = (0, u.useMemo)(() => { let r; let n = d.current; if (n && (d.current = !1), (0, f.isDynamicRoute)(o.pathname) && (o.isFallback || n && !o.isReady)) return null; try { r = new URL(o.asPath, "http://f") } catch (r) { return "/" } return r.pathname }, [o.asPath, o.isFallback, o.isReady, o.pathname]); return u.default.createElement(s.PathnameContext.Provider, { value: h }, n) } }, 74063: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { default: function () { return Router }, matchesMiddleware: function () { return matchesMiddleware }, createKey: function () { return createKey } }); let l = o(81351), u = o(35815), s = o(6847), f = o(26629), d = o(99156), h = u._(o(19032)), g = o(29972), _ = o(26573), y = l._(o(66656)), P = o(31393), b = o(1716), E = o(47400), S = l._(o(57759)), R = o(9339), O = o(62872), w = o(14564), A = o(89722), C = o(70629), x = o(17089), j = o(95263), M = o(66919), L = o(17420), I = o(17815), N = o(44346), D = o(15486), k = o(21067), F = o(49374), U = o(5420), H = o(69414), B = o(67870), W = o(99076), q = o(87973), z = o(58745); function buildCancellationError() { return Object.assign(Error("Route Cancelled"), { cancelled: !0 }) } async function matchesMiddleware(r) { let n = await Promise.resolve(r.router.pageLoader.getMiddleware()); if (!n) return !1; let { pathname: o } = (0, C.parsePath)(r.asPath), l = (0, I.hasBasePath)(o) ? (0, M.removeBasePath)(o) : o, u = (0, L.addBasePath)((0, x.addLocale)(l, r.locale)); return n.some(r => new RegExp(r.regexp).test(u)) } function stripOrigin(r) { let n = (0, P.getLocationOrigin)(); return r.startsWith(n) ? r.substring(n.length) : r } function prepareUrlAs(r, n, o) { let [l, u] = (0, N.resolveHref)(r, n, !0), s = (0, P.getLocationOrigin)(), f = l.startsWith(s), d = u && u.startsWith(s); l = stripOrigin(l), u = u ? stripOrigin(u) : u; let h = f ? l : (0, L.addBasePath)(l), g = o ? stripOrigin((0, N.resolveHref)(r, o)) : u || l; return { url: h, as: d ? g : (0, L.addBasePath)(g) } } function resolveDynamicRoute(r, n) { let o = (0, s.removeTrailingSlash)((0, g.denormalizePagePath)(r)); return "/404" === o || "/_error" === o ? r : (n.includes(o) || n.some(n => { if ((0, b.isDynamicRoute)(n) && (0, O.getRouteRegex)(n).re.test(o)) return r = n, !0 }), (0, s.removeTrailingSlash)(r)) } async function withMiddlewareEffects(r) { let n = await matchesMiddleware(r); if (!n || !r.fetchData) return null; try { let n = await r.fetchData(), o = await function (r, n, o) { let l = { basePath: o.router.basePath, i18n: { locales: o.router.locales }, trailingSlash: !1 }, u = n.headers.get("x-nextjs-rewrite"), d = u || n.headers.get("x-nextjs-matched-path"), h = n.headers.get("x-matched-path"); if (!h || d || h.includes("__next_data_catchall") || h.includes("/_error") || h.includes("/404") || (d = h), d) { if (d.startsWith("/")) { let n = (0, E.parseRelativeUrl)(d), h = (0, k.getNextPathnameInfo)(n.pathname, { nextConfig: l, parseData: !0 }), g = (0, s.removeTrailingSlash)(h.pathname); return Promise.all([o.router.pageLoader.getPageList(), (0, f.getClientBuildManifest)()]).then(l => { let [s, { __rewrites: f }] = l, d = (0, x.addLocale)(h.pathname, h.locale); if ((0, b.isDynamicRoute)(d) || !u && s.includes((0, _.normalizeLocalePath)((0, M.removeBasePath)(d), o.router.locales).pathname)) { let o = (0, k.getNextPathnameInfo)((0, E.parseRelativeUrl)(r).pathname, { nextConfig: void 0, parseData: !0 }); d = (0, L.addBasePath)(o.pathname), n.pathname = d } { let r = (0, S.default)(d, s, f, n.query, r => resolveDynamicRoute(r, s), o.router.locales); r.matchedPage && (n.pathname = r.parsedAs.pathname, d = n.pathname, Object.assign(n.query, r.parsedAs.query)) } let y = s.includes(g) ? g : resolveDynamicRoute((0, _.normalizeLocalePath)((0, M.removeBasePath)(n.pathname), o.router.locales).pathname, s); if ((0, b.isDynamicRoute)(y)) { let r = (0, R.getRouteMatcher)((0, O.getRouteRegex)(y))(d); Object.assign(n.query, r || {}) } return { type: "rewrite", parsedAs: n, resolvedHref: y } }) } let n = (0, C.parsePath)(r), h = (0, F.formatNextPathnameInfo)({ ...(0, k.getNextPathnameInfo)(n.pathname, { nextConfig: l, parseData: !0 }), defaultLocale: o.router.defaultLocale, buildId: "" }); return Promise.resolve({ type: "redirect-external", destination: "" + h + n.query + n.hash }) } let g = n.headers.get("x-nextjs-redirect"); if (g) { if (g.startsWith("/")) { let r = (0, C.parsePath)(g), n = (0, F.formatNextPathnameInfo)({ ...(0, k.getNextPathnameInfo)(r.pathname, { nextConfig: l, parseData: !0 }), defaultLocale: o.router.defaultLocale, buildId: "" }); return Promise.resolve({ type: "redirect-internal", newAs: "" + n + r.query + r.hash, newUrl: "" + n + r.query + r.hash }) } return Promise.resolve({ type: "redirect-external", destination: g }) } return Promise.resolve({ type: "next" }) }(n.dataHref, n.response, r); return { dataHref: n.dataHref, json: n.json, response: n.response, text: n.text, cacheKey: n.cacheKey, effect: o } } catch (r) { return null } } let G = Symbol("SSG_DATA_NOT_FOUND"); function tryToParseAsJSON(r) { try { return JSON.parse(r) } catch (r) { return null } } function fetchNextData(r) { var n; let { dataHref: o, inflightCache: l, isPrefetch: u, hasMiddleware: s, isServerRender: d, parseJSON: h, persistCache: g, isBackground: _, unstable_skipClientCache: y } = r, { href: P } = new URL(o, window.location.href), getData = r => (function fetchRetry(r, n, o) { return fetch(r, { credentials: "same-origin", method: o.method || "GET", headers: Object.assign({}, o.headers, { "x-nextjs-data": "1" }) }).then(l => !l.ok && n > 1 && l.status >= 500 ? fetchRetry(r, n - 1, o) : l) })(o, d ? 3 : 1, { headers: Object.assign({}, u ? { purpose: "prefetch" } : {}, u && s ? { "x-middleware-prefetch": "1" } : {}), method: null != (n = null == r ? void 0 : r.method) ? n : "GET" }).then(n => n.ok && (null == r ? void 0 : r.method) === "HEAD" ? { dataHref: o, response: n, text: "", json: {}, cacheKey: P } : n.text().then(r => { if (!n.ok) { if (s && [301, 302, 307, 308].includes(n.status)) return { dataHref: o, response: n, text: r, json: {}, cacheKey: P }; if (404 === n.status) { var l; if (null == (l = tryToParseAsJSON(r)) ? void 0 : l.notFound) return { dataHref: o, json: { notFound: G }, response: n, text: r, cacheKey: P } } let u = Error("Failed to load static props"); throw d || (0, f.markAssetError)(u), u } return { dataHref: o, json: h ? tryToParseAsJSON(r) : null, response: n, text: r, cacheKey: P } })).then(r => (g && "no-cache" !== r.response.headers.get("x-middleware-cache") || delete l[P], r)).catch(r => { throw y || delete l[P], ("Failed to fetch" === r.message || "NetworkError when attempting to fetch resource." === r.message || "Load failed" === r.message) && (0, f.markAssetError)(r), r }); return y && g ? getData({}).then(r => (l[P] = Promise.resolve(r), r)) : void 0 !== l[P] ? l[P] : l[P] = getData(_ ? { method: "HEAD" } : {}) } function createKey() { return Math.random().toString(36).slice(2, 10) } function handleHardNavigation(r) { let { url: n, router: o } = r; if (n === (0, L.addBasePath)((0, x.addLocale)(o.asPath, o.locale))) throw Error("Invariant: attempted to hard navigate to the same URL " + n + " " + location.href); window.location.href = n } let getCancelledHandler = r => { let { route: n, router: o } = r, l = !1, u = o.clc = () => { l = !0 }; return () => { if (l) { let r = Error('Abort fetching component for route: "' + n + '"'); throw r.cancelled = !0, r } u === o.clc && (o.clc = null) } }; let Router = class Router { reload() { window.location.reload() } back() { window.history.back() } forward() { window.history.forward() } push(r, n, o) { return void 0 === o && (o = {}), { url: r, as: n } = prepareUrlAs(this, r, n), this.change("pushState", r, n, o) } replace(r, n, o) { return void 0 === o && (o = {}), { url: r, as: n } = prepareUrlAs(this, r, n), this.change("replaceState", r, n, o) } async _bfl(r, n, o, l) { { let h = !1, g = !1; for (let _ of [r, n]) if (_) { let n = (0, s.removeTrailingSlash)(new URL(_, "http://n").pathname), y = (0, L.addBasePath)((0, x.addLocale)(n, o || this.locale)); if (n !== (0, s.removeTrailingSlash)(new URL(this.asPath, "http://n").pathname)) { var u, f, d; for (let r of (h = h || !!(null == (u = this._bfl_s) ? void 0 : u.contains(n)) || !!(null == (f = this._bfl_s) ? void 0 : f.contains(y)), [n, y])) { let n = r.split("/"); for (let r = 0; !g && r < n.length + 1; r++) { let o = n.slice(0, r).join("/"); if (o && (null == (d = this._bfl_d) ? void 0 : d.contains(o))) { g = !0; break } } } if (h || g) { if (l) return !0; return handleHardNavigation({ url: (0, L.addBasePath)((0, x.addLocale)(r, o || this.locale, this.defaultLocale)), router: this }), new Promise(() => { }) } } } } return !1 } async change(r, n, o, l, u) { var g, y, N, D, k, F, B, z, V, X; let Y, Q; if (!(0, H.isLocalURL)(n)) return handleHardNavigation({ url: n, router: this }), !1; let K = 1 === l._h; K || l.shallow || await this._bfl(o, void 0, l.locale); let $ = K || l._shouldResolveHref || (0, C.parsePath)(n).pathname === (0, C.parsePath)(o).pathname, J = { ...this.state }, Z = !0 !== this.isReady; this.isReady = !0; let ee = this.isSsr; if (K || (this.isSsr = !1), K && this.clc) return !1; let et = J.locale; { J.locale = !1 === l.locale ? this.defaultLocale : l.locale || J.locale, void 0 === l.locale && (l.locale = J.locale); let r = (0, E.parseRelativeUrl)((0, I.hasBasePath)(o) ? (0, M.removeBasePath)(o) : o), u = (0, _.normalizeLocalePath)(r.pathname, this.locales); u.detectedLocale && (J.locale = u.detectedLocale, r.pathname = (0, L.addBasePath)(r.pathname), o = (0, w.formatWithValidation)(r), n = (0, L.addBasePath)((0, _.normalizeLocalePath)((0, I.hasBasePath)(n) ? (0, M.removeBasePath)(n) : n, this.locales).pathname)); let s = !1; (null == (y = this.locales) ? void 0 : y.includes(J.locale)) || (r.pathname = (0, x.addLocale)(r.pathname, J.locale), handleHardNavigation({ url: (0, w.formatWithValidation)(r), router: this }), s = !0); let f = (0, A.detectDomainLocale)(this.domainLocales, void 0, J.locale); if (!s && f && this.isLocaleDomain && self.location.hostname !== f.domain) { let r = (0, M.removeBasePath)(o); handleHardNavigation({ url: "http" + (f.http ? "" : "s") + "://" + f.domain + (0, L.addBasePath)((J.locale === f.defaultLocale ? "" : "/" + J.locale) + ("/" === r ? "" : r) || "/"), router: this }), s = !0 } if (s) return new Promise(() => { }) } P.ST && performance.mark("routeChange"); let { shallow: er = !1, scroll: en = !0 } = l, ea = { shallow: er }; this._inFlightRoute && this.clc && (ee || Router.events.emit("routeChangeError", buildCancellationError(), this._inFlightRoute, ea), this.clc(), this.clc = null), o = (0, L.addBasePath)((0, x.addLocale)((0, I.hasBasePath)(o) ? (0, M.removeBasePath)(o) : o, l.locale, this.defaultLocale)); let eo = (0, j.removeLocale)((0, I.hasBasePath)(o) ? (0, M.removeBasePath)(o) : o, J.locale); this._inFlightRoute = o; let ei = et !== J.locale; if (!K && this.onlyAHashChange(eo) && !ei) { J.asPath = eo, Router.events.emit("hashChangeStart", o, ea), this.changeState(r, n, o, { ...l, scroll: !1 }), en && this.scrollToHash(eo); try { await this.set(J, this.components[J.route], null) } catch (r) { throw (0, h.default)(r) && r.cancelled && Router.events.emit("routeChangeError", r, eo, ea), r } return Router.events.emit("hashChangeComplete", o, ea), !0 } let el = (0, E.parseRelativeUrl)(n), { pathname: eu, query: es } = el; if (null == (g = this.components[eu]) ? void 0 : g.__appRouter) return handleHardNavigation({ url: o, router: this }), new Promise(() => { }); try { [Y, { __rewrites: Q }] = await Promise.all([this.pageLoader.getPageList(), (0, f.getClientBuildManifest)(), this.pageLoader.getMiddleware()]) } catch (r) { return handleHardNavigation({ url: o, router: this }), !1 } this.urlIsNew(eo) || ei || (r = "replaceState"); let ec = o; eu = eu ? (0, s.removeTrailingSlash)((0, M.removeBasePath)(eu)) : eu; let ef = (0, s.removeTrailingSlash)(eu), ed = o.startsWith("/") && (0, E.parseRelativeUrl)(o).pathname, ep = !!(ed && ef !== ed && (!(0, b.isDynamicRoute)(ef) || !(0, R.getRouteMatcher)((0, O.getRouteRegex)(ef))(ed))), eh = !l.shallow && await matchesMiddleware({ asPath: o, locale: J.locale, router: this }); if (K && eh && ($ = !1), $ && "/_error" !== eu) { if (l._shouldResolveHref = !0, o.startsWith("/")) { let r = (0, S.default)((0, L.addBasePath)((0, x.addLocale)(eo, J.locale), !0), Y, Q, es, r => resolveDynamicRoute(r, Y), this.locales); if (r.externalDest) return handleHardNavigation({ url: o, router: this }), !0; eh || (ec = r.asPath), r.matchedPage && r.resolvedHref && (eu = r.resolvedHref, el.pathname = (0, L.addBasePath)(eu), eh || (n = (0, w.formatWithValidation)(el))) } else el.pathname = resolveDynamicRoute(eu, Y), el.pathname === eu || (eu = el.pathname, el.pathname = (0, L.addBasePath)(eu), eh || (n = (0, w.formatWithValidation)(el))) } if (!(0, H.isLocalURL)(o)) return handleHardNavigation({ url: o, router: this }), !1; ec = (0, j.removeLocale)((0, M.removeBasePath)(ec), J.locale), ef = (0, s.removeTrailingSlash)(eu); let em = !1; if ((0, b.isDynamicRoute)(ef)) { let r = (0, E.parseRelativeUrl)(ec), l = r.pathname, u = (0, O.getRouteRegex)(ef); em = (0, R.getRouteMatcher)(u)(l); let s = ef === l, f = s ? (0, q.interpolateAs)(ef, l, es) : {}; if (em && (!s || f.result)) s ? o = (0, w.formatWithValidation)(Object.assign({}, r, { pathname: f.result, query: (0, W.omit)(es, f.params) })) : Object.assign(es, em); else { let r = Object.keys(u.groups).filter(r => !es[r] && !u.groups[r].optional); if (r.length > 0 && !eh) throw Error((s ? "The provided `href` (" + n + ") value is missing query values (" + r.join(", ") + ") to be interpolated properly. " : "The provided `as` value (" + l + ") is incompatible with the `href` value (" + ef + "). ") + "Read more: https://nextjs.org/docs/messages/" + (s ? "href-interpolation-failed" : "incompatible-href-as")) } } K || Router.events.emit("routeChangeStart", o, ea); let eg = "/404" === this.pathname || "/_error" === this.pathname; try { let s = await this.getRouteInfo({ route: ef, pathname: eu, query: es, as: o, resolvedAs: ec, routeProps: ea, locale: J.locale, isPreview: J.isPreview, hasMiddleware: eh, unstable_skipClientCache: l.unstable_skipClientCache, isQueryUpdating: K && !this.isFallback, isMiddlewareRewrite: ep }); if (K || l.shallow || await this._bfl(o, "resolvedAs" in s ? s.resolvedAs : void 0, J.locale), "route" in s && eh) { ef = eu = s.route || ef, ea.shallow || (es = Object.assign({}, s.query || {}, es)); let r = (0, I.hasBasePath)(el.pathname) ? (0, M.removeBasePath)(el.pathname) : el.pathname; if (em && eu !== r && Object.keys(em).forEach(r => { em && es[r] === em[r] && delete es[r] }), (0, b.isDynamicRoute)(eu)) { let r = !ea.shallow && s.resolvedAs ? s.resolvedAs : (0, L.addBasePath)((0, x.addLocale)(new URL(o, location.href).pathname, J.locale), !0), n = r; (0, I.hasBasePath)(n) && (n = (0, M.removeBasePath)(n)); { let r = (0, _.normalizeLocalePath)(n, this.locales); J.locale = r.detectedLocale || J.locale, n = r.pathname } let l = (0, O.getRouteRegex)(eu), u = (0, R.getRouteMatcher)(l)(new URL(n, location.href).pathname); u && Object.assign(es, u) } } if ("type" in s) { if ("redirect-internal" === s.type) return this.change(r, s.newUrl, s.newAs, l); return handleHardNavigation({ url: s.destination, router: this }), new Promise(() => { }) } let f = s.Component; if (f && f.unstable_scriptLoader) { let r = [].concat(f.unstable_scriptLoader()); r.forEach(r => { (0, d.handleClientScriptLoad)(r.props) }) } if ((s.__N_SSG || s.__N_SSP) && s.props) { if (s.props.pageProps && s.props.pageProps.__N_REDIRECT) { l.locale = !1; let n = s.props.pageProps.__N_REDIRECT; if (n.startsWith("/") && !1 !== s.props.pageProps.__N_REDIRECT_BASE_PATH) { let o = (0, E.parseRelativeUrl)(n); o.pathname = resolveDynamicRoute(o.pathname, Y); let { url: u, as: s } = prepareUrlAs(this, n, n); return this.change(r, u, s, l) } return handleHardNavigation({ url: n, router: this }), new Promise(() => { }) } if (J.isPreview = !!s.props.__N_PREVIEW, s.props.notFound === G) { let r; try { await this.fetchComponent("/404"), r = "/404" } catch (n) { r = "/_error" } if (s = await this.getRouteInfo({ route: r, pathname: r, query: es, as: o, resolvedAs: ec, routeProps: { shallow: !1 }, locale: J.locale, isPreview: J.isPreview, isNotFound: !0 }), "type" in s) throw Error("Unexpected middleware effect on /404") } } K && "/_error" === this.pathname && (null == (D = self.__NEXT_DATA__.props) ? void 0 : null == (N = D.pageProps) ? void 0 : N.statusCode) === 500 && (null == (k = s.props) ? void 0 : k.pageProps) && (s.props.pageProps.statusCode = 500); let g = l.shallow && J.route === (null != (F = s.route) ? F : ef), y = null != (B = l.scroll) ? B : !K && !g, P = null != u ? u : y ? { x: 0, y: 0 } : null, S = { ...J, route: ef, pathname: eu, query: es, asPath: eo, isFallback: !1 }; if (K && eg) { if (s = await this.getRouteInfo({ route: this.pathname, pathname: this.pathname, query: es, as: o, resolvedAs: ec, routeProps: { shallow: !1 }, locale: J.locale, isPreview: J.isPreview, isQueryUpdating: K && !this.isFallback }), "type" in s) throw Error("Unexpected middleware effect on " + this.pathname); "/_error" === this.pathname && (null == (V = self.__NEXT_DATA__.props) ? void 0 : null == (z = V.pageProps) ? void 0 : z.statusCode) === 500 && (null == (X = s.props) ? void 0 : X.pageProps) && (s.props.pageProps.statusCode = 500); try { await this.set(S, s, P) } catch (r) { throw (0, h.default)(r) && r.cancelled && Router.events.emit("routeChangeError", r, eo, ea), r } return !0 } Router.events.emit("beforeHistoryChange", o, ea), this.changeState(r, n, o, l); let w = K && !P && !Z && !ei && (0, U.compareRouterStates)(S, this.state); if (!w) { try { await this.set(S, s, P) } catch (r) { if (r.cancelled) s.error = s.error || r; else throw r } if (s.error) throw K || Router.events.emit("routeChangeError", s.error, eo, ea), s.error; J.locale && (document.documentElement.lang = J.locale), K || Router.events.emit("routeChangeComplete", o, ea), y && /#.+$/.test(o) && this.scrollToHash(o) } return !0 } catch (r) { if ((0, h.default)(r) && r.cancelled) return !1; throw r } } changeState(r, n, o, l) { void 0 === l && (l = {}), ("pushState" !== r || (0, P.getURL)() !== o) && (this._shallow = l.shallow, window.history[r]({ url: n, as: o, options: l, __N: !0, key: this._key = "pushState" !== r ? this._key : createKey() }, "", o)) } async handleRouteInfoError(r, n, o, l, u, s) { if (console.error(r), r.cancelled) throw r; if ((0, f.isAssetError)(r) || s) throw Router.events.emit("routeChangeError", r, l, u), handleHardNavigation({ url: l, router: this }), buildCancellationError(); try { let l; let { page: u, styleSheets: s } = await this.fetchComponent("/_error"), f = { props: l, Component: u, styleSheets: s, err: r, error: r }; if (!f.props) try { f.props = await this.getInitialProps(u, { err: r, pathname: n, query: o }) } catch (r) { console.error("Error in error page `getInitialProps`: ", r), f.props = {} } return f } catch (r) { return this.handleRouteInfoError((0, h.default)(r) ? r : Error(r + ""), n, o, l, u, !0) } } async getRouteInfo(r) { let { route: n, pathname: o, query: l, as: u, resolvedAs: f, routeProps: d, locale: g, hasMiddleware: y, isPreview: P, unstable_skipClientCache: b, isQueryUpdating: E, isMiddlewareRewrite: S, isNotFound: R } = r, O = n; try { var A, C, x, j; let r = getCancelledHandler({ route: O, router: this }), n = this.components[O]; if (d.shallow && n && this.route === O) return n; y && (n = void 0); let h = !n || "initial" in n ? void 0 : n, L = { dataHref: this.pageLoader.getDataHref({ href: (0, w.formatWithValidation)({ pathname: o, query: l }), skipInterpolation: !0, asPath: R ? "/404" : f, locale: g }), hasMiddleware: !0, isServerRender: this.isSsr, parseJSON: !0, inflightCache: E ? this.sbc : this.sdc, persistCache: !P, isPrefetch: !1, unstable_skipClientCache: b, isBackground: E }, I = E && !S ? null : await withMiddlewareEffects({ fetchData: () => fetchNextData(L), asPath: R ? "/404" : f, locale: g, router: this }).catch(r => { if (E) return null; throw r }); if (I && ("/_error" === o || "/404" === o) && (I.effect = void 0), E && (I ? I.json = self.__NEXT_DATA__.props : I = { json: self.__NEXT_DATA__.props }), r(), (null == I ? void 0 : null == (A = I.effect) ? void 0 : A.type) === "redirect-internal" || (null == I ? void 0 : null == (C = I.effect) ? void 0 : C.type) === "redirect-external") return I.effect; if ((null == I ? void 0 : null == (x = I.effect) ? void 0 : x.type) === "rewrite") { let r = (0, s.removeTrailingSlash)(I.effect.resolvedHref), u = await this.pageLoader.getPageList(); if ((!E || u.includes(r)) && (O = r, o = I.effect.resolvedHref, l = { ...l, ...I.effect.parsedAs.query }, f = (0, M.removeBasePath)((0, _.normalizeLocalePath)(I.effect.parsedAs.pathname, this.locales).pathname), n = this.components[O], d.shallow && n && this.route === O && !y)) return { ...n, route: O } } if ((0, D.isAPIRoute)(O)) return handleHardNavigation({ url: u, router: this }), new Promise(() => { }); let N = h || await this.fetchComponent(O).then(r => ({ Component: r.page, styleSheets: r.styleSheets, __N_SSG: r.mod.__N_SSG, __N_SSP: r.mod.__N_SSP })), k = null == I ? void 0 : null == (j = I.response) ? void 0 : j.headers.get("x-middleware-skip"), F = N.__N_SSG || N.__N_SSP; k && (null == I ? void 0 : I.dataHref) && delete this.sdc[I.dataHref]; let { props: U, cacheKey: H } = await this._getData(async () => { if (F) { if ((null == I ? void 0 : I.json) && !k) return { cacheKey: I.cacheKey, props: I.json }; let r = (null == I ? void 0 : I.dataHref) ? I.dataHref : this.pageLoader.getDataHref({ href: (0, w.formatWithValidation)({ pathname: o, query: l }), asPath: f, locale: g }), n = await fetchNextData({ dataHref: r, isServerRender: this.isSsr, parseJSON: !0, inflightCache: k ? {} : this.sdc, persistCache: !P, isPrefetch: !1, unstable_skipClientCache: b }); return { cacheKey: n.cacheKey, props: n.json || {} } } return { headers: {}, props: await this.getInitialProps(N.Component, { pathname: o, query: l, asPath: u, locale: g, locales: this.locales, defaultLocale: this.defaultLocale }) } }); return N.__N_SSP && L.dataHref && H && delete this.sdc[H], this.isPreview || !N.__N_SSG || E || fetchNextData(Object.assign({}, L, { isBackground: !0, persistCache: !1, inflightCache: this.sbc })).catch(() => { }), U.pageProps = Object.assign({}, U.pageProps), N.props = U, N.route = O, N.query = l, N.resolvedAs = f, this.components[O] = N, N } catch (r) { return this.handleRouteInfoError((0, h.getProperError)(r), o, l, u, d) } } set(r, n, o) { return this.state = r, this.sub(n, this.components["/_app"].Component, o) } beforePopState(r) { this._bps = r } onlyAHashChange(r) { if (!this.asPath) return !1; let [n, o] = this.asPath.split("#"), [l, u] = r.split("#"); return !!u && n === l && o === u || n === l && o !== u } scrollToHash(r) { let [, n = ""] = r.split("#"); (0, z.handleSmoothScroll)(() => { if ("" === n || "top" === n) { window.scrollTo(0, 0); return } let r = decodeURIComponent(n), o = document.getElementById(r); if (o) { o.scrollIntoView(); return } let l = document.getElementsByName(r)[0]; l && l.scrollIntoView() }, { onlyHashChange: this.onlyAHashChange(r) }) } urlIsNew(r) { return this.asPath !== r } async prefetch(r, n, o) { if (void 0 === n && (n = r), void 0 === o && (o = {}), (0, B.isBot)(window.navigator.userAgent)) return; let l = (0, E.parseRelativeUrl)(r), u = l.pathname, { pathname: d, query: h } = l, g = d; if (!1 === o.locale) { d = (0, _.normalizeLocalePath)(d, this.locales).pathname, l.pathname = d, r = (0, w.formatWithValidation)(l); let u = (0, E.parseRelativeUrl)(n), s = (0, _.normalizeLocalePath)(u.pathname, this.locales); u.pathname = s.pathname, o.locale = s.detectedLocale || this.defaultLocale, n = (0, w.formatWithValidation)(u) } let y = await this.pageLoader.getPageList(), P = n, A = void 0 !== o.locale ? o.locale || void 0 : this.locale, I = await matchesMiddleware({ asPath: n, locale: A, router: this }); if (n.startsWith("/")) { let o; ({ __rewrites: o } = await (0, f.getClientBuildManifest)()); let u = (0, S.default)((0, L.addBasePath)((0, x.addLocale)(n, this.locale), !0), y, o, l.query, r => resolveDynamicRoute(r, y), this.locales); if (u.externalDest) return; I || (P = (0, j.removeLocale)((0, M.removeBasePath)(u.asPath), this.locale)), u.matchedPage && u.resolvedHref && (d = u.resolvedHref, l.pathname = d, I || (r = (0, w.formatWithValidation)(l))) } l.pathname = resolveDynamicRoute(l.pathname, y), (0, b.isDynamicRoute)(l.pathname) && (d = l.pathname, l.pathname = d, Object.assign(h, (0, R.getRouteMatcher)((0, O.getRouteRegex)(l.pathname))((0, C.parsePath)(n).pathname) || {}), I || (r = (0, w.formatWithValidation)(l))); let N = await withMiddlewareEffects({ fetchData: () => fetchNextData({ dataHref: this.pageLoader.getDataHref({ href: (0, w.formatWithValidation)({ pathname: g, query: h }), skipInterpolation: !0, asPath: P, locale: A }), hasMiddleware: !0, isServerRender: this.isSsr, parseJSON: !0, inflightCache: this.sdc, persistCache: !this.isPreview, isPrefetch: !0 }), asPath: n, locale: A, router: this }); if ((null == N ? void 0 : N.effect.type) === "rewrite" && (l.pathname = N.effect.resolvedHref, d = N.effect.resolvedHref, h = { ...h, ...N.effect.parsedAs.query }, P = N.effect.parsedAs.pathname, r = (0, w.formatWithValidation)(l)), (null == N ? void 0 : N.effect.type) === "redirect-external") return; let D = (0, s.removeTrailingSlash)(d); await this._bfl(n, P, o.locale, !0) && (this.components[u] = { __appRouter: !0 }), await Promise.all([this.pageLoader._isSsg(D).then(n => !!n && fetchNextData({ dataHref: (null == N ? void 0 : N.json) ? null == N ? void 0 : N.dataHref : this.pageLoader.getDataHref({ href: r, asPath: P, locale: A }), isServerRender: !1, parseJSON: !0, inflightCache: this.sdc, persistCache: !this.isPreview, isPrefetch: !0, unstable_skipClientCache: o.unstable_skipClientCache || o.priority && !0 }).then(() => !1).catch(() => !1)), this.pageLoader[o.priority ? "loadPage" : "prefetch"](D)]) } async fetchComponent(r) { let n = getCancelledHandler({ route: r, router: this }); try { let o = await this.pageLoader.loadPage(r); return n(), o } catch (r) { throw n(), r } } _getData(r) { let n = !1, cancel = () => { n = !0 }; return this.clc = cancel, r().then(r => { if (cancel === this.clc && (this.clc = null), n) { let r = Error("Loading initial props cancelled"); throw r.cancelled = !0, r } return r }) } _getFlightData(r) { return fetchNextData({ dataHref: r, isServerRender: !0, parseJSON: !1, inflightCache: this.sdc, persistCache: !1, isPrefetch: !1 }).then(r => { let { text: n } = r; return { data: n } }) } getInitialProps(r, n) { let { Component: o } = this.components["/_app"], l = this._wrapApp(o); return n.AppTree = l, (0, P.loadGetInitialProps)(o, { AppTree: l, Component: r, router: this, ctx: n }) } get route() { return this.state.route } get pathname() { return this.state.pathname } get query() { return this.state.query } get asPath() { return this.state.asPath } get locale() { return this.state.locale } get isFallback() { return this.state.isFallback } get isPreview() { return this.state.isPreview } constructor(r, n, l, { initialProps: u, pageLoader: f, App: d, wrapApp: h, Component: g, err: _, subscription: y, isFallback: S, locale: R, locales: O, defaultLocale: C, domainLocales: x, isPreview: j }) { this.sdc = {}, this.sbc = {}, this.isFirstPopStateEvent = !0, this._key = createKey(), this.onPopState = r => { let n; let { isFirstPopStateEvent: o } = this; this.isFirstPopStateEvent = !1; let l = r.state; if (!l) { let { pathname: r, query: n } = this; this.changeState("replaceState", (0, w.formatWithValidation)({ pathname: (0, L.addBasePath)(r), query: n }), (0, P.getURL)()); return } if (l.__NA) { window.location.reload(); return } if (!l.__N || o && this.locale === l.options.locale && l.as === this.asPath) return; let { url: u, as: s, options: f, key: d } = l; this._key = d; let { pathname: h } = (0, E.parseRelativeUrl)(u); (!this.isSsr || s !== (0, L.addBasePath)(this.asPath) || h !== (0, L.addBasePath)(this.pathname)) && (!this._bps || this._bps(l)) && this.change("replaceState", u, s, Object.assign({}, f, { shallow: f.shallow && this._shallow, locale: f.locale || this.defaultLocale, _h: 0 }), n) }; let M = (0, s.removeTrailingSlash)(r); this.components = {}, "/_error" !== r && (this.components[M] = { Component: g, initial: !0, props: u, err: _, __N_SSG: u && u.__N_SSG, __N_SSP: u && u.__N_SSP }), this.components["/_app"] = { Component: d, styleSheets: [] }; { let { BloomFilter: r } = o(10178), n = { numItems: 1, errorRate: .01, numBits: 10, numHashes: 7, bitArray: [0, 1, 1, 0, 1, 1, 1, 0, 1, 0] }, l = { numItems: 0, errorRate: .01, numBits: 0, numHashes: null, bitArray: [] }; (null == n ? void 0 : n.numHashes) && (this._bfl_s = new r(n.numItems, n.errorRate), this._bfl_s.import(n)), (null == l ? void 0 : l.numHashes) && (this._bfl_d = new r(l.numItems, l.errorRate), this._bfl_d.import(l)) } this.events = Router.events, this.pageLoader = f; let I = (0, b.isDynamicRoute)(r) && self.__NEXT_DATA__.autoExport; if (this.basePath = "", this.sub = y, this.clc = null, this._wrapApp = h, this.isSsr = !0, this.isLocaleDomain = !1, this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || (I || self.location.search, 0)), this.locales = O, this.defaultLocale = C, this.domainLocales = x, this.isLocaleDomain = !!(0, A.detectDomainLocale)(x, self.location.hostname), this.state = { route: M, pathname: r, query: n, asPath: I ? r : l, isPreview: !!j, locale: R, isFallback: S }, this._initialMatchesMiddlewarePromise = Promise.resolve(!1), !l.startsWith("//")) { let o = { locale: R }, u = (0, P.getURL)(); this._initialMatchesMiddlewarePromise = matchesMiddleware({ router: this, locale: R, asPath: u }).then(s => (o._shouldResolveHref = l !== r, this.changeState("replaceState", s ? u : (0, w.formatWithValidation)({ pathname: (0, L.addBasePath)(r), query: n }), u, o), s)) } window.addEventListener("popstate", this.onPopState) } }; Router.events = (0, y.default)() }, 43715: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "addLocale", { enumerable: !0, get: function () { return addLocale } }); let l = o(46165), u = o(97360); function addLocale(r, n, o, s) { if (!n || n === o) return r; let f = r.toLowerCase(); return !s && ((0, u.pathHasPrefix)(f, "/api") || (0, u.pathHasPrefix)(f, "/" + n.toLowerCase())) ? r : (0, l.addPathPrefix)(r, "/" + n) } }, 46165: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "addPathPrefix", { enumerable: !0, get: function () { return addPathPrefix } }); let l = o(70629); function addPathPrefix(r, n) { if (!r.startsWith("/") || !n) return r; let { pathname: o, query: u, hash: s } = (0, l.parsePath)(r); return "" + n + o + u + s } }, 38006: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "addPathSuffix", { enumerable: !0, get: function () { return addPathSuffix } }); let l = o(70629); function addPathSuffix(r, n) { if (!r.startsWith("/") || !n) return r; let { pathname: o, query: u, hash: s } = (0, l.parsePath)(r); return "" + o + n + u + s } }, 62e3: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { normalizeAppPath: function () { return normalizeAppPath }, normalizeRscPath: function () { return normalizeRscPath } }); let l = o(21940), u = o(53686); function normalizeAppPath(r) { return (0, l.ensureLeadingSlash)(r.split("/").reduce((r, n, o, l) => !n || (0, u.isGroupSegment)(n) || "@" === n[0] || ("page" === n || "route" === n) && o === l.length - 1 ? r : r + "/" + n, "")) } function normalizeRscPath(r, n) { return n ? r.replace(/\.rsc($|\?)/, "$1") : r } }, 16233: function (r, n) { "use strict"; function asPathToSearchParams(r) { return new URL(r, "http://n").searchParams } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "asPathToSearchParams", { enumerable: !0, get: function () { return asPathToSearchParams } }) }, 5420: function (r, n) { "use strict"; function compareRouterStates(r, n) { let o = Object.keys(r); if (o.length !== Object.keys(n).length) return !1; for (let l = o.length; l--;) { let u = o[l]; if ("query" === u) { let o = Object.keys(r.query); if (o.length !== Object.keys(n.query).length) return !1; for (let l = o.length; l--;) { let u = o[l]; if (!n.query.hasOwnProperty(u) || r.query[u] !== n.query[u]) return !1 } } else if (!n.hasOwnProperty(u) || r[u] !== n[u]) return !1 } return !0 } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "compareRouterStates", { enumerable: !0, get: function () { return compareRouterStates } }) }, 49374: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "formatNextPathnameInfo", { enumerable: !0, get: function () { return formatNextPathnameInfo } }); let l = o(6847), u = o(46165), s = o(38006), f = o(43715); function formatNextPathnameInfo(r) { let n = (0, f.addLocale)(r.pathname, r.locale, r.buildId ? void 0 : r.defaultLocale, r.ignorePrefix); return (r.buildId || !r.trailingSlash) && (n = (0, l.removeTrailingSlash)(n)), r.buildId && (n = (0, s.addPathSuffix)((0, u.addPathPrefix)(n, "/_next/data/" + r.buildId), "/" === r.pathname ? "index.json" : ".json")), n = (0, u.addPathPrefix)(n, r.basePath), !r.buildId && r.trailingSlash ? n.endsWith("/") ? n : (0, s.addPathSuffix)(n, "/") : (0, l.removeTrailingSlash)(n) } }, 14564: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { formatUrl: function () { return formatUrl }, urlObjectKeys: function () { return f }, formatWithValidation: function () { return formatWithValidation } }); let l = o(35815), u = l._(o(69921)), s = /https?|ftp|gopher|file/; function formatUrl(r) { let { auth: n, hostname: o } = r, l = r.protocol || "", f = r.pathname || "", d = r.hash || "", h = r.query || "", g = !1; n = n ? encodeURIComponent(n).replace(/%3A/i, ":") + "@" : "", r.host ? g = n + r.host : o && (g = n + (~o.indexOf(":") ? "[" + o + "]" : o), r.port && (g += ":" + r.port)), h && "object" == typeof h && (h = String(u.urlQueryToSearchParams(h))); let _ = r.search || h && "?" + h || ""; return l && !l.endsWith(":") && (l += ":"), r.slashes || (!l || s.test(l)) && !1 !== g ? (g = "//" + (g || ""), f && "/" !== f[0] && (f = "/" + f)) : g || (g = ""), d && "#" !== d[0] && (d = "#" + d), _ && "?" !== _[0] && (_ = "?" + _), "" + l + g + (f = f.replace(/[?#]/g, encodeURIComponent)) + (_ = _.replace("#", "%23")) + d } let f = ["auth", "hash", "host", "hostname", "href", "path", "pathname", "port", "protocol", "query", "search", "slashes"]; function formatWithValidation(r) { return formatUrl(r) } }, 35547: function (r, n) { "use strict"; function getAssetPathFromRoute(r, n) { void 0 === n && (n = ""); let o = "/" === r ? "/index" : /^\/index(\/|$)/.test(r) ? "/index" + r : "" + r; return o + n } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return getAssetPathFromRoute } }) }, 21067: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getNextPathnameInfo", { enumerable: !0, get: function () { return getNextPathnameInfo } }); let l = o(26573), u = o(86733), s = o(97360); function getNextPathnameInfo(r, n) { var o, f; let { basePath: d, i18n: h, trailingSlash: g } = null != (o = n.nextConfig) ? o : {}, _ = { pathname: r, trailingSlash: "/" !== r ? r.endsWith("/") : g }; d && (0, s.pathHasPrefix)(_.pathname, d) && (_.pathname = (0, u.removePathPrefix)(_.pathname, d), _.basePath = d); let y = _.pathname; if (_.pathname.startsWith("/_next/data/") && _.pathname.endsWith(".json")) { let r = _.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/"), o = r[0]; _.buildId = o, y = "index" !== r[1] ? "/" + r.slice(1).join("/") : "/", !0 === n.parseData && (_.pathname = y) } if (h) { let r = n.i18nProvider ? n.i18nProvider.analyze(_.pathname) : (0, l.normalizeLocalePath)(_.pathname, h.locales); _.locale = r.detectedLocale, _.pathname = null != (f = r.pathname) ? f : _.pathname, !r.detectedLocale && _.buildId && (r = n.i18nProvider ? n.i18nProvider.analyze(y) : (0, l.normalizeLocalePath)(y, h.locales)).detectedLocale && (_.locale = r.detectedLocale) } return _ } }, 58745: function (r, n) { "use strict"; function handleSmoothScroll(r, n) { if (void 0 === n && (n = {}), n.onlyHashChange) { r(); return } let o = document.documentElement, l = o.style.scrollBehavior; o.style.scrollBehavior = "auto", n.dontForceLayout || o.getClientRects(), r(), o.style.scrollBehavior = l } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "handleSmoothScroll", { enumerable: !0, get: function () { return handleSmoothScroll } }) }, 50038: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { getSortedRoutes: function () { return l.getSortedRoutes }, isDynamicRoute: function () { return u.isDynamicRoute } }); let l = o(73001), u = o(1716) }, 87973: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "interpolateAs", { enumerable: !0, get: function () { return interpolateAs } }); let l = o(9339), u = o(62872); function interpolateAs(r, n, o) { let s = "", f = (0, u.getRouteRegex)(r), d = f.groups, h = (n !== r ? (0, l.getRouteMatcher)(f)(n) : "") || o; s = r; let g = Object.keys(d); return g.every(r => { let n = h[r] || "", { repeat: o, optional: l } = d[r], u = "[" + (o ? "..." : "") + r + "]"; return l && (u = (n ? "" : "/") + "[" + u + "]"), o && !Array.isArray(n) && (n = [n]), (l || r in h) && (s = s.replace(u, o ? n.map(r => encodeURIComponent(r)).join("/") : encodeURIComponent(n)) || "/") }) || (s = ""), { params: g, result: s } } }, 67870: function (r, n) { "use strict"; function isBot(r) { return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(r) } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isBot", { enumerable: !0, get: function () { return isBot } }) }, 1716: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isDynamicRoute", { enumerable: !0, get: function () { return isDynamicRoute } }); let o = /\/\[[^/]+?\](?=\/|$)/; function isDynamicRoute(r) { return o.test(r) } }, 69414: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isLocalURL", { enumerable: !0, get: function () { return isLocalURL } }); let l = o(31393), u = o(17815); function isLocalURL(r) { if (!(0, l.isAbsoluteUrl)(r)) return !0; try { let n = (0, l.getLocationOrigin)(), o = new URL(r, n); return o.origin === n && (0, u.hasBasePath)(o.pathname) } catch (r) { return !1 } } }, 99076: function (r, n) { "use strict"; function omit(r, n) { let o = {}; return Object.keys(r).forEach(l => { n.includes(l) || (o[l] = r[l]) }), o } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "omit", { enumerable: !0, get: function () { return omit } }) }, 70629: function (r, n) { "use strict"; function parsePath(r) { let n = r.indexOf("#"), o = r.indexOf("?"), l = o > -1 && (n < 0 || o < n); return l || n > -1 ? { pathname: r.substring(0, l ? o : n), query: l ? r.substring(o, n > -1 ? n : void 0) : "", hash: n > -1 ? r.slice(n) : "" } : { pathname: r, query: "", hash: "" } } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "parsePath", { enumerable: !0, get: function () { return parsePath } }) }, 47400: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "parseRelativeUrl", { enumerable: !0, get: function () { return parseRelativeUrl } }); let l = o(31393), u = o(69921); function parseRelativeUrl(r, n) { let o = new URL((0, l.getLocationOrigin)()), s = n ? new URL(n, o) : r.startsWith(".") ? new URL(window.location.href) : o, { pathname: f, searchParams: d, search: h, hash: g, href: _, origin: y } = new URL(r, s); if (y !== o.origin) throw Error("invariant: invalid relative URL, router received " + r); return { pathname: f, query: (0, u.searchParamsToUrlQuery)(d), search: h, hash: g, href: _.slice(o.origin.length) } } }, 42220: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "parseUrl", { enumerable: !0, get: function () { return parseUrl } }); let l = o(69921), u = o(47400); function parseUrl(r) { if (r.startsWith("/")) return (0, u.parseRelativeUrl)(r); let n = new URL(r); return { hash: n.hash, hostname: n.hostname, href: n.href, pathname: n.pathname, port: n.port, protocol: n.protocol, query: (0, l.searchParamsToUrlQuery)(n.searchParams), search: n.search } } }, 97360: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "pathHasPrefix", { enumerable: !0, get: function () { return pathHasPrefix } }); let l = o(70629); function pathHasPrefix(r, n) { if ("string" != typeof r) return !1; let { pathname: o } = (0, l.parsePath)(r); return o === n || o.startsWith(n + "/") } }, 28904: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getPathMatch", { enumerable: !0, get: function () { return getPathMatch } }); let l = o(64826); function getPathMatch(r, n) { let o = [], u = (0, l.pathToRegexp)(r, o, { delimiter: "/", sensitive: "boolean" == typeof (null == n ? void 0 : n.sensitive) && n.sensitive, strict: null == n ? void 0 : n.strict }), s = (0, l.regexpToFunction)((null == n ? void 0 : n.regexModifier) ? new RegExp(n.regexModifier(u.source), u.flags) : u, o); return (r, l) => { if ("string" != typeof r) return !1; let u = s(r); if (!u) return !1; if (null == n ? void 0 : n.removeUnnamedParams) for (let r of o) "number" == typeof r.name && delete u.params[r.name]; return { ...l, ...u.params } } } }, 41339: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { matchHas: function () { return matchHas }, compileNonPath: function () { return compileNonPath }, prepareDestination: function () { return prepareDestination } }); let l = o(64826), u = o(2912), s = o(42220), f = o(69867), d = o(74089), h = o(32275); function unescapeSegments(r) { return r.replace(/__ESC_COLON_/gi, ":") } function matchHas(r, n, o, l) { void 0 === o && (o = []), void 0 === l && (l = []); let u = {}, hasMatch = o => { let l; let s = o.key; switch (o.type) { case "header": s = s.toLowerCase(), l = r.headers[s]; break; case "cookie": if ("cookies" in r) l = r.cookies[o.key]; else { let n = (0, h.getCookieParser)(r.headers)(); l = n[o.key] } break; case "query": l = n[s]; break; case "host": { let { host: n } = (null == r ? void 0 : r.headers) || {}, o = null == n ? void 0 : n.split(":")[0].toLowerCase(); l = o } }if (!o.value && l) return u[function (r) { let n = ""; for (let o = 0; o < r.length; o++) { let l = r.charCodeAt(o); (l > 64 && l < 91 || l > 96 && l < 123) && (n += r[o]) } return n }(s)] = l, !0; if (l) { let r = RegExp("^" + o.value + "$"), n = Array.isArray(l) ? l.slice(-1)[0].match(r) : l.match(r); if (n) return Array.isArray(n) && (n.groups ? Object.keys(n.groups).forEach(r => { u[r] = n.groups[r] }) : "host" === o.type && n[0] && (u.host = n[0])), !0 } return !1 }, s = o.every(r => hasMatch(r)) && !l.some(r => hasMatch(r)); return !!s && u } function compileNonPath(r, n) { if (!r.includes(":")) return r; for (let o of Object.keys(n)) r.includes(":" + o) && (r = r.replace(RegExp(":" + o + "\\*", "g"), ":" + o + "--ESCAPED_PARAM_ASTERISKS").replace(RegExp(":" + o + "\\?", "g"), ":" + o + "--ESCAPED_PARAM_QUESTION").replace(RegExp(":" + o + "\\+", "g"), ":" + o + "--ESCAPED_PARAM_PLUS").replace(RegExp(":" + o + "(?!\\w)", "g"), "--ESCAPED_PARAM_COLON" + o)); return r = r.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*"), (0, l.compile)("/" + r, { validate: !1 })(n).slice(1) } function prepareDestination(r) { let n; let o = Object.assign({}, r.query); delete o.__nextLocale, delete o.__nextDefaultLocale, delete o.__nextDataReq, delete o.__nextInferredLocaleFromDefault, delete o[d.NEXT_RSC_UNION_QUERY]; let h = r.destination; for (let n of Object.keys({ ...r.params, ...o })) h = h.replace(RegExp(":" + (0, u.escapeStringRegexp)(n), "g"), "__ESC_COLON_" + n); let g = (0, s.parseUrl)(h), _ = g.query, y = unescapeSegments("" + g.pathname + (g.hash || "")), P = unescapeSegments(g.hostname || ""), b = [], E = []; (0, l.pathToRegexp)(y, b), (0, l.pathToRegexp)(P, E); let S = []; b.forEach(r => S.push(r.name)), E.forEach(r => S.push(r.name)); let R = (0, l.compile)(y, { validate: !1 }), O = (0, l.compile)(P, { validate: !1 }); for (let [n, o] of Object.entries(_)) Array.isArray(o) ? _[n] = o.map(n => compileNonPath(unescapeSegments(n), r.params)) : "string" == typeof o && (_[n] = compileNonPath(unescapeSegments(o), r.params)); let w = Object.keys(r.params).filter(r => "nextInternalLocale" !== r); if (r.appendParamsToQuery && !w.some(r => S.includes(r))) for (let n of w) n in _ || (_[n] = r.params[n]); if ((0, f.isInterceptionRouteAppPath)(y)) for (let n of y.split("/")) { let o = f.INTERCEPTION_ROUTE_MARKERS.find(r => n.startsWith(r)); if (o) { r.params["0"] = o; break } } try { n = R(r.params); let [o, l] = n.split("#"); g.hostname = O(r.params), g.pathname = o, g.hash = (l ? "#" : "") + (l || ""), delete g.search } catch (r) { if (r.message.match(/Expected .*? to not repeat, but got an array/)) throw Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match"); throw r } return g.query = { ...o, ...g.query }, { newUrl: n, destQuery: _, parsedDestination: g } } }, 69921: function (r, n) { "use strict"; function searchParamsToUrlQuery(r) { let n = {}; return r.forEach((r, o) => { void 0 === n[o] ? n[o] = r : Array.isArray(n[o]) ? n[o].push(r) : n[o] = [n[o], r] }), n } function stringifyUrlQueryParam(r) { return "string" != typeof r && ("number" != typeof r || isNaN(r)) && "boolean" != typeof r ? "" : String(r) } function urlQueryToSearchParams(r) { let n = new URLSearchParams; return Object.entries(r).forEach(r => { let [o, l] = r; Array.isArray(l) ? l.forEach(r => n.append(o, stringifyUrlQueryParam(r))) : n.set(o, stringifyUrlQueryParam(l)) }), n } function assign(r) { for (var n = arguments.length, o = Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++)o[l - 1] = arguments[l]; return o.forEach(n => { Array.from(n.keys()).forEach(n => r.delete(n)), n.forEach((n, o) => r.append(o, n)) }), r } Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { searchParamsToUrlQuery: function () { return searchParamsToUrlQuery }, urlQueryToSearchParams: function () { return urlQueryToSearchParams }, assign: function () { return assign } }) }, 86733: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "removePathPrefix", { enumerable: !0, get: function () { return removePathPrefix } }); let l = o(97360); function removePathPrefix(r, n) { if (!(0, l.pathHasPrefix)(r, n)) return r; let o = r.slice(n.length); return o.startsWith("/") ? o : "/" + o } }, 6847: function (r, n) { "use strict"; function removeTrailingSlash(r) { return r.replace(/\/$/, "") || "/" } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "removeTrailingSlash", { enumerable: !0, get: function () { return removeTrailingSlash } }) }, 57759: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return resolveRewrites } }); let l = o(28904), u = o(41339), s = o(6847), f = o(26573), d = o(66919), h = o(47400); function resolveRewrites(r, n, o, g, _, y) { let P, b = !1, E = !1, S = (0, h.parseRelativeUrl)(r), R = (0, s.removeTrailingSlash)((0, f.normalizeLocalePath)((0, d.removeBasePath)(S.pathname), y).pathname), handleRewrite = o => { let h = (0, l.getPathMatch)(o.source + "", { removeUnnamedParams: !0, strict: !0 }), O = h(S.pathname); if ((o.has || o.missing) && O) { let r = (0, u.matchHas)({ headers: { host: document.location.hostname, "user-agent": navigator.userAgent }, cookies: document.cookie.split("; ").reduce((r, n) => { let [o, ...l] = n.split("="); return r[o] = l.join("="), r }, {}) }, S.query, o.has, o.missing); r ? Object.assign(O, r) : O = !1 } if (O) { if (!o.destination) return E = !0, !0; let l = (0, u.prepareDestination)({ appendParamsToQuery: !0, destination: o.destination, params: O, query: g }); if (S = l.parsedDestination, r = l.newUrl, Object.assign(g, l.parsedDestination.query), R = (0, s.removeTrailingSlash)((0, f.normalizeLocalePath)((0, d.removeBasePath)(r), y).pathname), n.includes(R)) return b = !0, P = R, !0; if ((P = _(R)) !== r && n.includes(P)) return b = !0, !0 } }, O = !1; for (let r = 0; r < o.beforeFiles.length; r++)handleRewrite(o.beforeFiles[r]); if (!(b = n.includes(R))) { if (!O) { for (let r = 0; r < o.afterFiles.length; r++)if (handleRewrite(o.afterFiles[r])) { O = !0; break } } if (O || (P = _(R), O = b = n.includes(P)), !O) { for (let r = 0; r < o.fallback.length; r++)if (handleRewrite(o.fallback[r])) { O = !0; break } } } return { asPath: r, parsedAs: S, matchedPage: b, resolvedHref: P, externalDest: E } } }, 9339: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getRouteMatcher", { enumerable: !0, get: function () { return getRouteMatcher } }); let l = o(31393); function getRouteMatcher(r) { let { re: n, groups: o } = r; return r => { let u = n.exec(r); if (!u) return !1; let decode = r => { try { return decodeURIComponent(r) } catch (r) { throw new l.DecodeError("failed to decode param") } }, s = {}; return Object.keys(o).forEach(r => { let n = o[r], l = u[n.pos]; void 0 !== l && (s[r] = ~l.indexOf("/") ? l.split("/").map(r => decode(r)) : n.repeat ? [decode(l)] : decode(l)) }), s } } }, 62872: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { getRouteRegex: function () { return getRouteRegex }, getNamedRouteRegex: function () { return getNamedRouteRegex }, getNamedMiddlewareRegex: function () { return getNamedMiddlewareRegex } }); let l = o(69867), u = o(2912), s = o(6847); function parseParameter(r) { let n = r.startsWith("[") && r.endsWith("]"); n && (r = r.slice(1, -1)); let o = r.startsWith("..."); return o && (r = r.slice(3)), { key: r, repeat: o, optional: n } } function getParametrizedRoute(r) { let n = (0, s.removeTrailingSlash)(r).slice(1).split("/"), o = {}, f = 1; return { parameterizedRoute: n.map(r => { let n = l.INTERCEPTION_ROUTE_MARKERS.find(n => r.startsWith(n)), s = r.match(/\[((?:\[.*\])|.+)\]/); if (n && s) { let { key: r, optional: l, repeat: d } = parseParameter(s[1]); return o[r] = { pos: f++, repeat: d, optional: l }, "/" + (0, u.escapeStringRegexp)(n) + "([^/]+?)" } if (!s) return "/" + (0, u.escapeStringRegexp)(r); { let { key: r, repeat: n, optional: l } = parseParameter(s[1]); return o[r] = { pos: f++, repeat: n, optional: l }, n ? l ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)" } }).join(""), groups: o } } function getRouteRegex(r) { let { parameterizedRoute: n, groups: o } = getParametrizedRoute(r); return { re: RegExp("^" + n + "(?:/)?$"), groups: o } } function getSafeKeyFromSegment(r) { let { getSafeRouteKey: n, segment: o, routeKeys: l, keyPrefix: u } = r, { key: s, optional: f, repeat: d } = parseParameter(o), h = s.replace(/\W/g, ""); u && (h = "" + u + h); let g = !1; return (0 === h.length || h.length > 30) && (g = !0), isNaN(parseInt(h.slice(0, 1))) || (g = !0), g && (h = n()), u ? l[h] = "" + u + s : l[h] = "" + s, d ? f ? "(?:/(?<" + h + ">.+?))?" : "/(?<" + h + ">.+?)" : "/(?<" + h + ">[^/]+?)" } function getNamedParametrizedRoute(r, n) { let o; let f = (0, s.removeTrailingSlash)(r).slice(1).split("/"), d = (o = 0, () => { let r = "", n = ++o; for (; n > 0;)r += String.fromCharCode(97 + (n - 1) % 26), n = Math.floor((n - 1) / 26); return r }), h = {}; return { namedParameterizedRoute: f.map(r => { let o = l.INTERCEPTION_ROUTE_MARKERS.some(n => r.startsWith(n)), s = r.match(/\[((?:\[.*\])|.+)\]/); return o && s ? getSafeKeyFromSegment({ getSafeRouteKey: d, segment: s[1], routeKeys: h, keyPrefix: n ? "nxtI" : void 0 }) : s ? getSafeKeyFromSegment({ getSafeRouteKey: d, segment: s[1], routeKeys: h, keyPrefix: n ? "nxtP" : void 0 }) : "/" + (0, u.escapeStringRegexp)(r) }).join(""), routeKeys: h } } function getNamedRouteRegex(r, n) { let o = getNamedParametrizedRoute(r, n); return { ...getRouteRegex(r), namedRegex: "^" + o.namedParameterizedRoute + "(?:/)?$", routeKeys: o.routeKeys } } function getNamedMiddlewareRegex(r, n) { let { parameterizedRoute: o } = getParametrizedRoute(r), { catchAll: l = !0 } = n; if ("/" === o) return { namedRegex: "^/" + (l ? ".*" : "") + "$" }; let { namedParameterizedRoute: u } = getNamedParametrizedRoute(r, !1); return { namedRegex: "^" + u + (l ? "(?:(/.*)?)" : "") + "$" } } }, 73001: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getSortedRoutes", { enumerable: !0, get: function () { return getSortedRoutes } }); let UrlNode = class UrlNode { insert(r) { this._insert(r.split("/").filter(Boolean), [], !1) } smoosh() { return this._smoosh() } _smoosh(r) { void 0 === r && (r = "/"); let n = [...this.children.keys()].sort(); null !== this.slugName && n.splice(n.indexOf("[]"), 1), null !== this.restSlugName && n.splice(n.indexOf("[...]"), 1), null !== this.optionalRestSlugName && n.splice(n.indexOf("[[...]]"), 1); let o = n.map(n => this.children.get(n)._smoosh("" + r + n + "/")).reduce((r, n) => [...r, ...n], []); if (null !== this.slugName && o.push(...this.children.get("[]")._smoosh(r + "[" + this.slugName + "]/")), !this.placeholder) { let n = "/" === r ? "/" : r.slice(0, -1); if (null != this.optionalRestSlugName) throw Error('You cannot define a route with the same specificity as a optional catch-all route ("' + n + '" and "' + n + "[[..." + this.optionalRestSlugName + ']]").'); o.unshift(n) } return null !== this.restSlugName && o.push(...this.children.get("[...]")._smoosh(r + "[..." + this.restSlugName + "]/")), null !== this.optionalRestSlugName && o.push(...this.children.get("[[...]]")._smoosh(r + "[[..." + this.optionalRestSlugName + "]]/")), o } _insert(r, n, o) { if (0 === r.length) { this.placeholder = !1; return } if (o) throw Error("Catch-all must be the last part of the URL."); let l = r[0]; if (l.startsWith("[") && l.endsWith("]")) { let u = l.slice(1, -1), s = !1; if (u.startsWith("[") && u.endsWith("]") && (u = u.slice(1, -1), s = !0), u.startsWith("...") && (u = u.substring(3), o = !0), u.startsWith("[") || u.endsWith("]")) throw Error("Segment names may not start or end with extra brackets ('" + u + "')."); if (u.startsWith(".")) throw Error("Segment names may not start with erroneous periods ('" + u + "')."); function handleSlug(r, o) { if (null !== r && r !== o) throw Error("You cannot use different slug names for the same dynamic path ('" + r + "' !== '" + o + "')."); n.forEach(r => { if (r === o) throw Error('You cannot have the same slug name "' + o + '" repeat within a single dynamic path'); if (r.replace(/\W/g, "") === l.replace(/\W/g, "")) throw Error('You cannot have the slug names "' + r + '" and "' + o + '" differ only by non-word symbols within a single dynamic path') }), n.push(o) } if (o) { if (s) { if (null != this.restSlugName) throw Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + r[0] + '" ).'); handleSlug(this.optionalRestSlugName, u), this.optionalRestSlugName = u, l = "[[...]]" } else { if (null != this.optionalRestSlugName) throw Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + r[0] + '").'); handleSlug(this.restSlugName, u), this.restSlugName = u, l = "[...]" } } else { if (s) throw Error('Optional route parameters are not yet supported ("' + r[0] + '").'); handleSlug(this.slugName, u), this.slugName = u, l = "[]" } } this.children.has(l) || this.children.set(l, new UrlNode), this.children.get(l)._insert(r.slice(1), n, o) } constructor() { this.placeholder = !0, this.children = new Map, this.slugName = null, this.restSlugName = null, this.optionalRestSlugName = null } }; function getSortedRoutes(r) { let n = new UrlNode; return r.forEach(r => n.insert(r)), n.smoosh() } }, 84800: function (r, n) { "use strict"; let o; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { default: function () { return _default }, setConfig: function () { return setConfig } }); let _default = () => o; function setConfig(r) { o = r } }, 53686: function (r, n) { "use strict"; function isGroupSegment(r) { return "(" === r[0] && r.endsWith(")") } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isGroupSegment", { enumerable: !0, get: function () { return isGroupSegment } }) }, 48065: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "default", { enumerable: !0, get: function () { return SideEffect } }); let l = o(50959), u = l.useLayoutEffect, s = l.useEffect; function SideEffect(r) { let { headManager: n, reduceComponentsToState: o } = r; function emitChange() { if (n && n.mountedInstances) { let u = l.Children.toArray(Array.from(n.mountedInstances).filter(Boolean)); n.updateHead(o(u, r)) } } return u(() => { var o; return null == n || null == (o = n.mountedInstances) || o.add(r.children), () => { var o; null == n || null == (o = n.mountedInstances) || o.delete(r.children) } }), u(() => (n && (n._pendingUpdate = emitChange), () => { n && (n._pendingUpdate = emitChange) })), s(() => (n && n._pendingUpdate && (n._pendingUpdate(), n._pendingUpdate = null), () => { n && n._pendingUpdate && (n._pendingUpdate(), n._pendingUpdate = null) })), null } }, 31393: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { WEB_VITALS: function () { return o }, execOnce: function () { return execOnce }, isAbsoluteUrl: function () { return isAbsoluteUrl }, getLocationOrigin: function () { return getLocationOrigin }, getURL: function () { return getURL }, getDisplayName: function () { return getDisplayName }, isResSent: function () { return isResSent }, normalizeRepeatedSlashes: function () { return normalizeRepeatedSlashes }, loadGetInitialProps: function () { return loadGetInitialProps }, SP: function () { return u }, ST: function () { return s }, DecodeError: function () { return DecodeError }, NormalizeError: function () { return NormalizeError }, PageNotFoundError: function () { return PageNotFoundError }, MissingStaticPage: function () { return MissingStaticPage }, MiddlewareNotFoundError: function () { return MiddlewareNotFoundError }, stringifyError: function () { return stringifyError } }); let o = ["CLS", "FCP", "FID", "INP", "LCP", "TTFB"]; function execOnce(r) { let n, o = !1; return function () { for (var l = arguments.length, u = Array(l), s = 0; s < l; s++)u[s] = arguments[s]; return o || (o = !0, n = r(...u)), n } } let l = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/, isAbsoluteUrl = r => l.test(r); function getLocationOrigin() { let { protocol: r, hostname: n, port: o } = window.location; return r + "//" + n + (o ? ":" + o : "") } function getURL() { let { href: r } = window.location, n = getLocationOrigin(); return r.substring(n.length) } function getDisplayName(r) { return "string" == typeof r ? r : r.displayName || r.name || "Unknown" } function isResSent(r) { return r.finished || r.headersSent } function normalizeRepeatedSlashes(r) { let n = r.split("?"), o = n[0]; return o.replace(/\\/g, "/").replace(/\/\/+/g, "/") + (n[1] ? "?" + n.slice(1).join("?") : "") } async function loadGetInitialProps(r, n) { let o = n.res || n.ctx && n.ctx.res; if (!r.getInitialProps) return n.ctx && n.Component ? { pageProps: await loadGetInitialProps(n.Component, n.ctx) } : {}; let l = await r.getInitialProps(n); if (o && isResSent(o)) return l; if (!l) { let n = '"' + getDisplayName(r) + '.getInitialProps()" should resolve to an object. But found "' + l + '" instead.'; throw Error(n) } return l } let u = "undefined" != typeof performance, s = u && ["mark", "measure", "getEntriesByName"].every(r => "function" == typeof performance[r]); let DecodeError = class DecodeError extends Error { }; let NormalizeError = class NormalizeError extends Error { }; let PageNotFoundError = class PageNotFoundError extends Error { constructor(r) { super(), this.code = "ENOENT", this.name = "PageNotFoundError", this.message = "Cannot find module for page: " + r } }; let MissingStaticPage = class MissingStaticPage extends Error { constructor(r, n) { super(), this.message = "Failed to load static file for page: " + r + " " + n } }; let MiddlewareNotFoundError = class MiddlewareNotFoundError extends Error { constructor() { super(), this.code = "ENOENT", this.message = "Cannot find the middleware module" } }; function stringifyError(r) { return JSON.stringify({ message: r.message, stack: r.stack }) } }, 59010: function (r, n) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "warnOnce", { enumerable: !0, get: function () { return warnOnce } }); let warnOnce = r => { } }, 24690: function (r) {
    var n, o, l, u, s; "undefined" != typeof __nccwpck_require__ && (__nccwpck_require__.ab = "//"),/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */(n = {}).parse = function (r, n) { if ("string" != typeof r) throw TypeError("argument str must be a string"); for (var l = {}, s = r.split(u), f = (n || {}).decode || o, d = 0; d < s.length; d++) { var h = s[d], g = h.indexOf("="); if (!(g < 0)) { var _ = h.substr(0, g).trim(), y = h.substr(++g, h.length).trim(); '"' == y[0] && (y = y.slice(1, -1)), void 0 == l[_] && (l[_] = function (r, n) { try { return n(r) } catch (n) { return r } }(y, f)) } } return l }, n.serialize = function (r, n, o) { var u = o || {}, f = u.encode || l; if ("function" != typeof f) throw TypeError("option encode is invalid"); if (!s.test(r)) throw TypeError("argument name is invalid"); var d = f(n); if (d && !s.test(d)) throw TypeError("argument val is invalid"); var h = r + "=" + d; if (null != u.maxAge) { var g = u.maxAge - 0; if (isNaN(g) || !isFinite(g)) throw TypeError("option maxAge is invalid"); h += "; Max-Age=" + Math.floor(g) } if (u.domain) { if (!s.test(u.domain)) throw TypeError("option domain is invalid"); h += "; Domain=" + u.domain } if (u.path) { if (!s.test(u.path)) throw TypeError("option path is invalid"); h += "; Path=" + u.path } if (u.expires) { if ("function" != typeof u.expires.toUTCString) throw TypeError("option expires is invalid"); h += "; Expires=" + u.expires.toUTCString() } if (u.httpOnly && (h += "; HttpOnly"), u.secure && (h += "; Secure"), u.sameSite) switch ("string" == typeof u.sameSite ? u.sameSite.toLowerCase() : u.sameSite) { case !0: case "strict": h += "; SameSite=Strict"; break; case "lax": h += "; SameSite=Lax"; break; case "none": h += "; SameSite=None"; break; default: throw TypeError("option sameSite is invalid") }return h }, o = decodeURIComponent, l = encodeURIComponent, u = /; */, s = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, r.exports = n
  }, 64826: function (r, n) { "use strict"; function parse(r, n) { void 0 === n && (n = {}); for (var o = function (r) { for (var n = [], o = 0; o < r.length;) { var l = r[o]; if ("*" === l || "+" === l || "?" === l) { n.push({ type: "MODIFIER", index: o, value: r[o++] }); continue } if ("\\" === l) { n.push({ type: "ESCAPED_CHAR", index: o++, value: r[o++] }); continue } if ("{" === l) { n.push({ type: "OPEN", index: o, value: r[o++] }); continue } if ("}" === l) { n.push({ type: "CLOSE", index: o, value: r[o++] }); continue } if (":" === l) { for (var u = "", s = o + 1; s < r.length;) { var f = r.charCodeAt(s); if (f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || 95 === f) { u += r[s++]; continue } break } if (!u) throw TypeError("Missing parameter name at " + o); n.push({ type: "NAME", index: o, value: u }), o = s; continue } if ("(" === l) { var d = 1, h = "", s = o + 1; if ("?" === r[s]) throw TypeError('Pattern cannot start with "?" at ' + s); for (; s < r.length;) { if ("\\" === r[s]) { h += r[s++] + r[s++]; continue } if (")" === r[s]) { if (0 == --d) { s++; break } } else if ("(" === r[s] && (d++, "?" !== r[s + 1])) throw TypeError("Capturing groups are not allowed at " + s); h += r[s++] } if (d) throw TypeError("Unbalanced pattern at " + o); if (!h) throw TypeError("Missing pattern at " + o); n.push({ type: "PATTERN", index: o, value: h }), o = s; continue } n.push({ type: "CHAR", index: o, value: r[o++] }) } return n.push({ type: "END", index: o, value: "" }), n }(r), l = n.prefixes, u = void 0 === l ? "./" : l, s = "[^" + escapeString(n.delimiter || "/#?") + "]+?", f = [], d = 0, h = 0, g = "", tryConsume = function (r) { if (h < o.length && o[h].type === r) return o[h++].value }, mustConsume = function (r) { var n = tryConsume(r); if (void 0 !== n) return n; var l = o[h]; throw TypeError("Unexpected " + l.type + " at " + l.index + ", expected " + r) }, consumeText = function () { for (var r, n = ""; r = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR");)n += r; return n }; h < o.length;) { var _ = tryConsume("CHAR"), y = tryConsume("NAME"), P = tryConsume("PATTERN"); if (y || P) { var b = _ || ""; -1 === u.indexOf(b) && (g += b, b = ""), g && (f.push(g), g = ""), f.push({ name: y || d++, prefix: b, suffix: "", pattern: P || s, modifier: tryConsume("MODIFIER") || "" }); continue } var E = _ || tryConsume("ESCAPED_CHAR"); if (E) { g += E; continue } if (g && (f.push(g), g = ""), tryConsume("OPEN")) { var b = consumeText(), S = tryConsume("NAME") || "", R = tryConsume("PATTERN") || "", O = consumeText(); mustConsume("CLOSE"), f.push({ name: S || (R ? d++ : ""), pattern: S && !R ? s : R, prefix: b, suffix: O, modifier: tryConsume("MODIFIER") || "" }); continue } mustConsume("END") } return f } function tokensToFunction(r, n) { void 0 === n && (n = {}); var o = flags(n), l = n.encode, u = void 0 === l ? function (r) { return r } : l, s = n.validate, f = void 0 === s || s, d = r.map(function (r) { if ("object" == typeof r) return RegExp("^(?:" + r.pattern + ")$", o) }); return function (n) { for (var o = "", l = 0; l < r.length; l++) { var s = r[l]; if ("string" == typeof s) { o += s; continue } var h = n ? n[s.name] : void 0, g = "?" === s.modifier || "*" === s.modifier, _ = "*" === s.modifier || "+" === s.modifier; if (Array.isArray(h)) { if (!_) throw TypeError('Expected "' + s.name + '" to not repeat, but got an array'); if (0 === h.length) { if (g) continue; throw TypeError('Expected "' + s.name + '" to not be empty') } for (var y = 0; y < h.length; y++) { var P = u(h[y], s); if (f && !d[l].test(P)) throw TypeError('Expected all "' + s.name + '" to match "' + s.pattern + '", but got "' + P + '"'); o += s.prefix + P + s.suffix } continue } if ("string" == typeof h || "number" == typeof h) { var P = u(String(h), s); if (f && !d[l].test(P)) throw TypeError('Expected "' + s.name + '" to match "' + s.pattern + '", but got "' + P + '"'); o += s.prefix + P + s.suffix; continue } if (!g) { var b = _ ? "an array" : "a string"; throw TypeError('Expected "' + s.name + '" to be ' + b) } } return o } } function regexpToFunction(r, n, o) { void 0 === o && (o = {}); var l = o.decode, u = void 0 === l ? function (r) { return r } : l; return function (o) { var l = r.exec(o); if (!l) return !1; for (var s = l[0], f = l.index, d = Object.create(null), h = 1; h < l.length; h++)!function (r) { if (void 0 !== l[r]) { var o = n[r - 1]; "*" === o.modifier || "+" === o.modifier ? d[o.name] = l[r].split(o.prefix + o.suffix).map(function (r) { return u(r, o) }) : d[o.name] = u(l[r], o) } }(h); return { path: s, index: f, params: d } } } function escapeString(r) { return r.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function flags(r) { return r && r.sensitive ? "" : "i" } function tokensToRegexp(r, n, o) { void 0 === o && (o = {}); for (var l = o.strict, u = void 0 !== l && l, s = o.start, f = o.end, d = o.encode, h = void 0 === d ? function (r) { return r } : d, g = "[" + escapeString(o.endsWith || "") + "]|$", _ = "[" + escapeString(o.delimiter || "/#?") + "]", y = void 0 === s || s ? "^" : "", P = 0; P < r.length; P++) { var b = r[P]; if ("string" == typeof b) y += escapeString(h(b)); else { var E = escapeString(h(b.prefix)), S = escapeString(h(b.suffix)); if (b.pattern) { if (n && n.push(b), E || S) { if ("+" === b.modifier || "*" === b.modifier) { var R = "*" === b.modifier ? "?" : ""; y += "(?:" + E + "((?:" + b.pattern + ")(?:" + S + E + "(?:" + b.pattern + "))*)" + S + ")" + R } else y += "(?:" + E + "(" + b.pattern + ")" + S + ")" + b.modifier } else y += "(" + b.pattern + ")" + b.modifier } else y += "(?:" + E + S + ")" + b.modifier } } if (void 0 === f || f) u || (y += _ + "?"), y += o.endsWith ? "(?=" + g + ")" : "$"; else { var O = r[r.length - 1], w = "string" == typeof O ? _.indexOf(O[O.length - 1]) > -1 : void 0 === O; u || (y += "(?:" + _ + "(?=" + g + "))?"), w || (y += "(?=" + _ + "|" + g + ")") } return new RegExp(y, flags(o)) } function pathToRegexp(r, n, o) { return r instanceof RegExp ? function (r, n) { if (!n) return r; var o = r.source.match(/\((?!\?)/g); if (o) for (var l = 0; l < o.length; l++)n.push({ name: l, prefix: "", suffix: "", modifier: "", pattern: "" }); return r }(r, n) : Array.isArray(r) ? RegExp("(?:" + r.map(function (r) { return pathToRegexp(r, n, o).source }).join("|") + ")", flags(o)) : tokensToRegexp(parse(r, o), n, o) } Object.defineProperty(n, "__esModule", { value: !0 }), n.parse = parse, n.compile = function (r, n) { return tokensToFunction(parse(r, n), n) }, n.tokensToFunction = tokensToFunction, n.match = function (r, n) { var o = []; return regexpToFunction(pathToRegexp(r, o, n), o, n) }, n.regexpToFunction = regexpToFunction, n.tokensToRegexp = tokensToRegexp, n.pathToRegexp = pathToRegexp }, 33056: function (r) { var n, o, l, u, s, f, d, h, g, _, y, P, b, E, S, R, O, w, A, C, x, j, M, L, I, N, D, k, F, U, H, B, W, q, z, G, V, X, Y, Q, K, $, J, Z, ee, et; (n = {}).d = function (r, o) { for (var l in o) n.o(o, l) && !n.o(r, l) && Object.defineProperty(r, l, { enumerable: !0, get: o[l] }) }, n.o = function (r, n) { return Object.prototype.hasOwnProperty.call(r, n) }, n.r = function (r) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r, "__esModule", { value: !0 }) }, void 0 !== n && (n.ab = "//"), o = {}, n.r(o), n.d(o, { getCLS: function () { return M }, getFCP: function () { return C }, getFID: function () { return U }, getINP: function () { return $ }, getLCP: function () { return Z }, getTTFB: function () { return et }, onCLS: function () { return M }, onFCP: function () { return C }, onFID: function () { return U }, onINP: function () { return $ }, onLCP: function () { return Z }, onTTFB: function () { return et } }), h = -1, g = function (r) { addEventListener("pageshow", function (n) { n.persisted && (h = n.timeStamp, r(n)) }, !0) }, _ = function () { return window.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0] }, y = function () { var r = _(); return r && r.activationStart || 0 }, P = function (r, n) { var o = _(), l = "navigate"; return h >= 0 ? l = "back-forward-cache" : o && (l = document.prerendering || y() > 0 ? "prerender" : o.type.replace(/_/g, "-")), { name: r, value: void 0 === n ? -1 : n, rating: "good", delta: 0, entries: [], id: "v3-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12), navigationType: l } }, b = function (r, n, o) { try { if (PerformanceObserver.supportedEntryTypes.includes(r)) { var l = new PerformanceObserver(function (r) { n(r.getEntries()) }); return l.observe(Object.assign({ type: r, buffered: !0 }, o || {})), l } } catch (r) { } }, E = function (r, n) { var T = function t(o) { "pagehide" !== o.type && "hidden" !== document.visibilityState || (r(o), n && (removeEventListener("visibilitychange", t, !0), removeEventListener("pagehide", t, !0))) }; addEventListener("visibilitychange", T, !0), addEventListener("pagehide", T, !0) }, S = function (r, n, o, l) { var u, s; return function (f) { var d; n.value >= 0 && (f || l) && ((s = n.value - (u || 0)) || void 0 === u) && (u = n.value, n.delta = s, n.rating = (d = n.value) > o[1] ? "poor" : d > o[0] ? "needs-improvement" : "good", r(n)) } }, R = -1, O = function () { return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0 }, w = function () { E(function (r) { R = r.timeStamp }, !0) }, A = function () { return R < 0 && (R = O(), w(), g(function () { setTimeout(function () { R = O(), w() }, 0) })), { get firstHiddenTime() { return R } } }, C = function (r, n) { n = n || {}; var o, l = [1800, 3e3], u = A(), s = P("FCP"), c = function (r) { r.forEach(function (r) { "first-contentful-paint" === r.name && (d && d.disconnect(), r.startTime < u.firstHiddenTime && (s.value = r.startTime - y(), s.entries.push(r), o(!0))) }) }, f = window.performance && window.performance.getEntriesByName && window.performance.getEntriesByName("first-contentful-paint")[0], d = f ? null : b("paint", c); (f || d) && (o = S(r, s, l, n.reportAllChanges), f && c([f]), g(function (u) { o = S(r, s = P("FCP"), l, n.reportAllChanges), requestAnimationFrame(function () { requestAnimationFrame(function () { s.value = performance.now() - u.timeStamp, o(!0) }) }) })) }, x = !1, j = -1, M = function (r, n) { n = n || {}; var o = [.1, .25]; x || (C(function (r) { j = r.value }), x = !0); var l, i = function (n) { j > -1 && r(n) }, u = P("CLS", 0), s = 0, f = [], p = function (r) { r.forEach(function (r) { if (!r.hadRecentInput) { var n = f[0], o = f[f.length - 1]; s && r.startTime - o.startTime < 1e3 && r.startTime - n.startTime < 5e3 ? (s += r.value, f.push(r)) : (s = r.value, f = [r]), s > u.value && (u.value = s, u.entries = f, l()) } }) }, d = b("layout-shift", p); d && (l = S(i, u, o, n.reportAllChanges), E(function () { p(d.takeRecords()), l(!0) }), g(function () { s = 0, j = -1, l = S(i, u = P("CLS", 0), o, n.reportAllChanges) })) }, L = { passive: !0, capture: !0 }, I = new Date, N = function (r, n) { l || (l = n, u = r, s = new Date, F(removeEventListener), D()) }, D = function () { if (u >= 0 && u < s - I) { var r = { entryType: "first-input", name: l.type, target: l.target, cancelable: l.cancelable, startTime: l.timeStamp, processingStart: l.timeStamp + u }; f.forEach(function (n) { n(r) }), f = [] } }, k = function (r) { if (r.cancelable) { var n, o, l, u = (r.timeStamp > 1e12 ? new Date : performance.now()) - r.timeStamp; "pointerdown" == r.type ? (n = function () { N(u, r), l() }, o = function () { l() }, l = function () { removeEventListener("pointerup", n, L), removeEventListener("pointercancel", o, L) }, addEventListener("pointerup", n, L), addEventListener("pointercancel", o, L)) : N(u, r) } }, F = function (r) { ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (n) { return r(n, k, L) }) }, U = function (r, n) { n = n || {}; var o, s = [100, 300], d = A(), h = P("FID"), v = function (r) { r.startTime < d.firstHiddenTime && (h.value = r.processingStart - r.startTime, h.entries.push(r), o(!0)) }, m = function (r) { r.forEach(v) }, _ = b("first-input", m); o = S(r, h, s, n.reportAllChanges), _ && E(function () { m(_.takeRecords()), _.disconnect() }, !0), _ && g(function () { o = S(r, h = P("FID"), s, n.reportAllChanges), f = [], u = -1, l = null, F(addEventListener), f.push(v), D() }) }, H = 0, B = 1 / 0, W = 0, q = function (r) { r.forEach(function (r) { r.interactionId && (B = Math.min(B, r.interactionId), H = (W = Math.max(W, r.interactionId)) ? (W - B) / 7 + 1 : 0) }) }, z = function () { return d ? H : performance.interactionCount || 0 }, G = function () { "interactionCount" in performance || d || (d = b("event", q, { type: "event", buffered: !0, durationThreshold: 0 })) }, V = 0, X = function () { return z() - V }, Y = [], Q = {}, K = function (r) { var n = Y[Y.length - 1], o = Q[r.interactionId]; if (o || Y.length < 10 || r.duration > n.latency) { if (o) o.entries.push(r), o.latency = Math.max(o.latency, r.duration); else { var l = { id: r.interactionId, latency: r.duration, entries: [r] }; Q[l.id] = l, Y.push(l) } Y.sort(function (r, n) { return n.latency - r.latency }), Y.splice(10).forEach(function (r) { delete Q[r.id] }) } }, $ = function (r, n) { n = n || {}; var o = [200, 500]; G(); var l, u = P("INP"), a = function (r) { r.forEach(function (r) { r.interactionId && K(r), "first-input" !== r.entryType || Y.some(function (n) { return n.entries.some(function (n) { return r.duration === n.duration && r.startTime === n.startTime }) }) || K(r) }); var n, o = (n = Math.min(Y.length - 1, Math.floor(X() / 50)), Y[n]); o && o.latency !== u.value && (u.value = o.latency, u.entries = o.entries, l()) }, s = b("event", a, { durationThreshold: n.durationThreshold || 40 }); l = S(r, u, o, n.reportAllChanges), s && (s.observe({ type: "first-input", buffered: !0 }), E(function () { a(s.takeRecords()), u.value < 0 && X() > 0 && (u.value = 0, u.entries = []), l(!0) }), g(function () { Y = [], V = z(), l = S(r, u = P("INP"), o, n.reportAllChanges) })) }, J = {}, Z = function (r, n) { n = n || {}; var o, l = [2500, 4e3], u = A(), s = P("LCP"), c = function (r) { var n = r[r.length - 1]; if (n) { var l = n.startTime - y(); l < u.firstHiddenTime && (s.value = l, s.entries = [n], o()) } }, f = b("largest-contentful-paint", c); if (f) { o = S(r, s, l, n.reportAllChanges); var v = function () { J[s.id] || (c(f.takeRecords()), f.disconnect(), J[s.id] = !0, o(!0)) };["keydown", "click"].forEach(function (r) { addEventListener(r, v, { once: !0, capture: !0 }) }), E(v, !0), g(function (u) { o = S(r, s = P("LCP"), l, n.reportAllChanges), requestAnimationFrame(function () { requestAnimationFrame(function () { s.value = performance.now() - u.timeStamp, J[s.id] = !0, o(!0) }) }) }) } }, ee = function e(r) { document.prerendering ? addEventListener("prerenderingchange", function () { return e(r) }, !0) : "complete" !== document.readyState ? addEventListener("load", function () { return e(r) }, !0) : setTimeout(r, 0) }, et = function (r, n) { n = n || {}; var o = [800, 1800], l = P("TTFB"), u = S(r, l, o, n.reportAllChanges); ee(function () { var s = _(); if (s) { if (l.value = Math.max(s.responseStart - y(), 0), l.value < 0 || l.value > performance.now()) return; l.entries = [s], u(!0), g(function () { (u = S(r, l = P("TTFB", 0), o, n.reportAllChanges))(!0) }) } }) }, r.exports = o }, 15486: function (r, n) { "use strict"; function isAPIRoute(r) { return "/api" === r || !!(null == r ? void 0 : r.startsWith("/api/")) } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isAPIRoute", { enumerable: !0, get: function () { return isAPIRoute } }) }, 19032: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { default: function () { return isError }, getProperError: function () { return getProperError } }); let l = o(59109); function isError(r) { return "object" == typeof r && null !== r && "name" in r && "message" in r } function getProperError(r) { return isError(r) ? r : Error((0, l.isPlainObject)(r) ? JSON.stringify(r) : r + "") } }, 32275: function (r, n, o) { "use strict"; function getCookieParser(r) { return function () { let { cookie: n } = r; if (!n) return {}; let { parse: l } = o(24690); return l(Array.isArray(n) ? n.join("; ") : n) } } Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "getCookieParser", { enumerable: !0, get: function () { return getCookieParser } }) }, 69867: function (r, n, o) { "use strict"; Object.defineProperty(n, "__esModule", { value: !0 }), function (r, n) { for (var o in n) Object.defineProperty(r, o, { enumerable: !0, get: n[o] }) }(n, { INTERCEPTION_ROUTE_MARKERS: function () { return u }, isInterceptionRouteAppPath: function () { return isInterceptionRouteAppPath }, extractInterceptionRouteInformation: function () { return extractInterceptionRouteInformation } }); let l = o(62e3), u = ["(..)(..)", "(.)", "(..)", "(...)"]; function isInterceptionRouteAppPath(r) { return void 0 !== r.split("/").find(r => u.find(n => r.startsWith(n))) } function extractInterceptionRouteInformation(r) { let n, o, s; for (let l of r.split("/")) if (o = u.find(r => l.startsWith(r))) { [n, s] = r.split(o, 2); break } if (!n || !o || !s) throw Error(`Invalid interception route: ${r}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`); switch (n = (0, l.normalizeAppPath)(n), o) { case "(.)": s = "/" === n ? `/${s}` : n + "/" + s; break; case "(..)": if ("/" === n) throw Error(`Invalid interception route: ${r}. Cannot use (..) marker at the root level, use (.) instead.`); s = n.split("/").slice(0, -1).concat(s).join("/"); break; case "(...)": s = "/" + s; break; case "(..)(..)": let f = n.split("/"); if (f.length <= 2) throw Error(`Invalid interception route: ${r}. Cannot use (..)(..) marker at the root level or one level up.`); s = f.slice(0, -2).concat(s).join("/"); break; default: throw Error("Invariant: unexpected marker") }return { interceptingRoute: n, interceptedRoute: s } } }, 81351: function (r, n, o) { "use strict"; function _interop_require_default(r) { return r && r.__esModule ? r : { default: r } } o.r(n), o.d(n, { _: function () { return _interop_require_default }, _interop_require_default: function () { return _interop_require_default } }) }, 35815: function (r, n, o) { "use strict"; function _getRequireWildcardCache(r) { if ("function" != typeof WeakMap) return null; var n = new WeakMap, o = new WeakMap; return (_getRequireWildcardCache = function (r) { return r ? o : n })(r) } function _interop_require_wildcard(r, n) { if (!n && r && r.__esModule) return r; if (null === r || "object" != typeof r && "function" != typeof r) return { default: r }; var o = _getRequireWildcardCache(n); if (o && o.has(r)) return o.get(r); var l = {}, u = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var s in r) if ("default" !== s && Object.prototype.hasOwnProperty.call(r, s)) { var f = u ? Object.getOwnPropertyDescriptor(r, s) : null; f && (f.get || f.set) ? Object.defineProperty(l, s, f) : l[s] = r[s] } return l.default = r, o && o.set(r, l), l } o.r(n), o.d(n, { _: function () { return _interop_require_wildcard }, _interop_require_wildcard: function () { return _interop_require_wildcard } }) }
}, function (r) { r.O(0, [774], function () { return r(r.s = 22944) }), _N_E = r.O() }]);

!function () { var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function e(t) { var e = { exports: {} }; return t(e, e.exports), e.exports } var r = function (t) { return t && t.Math == Math && t }, n = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof t && t) || Function("return this")(), o = function (t) { try { return !!t() } catch (t) { return !0 } }, i = !o(function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] }), a = {}.propertyIsEnumerable, u = Object.getOwnPropertyDescriptor, s = u && !a.call({ 1: 2 }, 1) ? function (t) { var e = u(this, t); return !!e && e.enumerable } : a, c = { f: s }, f = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } }, l = {}.toString, h = function (t) { return l.call(t).slice(8, -1) }, p = "".split, d = o(function () { return !Object("z").propertyIsEnumerable(0) }) ? function (t) { return "String" == h(t) ? p.call(t, "") : Object(t) } : Object, v = function (t) { if (null == t) throw TypeError("Can't call method on " + t); return t }, g = function (t) { return d(v(t)) }, y = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t }, m = function (t, e) { if (!y(t)) return t; var r, n; if (e && "function" == typeof (r = t.toString) && !y(n = r.call(t))) return n; if ("function" == typeof (r = t.valueOf) && !y(n = r.call(t))) return n; if (!e && "function" == typeof (r = t.toString) && !y(n = r.call(t))) return n; throw TypeError("Can't convert object to primitive value") }, b = {}.hasOwnProperty, w = function (t, e) { return b.call(t, e) }, S = n.document, E = y(S) && y(S.createElement), x = function (t) { return E ? S.createElement(t) : {} }, A = !i && !o(function () { return 7 != Object.defineProperty(x("div"), "a", { get: function () { return 7 } }).a }), O = Object.getOwnPropertyDescriptor, R = { f: i ? O : function (t, e) { if (t = g(t), e = m(e, !0), A) try { return O(t, e) } catch (t) { } if (w(t, e)) return f(!c.f.call(t, e), t[e]) } }, j = function (t) { if (!y(t)) throw TypeError(String(t) + " is not an object"); return t }, P = Object.defineProperty, I = { f: i ? P : function (t, e, r) { if (j(t), e = m(e, !0), j(r), A) try { return P(t, e, r) } catch (t) { } if ("get" in r || "set" in r) throw TypeError("Accessors not supported"); return "value" in r && (t[e] = r.value), t } }, T = i ? function (t, e, r) { return I.f(t, e, f(1, r)) } : function (t, e, r) { return t[e] = r, t }, k = function (t, e) { try { T(n, t, e) } catch (r) { n[t] = e } return e }, L = "__core-js_shared__", U = n[L] || k(L, {}), M = Function.toString; "function" != typeof U.inspectSource && (U.inspectSource = function (t) { return M.call(t) }); var _, N, C, F = U.inspectSource, B = n.WeakMap, D = "function" == typeof B && /native code/.test(F(B)), q = !1, z = e(function (t) { (t.exports = function (t, e) { return U[t] || (U[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.6.5", mode: "global", copyright: " 2020 Denis Pushkarev (zloirock.ru)" }) }), W = 0, K = Math.random(), G = function (t) { return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++W + K).toString(36) }, $ = z("keys"), V = function (t) { return $[t] || ($[t] = G(t)) }, H = {}; if (D) { var X = new (0, n.WeakMap), Y = X.get, J = X.has, Q = X.set; _ = function (t, e) { return Q.call(X, t, e), e }, N = function (t) { return Y.call(X, t) || {} }, C = function (t) { return J.call(X, t) } } else { var Z = V("state"); H[Z] = !0, _ = function (t, e) { return T(t, Z, e), e }, N = function (t) { return w(t, Z) ? t[Z] : {} }, C = function (t) { return w(t, Z) } } var tt, et = { set: _, get: N, has: C, enforce: function (t) { return C(t) ? N(t) : _(t, {}) }, getterFor: function (t) { return function (e) { var r; if (!y(e) || (r = N(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required"); return r } } }, rt = e(function (t) { var e = et.get, r = et.enforce, o = String(String).split("String"); (t.exports = function (t, e, i, a) { var u = !!a && !!a.unsafe, s = !!a && !!a.enumerable, c = !!a && !!a.noTargetGet; "function" == typeof i && ("string" != typeof e || w(i, "name") || T(i, "name", e), r(i).source = o.join("string" == typeof e ? e : "")), t !== n ? (u ? !c && t[e] && (s = !0) : delete t[e], s ? t[e] = i : T(t, e, i)) : s ? t[e] = i : k(e, i) })(Function.prototype, "toString", function () { return "function" == typeof this && e(this).source || F(this) }) }), nt = n, ot = function (t) { return "function" == typeof t ? t : void 0 }, it = function (t, e) { return arguments.length < 2 ? ot(nt[t]) || ot(n[t]) : nt[t] && nt[t][e] || n[t] && n[t][e] }, at = Math.ceil, ut = Math.floor, st = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? ut : at)(t) }, ct = Math.min, ft = function (t) { return t > 0 ? ct(st(t), 9007199254740991) : 0 }, lt = Math.max, ht = Math.min, pt = function (t, e) { var r = st(t); return r < 0 ? lt(r + e, 0) : ht(r, e) }, dt = function (t) { return function (e, r, n) { var o, i = g(e), a = ft(i.length), u = pt(n, a); if (t && r != r) { for (; a > u;)if ((o = i[u++]) != o) return !0 } else for (; a > u; u++)if ((t || u in i) && i[u] === r) return t || u || 0; return !t && -1 } }, vt = { includes: dt(!0), indexOf: dt(!1) }, gt = vt.indexOf, yt = function (t, e) { var r, n = g(t), o = 0, i = []; for (r in n) !w(H, r) && w(n, r) && i.push(r); for (; e.length > o;)w(n, r = e[o++]) && (~gt(i, r) || i.push(r)); return i }, mt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], bt = mt.concat("length", "prototype"), wt = { f: Object.getOwnPropertyNames || function (t) { return yt(t, bt) } }, St = { f: Object.getOwnPropertySymbols }, Et = it("Reflect", "ownKeys") || function (t) { var e = wt.f(j(t)), r = St.f; return r ? e.concat(r(t)) : e }, xt = function (t, e) { for (var r = Et(e), n = I.f, o = R.f, i = 0; i < r.length; i++) { var a = r[i]; w(t, a) || n(t, a, o(e, a)) } }, At = /#|\.prototype\./, Ot = function (t, e) { var r = jt[Rt(t)]; return r == It || r != Pt && ("function" == typeof e ? o(e) : !!e) }, Rt = Ot.normalize = function (t) { return String(t).replace(At, ".").toLowerCase() }, jt = Ot.data = {}, Pt = Ot.NATIVE = "N", It = Ot.POLYFILL = "P", Tt = Ot, kt = R.f, Lt = function (t, e) { var r, o, i, a, u, s = t.target, c = t.global, f = t.stat; if (r = c ? n : f ? n[s] || k(s, {}) : (n[s] || {}).prototype) for (o in e) { if (a = e[o], i = t.noTargetGet ? (u = kt(r, o)) && u.value : r[o], !Tt(c ? o : s + (f ? "." : "#") + o, t.forced) && void 0 !== i) { if (typeof a == typeof i) continue; xt(a, i) } (t.sham || i && i.sham) && T(a, "sham", !0), rt(r, o, a, t) } }, Ut = function (t) { return Object(v(t)) }, Mt = Math.min, _t = [].copyWithin || function (t, e) { var r = Ut(this), n = ft(r.length), o = pt(t, n), i = pt(e, n), a = arguments.length > 2 ? arguments[2] : void 0, u = Mt((void 0 === a ? n : pt(a, n)) - i, n - o), s = 1; for (i < o && o < i + u && (s = -1, i += u - 1, o += u - 1); u-- > 0;)i in r ? r[o] = r[i] : delete r[o], o += s, i += s; return r }, Nt = !!Object.getOwnPropertySymbols && !o(function () { return !String(Symbol()) }), Ct = Nt && !Symbol.sham && "symbol" == typeof Symbol.iterator, Ft = z("wks"), Bt = n.Symbol, Dt = Ct ? Bt : Bt && Bt.withoutSetter || G, qt = function (t) { return w(Ft, t) || (Ft[t] = Nt && w(Bt, t) ? Bt[t] : Dt("Symbol." + t)), Ft[t] }, zt = Object.keys || function (t) { return yt(t, mt) }, Wt = i ? Object.defineProperties : function (t, e) { j(t); for (var r, n = zt(e), o = n.length, i = 0; o > i;)I.f(t, r = n[i++], e[r]); return t }, Kt = it("document", "documentElement"), Gt = V("IE_PROTO"), $t = function () { }, Vt = function (t) { return "<script>" + t + "<\/script>" }, Ht = function () { try { tt = document.domain && new ActiveXObject("htmlfile") } catch (t) { } var t, e; Ht = tt ? function (t) { t.write(Vt("")), t.close(); var e = t.parentWindow.Object; return t = null, e }(tt) : ((e = x("iframe")).style.display = "none", Kt.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(Vt("document.F=Object")), t.close(), t.F); for (var r = mt.length; r--;)delete Ht.prototype[mt[r]]; return Ht() }; H[Gt] = !0; var Xt = Object.create || function (t, e) { var r; return null !== t ? ($t.prototype = j(t), r = new $t, $t.prototype = null, r[Gt] = t) : r = Ht(), void 0 === e ? r : Wt(r, e) }, Yt = qt("unscopables"), Jt = Array.prototype; null == Jt[Yt] && I.f(Jt, Yt, { configurable: !0, value: Xt(null) }); var Qt = function (t) { Jt[Yt][t] = !0 }; Lt({ target: "Array", proto: !0 }, { copyWithin: _t }), Qt("copyWithin"); var Zt = function (t) { if ("function" != typeof t) throw TypeError(String(t) + " is not a function"); return t }, te = function (t, e, r) { if (Zt(t), void 0 === e) return t; switch (r) { case 0: return function () { return t.call(e) }; case 1: return function (r) { return t.call(e, r) }; case 2: return function (r, n) { return t.call(e, r, n) }; case 3: return function (r, n, o) { return t.call(e, r, n, o) } }return function () { return t.apply(e, arguments) } }, ee = Function.call, re = function (t, e, r) { return te(ee, n[t].prototype[e], r) }; re("Array", "copyWithin"), Lt({ target: "Array", proto: !0 }, { fill: function (t) { for (var e = Ut(this), r = ft(e.length), n = arguments.length, o = pt(n > 1 ? arguments[1] : void 0, r), i = n > 2 ? arguments[2] : void 0, a = void 0 === i ? r : pt(i, r); a > o;)e[o++] = t; return e } }), Qt("fill"), re("Array", "fill"); var ne = Array.isArray || function (t) { return "Array" == h(t) }, oe = qt("species"), ie = function (t, e) { var r; return ne(t) && ("function" != typeof (r = t.constructor) || r !== Array && !ne(r.prototype) ? y(r) && null === (r = r[oe]) && (r = void 0) : r = void 0), new (void 0 === r ? Array : r)(0 === e ? 0 : e) }, ae = [].push, ue = function (t) { var e = 1 == t, r = 2 == t, n = 3 == t, o = 4 == t, i = 6 == t, a = 5 == t || i; return function (u, s, c, f) { for (var l, h, p = Ut(u), v = d(p), g = te(s, c, 3), y = ft(v.length), m = 0, b = f || ie, w = e ? b(u, y) : r ? b(u, 0) : void 0; y > m; m++)if ((a || m in v) && (h = g(l = v[m], m, p), t)) if (e) w[m] = h; else if (h) switch (t) { case 3: return !0; case 5: return l; case 6: return m; case 2: ae.call(w, l) } else if (o) return !1; return i ? -1 : n || o ? o : w } }, se = { forEach: ue(0), map: ue(1), filter: ue(2), some: ue(3), every: ue(4), find: ue(5), findIndex: ue(6) }, ce = Object.defineProperty, fe = {}, le = function (t) { throw t }, he = function (t, e) { if (w(fe, t)) return fe[t]; e || (e = {}); var r = [][t], n = !!w(e, "ACCESSORS") && e.ACCESSORS, a = w(e, 0) ? e[0] : le, u = w(e, 1) ? e[1] : void 0; return fe[t] = !!r && !o(function () { if (n && !i) return !0; var t = { length: -1 }; n ? ce(t, 1, { enumerable: !0, get: le }) : t[1] = 1, r.call(t, a, u) }) }, pe = se.find, de = "find", ve = !0, ge = he(de); de in [] && Array(1).find(function () { ve = !1 }), Lt({ target: "Array", proto: !0, forced: ve || !ge }, { find: function (t) { return pe(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), Qt(de), re("Array", "find"); var ye = se.findIndex, me = "findIndex", be = !0, we = he(me); me in [] && Array(1).findIndex(function () { be = !1 }), Lt({ target: "Array", proto: !0, forced: be || !we }, { findIndex: function (t) { return ye(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), Qt(me), re("Array", "findIndex"); var Se = function (t, e, r, n, o, i, a, u) { for (var s, c = o, f = 0, l = !!a && te(a, u, 3); f < n;) { if (f in r) { if (s = l ? l(r[f], f, e) : r[f], i > 0 && ne(s)) c = Se(t, e, s, ft(s.length), c, i - 1) - 1; else { if (c >= 9007199254740991) throw TypeError("Exceed the acceptable array length"); t[c] = s } c++ } f++ } return c }, Ee = Se; Lt({ target: "Array", proto: !0 }, { flatMap: function (t) { var e, r = Ut(this), n = ft(r.length); return Zt(t), (e = ie(r, 0)).length = Ee(e, r, r, n, 0, 1, t, arguments.length > 1 ? arguments[1] : void 0), e } }), Qt("flatMap"), re("Array", "flatMap"), Lt({ target: "Array", proto: !0 }, { flat: function () { var t = arguments.length ? arguments[0] : void 0, e = Ut(this), r = ft(e.length), n = ie(e, 0); return n.length = Ee(n, e, e, r, 0, void 0 === t ? 1 : st(t)), n } }), Qt("flat"), re("Array", "flat"); var xe, Ae, Oe, Re = function (t) { return function (e, r) { var n, o, i = String(v(e)), a = st(r), u = i.length; return a < 0 || a >= u ? t ? "" : void 0 : (n = i.charCodeAt(a)) < 55296 || n > 56319 || a + 1 === u || (o = i.charCodeAt(a + 1)) < 56320 || o > 57343 ? t ? i.charAt(a) : n : t ? i.slice(a, a + 2) : o - 56320 + (n - 55296 << 10) + 65536 } }, je = { codeAt: Re(!1), charAt: Re(!0) }, Pe = !o(function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype }), Ie = V("IE_PROTO"), Te = Object.prototype, ke = Pe ? Object.getPrototypeOf : function (t) { return t = Ut(t), w(t, Ie) ? t[Ie] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? Te : null }, Le = qt("iterator"), Ue = !1;[].keys && ("next" in (Oe = [].keys()) ? (Ae = ke(ke(Oe))) !== Object.prototype && (xe = Ae) : Ue = !0), null == xe && (xe = {}), w(xe, Le) || T(xe, Le, function () { return this }); var Me = { IteratorPrototype: xe, BUGGY_SAFARI_ITERATORS: Ue }, _e = I.f, Ne = qt("toStringTag"), Ce = function (t, e, r) { t && !w(t = r ? t : t.prototype, Ne) && _e(t, Ne, { configurable: !0, value: e }) }, Fe = {}, Be = Me.IteratorPrototype, De = function () { return this }, qe = function (t, e, r) { var n = e + " Iterator"; return t.prototype = Xt(Be, { next: f(1, r) }), Ce(t, n, !1), Fe[n] = De, t }, ze = function (t) { if (!y(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype"); return t }, We = Object.setPrototypeOf || ("__proto__" in {} ? function () { var t, e = !1, r = {}; try { (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r, []), e = r instanceof Array } catch (t) { } return function (r, n) { return j(r), ze(n), e ? t.call(r, n) : r.__proto__ = n, r } }() : void 0), Ke = Me.IteratorPrototype, Ge = Me.BUGGY_SAFARI_ITERATORS, $e = qt("iterator"), Ve = "keys", He = "values", Xe = "entries", Ye = function () { return this }, Je = function (t, e, r, n, o, i, a) { qe(r, e, n); var u, s, c, f = function (t) { if (t === o && v) return v; if (!Ge && t in p) return p[t]; switch (t) { case Ve: case He: case Xe: return function () { return new r(this, t) } }return function () { return new r(this) } }, l = e + " Iterator", h = !1, p = t.prototype, d = p[$e] || p["@@iterator"] || o && p[o], v = !Ge && d || f(o), g = "Array" == e && p.entries || d; if (g && (u = ke(g.call(new t)), Ke !== Object.prototype && u.next && (ke(u) !== Ke && (We ? We(u, Ke) : "function" != typeof u[$e] && T(u, $e, Ye)), Ce(u, l, !0))), o == He && d && d.name !== He && (h = !0, v = function () { return d.call(this) }), p[$e] !== v && T(p, $e, v), Fe[e] = v, o) if (s = { values: f(He), keys: i ? v : f(Ve), entries: f(Xe) }, a) for (c in s) (Ge || h || !(c in p)) && rt(p, c, s[c]); else Lt({ target: e, proto: !0, forced: Ge || h }, s); return s }, Qe = je.charAt, Ze = "String Iterator", tr = et.set, er = et.getterFor(Ze); Je(String, "String", function (t) { tr(this, { type: Ze, string: String(t), index: 0 }) }, function () { var t, e = er(this), r = e.string, n = e.index; return n >= r.length ? { value: void 0, done: !0 } : (t = Qe(r, n), e.index += t.length, { value: t, done: !1 }) }); var rr = function (t, e, r, n) { try { return n ? e(j(r)[0], r[1]) : e(r) } catch (e) { var o = t.return; throw void 0 !== o && j(o.call(t)), e } }, nr = qt("iterator"), or = Array.prototype, ir = function (t) { return void 0 !== t && (Fe.Array === t || or[nr] === t) }, ar = function (t, e, r) { var n = m(e); n in t ? I.f(t, n, f(0, r)) : t[n] = r }, ur = {}; ur[qt("toStringTag")] = "z"; var sr = "[object z]" === String(ur), cr = qt("toStringTag"), fr = "Arguments" == h(function () { return arguments }()), lr = sr ? h : function (t) { var e, r, n; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = function (t, e) { try { return t[e] } catch (t) { } }(e = Object(t), cr)) ? r : fr ? h(e) : "Object" == (n = h(e)) && "function" == typeof e.callee ? "Arguments" : n }, hr = qt("iterator"), pr = function (t) { if (null != t) return t[hr] || t["@@iterator"] || Fe[lr(t)] }, dr = function (t) { var e, r, n, o, i, a, u = Ut(t), s = "function" == typeof this ? this : Array, c = arguments.length, f = c > 1 ? arguments[1] : void 0, l = void 0 !== f, h = pr(u), p = 0; if (l && (f = te(f, c > 2 ? arguments[2] : void 0, 2)), null == h || s == Array && ir(h)) for (r = new s(e = ft(u.length)); e > p; p++)a = l ? f(u[p], p) : u[p], ar(r, p, a); else for (i = (o = h.call(u)).next, r = new s; !(n = i.call(o)).done; p++)a = l ? rr(o, f, [n.value, p], !0) : n.value, ar(r, p, a); return r.length = p, r }, vr = qt("iterator"), gr = !1; try { var yr = 0, mr = { next: function () { return { done: !!yr++ } }, return: function () { gr = !0 } }; mr[vr] = function () { return this }, Array.from(mr, function () { throw 2 }) } catch (t) { } var br = function (t, e) { if (!e && !gr) return !1; var r = !1; try { var n = {}; n[vr] = function () { return { next: function () { return { done: r = !0 } } } }, t(n) } catch (t) { } return r }, wr = !br(function (t) { Array.from(t) }); Lt({ target: "Array", stat: !0, forced: wr }, { from: dr }); var Sr = vt.includes, Er = he("indexOf", { ACCESSORS: !0, 1: 0 }); Lt({ target: "Array", proto: !0, forced: !Er }, { includes: function (t) { return Sr(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), Qt("includes"), re("Array", "includes"); var xr = "Array Iterator", Ar = et.set, Or = et.getterFor(xr), Rr = Je(Array, "Array", function (t, e) { Ar(this, { type: xr, target: g(t), index: 0, kind: e }) }, function () { var t = Or(this), e = t.target, r = t.kind, n = t.index++; return !e || n >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : "keys" == r ? { value: n, done: !1 } : "values" == r ? { value: e[n], done: !1 } : { value: [n, e[n]], done: !1 } }, "values"); Fe.Arguments = Fe.Array, Qt("keys"), Qt("values"), Qt("entries"), re("Array", "values"); var jr = o(function () { function t() { } return !(Array.of.call(t) instanceof t) }); Lt({ target: "Array", stat: !0, forced: jr }, { of: function () { for (var t = 0, e = arguments.length, r = new ("function" == typeof this ? this : Array)(e); e > t;)ar(r, t, arguments[t++]); return r.length = e, r } }); var Pr = qt("hasInstance"), Ir = Function.prototype; Pr in Ir || I.f(Ir, Pr, { value: function (t) { if ("function" != typeof this || !y(t)) return !1; if (!y(this.prototype)) return t instanceof this; for (; t = ke(t);)if (this.prototype === t) return !0; return !1 } }), qt("hasInstance"); var Tr = Function.prototype, kr = Tr.toString, Lr = /^\s*function ([^ (]*)/, Ur = "name"; i && !(Ur in Tr) && (0, I.f)(Tr, Ur, { configurable: !0, get: function () { try { return kr.call(this).match(Lr)[1] } catch (t) { return "" } } }); var Mr = !o(function () { return Object.isExtensible(Object.preventExtensions({})) }), _r = e(function (t) { var e = I.f, r = G("meta"), n = 0, o = Object.isExtensible || function () { return !0 }, i = function (t) { e(t, r, { value: { objectID: "O" + ++n, weakData: {} } }) }, a = t.exports = { REQUIRED: !1, fastKey: function (t, e) { if (!y(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t; if (!w(t, r)) { if (!o(t)) return "F"; if (!e) return "E"; i(t) } return t[r].objectID }, getWeakData: function (t, e) { if (!w(t, r)) { if (!o(t)) return !0; if (!e) return !1; i(t) } return t[r].weakData }, onFreeze: function (t) { return Mr && a.REQUIRED && o(t) && !w(t, r) && i(t), t } }; H[r] = !0 }), Nr = e(function (t) { var e = function (t, e) { this.stopped = t, this.result = e }, r = t.exports = function (t, r, n, o, i) { var a, u, s, c, f, l, h, p = te(r, n, o ? 2 : 1); if (i) a = t; else { if ("function" != typeof (u = pr(t))) throw TypeError("Target is not iterable"); if (ir(u)) { for (s = 0, c = ft(t.length); c > s; s++)if ((f = o ? p(j(h = t[s])[0], h[1]) : p(t[s])) && f instanceof e) return f; return new e(!1) } a = u.call(t) } for (l = a.next; !(h = l.call(a)).done;)if ("object" == typeof (f = rr(a, p, h.value, o)) && f && f instanceof e) return f; return new e(!1) }; r.stop = function (t) { return new e(!0, t) } }), Cr = function (t, e, r) { if (!(t instanceof e)) throw TypeError("Incorrect " + (r ? r + " " : "") + "invocation"); return t }, Fr = function (t, e, r) { var n, o; return We && "function" == typeof (n = e.constructor) && n !== r && y(o = n.prototype) && o !== r.prototype && We(t, o), t }, Br = function (t, e, r) { var i = -1 !== t.indexOf("Map"), a = -1 !== t.indexOf("Weak"), u = i ? "set" : "add", s = n[t], c = s && s.prototype, f = s, l = {}, h = function (t) { var e = c[t]; rt(c, t, "add" == t ? function (t) { return e.call(this, 0 === t ? 0 : t), this } : "delete" == t ? function (t) { return !(a && !y(t)) && e.call(this, 0 === t ? 0 : t) } : "get" == t ? function (t) { return a && !y(t) ? void 0 : e.call(this, 0 === t ? 0 : t) } : "has" == t ? function (t) { return !(a && !y(t)) && e.call(this, 0 === t ? 0 : t) } : function (t, r) { return e.call(this, 0 === t ? 0 : t, r), this }) }; if (Tt(t, "function" != typeof s || !(a || c.forEach && !o(function () { (new s).entries().next() })))) f = r.getConstructor(e, t, i, u), _r.REQUIRED = !0; else if (Tt(t, !0)) { var p = new f, d = p[u](a ? {} : -0, 1) != p, v = o(function () { p.has(1) }), g = br(function (t) { new s(t) }), m = !a && o(function () { for (var t = new s, e = 5; e--;)t[u](e, e); return !t.has(-0) }); g || ((f = e(function (e, r) { Cr(e, f, t); var n = Fr(new s, e, f); return null != r && Nr(r, n[u], n, i), n })).prototype = c, c.constructor = f), (v || m) && (h("delete"), h("has"), i && h("get")), (m || d) && h(u), a && c.clear && delete c.clear } return l[t] = f, Lt({ global: !0, forced: f != s }, l), Ce(f, t), a || r.setStrong(f, t, i), f }, Dr = function (t, e, r) { for (var n in e) rt(t, n, e[n], r); return t }, qr = qt("species"), zr = function (t) { var e = it(t); i && e && !e[qr] && (0, I.f)(e, qr, { configurable: !0, get: function () { return this } }) }, Wr = I.f, Kr = _r.fastKey, Gr = et.set, $r = et.getterFor, Vr = { getConstructor: function (t, e, r, n) { var o = t(function (t, a) { Cr(t, o, e), Gr(t, { type: e, index: Xt(null), first: void 0, last: void 0, size: 0 }), i || (t.size = 0), null != a && Nr(a, t[n], t, r) }), a = $r(e), u = function (t, e, r) { var n, o, u = a(t), c = s(t, e); return c ? c.value = r : (u.last = c = { index: o = Kr(e, !0), key: e, value: r, previous: n = u.last, next: void 0, removed: !1 }, u.first || (u.first = c), n && (n.next = c), i ? u.size++ : t.size++, "F" !== o && (u.index[o] = c)), t }, s = function (t, e) { var r, n = a(t), o = Kr(e); if ("F" !== o) return n.index[o]; for (r = n.first; r; r = r.next)if (r.key == e) return r }; return Dr(o.prototype, { clear: function () { for (var t = a(this), e = t.index, r = t.first; r;)r.removed = !0, r.previous && (r.previous = r.previous.next = void 0), delete e[r.index], r = r.next; t.first = t.last = void 0, i ? t.size = 0 : this.size = 0 }, delete: function (t) { var e = this, r = a(e), n = s(e, t); if (n) { var o = n.next, u = n.previous; delete r.index[n.index], n.removed = !0, u && (u.next = o), o && (o.previous = u), r.first == n && (r.first = o), r.last == n && (r.last = u), i ? r.size-- : e.size-- } return !!n }, forEach: function (t) { for (var e, r = a(this), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : r.first;)for (n(e.value, e.key, this); e && e.removed;)e = e.previous }, has: function (t) { return !!s(this, t) } }), Dr(o.prototype, r ? { get: function (t) { var e = s(this, t); return e && e.value }, set: function (t, e) { return u(this, 0 === t ? 0 : t, e) } } : { add: function (t) { return u(this, t = 0 === t ? 0 : t, t) } }), i && Wr(o.prototype, "size", { get: function () { return a(this).size } }), o }, setStrong: function (t, e, r) { var n = e + " Iterator", o = $r(e), i = $r(n); Je(t, e, function (t, e) { Gr(this, { type: n, target: t, state: o(t), kind: e, last: void 0 }) }, function () { for (var t = i(this), e = t.kind, r = t.last; r && r.removed;)r = r.previous; return t.target && (t.last = r = r ? r.next : t.state.first) ? "keys" == e ? { value: r.key, done: !1 } : "values" == e ? { value: r.value, done: !1 } : { value: [r.key, r.value], done: !1 } : (t.target = void 0, { value: void 0, done: !0 }) }, r ? "entries" : "values", !r, !0), zr(e) } }, Hr = Br("Map", function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }, Vr); sr || rt(Object.prototype, "toString", sr ? {}.toString : function () { return "[object " + lr(this) + "]" }, { unsafe: !0 }); var Xr = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Yr = qt("iterator"), Jr = qt("toStringTag"), Qr = Rr.values; for (var Zr in Xr) { var tn = n[Zr], en = tn && tn.prototype; if (en) { if (en[Yr] !== Qr) try { T(en, Yr, Qr) } catch (t) { en[Yr] = Qr } if (en[Jr] || T(en, Jr, Zr), Xr[Zr]) for (var rn in Rr) if (en[rn] !== Rr[rn]) try { T(en, rn, Rr[rn]) } catch (t) { en[rn] = Rr[rn] } } } var nn = function (t) { var e, r, n, o, i = arguments.length, a = i > 1 ? arguments[1] : void 0; return Zt(this), (e = void 0 !== a) && Zt(a), null == t ? new this : (r = [], e ? (n = 0, o = te(a, i > 2 ? arguments[2] : void 0, 2), Nr(t, function (t) { r.push(o(t, n++)) })) : Nr(t, r.push, r), new this(r)) }; Lt({ target: "Map", stat: !0 }, { from: nn }); var on = function () { for (var t = arguments.length, e = new Array(t); t--;)e[t] = arguments[t]; return new this(e) }; Lt({ target: "Map", stat: !0 }, { of: on }); var an = function () { for (var t, e = j(this), r = Zt(e.delete), n = !0, o = 0, i = arguments.length; o < i; o++)t = r.call(e, arguments[o]), n = n && t; return !!n }; Lt({ target: "Map", proto: !0, real: !0, forced: q }, { deleteAll: function () { return an.apply(this, arguments) } }); var un = function (t) { var e = pr(t); if ("function" != typeof e) throw TypeError(String(t) + " is not iterable"); return j(e.call(t)) }, sn = function (t) { return Map.prototype.entries.call(t) }; Lt({ target: "Map", proto: !0, real: !0, forced: q }, { every: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return !Nr(r, function (t, r) { if (!n(r, t, e)) return Nr.stop() }, void 0, !0, !0).stopped } }); var cn = qt("species"), fn = function (t, e) { var r, n = j(t).constructor; return void 0 === n || null == (r = j(n)[cn]) ? e : Zt(r) }; Lt({ target: "Map", proto: !0, real: !0, forced: q }, { filter: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = new (fn(e, it("Map"))), i = Zt(o.set); return Nr(r, function (t, r) { n(r, t, e) && i.call(o, t, r) }, void 0, !0, !0), o } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { find: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return Nr(r, function (t, r) { if (n(r, t, e)) return Nr.stop(r) }, void 0, !0, !0).result } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { findKey: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return Nr(r, function (t, r) { if (n(r, t, e)) return Nr.stop(t) }, void 0, !0, !0).result } }), Lt({ target: "Map", stat: !0 }, { groupBy: function (t, e) { var r = new this; Zt(e); var n = Zt(r.has), o = Zt(r.get), i = Zt(r.set); return Nr(t, function (t) { var a = e(t); n.call(r, a) ? o.call(r, a).push(t) : i.call(r, a, [t]) }), r } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { includes: function (t) { return Nr(sn(j(this)), function (e, r) { if ((n = r) === (o = t) || n != n && o != o) return Nr.stop(); var n, o }, void 0, !0, !0).stopped } }), Lt({ target: "Map", stat: !0 }, { keyBy: function (t, e) { var r = new this; Zt(e); var n = Zt(r.set); return Nr(t, function (t) { n.call(r, e(t), t) }), r } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { keyOf: function (t) { return Nr(sn(j(this)), function (e, r) { if (r === t) return Nr.stop(e) }, void 0, !0, !0).result } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { mapKeys: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = new (fn(e, it("Map"))), i = Zt(o.set); return Nr(r, function (t, r) { i.call(o, n(r, t, e), r) }, void 0, !0, !0), o } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { mapValues: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = new (fn(e, it("Map"))), i = Zt(o.set); return Nr(r, function (t, r) { i.call(o, t, n(r, t, e)) }, void 0, !0, !0), o } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { merge: function (t) { for (var e = j(this), r = Zt(e.set), n = 0; n < arguments.length;)Nr(arguments[n++], r, e, !0); return e } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { reduce: function (t) { var e = j(this), r = sn(e), n = arguments.length < 2, o = n ? void 0 : arguments[1]; if (Zt(t), Nr(r, function (r, i) { n ? (n = !1, o = i) : o = t(o, i, r, e) }, void 0, !0, !0), n) throw TypeError("Reduce of empty map with no initial value"); return o } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { some: function (t) { var e = j(this), r = sn(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return Nr(r, function (t, r) { if (n(r, t, e)) return Nr.stop() }, void 0, !0, !0).stopped } }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { update: function (t, e) { var r = j(this), n = arguments.length; Zt(e); var o = r.has(t); if (!o && n < 3) throw TypeError("Updating absent value"); var i = o ? r.get(t) : Zt(n > 2 ? arguments[2] : void 0)(t, r); return r.set(t, e(i, t, r)), r } }); var ln = function (t, e) { var r, n = j(this), o = arguments.length > 2 ? arguments[2] : void 0; if ("function" != typeof e && "function" != typeof o) throw TypeError("At least one callback required"); return n.has(t) ? (r = n.get(t), "function" == typeof e && (r = e(r), n.set(t, r))) : "function" == typeof o && (r = o(), n.set(t, r)), r }; Lt({ target: "Map", proto: !0, real: !0, forced: q }, { upsert: ln }), Lt({ target: "Map", proto: !0, real: !0, forced: q }, { updateOrInsert: ln }); var hn = "\t\n\v\f\r \u2028\u2029\ufeff", pn = "[" + hn + "]", dn = RegExp("^" + pn + pn + "*"), vn = RegExp(pn + pn + "*$"), gn = function (t) { return function (e) { var r = String(v(e)); return 1 & t && (r = r.replace(dn, "")), 2 & t && (r = r.replace(vn, "")), r } }, yn = { start: gn(1), end: gn(2), trim: gn(3) }, mn = wt.f, bn = R.f, wn = I.f, Sn = yn.trim, En = "Number", xn = n.Number, An = xn.prototype, On = h(Xt(An)) == En, Rn = function (t) { var e, r, n, o, i, a, u, s, c = m(t, !1); if ("string" == typeof c && c.length > 2) if (43 === (e = (c = Sn(c)).charCodeAt(0)) || 45 === e) { if (88 === (r = c.charCodeAt(2)) || 120 === r) return NaN } else if (48 === e) { switch (c.charCodeAt(1)) { case 66: case 98: n = 2, o = 49; break; case 79: case 111: n = 8, o = 55; break; default: return +c }for (a = (i = c.slice(2)).length, u = 0; u < a; u++)if ((s = i.charCodeAt(u)) < 48 || s > o) return NaN; return parseInt(i, n) } return +c }; if (Tt(En, !xn(" 0o1") || !xn("0b1") || xn("+0x1"))) { for (var jn, Pn = function (t) { var e = arguments.length < 1 ? 0 : t, r = this; return r instanceof Pn && (On ? o(function () { An.valueOf.call(r) }) : h(r) != En) ? Fr(new xn(Rn(e)), r, Pn) : Rn(e) }, In = i ? mn(xn) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), Tn = 0; In.length > Tn; Tn++)w(xn, jn = In[Tn]) && !w(Pn, jn) && wn(Pn, jn, bn(xn, jn)); Pn.prototype = An, An.constructor = Pn, rt(n, En, Pn) } Lt({ target: "Number", stat: !0 }, { EPSILON: Math.pow(2, -52) }); var kn = n.isFinite; Lt({ target: "Number", stat: !0 }, { isFinite: Number.isFinite || function (t) { return "number" == typeof t && kn(t) } }); var Ln = Math.floor, Un = function (t) { return !y(t) && isFinite(t) && Ln(t) === t }; Lt({ target: "Number", stat: !0 }, { isInteger: Un }), Lt({ target: "Number", stat: !0 }, { isNaN: function (t) { return t != t } }); var Mn = Math.abs; Lt({ target: "Number", stat: !0 }, { isSafeInteger: function (t) { return Un(t) && Mn(t) <= 9007199254740991 } }), Lt({ target: "Number", stat: !0 }, { MAX_SAFE_INTEGER: 9007199254740991 }), Lt({ target: "Number", stat: !0 }, { MIN_SAFE_INTEGER: -9007199254740991 }); var _n = yn.trim, Nn = n.parseFloat, Cn = 1 / Nn(hn + "-0") != -Infinity ? function (t) { var e = _n(String(t)), r = Nn(e); return 0 === r && "-" == e.charAt(0) ? -0 : r } : Nn; Lt({ target: "Number", stat: !0, forced: Number.parseFloat != Cn }, { parseFloat: Cn }); var Fn = yn.trim, Bn = n.parseInt, Dn = /^[+-]?0[Xx]/, qn = 8 !== Bn(hn + "08") || 22 !== Bn(hn + "0x16") ? function (t, e) { var r = Fn(String(t)); return Bn(r, e >>> 0 || (Dn.test(r) ? 16 : 10)) } : Bn; Lt({ target: "Number", stat: !0, forced: Number.parseInt != qn }, { parseInt: qn }); var zn = c.f, Wn = function (t) { return function (e) { for (var r, n = g(e), o = zt(n), a = o.length, u = 0, s = []; a > u;)r = o[u++], i && !zn.call(n, r) || s.push(t ? [r, n[r]] : n[r]); return s } }, Kn = { entries: Wn(!0), values: Wn(!1) }, Gn = Kn.entries; Lt({ target: "Object", stat: !0 }, { entries: function (t) { return Gn(t) } }), Lt({ target: "Object", stat: !0, sham: !i }, { getOwnPropertyDescriptors: function (t) { for (var e, r, n = g(t), o = R.f, i = Et(n), a = {}, u = 0; i.length > u;)void 0 !== (r = o(n, e = i[u++])) && ar(a, e, r); return a } }); var $n = o(function () { zt(1) }); Lt({ target: "Object", stat: !0, forced: $n }, { keys: function (t) { return zt(Ut(t)) } }); var Vn = Object.is || function (t, e) { return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e }; Lt({ target: "Object", stat: !0 }, { is: Vn }); var Hn = Kn.values; Lt({ target: "Object", stat: !0 }, { values: function (t) { return Hn(t) } }); var Xn = it("Reflect", "apply"), Yn = Function.apply, Jn = !o(function () { Xn(function () { }) }); Lt({ target: "Reflect", stat: !0, forced: Jn }, { apply: function (t, e, r) { return Zt(t), j(r), Xn ? Xn(t, e, r) : Yn.call(t, e, r) } }); var Qn = [].slice, Zn = {}, to = function (t, e, r) { if (!(e in Zn)) { for (var n = [], o = 0; o < e; o++)n[o] = "a[" + o + "]"; Zn[e] = Function("C,a", "return new C(" + n.join(",") + ")") } return Zn[e](t, r) }, eo = Function.bind || function (t) { var e = Zt(this), r = Qn.call(arguments, 1), n = function () { var o = r.concat(Qn.call(arguments)); return this instanceof n ? to(e, o.length, o) : e.apply(t, o) }; return y(e.prototype) && (n.prototype = e.prototype), n }, ro = it("Reflect", "construct"), no = o(function () { function t() { } return !(ro(function () { }, [], t) instanceof t) }), oo = !o(function () { ro(function () { }) }), io = no || oo; Lt({ target: "Reflect", stat: !0, forced: io, sham: io }, { construct: function (t, e) { Zt(t), j(e); var r = arguments.length < 3 ? t : Zt(arguments[2]); if (oo && !no) return ro(t, e, r); if (t == r) { switch (e.length) { case 0: return new t; case 1: return new t(e[0]); case 2: return new t(e[0], e[1]); case 3: return new t(e[0], e[1], e[2]); case 4: return new t(e[0], e[1], e[2], e[3]) }var n = [null]; return n.push.apply(n, e), new (eo.apply(t, n)) } var o = r.prototype, i = Xt(y(o) ? o : Object.prototype), a = Function.apply.call(t, i, e); return y(a) ? a : i } }); var ao = o(function () { Reflect.defineProperty(I.f({}, 1, { value: 1 }), 1, { value: 2 }) }); Lt({ target: "Reflect", stat: !0, forced: ao, sham: !i }, { defineProperty: function (t, e, r) { j(t); var n = m(e, !0); j(r); try { return I.f(t, n, r), !0 } catch (t) { return !1 } } }); var uo = R.f; Lt({ target: "Reflect", stat: !0 }, { deleteProperty: function (t, e) { var r = uo(j(t), e); return !(r && !r.configurable) && delete t[e] } }), Lt({ target: "Reflect", stat: !0 }, { get: function t(e, r) { var n, o, i = arguments.length < 3 ? e : arguments[2]; return j(e) === i ? e[r] : (n = R.f(e, r)) ? w(n, "value") ? n.value : void 0 === n.get ? void 0 : n.get.call(i) : y(o = ke(e)) ? t(o, r, i) : void 0 } }), Lt({ target: "Reflect", stat: !0, sham: !i }, { getOwnPropertyDescriptor: function (t, e) { return R.f(j(t), e) } }), Lt({ target: "Reflect", stat: !0, sham: !Pe }, { getPrototypeOf: function (t) { return ke(j(t)) } }), Lt({ target: "Reflect", stat: !0 }, { has: function (t, e) { return e in t } }); var so = Object.isExtensible; Lt({ target: "Reflect", stat: !0 }, { isExtensible: function (t) { return j(t), !so || so(t) } }), Lt({ target: "Reflect", stat: !0 }, { ownKeys: Et }), Lt({ target: "Reflect", stat: !0, sham: !Mr }, { preventExtensions: function (t) { j(t); try { var e = it("Object", "preventExtensions"); return e && e(t), !0 } catch (t) { return !1 } } }); var co = o(function () { var t = I.f({}, "a", { configurable: !0 }); return !1 !== Reflect.set(ke(t), "a", 1, t) }); Lt({ target: "Reflect", stat: !0, forced: co }, { set: function t(e, r, n) { var o, i, a = arguments.length < 4 ? e : arguments[3], u = R.f(j(e), r); if (!u) { if (y(i = ke(e))) return t(i, r, n, a); u = f(0) } if (w(u, "value")) { if (!1 === u.writable || !y(a)) return !1; if (o = R.f(a, r)) { if (o.get || o.set || !1 === o.writable) return !1; o.value = n, I.f(a, r, o) } else I.f(a, r, f(0, n)); return !0 } return void 0 !== u.set && (u.set.call(a, n), !0) } }), We && Lt({ target: "Reflect", stat: !0 }, { setPrototypeOf: function (t, e) { j(t), ze(e); try { return We(t, e), !0 } catch (t) { return !1 } } }); var fo = _r.getWeakData, lo = et.set, ho = et.getterFor, po = se.find, vo = se.findIndex, go = 0, yo = function (t) { return t.frozen || (t.frozen = new mo) }, mo = function () { this.entries = [] }, bo = function (t, e) { return po(t.entries, function (t) { return t[0] === e }) }; mo.prototype = { get: function (t) { var e = bo(this, t); if (e) return e[1] }, has: function (t) { return !!bo(this, t) }, set: function (t, e) { var r = bo(this, t); r ? r[1] = e : this.entries.push([t, e]) }, delete: function (t) { var e = vo(this.entries, function (e) { return e[0] === t }); return ~e && this.entries.splice(e, 1), !!~e } }; var wo = { getConstructor: function (t, e, r, n) { var o = t(function (t, i) { Cr(t, o, e), lo(t, { type: e, id: go++, frozen: void 0 }), null != i && Nr(i, t[n], t, r) }), i = ho(e), a = function (t, e, r) { var n = i(t), o = fo(j(e), !0); return !0 === o ? yo(n).set(e, r) : o[n.id] = r, t }; return Dr(o.prototype, { delete: function (t) { var e = i(this); if (!y(t)) return !1; var r = fo(t); return !0 === r ? yo(e).delete(t) : r && w(r, e.id) && delete r[e.id] }, has: function (t) { var e = i(this); if (!y(t)) return !1; var r = fo(t); return !0 === r ? yo(e).has(t) : r && w(r, e.id) } }), Dr(o.prototype, r ? { get: function (t) { var e = i(this); if (y(t)) { var r = fo(t); return !0 === r ? yo(e).get(t) : r ? r[e.id] : void 0 } }, set: function (t, e) { return a(this, t, e) } } : { add: function (t) { return a(this, t, !0) } }), o } }, So = e(function (t) { var e, r = et.enforce, o = !n.ActiveXObject && "ActiveXObject" in n, i = Object.isExtensible, a = function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }, u = t.exports = Br("WeakMap", a, wo); if (D && o) { e = wo.getConstructor(a, "WeakMap", !0), _r.REQUIRED = !0; var s = u.prototype, c = s.delete, f = s.has, l = s.get, h = s.set; Dr(s, { delete: function (t) { if (y(t) && !i(t)) { var n = r(this); return n.frozen || (n.frozen = new e), c.call(this, t) || n.frozen.delete(t) } return c.call(this, t) }, has: function (t) { if (y(t) && !i(t)) { var n = r(this); return n.frozen || (n.frozen = new e), f.call(this, t) || n.frozen.has(t) } return f.call(this, t) }, get: function (t) { if (y(t) && !i(t)) { var n = r(this); return n.frozen || (n.frozen = new e), f.call(this, t) ? l.call(this, t) : n.frozen.get(t) } return l.call(this, t) }, set: function (t, n) { if (y(t) && !i(t)) { var o = r(this); o.frozen || (o.frozen = new e), f.call(this, t) ? h.call(this, t, n) : o.frozen.set(t, n) } else h.call(this, t, n); return this } }) } }), Eo = z("metadata"), xo = Eo.store || (Eo.store = new So), Ao = function (t, e, r) { var n = xo.get(t); if (!n) { if (!r) return; xo.set(t, n = new Hr) } var o = n.get(e); if (!o) { if (!r) return; n.set(e, o = new Hr) } return o }, Oo = { store: xo, getMap: Ao, has: function (t, e, r) { var n = Ao(e, r, !1); return void 0 !== n && n.has(t) }, get: function (t, e, r) { var n = Ao(e, r, !1); return void 0 === n ? void 0 : n.get(t) }, set: function (t, e, r, n) { Ao(r, n, !0).set(t, e) }, keys: function (t, e) { var r = Ao(t, e, !1), n = []; return r && r.forEach(function (t, e) { n.push(e) }), n }, toKey: function (t) { return void 0 === t || "symbol" == typeof t ? t : String(t) } }, Ro = Oo.toKey, jo = Oo.set; Lt({ target: "Reflect", stat: !0 }, { defineMetadata: function (t, e, r) { var n = arguments.length < 4 ? void 0 : Ro(arguments[3]); jo(t, e, j(r), n) } }); var Po = Oo.toKey, Io = Oo.getMap, To = Oo.store; Lt({ target: "Reflect", stat: !0 }, { deleteMetadata: function (t, e) { var r = arguments.length < 3 ? void 0 : Po(arguments[2]), n = Io(j(e), r, !1); if (void 0 === n || !n.delete(t)) return !1; if (n.size) return !0; var o = To.get(e); return o.delete(r), !!o.size || To.delete(e) } }); var ko = Oo.has, Lo = Oo.get, Uo = Oo.toKey, Mo = function (t, e, r) { if (ko(t, e, r)) return Lo(t, e, r); var n = ke(e); return null !== n ? Mo(t, n, r) : void 0 }; Lt({ target: "Reflect", stat: !0 }, { getMetadata: function (t, e) { var r = arguments.length < 3 ? void 0 : Uo(arguments[2]); return Mo(t, j(e), r) } }); var _o = Br("Set", function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }, Vr), No = Oo.keys, Co = Oo.toKey, Fo = function (t, e) { var r = No(t, e), n = ke(t); if (null === n) return r; var o, i, a = Fo(n, e); return a.length ? r.length ? (o = new _o(r.concat(a)), Nr(o, (i = []).push, i), i) : a : r }; Lt({ target: "Reflect", stat: !0 }, { getMetadataKeys: function (t) { var e = arguments.length < 2 ? void 0 : Co(arguments[1]); return Fo(j(t), e) } }); var Bo = Oo.get, Do = Oo.toKey; Lt({ target: "Reflect", stat: !0 }, { getOwnMetadata: function (t, e) { var r = arguments.length < 3 ? void 0 : Do(arguments[2]); return Bo(t, j(e), r) } }); var qo = Oo.keys, zo = Oo.toKey; Lt({ target: "Reflect", stat: !0 }, { getOwnMetadataKeys: function (t) { var e = arguments.length < 2 ? void 0 : zo(arguments[1]); return qo(j(t), e) } }); var Wo = Oo.has, Ko = Oo.toKey, Go = function (t, e, r) { if (Wo(t, e, r)) return !0; var n = ke(e); return null !== n && Go(t, n, r) }; Lt({ target: "Reflect", stat: !0 }, { hasMetadata: function (t, e) { var r = arguments.length < 3 ? void 0 : Ko(arguments[2]); return Go(t, j(e), r) } }); var $o = Oo.has, Vo = Oo.toKey; Lt({ target: "Reflect", stat: !0 }, { hasOwnMetadata: function (t, e) { var r = arguments.length < 3 ? void 0 : Vo(arguments[2]); return $o(t, j(e), r) } }); var Ho = Oo.toKey, Xo = Oo.set; Lt({ target: "Reflect", stat: !0 }, { metadata: function (t, e) { return function (r, n) { Xo(t, e, j(r), Ho(n)) } } }); var Yo = qt("match"), Jo = function (t) { var e; return y(t) && (void 0 !== (e = t[Yo]) ? !!e : "RegExp" == h(t)) }, Qo = function () { var t = j(this), e = ""; return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e }; function Zo(t, e) { return RegExp(t, e) } var ti = o(function () { var t = Zo("a", "y"); return t.lastIndex = 2, null != t.exec("abcd") }), ei = o(function () { var t = Zo("^r", "gy"); return t.lastIndex = 2, null != t.exec("str") }), ri = { UNSUPPORTED_Y: ti, BROKEN_CARET: ei }, ni = I.f, oi = wt.f, ii = et.set, ai = qt("match"), ui = n.RegExp, si = ui.prototype, ci = /a/g, fi = /a/g, li = new ui(ci) !== ci, hi = ri.UNSUPPORTED_Y; if (i && Tt("RegExp", !li || hi || o(function () { return fi[ai] = !1, ui(ci) != ci || ui(fi) == fi || "/a/i" != ui(ci, "i") }))) { for (var pi = function (t, e) { var r, n = this instanceof pi, o = Jo(t), i = void 0 === e; if (!n && o && t.constructor === pi && i) return t; li ? o && !i && (t = t.source) : t instanceof pi && (i && (e = Qo.call(t)), t = t.source), hi && (r = !!e && e.indexOf("y") > -1) && (e = e.replace(/y/g, "")); var a = Fr(li ? new ui(t, e) : ui(t, e), n ? this : si, pi); return hi && r && ii(a, { sticky: r }), a }, di = function (t) { t in pi || ni(pi, t, { configurable: !0, get: function () { return ui[t] }, set: function (e) { ui[t] = e } }) }, vi = oi(ui), gi = 0; vi.length > gi;)di(vi[gi++]); si.constructor = pi, pi.prototype = si, rt(n, "RegExp", pi) } zr("RegExp"); var yi = "toString", mi = RegExp.prototype, bi = mi.toString; (o(function () { return "/a/b" != bi.call({ source: "a", flags: "b" }) }) || bi.name != yi) && rt(RegExp.prototype, yi, function () { var t = j(this), e = String(t.source), r = t.flags; return "/" + e + "/" + String(void 0 === r && t instanceof RegExp && !("flags" in mi) ? Qo.call(t) : r) }, { unsafe: !0 }); var wi = RegExp.prototype.exec, Si = String.prototype.replace, Ei = wi, xi = function () { var t = /a/, e = /b*/g; return wi.call(t, "a"), wi.call(e, "a"), 0 !== t.lastIndex || 0 !== e.lastIndex }(), Ai = ri.UNSUPPORTED_Y || ri.BROKEN_CARET, Oi = void 0 !== /()??/.exec("")[1]; (xi || Oi || Ai) && (Ei = function (t) { var e, r, n, o, i = this, a = Ai && i.sticky, u = Qo.call(i), s = i.source, c = 0, f = t; return a && (-1 === (u = u.replace("y", "")).indexOf("g") && (u += "g"), f = String(t).slice(i.lastIndex), i.lastIndex > 0 && (!i.multiline || i.multiline && "\n" !== t[i.lastIndex - 1]) && (s = "(?: " + s + ")", f = " " + f, c++), r = new RegExp("^(?:" + s + ")", u)), Oi && (r = new RegExp("^" + s + "$(?!\\s)", u)), xi && (e = i.lastIndex), n = wi.call(a ? r : i, f), a ? n ? (n.input = n.input.slice(c), n[0] = n[0].slice(c), n.index = i.lastIndex, i.lastIndex += n[0].length) : i.lastIndex = 0 : xi && n && (i.lastIndex = i.global ? n.index + n[0].length : e), Oi && n && n.length > 1 && Si.call(n[0], r, function () { for (o = 1; o < arguments.length - 2; o++)void 0 === arguments[o] && (n[o] = void 0) }), n }); var Ri = Ei; Lt({ target: "RegExp", proto: !0, forced: /./.exec !== Ri }, { exec: Ri }), i && ("g" != /./g.flags || ri.UNSUPPORTED_Y) && I.f(RegExp.prototype, "flags", { configurable: !0, get: Qo }); var ji = et.get, Pi = RegExp.prototype; i && ri.UNSUPPORTED_Y && (0, I.f)(RegExp.prototype, "sticky", { configurable: !0, get: function () { if (this !== Pi) { if (this instanceof RegExp) return !!ji(this).sticky; throw TypeError("Incompatible receiver, RegExp required") } } }); var Ii, Ti, ki = (Ii = !1, (Ti = /[ac]/).exec = function () { return Ii = !0, /./.exec.apply(this, arguments) }, !0 === Ti.test("abc") && Ii), Li = /./.test; Lt({ target: "RegExp", proto: !0, forced: !ki }, { test: function (t) { if ("function" != typeof this.exec) return Li.call(this, t); var e = this.exec(t); if (null !== e && !y(e)) throw new Error("RegExp exec method returned something other than an Object or null"); return !!e } }); var Ui = qt("species"), Mi = !o(function () { var t = /./; return t.exec = function () { var t = []; return t.groups = { a: "7" }, t }, "7" !== "".replace(t, "$<a>") }), _i = "$0" === "a".replace(/./, "$0"), Ni = qt("replace"), Ci = !!/./[Ni] && "" === /./[Ni]("a", "$0"), Fi = !o(function () { var t = /(?:)/, e = t.exec; t.exec = function () { return e.apply(this, arguments) }; var r = "ab".split(t); return 2 !== r.length || "a" !== r[0] || "b" !== r[1] }), Bi = function (t, e, r, n) { var i = qt(t), a = !o(function () { var e = {}; return e[i] = function () { return 7 }, 7 != ""[t](e) }), u = a && !o(function () { var e = !1, r = /a/; return "split" === t && ((r = {}).constructor = {}, r.constructor[Ui] = function () { return r }, r.flags = "", r[i] = /./[i]), r.exec = function () { return e = !0, null }, r[i](""), !e }); if (!a || !u || "replace" === t && (!Mi || !_i || Ci) || "split" === t && !Fi) { var s = /./[i], c = r(i, ""[t], function (t, e, r, n, o) { return e.exec === Ri ? a && !o ? { done: !0, value: s.call(e, r, n) } : { done: !0, value: t.call(r, e, n) } : { done: !1 } }, { REPLACE_KEEPS_$0: _i, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Ci }), f = c[1]; rt(String.prototype, t, c[0]), rt(RegExp.prototype, i, 2 == e ? function (t, e) { return f.call(t, this, e) } : function (t) { return f.call(t, this) }) } n && T(RegExp.prototype[i], "sham", !0) }, Di = je.charAt, qi = function (t, e, r) { return e + (r ? Di(t, e).length : 1) }, zi = function (t, e) { var r = t.exec; if ("function" == typeof r) { var n = r.call(t, e); if ("object" != typeof n) throw TypeError("RegExp exec method returned something other than an Object or null"); return n } if ("RegExp" !== h(t)) throw TypeError("RegExp#exec called on incompatible receiver"); return Ri.call(t, e) }; Bi("match", 1, function (t, e, r) { return [function (e) { var r = v(this), n = null == e ? void 0 : e[t]; return void 0 !== n ? n.call(e, r) : new RegExp(e)[t](String(r)) }, function (t) { var n = r(e, t, this); if (n.done) return n.value; var o = j(t), i = String(this); if (!o.global) return zi(o, i); var a = o.unicode; o.lastIndex = 0; for (var u, s = [], c = 0; null !== (u = zi(o, i));) { var f = String(u[0]); s[c] = f, "" === f && (o.lastIndex = qi(i, ft(o.lastIndex), a)), c++ } return 0 === c ? null : s }] }); var Wi = Math.max, Ki = Math.min, Gi = Math.floor, $i = /\$([$&'`]|\d\d?|<[^>]*>)/g, Vi = /\$([$&'`]|\d\d?)/g; Bi("replace", 2, function (t, e, r, n) { var o = n.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i = n.REPLACE_KEEPS_$0, a = o ? "$" : "$0"; return [function (r, n) { var o = v(this), i = null == r ? void 0 : r[t]; return void 0 !== i ? i.call(r, o, n) : e.call(String(o), r, n) }, function (t, n) { if (!o && i || "string" == typeof n && -1 === n.indexOf(a)) { var s = r(e, t, this, n); if (s.done) return s.value } var c = j(t), f = String(this), l = "function" == typeof n; l || (n = String(n)); var h = c.global; if (h) { var p = c.unicode; c.lastIndex = 0 } for (var d = []; ;) { var v = zi(c, f); if (null === v) break; if (d.push(v), !h) break; "" === String(v[0]) && (c.lastIndex = qi(f, ft(c.lastIndex), p)) } for (var g, y = "", m = 0, b = 0; b < d.length; b++) { v = d[b]; for (var w = String(v[0]), S = Wi(Ki(st(v.index), f.length), 0), E = [], x = 1; x < v.length; x++)E.push(void 0 === (g = v[x]) ? g : String(g)); var A = v.groups; if (l) { var O = [w].concat(E, S, f); void 0 !== A && O.push(A); var R = String(n.apply(void 0, O)) } else R = u(w, f, S, E, A, n); S >= m && (y += f.slice(m, S) + R, m = S + w.length) } return y + f.slice(m) }]; function u(t, r, n, o, i, a) { var u = n + t.length, s = o.length, c = Vi; return void 0 !== i && (i = Ut(i), c = $i), e.call(a, c, function (e, a) { var c; switch (a.charAt(0)) { case "$": return "$"; case "&": return t; case "`": return r.slice(0, n); case "'": return r.slice(u); case "<": c = i[a.slice(1, -1)]; break; default: var f = +a; if (0 === f) return e; if (f > s) { var l = Gi(f / 10); return 0 === l ? e : l <= s ? void 0 === o[l - 1] ? a.charAt(1) : o[l - 1] + a.charAt(1) : e } c = o[f - 1] }return void 0 === c ? "" : c }) } }), Bi("search", 1, function (t, e, r) { return [function (e) { var r = v(this), n = null == e ? void 0 : e[t]; return void 0 !== n ? n.call(e, r) : new RegExp(e)[t](String(r)) }, function (t) { var n = r(e, t, this); if (n.done) return n.value; var o = j(t), i = String(this), a = o.lastIndex; Vn(a, 0) || (o.lastIndex = 0); var u = zi(o, i); return Vn(o.lastIndex, a) || (o.lastIndex = a), null === u ? -1 : u.index }] }); var Hi = [].push, Xi = Math.min, Yi = 4294967295, Ji = !o(function () { return !RegExp(Yi, "y") }); Bi("split", 2, function (t, e, r) { var n; return n = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, r) { var n = String(v(this)), o = void 0 === r ? Yi : r >>> 0; if (0 === o) return []; if (void 0 === t) return [n]; if (!Jo(t)) return e.call(n, t, o); for (var i, a, u, s = [], c = 0, f = new RegExp(t.source, (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : "") + "g"); (i = Ri.call(f, n)) && !((a = f.lastIndex) > c && (s.push(n.slice(c, i.index)), i.length > 1 && i.index < n.length && Hi.apply(s, i.slice(1)), u = i[0].length, c = a, s.length >= o));)f.lastIndex === i.index && f.lastIndex++; return c === n.length ? !u && f.test("") || s.push("") : s.push(n.slice(c)), s.length > o ? s.slice(0, o) : s } : "0".split(void 0, 0).length ? function (t, r) { return void 0 === t && 0 === r ? [] : e.call(this, t, r) } : e, [function (e, r) { var o = v(this), i = null == e ? void 0 : e[t]; return void 0 !== i ? i.call(e, o, r) : n.call(String(o), e, r) }, function (t, o) { var i = r(n, t, this, o, n !== e); if (i.done) return i.value; var a = j(t), u = String(this), s = fn(a, RegExp), c = a.unicode, f = new s(Ji ? a : "^(?:" + a.source + ")", (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (Ji ? "y" : "g")), l = void 0 === o ? Yi : o >>> 0; if (0 === l) return []; if (0 === u.length) return null === zi(f, u) ? [u] : []; for (var h = 0, p = 0, d = []; p < u.length;) { f.lastIndex = Ji ? p : 0; var v, g = zi(f, Ji ? u : u.slice(p)); if (null === g || (v = Xi(ft(f.lastIndex + (Ji ? 0 : p)), u.length)) === h) p = qi(u, p, c); else { if (d.push(u.slice(h, p)), d.length === l) return d; for (var y = 1; y <= g.length - 1; y++)if (d.push(g[y]), d.length === l) return d; p = h = v } } return d.push(u.slice(h)), d }] }, !Ji), Lt({ target: "Set", stat: !0 }, { from: nn }), Lt({ target: "Set", stat: !0 }, { of: on }); var Qi = function () { for (var t = j(this), e = Zt(t.add), r = 0, n = arguments.length; r < n; r++)e.call(t, arguments[r]); return t }; Lt({ target: "Set", proto: !0, real: !0, forced: q }, { addAll: function () { return Qi.apply(this, arguments) } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { deleteAll: function () { return an.apply(this, arguments) } }); var Zi = function (t) { return Set.prototype.values.call(t) }; Lt({ target: "Set", proto: !0, real: !0, forced: q }, { every: function (t) { var e = j(this), r = Zi(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return !Nr(r, function (t) { if (!n(t, t, e)) return Nr.stop() }, void 0, !1, !0).stopped } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { difference: function (t) { var e = j(this), r = new (fn(e, it("Set")))(e), n = Zt(r.delete); return Nr(t, function (t) { n.call(r, t) }), r } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { filter: function (t) { var e = j(this), r = Zi(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = new (fn(e, it("Set"))), i = Zt(o.add); return Nr(r, function (t) { n(t, t, e) && i.call(o, t) }, void 0, !1, !0), o } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { find: function (t) { var e = j(this), r = Zi(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return Nr(r, function (t) { if (n(t, t, e)) return Nr.stop(t) }, void 0, !1, !0).result } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { intersection: function (t) { var e = j(this), r = new (fn(e, it("Set"))), n = Zt(e.has), o = Zt(r.add); return Nr(t, function (t) { n.call(e, t) && o.call(r, t) }), r } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { isDisjointFrom: function (t) { var e = j(this), r = Zt(e.has); return !Nr(t, function (t) { if (!0 === r.call(e, t)) return Nr.stop() }).stopped } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { isSubsetOf: function (t) { var e = un(this), r = j(t), n = r.has; return "function" != typeof n && (r = new (it("Set"))(t), n = Zt(r.has)), !Nr(e, function (t) { if (!1 === n.call(r, t)) return Nr.stop() }, void 0, !1, !0).stopped } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { isSupersetOf: function (t) { var e = j(this), r = Zt(e.has); return !Nr(t, function (t) { if (!1 === r.call(e, t)) return Nr.stop() }).stopped } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { join: function (t) { var e = j(this), r = Zi(e), n = void 0 === t ? "," : String(t), o = []; return Nr(r, o.push, o, !1, !0), o.join(n) } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { map: function (t) { var e = j(this), r = Zi(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = new (fn(e, it("Set"))), i = Zt(o.add); return Nr(r, function (t) { i.call(o, n(t, t, e)) }, void 0, !1, !0), o } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { reduce: function (t) { var e = j(this), r = Zi(e), n = arguments.length < 2, o = n ? void 0 : arguments[1]; if (Zt(t), Nr(r, function (r) { n ? (n = !1, o = r) : o = t(o, r, r, e) }, void 0, !1, !0), n) throw TypeError("Reduce of empty set with no initial value"); return o } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { some: function (t) { var e = j(this), r = Zi(e), n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3); return Nr(r, function (t) { if (n(t, t, e)) return Nr.stop() }, void 0, !1, !0).stopped } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { symmetricDifference: function (t) { var e = j(this), r = new (fn(e, it("Set")))(e), n = Zt(r.delete), o = Zt(r.add); return Nr(t, function (t) { n.call(r, t) || o.call(r, t) }), r } }), Lt({ target: "Set", proto: !0, real: !0, forced: q }, { union: function (t) { var e = j(this), r = new (fn(e, it("Set")))(e); return Nr(t, Zt(r.add), r), r } }); var ta, ea, ra = it("navigator", "userAgent") || "", na = n.process, oa = na && na.versions, ia = oa && oa.v8; ia ? ea = (ta = ia.split("."))[0] + ta[1] : ra && (!(ta = ra.match(/Edge\/(\d+)/)) || ta[1] >= 74) && (ta = ra.match(/Chrome\/(\d+)/)) && (ea = ta[1]); var aa = ea && +ea, ua = qt("species"), sa = qt("isConcatSpreadable"), ca = 9007199254740991, fa = "Maximum allowed index exceeded", la = aa >= 51 || !o(function () { var t = []; return t[sa] = !1, t.concat()[0] !== t }), ha = aa >= 51 || !o(function () { var t = []; return (t.constructor = {})[ua] = function () { return { foo: 1 } }, 1 !== t.concat(Boolean).foo }), pa = function (t) { if (!y(t)) return !1; var e = t[sa]; return void 0 !== e ? !!e : ne(t) }; Lt({ target: "Array", proto: !0, forced: !la || !ha }, { concat: function (t) { var e, r, n, o, i, a = Ut(this), u = ie(a, 0), s = 0; for (e = -1, n = arguments.length; e < n; e++)if (pa(i = -1 === e ? a : arguments[e])) { if (s + (o = ft(i.length)) > ca) throw TypeError(fa); for (r = 0; r < o; r++, s++)r in i && ar(u, s, i[r]) } else { if (s >= ca) throw TypeError(fa); ar(u, s++, i) } return u.length = s, u } }); var da = wt.f, va = {}.toString, ga = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], ya = { f: function (t) { return ga && "[object Window]" == va.call(t) ? function (t) { try { return da(t) } catch (t) { return ga.slice() } }(t) : da(g(t)) } }, ma = { f: qt }, ba = I.f, wa = function (t) { var e = nt.Symbol || (nt.Symbol = {}); w(e, t) || ba(e, t, { value: ma.f(t) }) }, Sa = se.forEach, Ea = V("hidden"), xa = "Symbol", Aa = qt("toPrimitive"), Oa = et.set, Ra = et.getterFor(xa), ja = Object.prototype, Pa = n.Symbol, Ia = it("JSON", "stringify"), Ta = R.f, ka = I.f, La = ya.f, Ua = c.f, Ma = z("symbols"), _a = z("op-symbols"), Na = z("string-to-symbol-registry"), Ca = z("symbol-to-string-registry"), Fa = z("wks"), Ba = n.QObject, Da = !Ba || !Ba.prototype || !Ba.prototype.findChild, qa = i && o(function () { return 7 != Xt(ka({}, "a", { get: function () { return ka(this, "a", { value: 7 }).a } })).a }) ? function (t, e, r) { var n = Ta(ja, e); n && delete ja[e], ka(t, e, r), n && t !== ja && ka(ja, e, n) } : ka, za = function (t, e) { var r = Ma[t] = Xt(Pa.prototype); return Oa(r, { type: xa, tag: t, description: e }), i || (r.description = e), r }, Wa = Ct ? function (t) { return "symbol" == typeof t } : function (t) { return Object(t) instanceof Pa }, Ka = function (t, e, r) { t === ja && Ka(_a, e, r), j(t); var n = m(e, !0); return j(r), w(Ma, n) ? (r.enumerable ? (w(t, Ea) && t[Ea][n] && (t[Ea][n] = !1), r = Xt(r, { enumerable: f(0, !1) })) : (w(t, Ea) || ka(t, Ea, f(1, {})), t[Ea][n] = !0), qa(t, n, r)) : ka(t, n, r) }, Ga = function (t, e) { j(t); var r = g(e), n = zt(r).concat(Xa(r)); return Sa(n, function (e) { i && !$a.call(r, e) || Ka(t, e, r[e]) }), t }, $a = function (t) { var e = m(t, !0), r = Ua.call(this, e); return !(this === ja && w(Ma, e) && !w(_a, e)) && (!(r || !w(this, e) || !w(Ma, e) || w(this, Ea) && this[Ea][e]) || r) }, Va = function (t, e) { var r = g(t), n = m(e, !0); if (r !== ja || !w(Ma, n) || w(_a, n)) { var o = Ta(r, n); return !o || !w(Ma, n) || w(r, Ea) && r[Ea][n] || (o.enumerable = !0), o } }, Ha = function (t) { var e = La(g(t)), r = []; return Sa(e, function (t) { w(Ma, t) || w(H, t) || r.push(t) }), r }, Xa = function (t) { var e = t === ja, r = La(e ? _a : g(t)), n = []; return Sa(r, function (t) { !w(Ma, t) || e && !w(ja, t) || n.push(Ma[t]) }), n }; if (Nt || (Pa = function () { if (this instanceof Pa) throw TypeError("Symbol is not a constructor"); var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, e = G(t), r = function (t) { this === ja && r.call(_a, t), w(this, Ea) && w(this[Ea], e) && (this[Ea][e] = !1), qa(this, e, f(1, t)) }; return i && Da && qa(ja, e, { configurable: !0, set: r }), za(e, t) }, rt(Pa.prototype, "toString", function () { return Ra(this).tag }), rt(Pa, "withoutSetter", function (t) { return za(G(t), t) }), c.f = $a, I.f = Ka, R.f = Va, wt.f = ya.f = Ha, St.f = Xa, ma.f = function (t) { return za(qt(t), t) }, i && (ka(Pa.prototype, "description", { configurable: !0, get: function () { return Ra(this).description } }), rt(ja, "propertyIsEnumerable", $a, { unsafe: !0 }))), Lt({ global: !0, wrap: !0, forced: !Nt, sham: !Nt }, { Symbol: Pa }), Sa(zt(Fa), function (t) { wa(t) }), Lt({ target: xa, stat: !0, forced: !Nt }, { for: function (t) { var e = String(t); if (w(Na, e)) return Na[e]; var r = Pa(e); return Na[e] = r, Ca[r] = e, r }, keyFor: function (t) { if (!Wa(t)) throw TypeError(t + " is not a symbol"); if (w(Ca, t)) return Ca[t] }, useSetter: function () { Da = !0 }, useSimple: function () { Da = !1 } }), Lt({ target: "Object", stat: !0, forced: !Nt, sham: !i }, { create: function (t, e) { return void 0 === e ? Xt(t) : Ga(Xt(t), e) }, defineProperty: Ka, defineProperties: Ga, getOwnPropertyDescriptor: Va }), Lt({ target: "Object", stat: !0, forced: !Nt }, { getOwnPropertyNames: Ha, getOwnPropertySymbols: Xa }), Lt({ target: "Object", stat: !0, forced: o(function () { St.f(1) }) }, { getOwnPropertySymbols: function (t) { return St.f(Ut(t)) } }), Ia) { var Ya = !Nt || o(function () { var t = Pa(); return "[null]" != Ia([t]) || "{}" != Ia({ a: t }) || "{}" != Ia(Object(t)) }); Lt({ target: "JSON", stat: !0, forced: Ya }, { stringify: function (t, e, r) { for (var n, o = [t], i = 1; arguments.length > i;)o.push(arguments[i++]); if (n = e, (y(e) || void 0 !== t) && !Wa(t)) return ne(e) || (e = function (t, e) { if ("function" == typeof n && (e = n.call(this, t, e)), !Wa(e)) return e }), o[1] = e, Ia.apply(null, o) } }) } Pa.prototype[Aa] || T(Pa.prototype, Aa, Pa.prototype.valueOf), Ce(Pa, xa), H[Ea] = !0, wa("asyncIterator"); var Ja = I.f, Qa = n.Symbol; if (i && "function" == typeof Qa && (!("description" in Qa.prototype) || void 0 !== Qa().description)) { var Za = {}, tu = function () { var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), e = this instanceof tu ? new Qa(t) : void 0 === t ? Qa() : Qa(t); return "" === t && (Za[e] = !0), e }; xt(tu, Qa); var eu = tu.prototype = Qa.prototype; eu.constructor = tu; var ru = eu.toString, nu = "Symbol(test)" == String(Qa("test")), ou = /^Symbol\((.*)\)[^)]+$/; Ja(eu, "description", { configurable: !0, get: function () { var t = y(this) ? this.valueOf() : this, e = ru.call(t); if (w(Za, t)) return ""; var r = nu ? e.slice(7, -1) : e.replace(ou, "$1"); return "" === r ? void 0 : r } }), Lt({ global: !0, forced: !0 }, { Symbol: tu }) } wa("hasInstance"), wa("isConcatSpreadable"), wa("iterator"), wa("match"), wa("matchAll"), wa("replace"), wa("search"), wa("species"), wa("split"), wa("toPrimitive"), wa("toStringTag"), wa("unscopables"), Ce(Math, "Math", !0), Ce(n.JSON, "JSON", !0), wa("asyncDispose"), wa("dispose"), wa("observable"), wa("patternMatch"), wa("replaceAll"), ma.f("asyncIterator"); var iu = je.codeAt; Lt({ target: "String", proto: !0 }, { codePointAt: function (t) { return iu(this, t) } }), re("String", "codePointAt"); var au, uu = function (t) { if (Jo(t)) throw TypeError("The method doesn't accept regular expressions"); return t }, su = qt("match"), cu = function (t) { var e = /./; try { "/./"[t](e) } catch (r) { try { return e[su] = !1, "/./"[t](e) } catch (t) { } } return !1 }, fu = R.f, lu = "".endsWith, hu = Math.min, pu = cu("endsWith"), du = !(pu || (au = fu(String.prototype, "endsWith"), !au || au.writable)); Lt({ target: "String", proto: !0, forced: !du && !pu }, { endsWith: function (t) { var e = String(v(this)); uu(t); var r = arguments.length > 1 ? arguments[1] : void 0, n = ft(e.length), o = void 0 === r ? n : hu(ft(r), n), i = String(t); return lu ? lu.call(e, i, o) : e.slice(o - i.length, o) === i } }), re("String", "endsWith"); var vu = String.fromCharCode, gu = String.fromCodePoint; Lt({ target: "String", stat: !0, forced: !!gu && 1 != gu.length }, { fromCodePoint: function (t) { for (var e, r = [], n = arguments.length, o = 0; n > o;) { if (e = +arguments[o++], pt(e, 1114111) !== e) throw RangeError(e + " is not a valid code point"); r.push(e < 65536 ? vu(e) : vu(55296 + ((e -= 65536) >> 10), e % 1024 + 56320)) } return r.join("") } }), Lt({ target: "String", proto: !0, forced: !cu("includes") }, { includes: function (t) { return !!~String(v(this)).indexOf(uu(t), arguments.length > 1 ? arguments[1] : void 0) } }), re("String", "includes"); var yu = "".repeat || function (t) { var e = String(v(this)), r = "", n = st(t); if (n < 0 || Infinity == n) throw RangeError("Wrong number of repetitions"); for (; n > 0; (n >>>= 1) && (e += e))1 & n && (r += e); return r }, mu = Math.ceil, bu = function (t) { return function (e, r, n) { var o, i, a = String(v(e)), u = a.length, s = void 0 === n ? " " : String(n), c = ft(r); return c <= u || "" == s ? a : ((i = yu.call(s, mu((o = c - u) / s.length))).length > o && (i = i.slice(0, o)), t ? a + i : i + a) } }, wu = { start: bu(!1), end: bu(!0) }, Su = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(ra), Eu = wu.start; Lt({ target: "String", proto: !0, forced: Su }, { padStart: function (t) { return Eu(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), re("String", "padStart"); var xu = wu.end; Lt({ target: "String", proto: !0, forced: Su }, { padEnd: function (t) { return xu(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), re("String", "padEnd"), Lt({ target: "String", stat: !0 }, { raw: function (t) { for (var e = g(t.raw), r = ft(e.length), n = arguments.length, o = [], i = 0; r > i;)o.push(String(e[i++])), i < n && o.push(String(arguments[i])); return o.join("") } }), Lt({ target: "String", proto: !0 }, { repeat: yu }), re("String", "repeat"); var Au = R.f, Ou = "".startsWith, Ru = Math.min, ju = cu("startsWith"), Pu = !ju && !!function () { var t = Au(String.prototype, "startsWith"); return t && !t.writable }(); Lt({ target: "String", proto: !0, forced: !Pu && !ju }, { startsWith: function (t) { var e = String(v(this)); uu(t); var r = ft(Ru(arguments.length > 1 ? arguments[1] : void 0, e.length)), n = String(t); return Ou ? Ou.call(e, n, r) : e.slice(r, r + n.length) === n } }), re("String", "startsWith"); var Iu = function (t) { return o(function () { return !!hn[t]() || "" != ""[t]() || hn[t].name !== t }) }, Tu = yn.start, ku = Iu("trimStart"), Lu = ku ? function () { return Tu(this) } : "".trimStart; Lt({ target: "String", proto: !0, forced: ku }, { trimStart: Lu, trimLeft: Lu }), re("String", "trimLeft"); var Uu = yn.end, Mu = Iu("trimEnd"), _u = Mu ? function () { return Uu(this) } : "".trimEnd; Lt({ target: "String", proto: !0, forced: Mu }, { trimEnd: _u, trimRight: _u }), re("String", "trimRight"); var Nu = qt("iterator"), Cu = !o(function () { var t = new URL("b?a=1&b=2&c=3", "http://a"), e = t.searchParams, r = ""; return t.pathname = "c%20d", e.forEach(function (t, n) { e.delete("b"), r += n + t }), !e.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== e.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !e[Nu] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://").host || "#%D0%B1" !== new URL("http://a#").hash || "a1c3" !== r || "x" !== new URL("http://x", void 0).host }), Fu = Object.assign, Bu = Object.defineProperty, Du = !Fu || o(function () { if (i && 1 !== Fu({ b: 1 }, Fu(Bu({}, "a", { enumerable: !0, get: function () { Bu(this, "b", { value: 3, enumerable: !1 }) } }), { b: 2 })).b) return !0; var t = {}, e = {}, r = Symbol(), n = "abcdefghijklmnopqrst"; return t[r] = 7, n.split("").forEach(function (t) { e[t] = t }), 7 != Fu({}, t)[r] || zt(Fu({}, e)).join("") != n }) ? function (t, e) { for (var r = Ut(t), n = arguments.length, o = 1, a = St.f, u = c.f; n > o;)for (var s, f = d(arguments[o++]), l = a ? zt(f).concat(a(f)) : zt(f), h = l.length, p = 0; h > p;)s = l[p++], i && !u.call(f, s) || (r[s] = f[s]); return r } : Fu, qu = 2147483647, zu = /[^\0-\u007E]/, Wu = /[.\u3002\uFF0E\uFF61]/g, Ku = "Overflow: input needs wider integers to process", Gu = Math.floor, $u = String.fromCharCode, Vu = function (t) { return t + 22 + 75 * (t < 26) }, Hu = function (t, e, r) { var n = 0; for (t = r ? Gu(t / 700) : t >> 1, t += Gu(t / e); t > 455; n += 36)t = Gu(t / 35); return Gu(n + 36 * t / (t + 38)) }, Xu = function (t) { var e = []; t = function (t) { for (var e = [], r = 0, n = t.length; r < n;) { var o = t.charCodeAt(r++); if (o >= 55296 && o <= 56319 && r < n) { var i = t.charCodeAt(r++); 56320 == (64512 & i) ? e.push(((1023 & o) << 10) + (1023 & i) + 65536) : (e.push(o), r--) } else e.push(o) } return e }(t); var r, n, o = t.length, i = 128, a = 0, u = 72; for (r = 0; r < t.length; r++)(n = t[r]) < 128 && e.push($u(n)); var s = e.length, c = s; for (s && e.push("-"); c < o;) { var f = qu; for (r = 0; r < t.length; r++)(n = t[r]) >= i && n < f && (f = n); var l = c + 1; if (f - i > Gu((qu - a) / l)) throw RangeError(Ku); for (a += (f - i) * l, i = f, r = 0; r < t.length; r++) { if ((n = t[r]) < i && ++a > qu) throw RangeError(Ku); if (n == i) { for (var h = a, p = 36; ; p += 36) { var d = p <= u ? 1 : p >= u + 26 ? 26 : p - u; if (h < d) break; var v = h - d, g = 36 - d; e.push($u(Vu(d + v % g))), h = Gu(v / g) } e.push($u(Vu(h))), u = Hu(a, l, c == s), a = 0, ++c } } ++a, ++i } return e.join("") }, Yu = it("fetch"), Ju = it("Headers"), Qu = qt("iterator"), Zu = "URLSearchParams", ts = "URLSearchParamsIterator", es = et.set, rs = et.getterFor(Zu), ns = et.getterFor(ts), os = /\+/g, is = Array(4), as = function (t) { return is[t - 1] || (is[t - 1] = RegExp("((?:%[\\da-f]{2}){" + t + "})", "gi")) }, us = function (t) { try { return decodeURIComponent(t) } catch (e) { return t } }, ss = function (t) { var e = t.replace(os, " "), r = 4; try { return decodeURIComponent(e) } catch (t) { for (; r;)e = e.replace(as(r--), us); return e } }, cs = /[!'()~]|%20/g, fs = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, ls = function (t) { return fs[t] }, hs = function (t) { return encodeURIComponent(t).replace(cs, ls) }, ps = function (t, e) { if (e) for (var r, n, o = e.split("&"), i = 0; i < o.length;)(r = o[i++]).length && (n = r.split("="), t.push({ key: ss(n.shift()), value: ss(n.join("=")) })) }, ds = function (t) { this.entries.length = 0, ps(this.entries, t) }, vs = function (t, e) { if (t < e) throw TypeError("Not enough arguments") }, gs = qe(function (t, e) { es(this, { type: ts, iterator: un(rs(t).entries), kind: e }) }, "Iterator", function () { var t = ns(this), e = t.kind, r = t.iterator.next(), n = r.value; return r.done || (r.value = "keys" === e ? n.key : "values" === e ? n.value : [n.key, n.value]), r }), ys = function () { Cr(this, ys, Zu); var t, e, r, n, o, i, a, u, s, c = arguments.length > 0 ? arguments[0] : void 0, f = this, l = []; if (es(f, { type: Zu, entries: l, updateURL: function () { }, updateSearchParams: ds }), void 0 !== c) if (y(c)) if ("function" == typeof (t = pr(c))) for (r = (e = t.call(c)).next; !(n = r.call(e)).done;) { if ((a = (i = (o = un(j(n.value))).next).call(o)).done || (u = i.call(o)).done || !i.call(o).done) throw TypeError("Expected sequence with length 2"); l.push({ key: a.value + "", value: u.value + "" }) } else for (s in c) w(c, s) && l.push({ key: s, value: c[s] + "" }); else ps(l, "string" == typeof c ? "?" === c.charAt(0) ? c.slice(1) : c : c + "") }, ms = ys.prototype; Dr(ms, { append: function (t, e) { vs(arguments.length, 2); var r = rs(this); r.entries.push({ key: t + "", value: e + "" }), r.updateURL() }, delete: function (t) { vs(arguments.length, 1); for (var e = rs(this), r = e.entries, n = t + "", o = 0; o < r.length;)r[o].key === n ? r.splice(o, 1) : o++; e.updateURL() }, get: function (t) { vs(arguments.length, 1); for (var e = rs(this).entries, r = t + "", n = 0; n < e.length; n++)if (e[n].key === r) return e[n].value; return null }, getAll: function (t) { vs(arguments.length, 1); for (var e = rs(this).entries, r = t + "", n = [], o = 0; o < e.length; o++)e[o].key === r && n.push(e[o].value); return n }, has: function (t) { vs(arguments.length, 1); for (var e = rs(this).entries, r = t + "", n = 0; n < e.length;)if (e[n++].key === r) return !0; return !1 }, set: function (t, e) { vs(arguments.length, 1); for (var r, n = rs(this), o = n.entries, i = !1, a = t + "", u = e + "", s = 0; s < o.length; s++)(r = o[s]).key === a && (i ? o.splice(s--, 1) : (i = !0, r.value = u)); i || o.push({ key: a, value: u }), n.updateURL() }, sort: function () { var t, e, r, n = rs(this), o = n.entries, i = o.slice(); for (o.length = 0, r = 0; r < i.length; r++) { for (t = i[r], e = 0; e < r; e++)if (o[e].key > t.key) { o.splice(e, 0, t); break } e === r && o.push(t) } n.updateURL() }, forEach: function (t) { for (var e, r = rs(this).entries, n = te(t, arguments.length > 1 ? arguments[1] : void 0, 3), o = 0; o < r.length;)n((e = r[o++]).value, e.key, this) }, keys: function () { return new gs(this, "keys") }, values: function () { return new gs(this, "values") }, entries: function () { return new gs(this, "entries") } }, { enumerable: !0 }), rt(ms, Qu, ms.entries), rt(ms, "toString", function () { for (var t, e = rs(this).entries, r = [], n = 0; n < e.length;)t = e[n++], r.push(hs(t.key) + "=" + hs(t.value)); return r.join("&") }, { enumerable: !0 }), Ce(ys, Zu), Lt({ global: !0, forced: !Cu }, { URLSearchParams: ys }), Cu || "function" != typeof Yu || "function" != typeof Ju || Lt({ global: !0, enumerable: !0, forced: !0 }, { fetch: function (t) { var e, r, n, o = [t]; return arguments.length > 1 && (y(e = arguments[1]) && lr(r = e.body) === Zu && ((n = e.headers ? new Ju(e.headers) : new Ju).has("content-type") || n.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), e = Xt(e, { body: f(0, String(r)), headers: f(0, n) })), o.push(e)), Yu.apply(this, o) } }); var bs, ws = { URLSearchParams: ys, getState: rs }, Ss = je.codeAt, Es = n.URL, xs = ws.URLSearchParams, As = ws.getState, Os = et.set, Rs = et.getterFor("URL"), js = Math.floor, Ps = Math.pow, Is = "Invalid scheme", Ts = "Invalid host", ks = "Invalid port", Ls = /[A-Za-z]/, Us = /[\d+-.A-Za-z]/, Ms = /\d/, _s = /^(0x|0X)/, Ns = /^[0-7]+$/, Cs = /^\d+$/, Fs = /^[\dA-Fa-f]+$/, Bs = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/, Ds = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/, qs = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g, zs = /[\u0009\u000A\u000D]/g, Ws = function (t, e) { var r, n, o; if ("[" == e.charAt(0)) { if ("]" != e.charAt(e.length - 1)) return Ts; if (!(r = Gs(e.slice(1, -1)))) return Ts; t.host = r } else if (Zs(t)) { if (e = function (t) { var e, r, n = [], o = t.toLowerCase().replace(Wu, ".").split("."); for (e = 0; e < o.length; e++)n.push(zu.test(r = o[e]) ? "xn--" + Xu(r) : r); return n.join(".") }(e), Bs.test(e)) return Ts; if (null === (r = Ks(e))) return Ts; t.host = r } else { if (Ds.test(e)) return Ts; for (r = "", n = dr(e), o = 0; o < n.length; o++)r += Js(n[o], Vs); t.host = r } }, Ks = function (t) { var e, r, n, o, i, a, u, s = t.split("."); if (s.length && "" == s[s.length - 1] && s.pop(), (e = s.length) > 4) return t; for (r = [], n = 0; n < e; n++) { if ("" == (o = s[n])) return t; if (i = 10, o.length > 1 && "0" == o.charAt(0) && (i = _s.test(o) ? 16 : 8, o = o.slice(8 == i ? 1 : 2)), "" === o) a = 0; else { if (!(10 == i ? Cs : 8 == i ? Ns : Fs).test(o)) return t; a = parseInt(o, i) } r.push(a) } for (n = 0; n < e; n++)if (a = r[n], n == e - 1) { if (a >= Ps(256, 5 - e)) return null } else if (a > 255) return null; for (u = r.pop(), n = 0; n < r.length; n++)u += r[n] * Ps(256, 3 - n); return u }, Gs = function (t) { var e, r, n, o, i, a, u, s = [0, 0, 0, 0, 0, 0, 0, 0], c = 0, f = null, l = 0, h = function () { return t.charAt(l) }; if (":" == h()) { if (":" != t.charAt(1)) return; l += 2, f = ++c } for (; h();) { if (8 == c) return; if (":" != h()) { for (e = r = 0; r < 4 && Fs.test(h());)e = 16 * e + parseInt(h(), 16), l++, r++; if ("." == h()) { if (0 == r) return; if (l -= r, c > 6) return; for (n = 0; h();) { if (o = null, n > 0) { if (!("." == h() && n < 4)) return; l++ } if (!Ms.test(h())) return; for (; Ms.test(h());) { if (i = parseInt(h(), 10), null === o) o = i; else { if (0 == o) return; o = 10 * o + i } if (o > 255) return; l++ } s[c] = 256 * s[c] + o, 2 != ++n && 4 != n || c++ } if (4 != n) return; break } if (":" == h()) { if (l++, !h()) return } else if (h()) return; s[c++] = e } else { if (null !== f) return; l++, f = ++c } } if (null !== f) for (a = c - f, c = 7; 0 != c && a > 0;)u = s[c], s[c--] = s[f + a - 1], s[f + --a] = u; else if (8 != c) return; return s }, $s = function (t) { var e, r, n, o; if ("number" == typeof t) { for (e = [], r = 0; r < 4; r++)e.unshift(t % 256), t = js(t / 256); return e.join(".") } if ("object" == typeof t) { for (e = "", n = function (t) { for (var e = null, r = 1, n = null, o = 0, i = 0; i < 8; i++)0 !== t[i] ? (o > r && (e = n, r = o), n = null, o = 0) : (null === n && (n = i), ++o); return o > r && (e = n, r = o), e }(t), r = 0; r < 8; r++)o && 0 === t[r] || (o && (o = !1), n === r ? (e += r ? ":" : "::", o = !0) : (e += t[r].toString(16), r < 7 && (e += ":"))); return "[" + e + "]" } return t }, Vs = {}, Hs = Du({}, Vs, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), Xs = Du({}, Hs, { "#": 1, "?": 1, "{": 1, "}": 1 }), Ys = Du({}, Xs, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), Js = function (t, e) { var r = Ss(t, 0); return r > 32 && r < 127 && !w(e, t) ? t : encodeURIComponent(t) }, Qs = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, Zs = function (t) { return w(Qs, t.scheme) }, tc = function (t) { return "" != t.username || "" != t.password }, ec = function (t) { return !t.host || t.cannotBeABaseURL || "file" == t.scheme }, rc = function (t, e) { var r; return 2 == t.length && Ls.test(t.charAt(0)) && (":" == (r = t.charAt(1)) || !e && "|" == r) }, nc = function (t) { var e; return t.length > 1 && rc(t.slice(0, 2)) && (2 == t.length || "/" === (e = t.charAt(2)) || "\\" === e || "?" === e || "#" === e) }, oc = function (t) { var e = t.path, r = e.length; !r || "file" == t.scheme && 1 == r && rc(e[0], !0) || e.pop() }, ic = function (t) { return "." === t || "%2e" === t.toLowerCase() }, ac = {}, uc = {}, sc = {}, cc = {}, fc = {}, lc = {}, hc = {}, pc = {}, dc = {}, vc = {}, gc = {}, yc = {}, mc = {}, bc = {}, wc = {}, Sc = {}, Ec = {}, xc = {}, Ac = {}, Oc = {}, Rc = {}, jc = function (t, e, r, n) { var o, i, a, u, s, c = r || ac, f = 0, l = "", h = !1, p = !1, d = !1; for (r || (t.scheme = "", t.username = "", t.password = "", t.host = null, t.port = null, t.path = [], t.query = null, t.fragment = null, t.cannotBeABaseURL = !1, e = e.replace(qs, "")), e = e.replace(zs, ""), o = dr(e); f <= o.length;) { switch (i = o[f], c) { case ac: if (!i || !Ls.test(i)) { if (r) return Is; c = sc; continue } l += i.toLowerCase(), c = uc; break; case uc: if (i && (Us.test(i) || "+" == i || "-" == i || "." == i)) l += i.toLowerCase(); else { if (":" != i) { if (r) return Is; l = "", c = sc, f = 0; continue } if (r && (Zs(t) != w(Qs, l) || "file" == l && (tc(t) || null !== t.port) || "file" == t.scheme && !t.host)) return; if (t.scheme = l, r) return void (Zs(t) && Qs[t.scheme] == t.port && (t.port = null)); l = "", "file" == t.scheme ? c = bc : Zs(t) && n && n.scheme == t.scheme ? c = cc : Zs(t) ? c = pc : "/" == o[f + 1] ? (c = fc, f++) : (t.cannotBeABaseURL = !0, t.path.push(""), c = Ac) } break; case sc: if (!n || n.cannotBeABaseURL && "#" != i) return Is; if (n.cannotBeABaseURL && "#" == i) { t.scheme = n.scheme, t.path = n.path.slice(), t.query = n.query, t.fragment = "", t.cannotBeABaseURL = !0, c = Rc; break } c = "file" == n.scheme ? bc : lc; continue; case cc: if ("/" != i || "/" != o[f + 1]) { c = lc; continue } c = dc, f++; break; case fc: if ("/" == i) { c = vc; break } c = xc; continue; case lc: if (t.scheme = n.scheme, i == bs) t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = n.query; else if ("/" == i || "\\" == i && Zs(t)) c = hc; else if ("?" == i) t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = "", c = Oc; else { if ("#" != i) { t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.path.pop(), c = xc; continue } t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, t.path = n.path.slice(), t.query = n.query, t.fragment = "", c = Rc } break; case hc: if (!Zs(t) || "/" != i && "\\" != i) { if ("/" != i) { t.username = n.username, t.password = n.password, t.host = n.host, t.port = n.port, c = xc; continue } c = vc } else c = dc; break; case pc: if (c = dc, "/" != i || "/" != l.charAt(f + 1)) continue; f++; break; case dc: if ("/" != i && "\\" != i) { c = vc; continue } break; case vc: if ("@" == i) { h && (l = "%40" + l), h = !0, a = dr(l); for (var v = 0; v < a.length; v++) { var g = a[v]; if (":" != g || d) { var y = Js(g, Ys); d ? t.password += y : t.username += y } else d = !0 } l = "" } else if (i == bs || "/" == i || "?" == i || "#" == i || "\\" == i && Zs(t)) { if (h && "" == l) return "Invalid authority"; f -= dr(l).length + 1, l = "", c = gc } else l += i; break; case gc: case yc: if (r && "file" == t.scheme) { c = Sc; continue } if (":" != i || p) { if (i == bs || "/" == i || "?" == i || "#" == i || "\\" == i && Zs(t)) { if (Zs(t) && "" == l) return Ts; if (r && "" == l && (tc(t) || null !== t.port)) return; if (u = Ws(t, l)) return u; if (l = "", c = Ec, r) return; continue } "[" == i ? p = !0 : "]" == i && (p = !1), l += i } else { if ("" == l) return Ts; if (u = Ws(t, l)) return u; if (l = "", c = mc, r == yc) return } break; case mc: if (!Ms.test(i)) { if (i == bs || "/" == i || "?" == i || "#" == i || "\\" == i && Zs(t) || r) { if ("" != l) { var m = parseInt(l, 10); if (m > 65535) return ks; t.port = Zs(t) && m === Qs[t.scheme] ? null : m, l = "" } if (r) return; c = Ec; continue } return ks } l += i; break; case bc: if (t.scheme = "file", "/" == i || "\\" == i) c = wc; else { if (!n || "file" != n.scheme) { c = xc; continue } if (i == bs) t.host = n.host, t.path = n.path.slice(), t.query = n.query; else if ("?" == i) t.host = n.host, t.path = n.path.slice(), t.query = "", c = Oc; else { if ("#" != i) { nc(o.slice(f).join("")) || (t.host = n.host, t.path = n.path.slice(), oc(t)), c = xc; continue } t.host = n.host, t.path = n.path.slice(), t.query = n.query, t.fragment = "", c = Rc } } break; case wc: if ("/" == i || "\\" == i) { c = Sc; break } n && "file" == n.scheme && !nc(o.slice(f).join("")) && (rc(n.path[0], !0) ? t.path.push(n.path[0]) : t.host = n.host), c = xc; continue; case Sc: if (i == bs || "/" == i || "\\" == i || "?" == i || "#" == i) { if (!r && rc(l)) c = xc; else if ("" == l) { if (t.host = "", r) return; c = Ec } else { if (u = Ws(t, l)) return u; if ("localhost" == t.host && (t.host = ""), r) return; l = "", c = Ec } continue } l += i; break; case Ec: if (Zs(t)) { if (c = xc, "/" != i && "\\" != i) continue } else if (r || "?" != i) if (r || "#" != i) { if (i != bs && (c = xc, "/" != i)) continue } else t.fragment = "", c = Rc; else t.query = "", c = Oc; break; case xc: if (i == bs || "/" == i || "\\" == i && Zs(t) || !r && ("?" == i || "#" == i)) { if (".." === (s = (s = l).toLowerCase()) || "%2e." === s || ".%2e" === s || "%2e%2e" === s ? (oc(t), "/" == i || "\\" == i && Zs(t) || t.path.push("")) : ic(l) ? "/" == i || "\\" == i && Zs(t) || t.path.push("") : ("file" == t.scheme && !t.path.length && rc(l) && (t.host && (t.host = ""), l = l.charAt(0) + ":"), t.path.push(l)), l = "", "file" == t.scheme && (i == bs || "?" == i || "#" == i)) for (; t.path.length > 1 && "" === t.path[0];)t.path.shift(); "?" == i ? (t.query = "", c = Oc) : "#" == i && (t.fragment = "", c = Rc) } else l += Js(i, Xs); break; case Ac: "?" == i ? (t.query = "", c = Oc) : "#" == i ? (t.fragment = "", c = Rc) : i != bs && (t.path[0] += Js(i, Vs)); break; case Oc: r || "#" != i ? i != bs && ("'" == i && Zs(t) ? t.query += "%27" : t.query += "#" == i ? "%23" : Js(i, Vs)) : (t.fragment = "", c = Rc); break; case Rc: i != bs && (t.fragment += Js(i, Hs)) }f++ } }, Pc = function (t) { var e, r, n = Cr(this, Pc, "URL"), o = arguments.length > 1 ? arguments[1] : void 0, a = String(t), u = Os(n, { type: "URL" }); if (void 0 !== o) if (o instanceof Pc) e = Rs(o); else if (r = jc(e = {}, String(o))) throw TypeError(r); if (r = jc(u, a, null, e)) throw TypeError(r); var s = u.searchParams = new xs, c = As(s); c.updateSearchParams(u.query), c.updateURL = function () { u.query = String(s) || null }, i || (n.href = Tc.call(n), n.origin = kc.call(n), n.protocol = Lc.call(n), n.username = Uc.call(n), n.password = Mc.call(n), n.host = _c.call(n), n.hostname = Nc.call(n), n.port = Cc.call(n), n.pathname = Fc.call(n), n.search = Bc.call(n), n.searchParams = Dc.call(n), n.hash = qc.call(n)) }, Ic = Pc.prototype, Tc = function () { var t = Rs(this), e = t.scheme, r = t.username, n = t.password, o = t.host, i = t.port, a = t.path, u = t.query, s = t.fragment, c = e + ":"; return null !== o ? (c += "//", tc(t) && (c += r + (n ? ":" + n : "") + "@"), c += $s(o), null !== i && (c += ":" + i)) : "file" == e && (c += "//"), c += t.cannotBeABaseURL ? a[0] : a.length ? "/" + a.join("/") : "", null !== u && (c += "?" + u), null !== s && (c += "#" + s), c }, kc = function () { var t = Rs(this), e = t.scheme, r = t.port; if ("blob" == e) try { return new URL(e.path[0]).origin } catch (t) { return "null" } return "file" != e && Zs(t) ? e + "://" + $s(t.host) + (null !== r ? ":" + r : "") : "null" }, Lc = function () { return Rs(this).scheme + ":" }, Uc = function () { return Rs(this).username }, Mc = function () { return Rs(this).password }, _c = function () { var t = Rs(this), e = t.host, r = t.port; return null === e ? "" : null === r ? $s(e) : $s(e) + ":" + r }, Nc = function () { var t = Rs(this).host; return null === t ? "" : $s(t) }, Cc = function () { var t = Rs(this).port; return null === t ? "" : String(t) }, Fc = function () { var t = Rs(this), e = t.path; return t.cannotBeABaseURL ? e[0] : e.length ? "/" + e.join("/") : "" }, Bc = function () { var t = Rs(this).query; return t ? "?" + t : "" }, Dc = function () { return Rs(this).searchParams }, qc = function () { var t = Rs(this).fragment; return t ? "#" + t : "" }, zc = function (t, e) { return { get: t, set: e, configurable: !0, enumerable: !0 } }; if (i && Wt(Ic, { href: zc(Tc, function (t) { var e = Rs(this), r = String(t), n = jc(e, r); if (n) throw TypeError(n); As(e.searchParams).updateSearchParams(e.query) }), origin: zc(kc), protocol: zc(Lc, function (t) { var e = Rs(this); jc(e, String(t) + ":", ac) }), username: zc(Uc, function (t) { var e = Rs(this), r = dr(String(t)); if (!ec(e)) { e.username = ""; for (var n = 0; n < r.length; n++)e.username += Js(r[n], Ys) } }), password: zc(Mc, function (t) { var e = Rs(this), r = dr(String(t)); if (!ec(e)) { e.password = ""; for (var n = 0; n < r.length; n++)e.password += Js(r[n], Ys) } }), host: zc(_c, function (t) { var e = Rs(this); e.cannotBeABaseURL || jc(e, String(t), gc) }), hostname: zc(Nc, function (t) { var e = Rs(this); e.cannotBeABaseURL || jc(e, String(t), yc) }), port: zc(Cc, function (t) { var e = Rs(this); ec(e) || ("" == (t = String(t)) ? e.port = null : jc(e, t, mc)) }), pathname: zc(Fc, function (t) { var e = Rs(this); e.cannotBeABaseURL || (e.path = [], jc(e, t + "", Ec)) }), search: zc(Bc, function (t) { var e = Rs(this); "" == (t = String(t)) ? e.query = null : ("?" == t.charAt(0) && (t = t.slice(1)), e.query = "", jc(e, t, Oc)), As(e.searchParams).updateSearchParams(e.query) }), searchParams: zc(Dc), hash: zc(qc, function (t) { var e = Rs(this); "" != (t = String(t)) ? ("#" == t.charAt(0) && (t = t.slice(1)), e.fragment = "", jc(e, t, Rc)) : e.fragment = null }) }), rt(Ic, "toJSON", function () { return Tc.call(this) }, { enumerable: !0 }), rt(Ic, "toString", function () { return Tc.call(this) }, { enumerable: !0 }), Es) { var Wc = Es.createObjectURL, Kc = Es.revokeObjectURL; Wc && rt(Pc, "createObjectURL", function (t) { return Wc.apply(Es, arguments) }), Kc && rt(Pc, "revokeObjectURL", function (t) { return Kc.apply(Es, arguments) }) } Ce(Pc, "URL"), Lt({ global: !0, forced: !Cu, sham: !i }, { URL: Pc }), Lt({ target: "URL", proto: !0, enumerable: !0 }, { toJSON: function () { return URL.prototype.toString.call(this) } }), Lt({ target: "WeakMap", stat: !0 }, { from: nn }), Lt({ target: "WeakMap", stat: !0 }, { of: on }), Lt({ target: "WeakMap", proto: !0, real: !0, forced: q }, { deleteAll: function () { return an.apply(this, arguments) } }), Lt({ target: "WeakMap", proto: !0, real: !0, forced: q }, { upsert: ln }), Br("WeakSet", function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }, wo), Lt({ target: "WeakSet", proto: !0, real: !0, forced: q }, { addAll: function () { return Qi.apply(this, arguments) } }), Lt({ target: "WeakSet", proto: !0, real: !0, forced: q }, { deleteAll: function () { return an.apply(this, arguments) } }), Lt({ target: "WeakSet", stat: !0 }, { from: nn }), Lt({ target: "WeakSet", stat: !0 }, { of: on }); var Gc, $c, Vc, Hc = n.Promise, Xc = /(iphone|ipod|ipad).*applewebkit/i.test(ra), Yc = n.location, Jc = n.setImmediate, Qc = n.clearImmediate, Zc = n.process, tf = n.MessageChannel, ef = n.Dispatch, rf = 0, nf = {}, of = function (t) { if (nf.hasOwnProperty(t)) { var e = nf[t]; delete nf[t], e() } }, af = function (t) { return function () { of(t) } }, uf = function (t) { of(t.data) }, sf = function (t) { n.postMessage(t + "", Yc.protocol + "//" + Yc.host) }; Jc && Qc || (Jc = function (t) { for (var e = [], r = 1; arguments.length > r;)e.push(arguments[r++]); return nf[++rf] = function () { ("function" == typeof t ? t : Function(t)).apply(void 0, e) }, Gc(rf), rf }, Qc = function (t) { delete nf[t] }, "process" == h(Zc) ? Gc = function (t) { Zc.nextTick(af(t)) } : ef && ef.now ? Gc = function (t) { ef.now(af(t)) } : tf && !Xc ? (Vc = ($c = new tf).port2, $c.port1.onmessage = uf, Gc = te(Vc.postMessage, Vc, 1)) : !n.addEventListener || "function" != typeof postMessage || n.importScripts || o(sf) || "file:" === Yc.protocol ? Gc = "onreadystatechange" in x("script") ? function (t) { Kt.appendChild(x("script")).onreadystatechange = function () { Kt.removeChild(this), of(t) } } : function (t) { setTimeout(af(t), 0) } : (Gc = sf, n.addEventListener("message", uf, !1))); var cf, ff, lf, hf, pf, df, vf, gf, yf = { set: Jc, clear: Qc }, mf = R.f, bf = yf.set, wf = n.MutationObserver || n.WebKitMutationObserver, Sf = n.process, Ef = n.Promise, xf = "process" == h(Sf), Af = mf(n, "queueMicrotask"), Of = Af && Af.value; Of || (cf = function () { var t, e; for (xf && (t = Sf.domain) && t.exit(); ff;) { e = ff.fn, ff = ff.next; try { e() } catch (t) { throw ff ? hf() : lf = void 0, t } } lf = void 0, t && t.enter() }, xf ? hf = function () { Sf.nextTick(cf) } : wf && !Xc ? (pf = !0, df = document.createTextNode(""), new wf(cf).observe(df, { characterData: !0 }), hf = function () { df.data = pf = !pf }) : Ef && Ef.resolve ? (vf = Ef.resolve(void 0), gf = vf.then, hf = function () { gf.call(vf, cf) }) : hf = function () { bf.call(n, cf) }); var Rf, jf, Pf, If, Tf = Of || function (t) { var e = { fn: t, next: void 0 }; lf && (lf.next = e), ff || (ff = e, hf()), lf = e }, kf = function (t) { var e, r; this.promise = new t(function (t, n) { if (void 0 !== e || void 0 !== r) throw TypeError("Bad Promise constructor"); e = t, r = n }), this.resolve = Zt(e), this.reject = Zt(r) }, Lf = { f: function (t) { return new kf(t) } }, Uf = function (t, e) { if (j(t), y(e) && e.constructor === t) return e; var r = Lf.f(t); return (0, r.resolve)(e), r.promise }, Mf = function (t) { try { return { error: !1, value: t() } } catch (t) { return { error: !0, value: t } } }, _f = yf.set, Nf = qt("species"), Cf = "Promise", Ff = et.get, Bf = et.set, Df = et.getterFor(Cf), qf = Hc, zf = n.TypeError, Wf = n.document, Kf = n.process, Gf = it("fetch"), $f = Lf.f, Vf = $f, Hf = "process" == h(Kf), Xf = !!(Wf && Wf.createEvent && n.dispatchEvent), Yf = "unhandledrejection", Jf = Tt(Cf, function () { if (F(qf) === String(qf)) { if (66 === aa) return !0; if (!Hf && "function" != typeof PromiseRejectionEvent) return !0 } if (aa >= 51 && /native code/.test(qf)) return !1; var t = qf.resolve(1), e = function (t) { t(function () { }, function () { }) }; return (t.constructor = {})[Nf] = e, !(t.then(function () { }) instanceof e) }), Qf = Jf || !br(function (t) { qf.all(t).catch(function () { }) }), Zf = function (t) { var e; return !(!y(t) || "function" != typeof (e = t.then)) && e }, tl = function (t, e, r) { if (!e.notified) { e.notified = !0; var n = e.reactions; Tf(function () { for (var o = e.value, i = 1 == e.state, a = 0; n.length > a;) { var u, s, c, f = n[a++], l = i ? f.ok : f.fail, h = f.resolve, p = f.reject, d = f.domain; try { l ? (i || (2 === e.rejection && ol(t, e), e.rejection = 1), !0 === l ? u = o : (d && d.enter(), u = l(o), d && (d.exit(), c = !0)), u === f.promise ? p(zf("Promise-chain cycle")) : (s = Zf(u)) ? s.call(u, h, p) : h(u)) : p(o) } catch (t) { d && !c && d.exit(), p(t) } } e.reactions = [], e.notified = !1, r && !e.rejection && rl(t, e) }) } }, el = function (t, e, r) { var o, i; Xf ? ((o = Wf.createEvent("Event")).promise = e, o.reason = r, o.initEvent(t, !1, !0), n.dispatchEvent(o)) : o = { promise: e, reason: r }, (i = n["on" + t]) ? i(o) : t === Yf && function (t, e) { var r = n.console; r && r.error && (1 === arguments.length ? r.error(t) : r.error(t, e)) }("Unhandled promise rejection", r) }, rl = function (t, e) { _f.call(n, function () { var r, n = e.value; if (nl(e) && (r = Mf(function () { Hf ? Kf.emit("unhandledRejection", n, t) : el(Yf, t, n) }), e.rejection = Hf || nl(e) ? 2 : 1, r.error)) throw r.value }) }, nl = function (t) { return 1 !== t.rejection && !t.parent }, ol = function (t, e) { _f.call(n, function () { Hf ? Kf.emit("rejectionHandled", t) : el("rejectionhandled", t, e.value) }) }, il = function (t, e, r, n) { return function (o) { t(e, r, o, n) } }, al = function (t, e, r, n) { e.done || (e.done = !0, n && (e = n), e.value = r, e.state = 2, tl(t, e, !0)) }, ul = function (t, e, r, n) { if (!e.done) { e.done = !0, n && (e = n); try { if (t === r) throw zf("Promise can't be resolved itself"); var o = Zf(r); o ? Tf(function () { var n = { done: !1 }; try { o.call(r, il(ul, t, n, e), il(al, t, n, e)) } catch (r) { al(t, n, r, e) } }) : (e.value = r, e.state = 1, tl(t, e, !1)) } catch (r) { al(t, { done: !1 }, r, e) } } }; Jf && (qf = function (t) { Cr(this, qf, Cf), Zt(t), Rf.call(this); var e = Ff(this); try { t(il(ul, this, e), il(al, this, e)) } catch (t) { al(this, e, t) } }, (Rf = function (t) { Bf(this, { type: Cf, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: 0, value: void 0 }) }).prototype = Dr(qf.prototype, { then: function (t, e) { var r = Df(this), n = $f(fn(this, qf)); return n.ok = "function" != typeof t || t, n.fail = "function" == typeof e && e, n.domain = Hf ? Kf.domain : void 0, r.parent = !0, r.reactions.push(n), 0 != r.state && tl(this, r, !1), n.promise }, catch: function (t) { return this.then(void 0, t) } }), jf = function () { var t = new Rf, e = Ff(t); this.promise = t, this.resolve = il(ul, t, e), this.reject = il(al, t, e) }, Lf.f = $f = function (t) { return t === qf || t === Pf ? new jf(t) : Vf(t) }, "function" == typeof Hc && (If = Hc.prototype.then, rt(Hc.prototype, "then", function (t, e) { var r = this; return new qf(function (t, e) { If.call(r, t, e) }).then(t, e) }, { unsafe: !0 }), "function" == typeof Gf && Lt({ global: !0, enumerable: !0, forced: !0 }, { fetch: function (t) { return Uf(qf, Gf.apply(n, arguments)) } }))), Lt({ global: !0, wrap: !0, forced: Jf }, { Promise: qf }), Ce(qf, Cf, !1), zr(Cf), Pf = it(Cf), Lt({ target: Cf, stat: !0, forced: Jf }, { reject: function (t) { var e = $f(this); return e.reject.call(void 0, t), e.promise } }), Lt({ target: Cf, stat: !0, forced: Jf }, { resolve: function (t) { return Uf(this, t) } }), Lt({ target: Cf, stat: !0, forced: Qf }, { all: function (t) { var e = this, r = $f(e), n = r.resolve, o = r.reject, i = Mf(function () { var r = Zt(e.resolve), i = [], a = 0, u = 1; Nr(t, function (t) { var s = a++, c = !1; i.push(void 0), u++, r.call(e, t).then(function (t) { c || (c = !0, i[s] = t, --u || n(i)) }, o) }), --u || n(i) }); return i.error && o(i.value), r.promise }, race: function (t) { var e = this, r = $f(e), n = r.reject, o = Mf(function () { var o = Zt(e.resolve); Nr(t, function (t) { o.call(e, t).then(r.resolve, n) }) }); return o.error && n(o.value), r.promise } }), Lt({ target: "Promise", stat: !0 }, { allSettled: function (t) { var e = this, r = Lf.f(e), n = r.resolve, o = r.reject, i = Mf(function () { var r = Zt(e.resolve), o = [], i = 0, a = 1; Nr(t, function (t) { var u = i++, s = !1; o.push(void 0), a++, r.call(e, t).then(function (t) { s || (s = !0, o[u] = { status: "fulfilled", value: t }, --a || n(o)) }, function (t) { s || (s = !0, o[u] = { status: "rejected", reason: t }, --a || n(o)) }) }), --a || n(o) }); return i.error && o(i.value), r.promise } }); var sl = !!Hc && o(function () { Hc.prototype.finally.call({ then: function () { } }, function () { }) }); Lt({ target: "Promise", proto: !0, real: !0, forced: sl }, { finally: function (t) { var e = fn(this, it("Promise")), r = "function" == typeof t; return this.then(r ? function (r) { return Uf(e, t()).then(function () { return r }) } : t, r ? function (r) { return Uf(e, t()).then(function () { throw r }) } : t) } }), "function" != typeof Hc || Hc.prototype.finally || rt(Hc.prototype, "finally", it("Promise").prototype.finally); var cl = et.set, fl = et.getterFor("AggregateError"), ll = function (t, e) { var r = this; if (!(r instanceof ll)) return new ll(t, e); We && (r = We(new Error(e), ke(r))); var n = []; return Nr(t, n.push, n), i ? cl(r, { errors: n, type: "AggregateError" }) : r.errors = n, void 0 !== e && T(r, "message", String(e)), r }; ll.prototype = Xt(Error.prototype, { constructor: f(5, ll), message: f(5, ""), name: f(5, "AggregateError") }), i && I.f(ll.prototype, "errors", { get: function () { return fl(this).errors }, configurable: !0 }), Lt({ global: !0 }, { AggregateError: ll }), Lt({ target: "Promise", stat: !0 }, { try: function (t) { var e = Lf.f(this), r = Mf(t); return (r.error ? e.reject : e.resolve)(r.value), e.promise } }); var hl = "No one promise resolved"; Lt({ target: "Promise", stat: !0 }, { any: function (t) { var e = this, r = Lf.f(e), n = r.resolve, o = r.reject, i = Mf(function () { var r = Zt(e.resolve), i = [], a = 0, u = 1, s = !1; Nr(t, function (t) { var c = a++, f = !1; i.push(void 0), u++, r.call(e, t).then(function (t) { f || s || (s = !0, n(t)) }, function (t) { f || s || (f = !0, i[c] = t, --u || o(new (it("AggregateError"))(i, hl))) }) }), --u || o(new (it("AggregateError"))(i, hl)) }); return i.error && o(i.value), r.promise } }), re("Promise", "finally"); var pl = "URLSearchParams" in self, dl = "Symbol" in self && "iterator" in Symbol, vl = "FileReader" in self && "Blob" in self && function () { try { return new Blob, !0 } catch (t) { return !1 } }(), gl = "FormData" in self, yl = "ArrayBuffer" in self; if (yl) var ml = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], bl = ArrayBuffer.isView || function (t) { return t && ml.indexOf(Object.prototype.toString.call(t)) > -1 }; function wl(t) { if ("string" != typeof t && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t)) throw new TypeError("Invalid character in header field name"); return t.toLowerCase() } function Sl(t) { return "string" != typeof t && (t = String(t)), t } function El(t) { var e = { next: function () { var e = t.shift(); return { done: void 0 === e, value: e } } }; return dl && (e[Symbol.iterator] = function () { return e }), e } function xl(t) { this.map = {}, t instanceof xl ? t.forEach(function (t, e) { this.append(e, t) }, this) : Array.isArray(t) ? t.forEach(function (t) { this.append(t[0], t[1]) }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) { this.append(e, t[e]) }, this) } function Al(t) { if (t.bodyUsed) return Promise.reject(new TypeError("Already read")); t.bodyUsed = !0 } function Ol(t) { return new Promise(function (e, r) { t.onload = function () { e(t.result) }, t.onerror = function () { r(t.error) } }) } function Rl(t) { var e = new FileReader, r = Ol(e); return e.readAsArrayBuffer(t), r } function jl(t) { if (t.slice) return t.slice(0); var e = new Uint8Array(t.byteLength); return e.set(new Uint8Array(t)), e.buffer } function Pl() { return this.bodyUsed = !1, this._initBody = function (t) { var e; this._bodyInit = t, t ? "string" == typeof t ? this._bodyText = t : vl && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : gl && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : pl && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : yl && vl && (e = t) && DataView.prototype.isPrototypeOf(e) ? (this._bodyArrayBuffer = jl(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : yl && (ArrayBuffer.prototype.isPrototypeOf(t) || bl(t)) ? this._bodyArrayBuffer = jl(t) : this._bodyText = t = Object.prototype.toString.call(t) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : pl && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")) }, vl && (this.blob = function () { var t = Al(this); if (t) return t; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error("could not read FormData body as blob"); return Promise.resolve(new Blob([this._bodyText])) }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? Al(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(Rl) }), this.text = function () { var t = Al(this); if (t) return t; if (this._bodyBlob) return function (t) { var e = new FileReader, r = Ol(e); return e.readAsText(t), r }(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(function (t) { for (var e = new Uint8Array(t), r = new Array(e.length), n = 0; n < e.length; n++)r[n] = String.fromCharCode(e[n]); return r.join("") }(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error("could not read FormData body as text"); return Promise.resolve(this._bodyText) }, gl && (this.formData = function () { return this.text().then(kl) }), this.json = function () { return this.text().then(JSON.parse) }, this } xl.prototype.append = function (t, e) { t = wl(t), e = Sl(e); var r = this.map[t]; this.map[t] = r ? r + ", " + e : e }, xl.prototype.delete = function (t) { delete this.map[wl(t)] }, xl.prototype.get = function (t) { return t = wl(t), this.has(t) ? this.map[t] : null }, xl.prototype.has = function (t) { return this.map.hasOwnProperty(wl(t)) }, xl.prototype.set = function (t, e) { this.map[wl(t)] = Sl(e) }, xl.prototype.forEach = function (t, e) { for (var r in this.map) this.map.hasOwnProperty(r) && t.call(e, this.map[r], r, this) }, xl.prototype.keys = function () { var t = []; return this.forEach(function (e, r) { t.push(r) }), El(t) }, xl.prototype.values = function () { var t = []; return this.forEach(function (e) { t.push(e) }), El(t) }, xl.prototype.entries = function () { var t = []; return this.forEach(function (e, r) { t.push([r, e]) }), El(t) }, dl && (xl.prototype[Symbol.iterator] = xl.prototype.entries); var Il = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]; function Tl(t, e) { var r, n, o = (e = e || {}).body; if (t instanceof Tl) { if (t.bodyUsed) throw new TypeError("Already read"); this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new xl(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, o || null == t._bodyInit || (o = t._bodyInit, t.bodyUsed = !0) } else this.url = String(t); if (this.credentials = e.credentials || this.credentials || "same-origin", !e.headers && this.headers || (this.headers = new xl(e.headers)), this.method = (n = (r = e.method || this.method || "GET").toUpperCase(), Il.indexOf(n) > -1 ? n : r), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && o) throw new TypeError("Body not allowed for GET or HEAD requests"); this._initBody(o) } function kl(t) { var e = new FormData; return t.trim().split("&").forEach(function (t) { if (t) { var r = t.split("="), n = r.shift().replace(/\+/g, " "), o = r.join("=").replace(/\+/g, " "); e.append(decodeURIComponent(n), decodeURIComponent(o)) } }), e } function Ll(t, e) { e || (e = {}), this.type = "default", this.status = void 0 === e.status ? 200 : e.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in e ? e.statusText : "OK", this.headers = new xl(e.headers), this.url = e.url || "", this._initBody(t) } Tl.prototype.clone = function () { return new Tl(this, { body: this._bodyInit }) }, Pl.call(Tl.prototype), Pl.call(Ll.prototype), Ll.prototype.clone = function () { return new Ll(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new xl(this.headers), url: this.url }) }, Ll.error = function () { var t = new Ll(null, { status: 0, statusText: "" }); return t.type = "error", t }; var Ul = [301, 302, 303, 307, 308]; Ll.redirect = function (t, e) { if (-1 === Ul.indexOf(e)) throw new RangeError("Invalid status code"); return new Ll(null, { status: e, headers: { location: t } }) }; var Ml = self.DOMException; try { new Ml } catch (t) { (Ml = function (t, e) { this.message = t, this.name = e; var r = Error(t); this.stack = r.stack }).prototype = Object.create(Error.prototype), Ml.prototype.constructor = Ml } function _l(t, e) { return new Promise(function (r, n) { var o = new Tl(t, e); if (o.signal && o.signal.aborted) return n(new Ml("Aborted", "AbortError")); var i = new XMLHttpRequest; function a() { i.abort() } i.onload = function () { var t, e, n = { status: i.status, statusText: i.statusText, headers: (t = i.getAllResponseHeaders() || "", e = new xl, t.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function (t) { var r = t.split(":"), n = r.shift().trim(); if (n) { var o = r.join(":").trim(); e.append(n, o) } }), e) }; n.url = "responseURL" in i ? i.responseURL : n.headers.get("X-Request-URL"), r(new Ll("response" in i ? i.response : i.responseText, n)) }, i.onerror = function () { n(new TypeError("Network request failed")) }, i.ontimeout = function () { n(new TypeError("Network request failed")) }, i.onabort = function () { n(new Ml("Aborted", "AbortError")) }, i.open(o.method, o.url, !0), "include" === o.credentials ? i.withCredentials = !0 : "omit" === o.credentials && (i.withCredentials = !1), "responseType" in i && vl && (i.responseType = "blob"), o.headers.forEach(function (t, e) { i.setRequestHeader(e, t) }), o.signal && (o.signal.addEventListener("abort", a), i.onreadystatechange = function () { 4 === i.readyState && o.signal.removeEventListener("abort", a) }), i.send(void 0 === o._bodyInit ? null : o._bodyInit) }) } _l.polyfill = !0, self.fetch || (self.fetch = _l, self.Headers = xl, self.Request = Tl, self.Response = Ll); var Nl = Object.getOwnPropertySymbols, Cl = Object.prototype.hasOwnProperty, Fl = Object.prototype.propertyIsEnumerable; function Bl(t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } var Dl = function () { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, r = 0; r < 10; r++)e["_" + String.fromCharCode(r)] = r; if ("0123456789" !== Object.getOwnPropertyNames(e).map(function (t) { return e[t] }).join("")) return !1; var n = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { n[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("") } catch (t) { return !1 } }() ? Object.assign : function (t, e) { for (var r, n, o = Bl(t), i = 1; i < arguments.length; i++) { for (var a in r = Object(arguments[i])) Cl.call(r, a) && (o[a] = r[a]); if (Nl) { n = Nl(r); for (var u = 0; u < n.length; u++)Fl.call(r, n[u]) && (o[n[u]] = r[n[u]]) } } return o }; Object.assign = Dl }();

!function () { "use strict"; var e, r, t, _, n, i, u, a, c, o, f = {}, p = {}; function __webpack_require__(e) { var r = p[e]; if (void 0 !== r) return r.exports; var t = p[e] = { exports: {} }, _ = !0; try { f[e].call(t.exports, t, t.exports, __webpack_require__), _ = !1 } finally { _ && delete p[e] } return t.exports } __webpack_require__.m = f, e = [], __webpack_require__.O = function (r, t, _, n) { if (t) { n = n || 0; for (var i = e.length; i > 0 && e[i - 1][2] > n; i--)e[i] = e[i - 1]; e[i] = [t, _, n]; return } for (var u = 1 / 0, i = 0; i < e.length; i++) { for (var t = e[i][0], _ = e[i][1], n = e[i][2], a = !0, c = 0; c < t.length; c++)u >= n && Object.keys(__webpack_require__.O).every(function (e) { return __webpack_require__.O[e](t[c]) }) ? t.splice(c--, 1) : (a = !1, n < u && (u = n)); if (a) { e.splice(i--, 1); var o = _() } } return o }, __webpack_require__.n = function (e) { var r = e && e.__esModule ? function () { return e.default } : function () { return e }; return __webpack_require__.d(r, { a: r }), r }, __webpack_require__.d = function (e, r) { for (var t in r) __webpack_require__.o(r, t) && !__webpack_require__.o(e, t) && Object.defineProperty(e, t, { enumerable: !0, get: r[t] }) }, __webpack_require__.f = {}, __webpack_require__.e = function (e) { return Promise.all(Object.keys(__webpack_require__.f).reduce(function (r, t) { return __webpack_require__.f[t](e, r), r }, [])) }, __webpack_require__.u = function (e) { return 774 === e ? "static/chunks/framework-c470b5de91e42e1c.js" : "static/chunks/" + (48 === e ? "01e5311c" : e) + "." + ({ 3: "d415239a49e9ce46", 48: "98e903d9eca78571", 599: "1ccb8215d5ca6b2b", 821: "2f23bd1b570661bd" })[e] + ".js" }, __webpack_require__.miniCssF = function (e) { return "static/css/" + ({ 188: "d5cf3d5f5cb7d323", 197: "3057a248a2251c46", 297: "34a660eb4981ff48", 303: "3bd8e11342a3de28", 321: "eb89da97e079b8bd", 330: "1ee8dd31df995f7e", 405: "d7135b6f499f862e", 569: "e55df71fd86bef7a", 599: "d3d21cfb3c7d531c", 761: "2f477def4e52038d", 820: "5366c7a90790dbf0", 829: "d1d0dce46d2a795a", 877: "401895bf9a7263c5", 888: "6a43ae7c4bd31e03", 908: "63070ffc5f0bbd74", 911: "787e46c260b00a4e", 999: "07f5838a2ab66f5a" })[e] + ".css" }, __webpack_require__.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), __webpack_require__.o = function (e, r) { return Object.prototype.hasOwnProperty.call(e, r) }, r = {}, t = "_N_E:", __webpack_require__.l = function (e, _, n, i) { if (r[e]) { r[e].push(_); return } if (void 0 !== n) for (var u, a, c = document.getElementsByTagName("script"), o = 0; o < c.length; o++) { var f = c[o]; if (f.getAttribute("src") == e || f.getAttribute("data-webpack") == t + n) { u = f; break } } u || (a = !0, (u = document.createElement("script")).charset = "utf-8", u.timeout = 120, __webpack_require__.nc && u.setAttribute("nonce", __webpack_require__.nc), u.setAttribute("data-webpack", t + n), u.src = __webpack_require__.tu(e)), r[e] = [_]; var onScriptComplete = function (t, _) { u.onerror = u.onload = null, clearTimeout(p); var n = r[e]; if (delete r[e], u.parentNode && u.parentNode.removeChild(u), n && n.forEach(function (e) { return e(_) }), t) return t(_) }, p = setTimeout(onScriptComplete.bind(null, void 0, { type: "timeout", target: u }), 12e4); u.onerror = onScriptComplete.bind(null, u.onerror), u.onload = onScriptComplete.bind(null, u.onload), a && document.head.appendChild(u) }, __webpack_require__.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, __webpack_require__.tt = function () { return void 0 === _ && (_ = { createScriptURL: function (e) { return e } }, "undefined" != typeof trustedTypes && trustedTypes.createPolicy && (_ = trustedTypes.createPolicy("nextjs#bundler", _))), _ }, __webpack_require__.tu = function (e) { return __webpack_require__.tt().createScriptURL(e) }, __webpack_require__.p = "/_next/", n = function (e, r, t, _) { var n = document.createElement("link"); return n.rel = "stylesheet", n.type = "text/css", n.onerror = n.onload = function (i) { if (n.onerror = n.onload = null, "load" === i.type) t(); else { var u = i && ("load" === i.type ? "missing" : i.type), a = i && i.target && i.target.href || r, c = Error("Loading CSS chunk " + e + " failed.\n(" + a + ")"); c.code = "CSS_CHUNK_LOAD_FAILED", c.type = u, c.request = a, n.parentNode.removeChild(n), _(c) } }, n.href = r, document.head.appendChild(n), n }, i = function (e, r) { for (var t = document.getElementsByTagName("link"), _ = 0; _ < t.length; _++) { var n = t[_], i = n.getAttribute("data-href") || n.getAttribute("href"); if ("stylesheet" === n.rel && (i === e || i === r)) return n } for (var u = document.getElementsByTagName("style"), _ = 0; _ < u.length; _++) { var n = u[_], i = n.getAttribute("data-href"); if (i === e || i === r) return n } }, u = { 272: 0 }, __webpack_require__.f.miniCss = function (e, r) { u[e] ? r.push(u[e]) : 0 !== u[e] && ({ 599: 1 })[e] && r.push(u[e] = new Promise(function (r, t) { var _ = __webpack_require__.miniCssF(e), u = __webpack_require__.p + _; if (i(_, u)) return r(); n(e, u, r, t) }).then(function () { u[e] = 0 }, function (r) { throw delete u[e], r })) }, a = { 272: 0 }, __webpack_require__.f.j = function (e, r) { var t = __webpack_require__.o(a, e) ? a[e] : void 0; if (0 !== t) { if (t) r.push(t[2]); else if (272 != e) { var _ = new Promise(function (r, _) { t = a[e] = [r, _] }); r.push(t[2] = _); var n = __webpack_require__.p + __webpack_require__.u(e), i = Error(); __webpack_require__.l(n, function (r) { if (__webpack_require__.o(a, e) && (0 !== (t = a[e]) && (a[e] = void 0), t)) { var _ = r && ("load" === r.type ? "missing" : r.type), n = r && r.target && r.target.src; i.message = "Loading chunk " + e + " failed.\n(" + _ + ": " + n + ")", i.name = "ChunkLoadError", i.type = _, i.request = n, t[1](i) } }, "chunk-" + e, e) } else a[e] = 0 } }, __webpack_require__.O.j = function (e) { return 0 === a[e] }, c = function (e, r) { var t, _, n = r[0], i = r[1], u = r[2], c = 0; if (n.some(function (e) { return 0 !== a[e] })) { for (t in i) __webpack_require__.o(i, t) && (__webpack_require__.m[t] = i[t]); if (u) var o = u(__webpack_require__) } for (e && e(r); c < n.length; c++)_ = n[c], __webpack_require__.o(a, _) && a[_] && a[_][0](), a[_] = 0; return __webpack_require__.O(o) }, (o = self.webpackChunk_N_E = self.webpackChunk_N_E || []).forEach(c.bind(null, 0)), o.push = c.bind(null, o.push.bind(o)) }();

self.__BUILD_MANIFEST = function (s, t, c, e, a, o, r, n, d) { return { __rewrites: { afterFiles: [{ has: void 0, source: "/:nextInternalLocale(default|en|nl)/robots.txt", destination: "/:nextInternalLocale/api/robots" }], beforeFiles: [], fallback: [] }, "/": [t, s, c, e, a, "static/css/d7135b6f499f862e.css", "static/chunks/pages/index-5744fed2ebc5415e.js"], "/404": [t, s, c, e, a, "static/css/3057a248a2251c46.css", "static/chunks/pages/404-f2f4a014e5ff481e.js"], "/_error": ["static/css/5366c7a90790dbf0.css", "static/chunks/pages/_error-6d58136dc0438e46.js"], "/sitemap.xml": ["static/chunks/pages/sitemap.xml-339f0584d54d8184.js"], "/store": ["static/css/d1d0dce46d2a795a.css", "static/chunks/pages/store-493ac6821792dc92.js"], "/store/blogs/[slug]": [t, s, c, e, o, a, r, n, "static/chunks/pages/store/blogs/[slug]-1d060b918a6943d4.js"], "/store/bookmarks": [o, d, "static/css/07f5838a2ab66f5a.css", "static/chunks/pages/store/bookmarks-7d366e14cd5e5acd.js"], "/store/content/[slug]": [t, s, c, e, o, a, r, n, "static/chunks/pages/store/content/[slug]-102d3a720367d195.js"], "/store/events/[slug]": [t, s, c, e, o, a, r, n, "static/css/34a660eb4981ff48.css", "static/chunks/pages/store/events/[slug]-0650e70b4bfc2953.js"], "/store/explore": [t, s, c, e, a, "static/css/2f477def4e52038d.css", "static/chunks/pages/store/explore-c86ff4fe7d04c6c3.js"], "/store/explore/results": [s, o, d, "static/css/63070ffc5f0bbd74.css", "static/chunks/pages/store/explore/results-d506a891ff83171f.js"], "/store/locations/[slug]": [t, s, c, e, o, a, r, n, "static/css/e55df71fd86bef7a.css", "static/chunks/pages/store/locations/[slug]-977dff117d8d13be.js"], "/store/map": ["static/css/d5cf3d5f5cb7d323.css", "static/chunks/pages/store/map-8830d5a9f3bbc470.js"], "/store/not-found": ["static/css/401895bf9a7263c5.css", "static/chunks/pages/store/not-found-ca454b9ded71e29c.js"], "/store/routes/[slug]": [t, s, c, e, o, a, r, n, "static/css/eb89da97e079b8bd.css", "static/chunks/pages/store/routes/[slug]-2ad7c0c221372008.js"], "/[...slug]": [t, s, c, e, "static/chunks/31-905d440a4306295c.js", a, "static/css/1ee8dd31df995f7e.css", "static/chunks/pages/[...slug]-ec61fae2f5f869d8.js"], sortedPages: ["/", "/404", "/_app", "/_error", "/sitemap.xml", "/store", "/store/blogs/[slug]", "/store/bookmarks", "/store/content/[slug]", "/store/events/[slug]", "/store/explore", "/store/explore/results", "/store/locations/[slug]", "/store/map", "/store/not-found", "/store/routes/[slug]", "/[...slug]"] } }("static/chunks/152-cd4d97b125a4265e.js", "static/chunks/e0ebb59b-10335dae85bf0c61.js", "static/css/3bd8e11342a3de28.css", "static/chunks/303-ada549755fac621a.js", "static/chunks/883-1e772c6561b52df3.js", "static/chunks/792-10b75b64e4b7121c.js", "static/css/787e46c260b00a4e.css", "static/chunks/911-c18bc1ac7452186b.js", "static/chunks/390-a092af5b8c93456c.js"), self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB();

self.__SSG_MANIFEST=new Set(["\u002F404"]);self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()